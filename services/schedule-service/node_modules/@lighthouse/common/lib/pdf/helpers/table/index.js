import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { chunk, concat, defaults, fill, map, slice, take } from 'lodash';
import Promise from 'bluebird';
import { DEFAULT_IMAGE_COLUMN_LENGTH, DEFAULT_SUMMARY_FIELDS_COLUMN_LENGTH } from '../../../constants';
import { buildSummaryField, text } from '../';
var defaultLayout = {
  fillColor: zebraFillColor,
  hLineWidth: function hLineWidth() {
    return 0;
  },
  paddingLeft: function paddingLeft() {
    return 5;
  },
  paddingRight: function paddingRight() {
    return 5;
  },
  paddingTop: function paddingTop() {
    return 5;
  },
  paddingBottom: function paddingBottom() {
    return 5;
  },
  vLineWidth: function vLineWidth() {
    return 0;
  }
};
export var GRAY = '#DDDDDD';
export var LIGHT_BLUE = '#F0FBFF';
export var WHITE = '#FFFFFF';
export function imageTables(images) {
  var imageRows = chunk(images, DEFAULT_IMAGE_COLUMN_LENGTH);
  var tables = map(imageRows, function (imageRow, index) {
    var defaultRow = fill(Array(DEFAULT_IMAGE_COLUMN_LENGTH), {
      text: ''
    });
    var row = concat(imageRow, slice(defaultRow, imageRow.length));
    var isMiddleRow = index !== 1 && index !== imageRows.length;
    var margin = isMiddleRow ? 5 : 0;
    return [{
      headerRows: 0,
      table: {
        body: [_toConsumableArray(row)],
        widths: ['*', '*']
      },
      layout: {
        hLineColor: function hLineColor() {
          return GRAY;
        },
        hLineWidth: function hLineWidth() {
          return 1;
        },
        paddingLeft: function paddingLeft() {
          return 5;
        },
        paddingRight: function paddingRight() {
          return 5;
        },
        paddingTop: function paddingTop() {
          return 5;
        },
        paddingBottom: function paddingBottom() {
          return 5;
        },
        vLineColor: function vLineColor() {
          return GRAY;
        },
        vLineWidth: function vLineWidth() {
          return 1;
        }
      },
      margin: [0, margin, 0, margin]
    }];
  });
  return tables;
}
export function summaryFieldsTable(_x) {
  return _summaryFieldsTable.apply(this, arguments);
}

function _summaryFieldsTable() {
  _summaryFieldsTable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
    var fields, settings, timezone, tableHeader, defaultHeaders, defaultRow, tableRow, headers, row, summaryFieldTable;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            fields = _ref.fields, settings = _ref.settings, timezone = _ref.timezone;
            tableHeader = map(fields, function (_ref2) {
              var label = _ref2.label;
              return text(label, {
                bold: true,
                fontSize: 7
              });
            });
            defaultHeaders = fill(Array(DEFAULT_SUMMARY_FIELDS_COLUMN_LENGTH), {
              text: ''
            });
            defaultRow = fill(Array(DEFAULT_SUMMARY_FIELDS_COLUMN_LENGTH), {
              text: ''
            });
            _context.next = 6;
            return Promise.map(fields, function (field) {
              return buildSummaryField({
                field: field,
                settings: settings,
                timezone: timezone
              });
            });

          case 6:
            tableRow = _context.sent;
            // NOTE: a user can only select three summary fields on the template however
            // if the form group is repeatable we could have more than the default
            // summary field column length so cap otherwise pdf will fail to generate
            headers = take(concat(tableHeader, slice(defaultHeaders, tableHeader.length)), DEFAULT_SUMMARY_FIELDS_COLUMN_LENGTH);
            row = take(concat(tableRow, slice(defaultRow, tableRow.length)), DEFAULT_SUMMARY_FIELDS_COLUMN_LENGTH);
            summaryFieldTable = table({
              body: [headers, row],
              colSpan: 5,
              dontBreakRows: true,
              headerRows: 0,
              layout: {
                hLineWidth: function hLineWidth() {
                  return 0;
                },
                paddingLeft: function paddingLeft() {
                  return 0;
                },
                paddingRight: function paddingRight() {
                  return 5;
                },
                paddingTop: function paddingTop() {
                  return 2;
                },
                paddingBottom: function paddingBottom() {
                  return 2;
                },
                vLineWidth: function vLineWidth() {
                  return 0;
                }
              },
              // NOTE: pdfmake applies margin/padding to nested tables
              margin: [0, -5, 0, 0],
              widths: ['*', '*', '*']
            });
            return _context.abrupt("return", summaryFieldTable);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _summaryFieldsTable.apply(this, arguments);
}

export function summaryStatTable(options) {
  var tableOptions = defaults({}, options, {
    layout: {
      fillColor: LIGHT_BLUE,
      hLineWidth: function hLineWidth() {
        return 0;
      },
      paddingLeft: function paddingLeft() {
        return 10;
      },
      paddingRight: function paddingRight() {
        return 10;
      },
      paddingTop: function paddingTop() {
        return 2;
      },
      paddingBottom: function paddingBottom() {
        return 2;
      },
      vLineWidth: function vLineWidth() {
        return 0;
      }
    },
    widths: ['*']
  });
  return table(tableOptions);
}
export function summaryWrapperTable(options) {
  var tableOptions = defaults({}, options, {
    layout: {
      fillColor: WHITE,
      hLineWidth: function hLineWidth() {
        return 0;
      },
      paddingLeft: function paddingLeft() {
        return 0;
      },
      paddingRight: function paddingRight() {
        return 10;
      },
      paddingTop: function paddingTop() {
        return 0;
      },
      paddingBottom: function paddingBottom() {
        return 0;
      },
      vLineWidth: function vLineWidth() {
        return 0;
      }
    },
    style: 'summaryWrapperTable'
  });
  return table(tableOptions);
}
export function table(options) {
  var body = options.body,
      colSpan = options.colSpan,
      _options$dontBreakRow = options.dontBreakRows,
      dontBreakRows = _options$dontBreakRow === void 0 ? false : _options$dontBreakRow,
      _options$headerRows = options.headerRows,
      headerRows = _options$headerRows === void 0 ? 1 : _options$headerRows,
      _options$layout = options.layout,
      layout = _options$layout === void 0 ? defaultLayout : _options$layout,
      _options$style = options.style,
      style = _options$style === void 0 ? 'table' : _options$style,
      margin = options.margin,
      widths = options.widths;
  var definition = {
    colSpan: colSpan,
    layout: layout,
    style: style,
    table: {
      body: body,
      // NOTE: be wary of this feature, if a row spans multiple pages it won't
      // be drawn on to the pdf, only pass true here when row will be less than
      // a page
      dontBreakRows: dontBreakRows,
      headerRows: headerRows
    },
    margin: margin
  }; // NOTE: only adds widths if passed
  // as otherwise pdfmake will error!
  // if none defined it auto calculates

  if (widths) {
    definition.table.widths = widths;
  }

  return definition;
}
export function twoColumnTable(options) {
  var tableOptions = defaults({}, options, {
    widths: ['50%', '50%']
  });
  return table(tableOptions);
}
export function threeColumnTable(options) {
  var tableOptions = defaults({}, options, {
    widths: ['33%', '33%', '*']
  });
  return table(tableOptions);
}
export function fourColumnTable(options) {
  var tableOptions = defaults({}, options, {
    widths: ['25%', '25%', '25%', '25%']
  });
  return table(tableOptions);
}
export function zebraFillColor(index) {
  return index % 2 === 0 ? WHITE : LIGHT_BLUE;
}
//# sourceMappingURL=index.js.map