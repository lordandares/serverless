import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { get, isEmpty, map } from 'lodash';
import moment from 'moment-timezone';
import { generateDefinition, horizontalLine, table, text, twoColumnTable } from '../helpers';
import { getJobDetails, getPrettyDuration, getTimezoneDatetime, getUserFullName } from '../../helpers';
var ACTIVITY_COLUMN_HEADERS = [{
  text: 'Type',
  bold: true
}, {
  text: 'User',
  bold: true
}, {
  text: 'Start Time',
  bold: true
}, {
  text: 'Start Location',
  bold: true
}, {
  text: 'End Time',
  bold: true
}, {
  text: 'End Location',
  bold: true
}, {
  text: 'Duration',
  bold: true
}];
/**
 * buildJobPdf
 *
 * @param {object} pdfOptions - the pdf options
 * @param {string} pdfOptions.fileTitle - pdf file title
 * @param {function} pdfOptions.footer - function executed to generate footer
 * @param {function} pdfOptions.header - function executed to generate header
 * @param {string} pdfOptions.logoUrl - pdf logo url
 * @param {array} pdfOptions.pageMargins - pdf page margins
 * @param {string} pdfOptions.pageOrientation - pdf page orientation
 * @param {string} pdfOptions.pageSize - pdf page size
 * @param {object} pdfOptions.styles - pdf styles
 * @param {object} pdfOptions.title - pdf title
 * @param {object} data - pdf data
 * @param {object} data.entity - job document
 * @param {array} data.jobActivities - job activities documents
 * @param {object} data.settings - settings properties
 * @param {string} data.settings.awsS3BaseUrl - aws S3 base url
 * @param {string} data.settings.cloudinaryBaseUrl - cloudinary base url
 * @param {string} data.timezone - timezone string
 * @param {object} data.users - application user documents
 * @returns {Promise} returns pdfmake definition object
 */

export function buildJobPdf(pdfOptions, data) {
  var entity = data.entity,
      timezone = data.timezone;
  var timestamp = entity.createdAt;
  var title = entity.title || 'Unknown';
  var fileTitle = "Job Report - ".concat(title);
  var content = generateContent(data);
  return generateDefinition(_objectSpread({
    content: content,
    fileTitle: fileTitle,
    pageOrientation: 'landscape',
    timestamp: timestamp,
    timezone: timezone,
    type: 'Job'
  }, pdfOptions));
}

function generateContent(data) {
  var entity = data.entity;
  var title = entity.title;
  var entityDetails = getJobDetails(data);
  var metaTableData = [[{
    text: 'Location',
    bold: true
  }, entityDetails.locationText], [{
    text: 'Author',
    bold: true
  }, entityDetails.authorFullName], [{
    text: 'Reference',
    bold: true
  }, entityDetails.reference], [{
    text: 'Description',
    bold: true
  }, entityDetails.description], [{
    text: 'Due Date',
    bold: true
  }, entityDetails.dueDateTimezoneDateTime], [{
    text: 'Assignees',
    bold: true
  }, entityDetails.assigneeNames], [{
    text: 'Status',
    bold: true
  }, {
    text: entityDetails.statusText,
    color: entityDetails.statusColor
  }], [{
    text: 'Created',
    bold: true
  }, entityDetails.createdTimezoneDateTime], [{
    text: 'Timezone',
    bold: true
  }, entityDetails.timezoneAbbrText]];
  var headerTitle = text("Job Report: ".concat(title), {
    style: 'title'
  });
  var titleTable = table({
    body: [[headerTitle]],
    layout: 'noBorders',
    style: 'titleTable'
  });
  var metaDataTable = twoColumnTable({
    body: metaTableData,
    widths: [150, '*']
  });
  var activitiesTitleTable = table({
    body: [['Job Activities']],
    layout: 'noBorders',
    style: 'activitiesTable'
  });
  var activityTableData = buildActivitiesContent(data);
  var activityTable = table(activityTableData);
  var hLine = horizontalLine();
  return [titleTable, metaDataTable, activitiesTitleTable, hLine, activityTable, hLine];
}

function buildActivitiesContent(data) {
  var jobActivities = data.jobActivities,
      timezone = data.timezone,
      users = data.users;

  if (isEmpty(jobActivities)) {
    return {
      body: [['No Job Activities']],
      widths: '*'
    };
  }

  var activityRows = map(jobActivities, function (activity) {
    var entity = activity.entity;
    var type = entity.type,
        duration = entity.duration,
        user = entity.user,
        _entity$start = entity.start,
        start = _entity$start === void 0 ? {} : _entity$start,
        _entity$end = entity.end,
        end = _entity$end === void 0 ? {} : _entity$end;
    var authorText = getUserFullName(users, user);
    var mDuration = moment.duration(duration, 'minutes');
    var durationText = duration ? getPrettyDuration(mDuration) : '-';
    var startTime = start.time;
    var startLocation = get(start, 'geometryReverseGeocoded.label', '-');
    var endTime = end.time;
    var endLocation = get(end, 'geometryReverseGeocoded.label', '-');
    var startTimeText = startTime ? getTimezoneDatetime({
      showTzAbbr: false,
      timestamp: startTime,
      timezone: timezone
    }) : '-';
    var endTimeText = endTime ? getTimezoneDatetime({
      showTzAbbr: false,
      timestamp: endTime,
      timezone: timezone
    }) : '-';
    return [type, authorText, startTimeText, startLocation, endTimeText, endLocation, durationText];
  });
  return {
    body: [ACTIVITY_COLUMN_HEADERS].concat(_toConsumableArray(activityRows)),
    widths: [70, 80, 60, '*', 60, '*', 50]
  };
}
//# sourceMappingURL=index.js.map