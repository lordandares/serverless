import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { isEmpty } from 'lodash';
import { buildTemplateContent, generateDefinition, getFormattedAddress, text, table } from '../helpers';
import { getTaskEntryDetails } from '../../helpers';
/**
 * buildTaskPdf
 *
 * @param {object} pdfOptions - the pdf options
 * @param {string} pdfOptions.fileTitle - pdf file title
 * @param {function} pdfOptions.footer - function executed to generate footer
 * @param {function} pdfOptions.header - function executed to generate header
 * @param {string} pdfOptions.logoUrl - pdf logo url
 * @param {array} pdfOptions.pageMargins - pdf page margins
 * @param {string} pdfOptions.pageOrientation - pdf page orientation
 * @param {string} pdfOptions.pageSize - pdf page size
 * @param {object} pdfOptions.styles - pdf styles
 * @param {object} pdfOptions.title - pdf title
 * @param {object} data - pdf data
 * @param {object} data.entity - task document
 * @param {object} data.locations - locations documents
 * @param {object} data.settings - settings properties
 * @param {string} data.settings.awsS3BaseUrl - aws S3 base url
 * @param {string} data.settings.cloudinaryBaseUrl - cloudinary base url
 * @param {string} data.timezone - timezone string
 * @param {object} data.users - application user documents
 * @param {object} data.zones - zone documents
 * @returns {Promise} returns pdfmake definition object
 */

export function buildTaskPdf(pdfOptions, data) {
  var entity = data.entity,
      timezone = data.timezone;
  var timestamp = entity.createdAt;
  var title = entity.title || 'Unknown';
  var fileTitle = "Task Report - ".concat(title);
  return generateContent(data).then(function (content) {
    return generateDefinition(_objectSpread({
      content: content,
      fileTitle: fileTitle,
      timestamp: timestamp,
      timezone: timezone,
      type: 'Task'
    }, pdfOptions));
  });
}

function generateContent(data) {
  var entity = data.entity;
  var entry = entity.entry,
      _entity$gps = entity.gps,
      gps = _entity$gps === void 0 ? {} : _entity$gps,
      title = entity.title;
  var entityDetails = getTaskEntryDetails(data);
  var gpsText = entityDetails.gpsText,
      locationText = entityDetails.locationText,
      referenceValue = entityDetails.referenceValue,
      timezoneHourTime = entityDetails.timezoneHourTime;
  var reverseGeocoded = gps.reverseGeocoded;
  var subTitle = "".concat(locationText || gpsText, " - ").concat(timezoneHourTime, " by ").concat(referenceValue);
  var headerSubTitle = text(subTitle, {
    style: 'subTitle'
  });
  var headerTitle = text(title, {
    style: 'title'
  });
  var address = !isEmpty(reverseGeocoded) ? getFormattedAddress(reverseGeocoded) : '';
  var headerAddress = text(address, {
    style: 'small'
  });
  var body = !isEmpty(reverseGeocoded) ? [[headerTitle], [headerSubTitle], [headerAddress]] : [[headerTitle], [headerSubTitle]];
  var titleTable = table({
    body: body,
    layout: 'noBorders',
    style: 'titleTable'
  });
  return buildTemplateContent(entry.formGroups, data).then(function (entry) {
    return [titleTable].concat(_toConsumableArray(entry));
  });
}
//# sourceMappingURL=index.js.map