import _regeneratorRuntime from "@babel/runtime/regenerator";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";

var _marked = /*#__PURE__*/_regeneratorRuntime.mark(serviceIntervalsGenerator);

import { filter, flow, forEach, map } from 'lodash/fp';
import moment from 'moment-timezone';
import { Behaviours, Durations, Types } from '../../service-hours';
import { Unit } from '../scheduling.types';
import { convertToTimezone, intervalCovers, intervalOnlyIntersectsEnd, intervalOnlyIntersectsStart, intervalWithin, mergeIntervals, splitIntervals } from '../helpers';

/**
 * Generates service intervals between start and end range for service hours
 */
export function serviceIntervalsGenerator(props) {
  var end, serviceHours, start, timezone, hasValidStartAndEnd, mStart, mEnd, mStartValid, mEndValid, hours, rangeInterval, closeOverrideHours, defaultHours, openOverrideHours, closeIntervals, openIntervals, weekStart, defaultIntervals, getOverrideIntervalsForRange, rangeOpenIntervals, rangeCloseIntervals, mergedIntervals, serviceIntervals, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, interval;

  return _regeneratorRuntime.wrap(function serviceIntervalsGenerator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          end = props.end, serviceHours = props.serviceHours, start = props.start;
          timezone = serviceHours.timezone;
          hasValidStartAndEnd = end > start && start < end;

          if (hasValidStartAndEnd) {
            _context.next = 5;
            break;
          }

          return _context.abrupt("return", []);

        case 5:
          mStart = moment.tz(start, timezone);
          mEnd = moment.tz(end, timezone);
          mStartValid = mStart.isValid();
          mEndValid = mEnd.isValid();

          if (!(!mStartValid || !mEndValid)) {
            _context.next = 11;
            break;
          }

          return _context.abrupt("return", []);

        case 11:
          hours = serviceHours.hours;
          rangeInterval = [start, end];
          closeOverrideHours = filter({
            behaviour: Behaviours.Close,
            type: Types.Override
          }, hours);
          defaultHours = filter({
            type: Types.Default
          }, hours);
          openOverrideHours = filter({
            behaviour: Behaviours.Open,
            type: Types.Override
          }, hours); // NOTE: we must apply the timezone to overrides as they are stored in UTC
          // and must be converted to timestamps in the timezone before processing

          closeIntervals = map(function (override) {
            var start = convertToTimezone(override.start, timezone);
            var end = convertToTimezone(override.end, timezone);
            return [start, end];
          }, closeOverrideHours);
          openIntervals = map(function (override) {
            var start = convertToTimezone(override.start, timezone);
            var end = convertToTimezone(override.end, timezone);
            return [start, end];
          }, openOverrideHours);
          weekStart = mStart.startOf(Unit.Week).valueOf();
          defaultIntervals = [];

          while (weekStart < end) {
            forEach(function (hour) {
              // NOTE: hour start and end values are the number of minutes from the
              // start of the week so are simply offsets
              var endOffset = hour.end,
                  startOffset = hour.start;
              var hourStart = weekStart + startOffset;
              var hourEnd = weekStart + endOffset;
              var interval = [hourStart, hourEnd];
              var isIntervalIntersectingRangeEnd = intervalOnlyIntersectsEnd(interval, rangeInterval);
              var isIntervalIntersectingRangeStart = intervalOnlyIntersectsStart(interval, rangeInterval);
              var isIntervalInsideRange = intervalWithin(interval, rangeInterval);
              var isRangeInsideInterval = intervalWithin(rangeInterval, interval);
              var shouldSkip = !isIntervalInsideRange && !isRangeInsideInterval && !isIntervalIntersectingRangeStart && !isIntervalIntersectingRangeEnd;
              if (shouldSkip) return;
              var nextStart = isRangeInsideInterval || isIntervalIntersectingRangeStart ? start : hourStart;
              var nextEnd = isRangeInsideInterval || isIntervalIntersectingRangeEnd ? end : hourEnd;
              defaultIntervals.push([nextStart, nextEnd]);
            }, defaultHours);
            weekStart = weekStart + Durations.Week;
          } // NOTE: only include intervals which intersect our range and then map to
          // ensure the intervals conform to the range interval


          getOverrideIntervalsForRange = flow(filter(function (interval) {
            return interval[0] >= rangeInterval[0] || interval[0] <= rangeInterval[1];
          }), map(function (interval) {
            var intervalCoversRange = intervalCovers(interval, rangeInterval);
            var intervalIntersectsRangeEnd = intervalOnlyIntersectsEnd(interval, rangeInterval);
            var intervalIntersectsRangeStart = intervalOnlyIntersectsStart(interval, rangeInterval);
            var intervalStart = intervalIntersectsRangeStart ? rangeInterval[0] : interval[0];
            var intervalEnd = intervalIntersectsRangeEnd ? rangeInterval[1] : interval[1];
            return intervalCoversRange ? rangeInterval : [intervalStart, intervalEnd];
          })); // NOTE: for simplicity we calculate all default service intervals and then
          // apply the open and closed overrides, we can't do this as we iterate
          // through the weeks as open and close overrides can potentially intersect
          // across weeks

          rangeOpenIntervals = getOverrideIntervalsForRange(openIntervals);
          rangeCloseIntervals = getOverrideIntervalsForRange(closeIntervals);
          mergedIntervals = mergeIntervals([].concat(defaultIntervals, _toConsumableArray(rangeOpenIntervals)));
          serviceIntervals = splitIntervals(mergedIntervals, rangeCloseIntervals);
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 29;
          _iterator = serviceIntervals[Symbol.iterator]();

        case 31:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 38;
            break;
          }

          interval = _step.value;
          _context.next = 35;
          return interval;

        case 35:
          _iteratorNormalCompletion = true;
          _context.next = 31;
          break;

        case 38:
          _context.next = 44;
          break;

        case 40:
          _context.prev = 40;
          _context.t0 = _context["catch"](29);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 44:
          _context.prev = 44;
          _context.prev = 45;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 47:
          _context.prev = 47;

          if (!_didIteratorError) {
            _context.next = 50;
            break;
          }

          throw _iteratorError;

        case 50:
          return _context.finish(47);

        case 51:
          return _context.finish(44);

        case 52:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[29, 40, 44, 52], [45,, 47, 51]]);
}
//# sourceMappingURL=serviceIntervalsGenerator.js.map