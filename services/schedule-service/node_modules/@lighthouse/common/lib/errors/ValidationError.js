import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import { ValidationError as SchemaValidationError } from 'yup';
import DomainError from './DomainError';
var DEFAULT_MESSAGE = 'The data you submitted was invalid. Please try again with valid data.';

var ValidationError = /*#__PURE__*/function (_DomainError) {
  _inherits(ValidationError, _DomainError);

  function ValidationError(_ref) {
    var _this;

    var data = _ref.data,
        _ref$message = _ref.message,
        message = _ref$message === void 0 ? DEFAULT_MESSAGE : _ref$message;

    _classCallCheck(this, ValidationError);

    // When the data object is a schema validation error, take its data
    // attributes and apply to our wrapped error
    if (data instanceof SchemaValidationError) {
      var validationMessage = data.message,
          name = data.name,
          other = _objectWithoutProperties(data, ["message", "name"]);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ValidationError).call(this, validationMessage));
      _this.data = other;
      _this.status = 400;
      return _possibleConstructorReturn(_this);
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ValidationError).call(this, message));
    _this.data = data;
    _this.status = 400;
    return _possibleConstructorReturn(_this);
  }

  return ValidationError;
}(DomainError);

export { ValidationError as default };
//# sourceMappingURL=ValidationError.js.map