"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateOverlappingHours = validateOverlappingHours;
exports.default = exports.schema = exports.Weekdays = exports.Types = exports.Durations = exports.Behaviours = void 0;

var _yup = require("yup");

var _fp = require("lodash/fp");

var _lodash = require("lodash");

const MAX_OFFSET_MS = 604800000;
let Behaviours;
exports.Behaviours = Behaviours;

(function (Behaviours) {
  Behaviours["Open"] = "OPEN";
  Behaviours["Close"] = "CLOSE";
})(Behaviours || (exports.Behaviours = Behaviours = {}));

let Durations;
exports.Durations = Durations;

(function (Durations) {
  Durations[Durations["Second"] = 1000] = "Second";
  Durations[Durations["Minute"] = 60000] = "Minute";
  Durations[Durations["Hour"] = 3600000] = "Hour";
  Durations[Durations["Day"] = 86400000] = "Day";
  Durations[Durations["Week"] = 604800000] = "Week";
})(Durations || (exports.Durations = Durations = {}));

let Types;
exports.Types = Types;

(function (Types) {
  Types["Default"] = "DEFAULT";
  Types["Override"] = "OVERRIDE";
})(Types || (exports.Types = Types = {}));

let Weekdays;
exports.Weekdays = Weekdays;

(function (Weekdays) {
  Weekdays["Monday"] = "MONDAY";
  Weekdays["Tuesday"] = "TUESDAY";
  Weekdays["Wednesday"] = "WEDNESDAY";
  Weekdays["Thursday"] = "THURSDAY";
  Weekdays["Friday"] = "FRIDAY";
  Weekdays["Saturday"] = "SATURDAY";
  Weekdays["Sunday"] = "SUNDAY";
})(Weekdays || (exports.Weekdays = Weekdays = {}));

const hoursSchema = (0, _yup.object)({
  type: (0, _yup.string)().oneOf([Types.Default, Types.Override]).required(),
  start: (0, _yup.number)().min(0).required(),
  end: (0, _yup.number)().min(0).required().when('start', (start, endSchema) => {
    return endSchema.min(start);
  }),
  duration: (0, _yup.number)().integer().when(['start', 'end'], (start, end, durationSchema) => {
    // NOTE This is a bit of a hack to check the exact value, but I can't find
    // an API to check the exact value of a number
    const expectedDuration = end - start;
    const message = '${path} must be equal to ' + expectedDuration;
    return durationSchema.min(expectedDuration, message).max(expectedDuration, message);
  }),
  description: (0, _yup.string)(),
  behaviour: (0, _yup.string)().oneOf([Behaviours.Open, Behaviours.Close]).when('type', (type, behaviourSchema) => {
    return type === Types.Override ? behaviourSchema.required() : behaviourSchema.strip(true);
  })
});
const schema = (0, _yup.object)({
  timezone: (0, _yup.string)().required(),
  options: (0, _yup.object)({
    startWeekday: (0, _yup.string)().oneOf((0, _fp.values)(Weekdays))
  }),
  hours: (0, _yup.array)().of(hoursSchema).test('hasUndefinedHours', 'hours is a required field', value => !(0, _fp.isNil)(value)).test('hasOverlappingDefaultHours', 'default hours must not overlap', value => {
    const defaultHours = (0, _fp.filter)({
      type: Types.Default
    }, value);
    const hasOverlappingHours = validateOverlappingHours({
      hoursArr: defaultHours
    }) !== -1;
    if (hasOverlappingHours) return false;
    return true;
  }).test('hasOverlappingOverrideHours', 'override hours must not overlap', value => {
    const overrideHours = (0, _fp.filter)({
      type: Types.Override
    }, value);
    const hasOverlappingHours = validateOverlappingHours({
      hoursArr: overrideHours,
      isUnix: true
    }) !== -1;
    if (hasOverlappingHours) return false;
    return true;
  })
});
exports.schema = schema;

/**
 * validateOverlappingHours
 * Validates that any hours do not overlap each other 
 * Validates default hours are within a week range
 */
function validateOverlappingHours(options) {
  const {
    hoursArr,
    isUnix
  } = options;
  let failingIndex = -1;

  if ((0, _fp.isEmpty)(hoursArr)) {
    return failingIndex;
  } // NOTE: when default hours and not override hours


  if (!isUnix) {
    const sortedHoursArr = (0, _fp.orderBy)(['start', 'end'], ['asc', 'asc'], hoursArr);
    const {
      start: firstStart
    } = (0, _fp.first)(sortedHoursArr);
    const {
      end: lastEnd
    } = (0, _fp.last)(sortedHoursArr); // NOTE: default service hour values are invalid if the first start and
    // last end exceed the MAX_OFFSET_MS which is a week

    const isRangeWithinWeek = lastEnd - firstStart <= MAX_OFFSET_MS;

    if (!isRangeWithinWeek) {
      failingIndex = 1;
      return failingIndex;
    }
  }

  (0, _lodash.some)(hoursArr, (thisHours, thisIndex) => {
    const overlap = (0, _lodash.some)(hoursArr, (otherHours, otherIndex) => {
      if (otherIndex === thisIndex) return false;
      const {
        start: thisStart,
        end: thisEnd
      } = thisHours;
      const {
        start: otherStart,
        end: otherEnd
      } = otherHours;
      const isMatching = otherStart === thisStart && otherEnd === thisEnd;
      const isWithin = thisStart > otherStart && thisEnd < otherEnd;
      const overlappingStart = thisStart < otherStart && thisEnd > otherStart;
      const overlappingEnd = thisStart < otherEnd && thisEnd > otherEnd;
      return isMatching || isWithin || overlappingStart || overlappingEnd;
    });

    if (overlap) {
      failingIndex = thisIndex;
      return true;
    }
  });
  return failingIndex;
}

var _default = schema;
exports.default = _default;