"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildIssuePdf = buildIssuePdf;

var _lodash = require("lodash");

var _helpers = require("../helpers");

var _helpers2 = require("../../helpers");

/**
 * buildIssuePdf
 *
 * @param {object} pdfOptions - the pdf options
 * @param {string} pdfOptions.fileTitle - pdf file title
 * @param {function} pdfOptions.footer - function executed to generate footer
 * @param {function} pdfOptions.header - function executed to generate header
 * @param {string} pdfOptions.logoUrl - pdf logo url
 * @param {array} pdfOptions.pageMargins - pdf page margins
 * @param {string} pdfOptions.pageOrientation - pdf page orientation
 * @param {string} pdfOptions.pageSize - pdf page size
 * @param {object} pdfOptions.styles - pdf styles
 * @param {object} pdfOptions.title - pdf title
 * @param {object} data - pdf data
 * @param {object} data.entity - issue document
 * @param {object} data.locations - locations documents
 * @param {object} data.settings - settings properties
 * @param {string} data.settings.awsS3BaseUrl - aws S3 base url
 * @param {string} data.settings.cloudinaryBaseUrl - cloudinary base url
 * @param {string} data.timezone - timezone string
 * @param {object} data.users - application user documents
 * @param {object} data.zones - zone documents
 * @returns {Promise} returns pdfmake definition object
 */
function buildIssuePdf(pdfOptions, data) {
  const {
    entity,
    timezone
  } = data;
  const timestamp = entity.createdAt;
  const title = entity.title || 'Unknown';
  const fileTitle = `Issue Report - ${title}`;
  return generateContent(data).then(content => (0, _helpers.generateDefinition)({
    content,
    fileTitle,
    timestamp,
    timezone,
    type: 'Issue',
    ...pdfOptions
  }));
}

function generateContent(data) {
  const {
    entity,
    timezone
  } = data;
  const {
    entry,
    gps = {},
    timeline = [],
    title
  } = entity;
  const entityDetails = (0, _helpers2.getIssueDetails)(data);
  const {
    assigneeNames,
    gpsText,
    locationText,
    statusColor,
    statusText
  } = entityDetails;
  const reverseGeocoded = gps.reverseGeocoded;
  const subTitle = `${locationText || gpsText}`;
  const headerTitle = (0, _helpers.text)(title, {
    style: 'title'
  });
  const headerSubTitle = (0, _helpers.text)(subTitle, {
    style: 'subTitle'
  });
  const address = !(0, _lodash.isEmpty)(reverseGeocoded) ? (0, _helpers.getFormattedAddress)(reverseGeocoded) : '';
  const headerAddress = (0, _helpers.text)(address, {
    style: 'small'
  });
  const body = !(0, _lodash.isEmpty)(reverseGeocoded) ? [[headerTitle], [headerSubTitle], [headerAddress]] : [[headerTitle], [headerSubTitle]];
  const titleTable = (0, _helpers.table)({
    body,
    layout: 'noBorders',
    style: 'titleTable'
  });
  const assigneeLabelText = (0, _helpers.text)('Assignees', {
    bold: true
  });
  const assigneeValueText = (0, _helpers.text)(assigneeNames);
  const statusLabelText = (0, _helpers.text)('Status', {
    bold: true
  });
  const statusValueText = (0, _helpers.text)(statusText, {
    color: statusColor
  });
  const metaTable = (0, _helpers.table)({
    body: [[statusLabelText, statusValueText], [assigneeLabelText, assigneeValueText]],
    layout: 'noBorders',
    style: 'metaTable'
  });
  const timelineTitle = (0, _helpers.text)('Timeline', {
    style: 'timelineTitle'
  });
  const timelineHorizontalLine = (0, _helpers.horizontalLine)();
  const timelineTable = createTimelineTable(timeline, timezone);
  return (0, _helpers.buildTemplateContent)(entry.formGroups, data).then(entry => [titleTable, metaTable, timelineTitle, timelineHorizontalLine, timelineTable, ...entry]);
}

function createTimelineTable(timeline, timezone) {
  const timezoneAbbr = (0, _helpers2.getTimezoneAbbr)(timezone);
  const timelineHeaderRow = [(0, _helpers.text)('Activity', {
    bold: true
  }), (0, _helpers.text)('User', {
    bold: true
  }), (0, _helpers.text)(`Timestamp (${timezoneAbbr})`, {
    alignment: 'right',
    bold: true
  })];
  const statusUpdates = (0, _lodash.filter)(timeline, ['meta.field', 'status']);
  const timelineBodyRows = (0, _lodash.isEmpty)(statusUpdates) ? [(0, _helpers.text)('No Timeline activity', {
    colSpan: 3
  })] : (0, _lodash.map)(statusUpdates, item => {
    const {
      meta = {},
      source,
      timestamp,
      type
    } = item;
    const next = (0, _lodash.get)(meta, 'next');
    const firstName = (0, _lodash.get)(source, 'meta.firstName');
    const lastName = (0, _lodash.get)(source, 'meta.lastName');
    const fullName = firstName && lastName ? `${firstName} ${lastName}` : 'Unknown User';
    const isNew = type === 'issue-new';
    const isUpdate = type === 'issue-update';
    const isOpen = next === 'open';
    const statusDetails = (0, _helpers2.getStatusDetails)(next);
    const nextStatusText = statusDetails.text;
    const activity = isNew && isOpen ? 'Issue opened' : isNew && !isOpen ? `Issue opened with status ${nextStatusText}` : isUpdate ? `Issue updated to ${nextStatusText}` : 'Unknown status timeline change';
    const datetime = (0, _helpers2.getTimezoneDatetime)({
      format: 'h:mm a',
      showTzAbbr: false,
      timestamp,
      timezone
    });
    return [(0, _helpers.text)(activity), (0, _helpers.text)(fullName), (0, _helpers.text)(datetime, {
      alignment: 'right'
    })];
  });
  const timelineTable = (0, _helpers.threeColumnTable)({
    body: [timelineHeaderRow, ...timelineBodyRows]
  });
  return timelineTable;
}