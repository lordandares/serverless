"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serviceIntervalsGenerator = serviceIntervalsGenerator;

var _fp = require("lodash/fp");

var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _serviceHours = require("../../service-hours");

var _scheduling = require("../scheduling.types");

var _helpers = require("../helpers");

/**
 * Generates service intervals between start and end range for service hours
 */
function* serviceIntervalsGenerator(props) {
  const {
    end,
    serviceHours,
    start
  } = props;
  const {
    timezone
  } = serviceHours;
  const hasValidStartAndEnd = end > start && start < end;
  if (!hasValidStartAndEnd) return [];

  const mStart = _momentTimezone.default.tz(start, timezone);

  const mEnd = _momentTimezone.default.tz(end, timezone);

  const mStartValid = mStart.isValid();
  const mEndValid = mEnd.isValid();
  if (!mStartValid || !mEndValid) return [];
  const {
    hours
  } = serviceHours;
  const rangeInterval = [start, end];
  const closeOverrideHours = (0, _fp.filter)({
    behaviour: _serviceHours.Behaviours.Close,
    type: _serviceHours.Types.Override
  }, hours);
  const defaultHours = (0, _fp.filter)({
    type: _serviceHours.Types.Default
  }, hours);
  const openOverrideHours = (0, _fp.filter)({
    behaviour: _serviceHours.Behaviours.Open,
    type: _serviceHours.Types.Override
  }, hours); // NOTE: we must apply the timezone to overrides as they are stored in UTC
  // and must be converted to timestamps in the timezone before processing

  const closeIntervals = (0, _fp.map)(override => {
    const start = (0, _helpers.convertToTimezone)(override.start, timezone);
    const end = (0, _helpers.convertToTimezone)(override.end, timezone);
    return [start, end];
  }, closeOverrideHours);
  const openIntervals = (0, _fp.map)(override => {
    const start = (0, _helpers.convertToTimezone)(override.start, timezone);
    const end = (0, _helpers.convertToTimezone)(override.end, timezone);
    return [start, end];
  }, openOverrideHours);
  let weekStart = mStart.startOf(_scheduling.Unit.Week).valueOf();
  const defaultIntervals = [];

  while (weekStart < end) {
    (0, _fp.forEach)(hour => {
      // NOTE: hour start and end values are the number of minutes from the
      // start of the week so are simply offsets
      const {
        end: endOffset,
        start: startOffset
      } = hour;
      const hourStart = weekStart + startOffset;
      const hourEnd = weekStart + endOffset;
      const interval = [hourStart, hourEnd];
      const isIntervalIntersectingRangeEnd = (0, _helpers.intervalOnlyIntersectsEnd)(interval, rangeInterval);
      const isIntervalIntersectingRangeStart = (0, _helpers.intervalOnlyIntersectsStart)(interval, rangeInterval);
      const isIntervalInsideRange = (0, _helpers.intervalWithin)(interval, rangeInterval);
      const isRangeInsideInterval = (0, _helpers.intervalWithin)(rangeInterval, interval);
      const shouldSkip = !isIntervalInsideRange && !isRangeInsideInterval && !isIntervalIntersectingRangeStart && !isIntervalIntersectingRangeEnd;
      if (shouldSkip) return;
      const nextStart = isRangeInsideInterval || isIntervalIntersectingRangeStart ? start : hourStart;
      const nextEnd = isRangeInsideInterval || isIntervalIntersectingRangeEnd ? end : hourEnd;
      defaultIntervals.push([nextStart, nextEnd]);
    }, defaultHours);
    weekStart = weekStart + _serviceHours.Durations.Week;
  } // NOTE: only include intervals which intersect our range and then map to
  // ensure the intervals conform to the range interval


  const getOverrideIntervalsForRange = (0, _fp.flow)((0, _fp.filter)(interval => interval[0] >= rangeInterval[0] || interval[0] <= rangeInterval[1]), (0, _fp.map)(interval => {
    const intervalCoversRange = (0, _helpers.intervalCovers)(interval, rangeInterval);
    const intervalIntersectsRangeEnd = (0, _helpers.intervalOnlyIntersectsEnd)(interval, rangeInterval);
    const intervalIntersectsRangeStart = (0, _helpers.intervalOnlyIntersectsStart)(interval, rangeInterval);
    const intervalStart = intervalIntersectsRangeStart ? rangeInterval[0] : interval[0];
    const intervalEnd = intervalIntersectsRangeEnd ? rangeInterval[1] : interval[1];
    return intervalCoversRange ? rangeInterval : [intervalStart, intervalEnd];
  })); // NOTE: for simplicity we calculate all default service intervals and then
  // apply the open and closed overrides, we can't do this as we iterate
  // through the weeks as open and close overrides can potentially intersect
  // across weeks

  const rangeOpenIntervals = getOverrideIntervalsForRange(openIntervals);
  const rangeCloseIntervals = getOverrideIntervalsForRange(closeIntervals);
  const mergedIntervals = (0, _helpers.mergeIntervals)([...defaultIntervals, ...rangeOpenIntervals]);
  const serviceIntervals = (0, _helpers.splitIntervals)(mergedIntervals, rangeCloseIntervals);

  for (let interval of serviceIntervals) yield interval;
}