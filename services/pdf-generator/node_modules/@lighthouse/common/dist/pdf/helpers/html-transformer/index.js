"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToPdfMake = convertToPdfMake;
exports.getStyleAttributes = getStyleAttributes;
exports.parseHtml = parseHtml;
exports.toPdf = toPdf;

var _lodash = require("lodash");

var _reactHtmlParser = require("react-html-parser");

const LIST_KEY_MATCHER = ['ol', 'ul'];
const NEW_LINE_MATCHER = /.*\n.*/; // NOTE: this will remove all whitespace except spaces

const WHITSPACE_MATCHER = /[\t\r\n\f]/g;

function convertToPdfMake(obj) {
  if (!(0, _lodash.isPlainObject)(obj)) {
    return '';
  }

  const {
    children = [],
    data = '',
    name = '',
    type
  } = obj;

  if (type === 'text' && data) {
    const trimmed = data.replace(WHITSPACE_MATCHER, ''); // NOTE: Originally tried to achieve this by using inline styles, however PDFMake
    // does not support adding margins or padding when applying inline styles
    // (bold/italics/underline).  The easiest way to get around this was to add
    // an extra space after text.

    return trimmed;
  } // NOTE: Reject any children that are WYSIWYG carriage returns


  const filtered = (0, _lodash.reject)(children, ['data', NEW_LINE_MATCHER]);
  const parsed = (0, _lodash.compact)((0, _lodash.map)(filtered, convertToPdfMake));
  const key = (0, _lodash.includes)(LIST_KEY_MATCHER, name) ? name : 'text'; // NOTE: If the child is an array with a single text string, we just need to return
  // the string, so that the styles can be applied

  const text = (0, _lodash.isArray)(parsed) && parsed.length === 1 && (0, _lodash.isString)(parsed[0]) ? parsed[0] : parsed;
  return { ...getStyleAttributes(obj),
    [key]: text,
    preserveLeadingSpaces: true
  };
}

function getStyleAttributes({
  name = ''
}) {
  const result = {};
  if (name === 'em') result.italics = true;
  if (name === 'ins') result.decoration = 'underline';
  if (name === 'strong') result.bold = true;

  if (!result.bold && !result.decoration && !result.italics) {
    result.style = name;
  }

  return result;
}

function parseHtml(html) {
  if ((0, _lodash.isEmpty)(html) || !(0, _lodash.isString)(html)) {
    return '';
  }

  return _reactHtmlParser.htmlparser2.parseDOM(html, {
    decodeEntities: true
  });
}

function toPdf(htmlString) {
  if ((0, _lodash.isEmpty)(htmlString) || !(0, _lodash.isString)(htmlString)) {
    return [];
  }

  const arr = parseHtml(htmlString);
  return (0, _lodash.compact)((0, _lodash.map)(arr, convertToPdfMake));
}