import moment from 'moment-timezone';
import { Unit } from '../scheduling.types';
/**
 * Generates next occurrence interval for x day of x week of month strategy
 */

export function getNextXDayOfXWeekOfMonth(_ref) {
  var end = _ref.end,
      isInitial = _ref.isInitial,
      options = _ref.options,
      start = _ref.start,
      timezone = _ref.timezone;
  var dayOfWeek = options.dayOfWeek,
      duration = options.duration,
      frequency = options.frequency,
      weekOfMonth = options.weekOfMonth;
  var durationUnit = duration.unit,
      durationValue = duration.value;
  var frequencyUnit = frequency.unit,
      frequencyValue = frequency.value;
  var dateCursor = start;

  while (dateCursor < end) {
    var mStartOfMonth = isInitial ? moment.tz(dateCursor, timezone).startOf(Unit.Month) : moment.tz(dateCursor, timezone).add(frequencyValue, frequencyUnit).startOf(Unit.Month);
    var year = mStartOfMonth.year();
    var month = mStartOfMonth.month();
    var startDayOfMonth = mStartOfMonth.isoWeekday();
    var weekOffset = (weekOfMonth - 1) * 7;
    var day = startDayOfMonth > dayOfWeek ? dayOfWeek - startDayOfMonth + 8 : dayOfWeek - startDayOfMonth + 1;
    var date = weekOffset + day;
    var nextOccurrenceEnd = moment.tz(timezone).year(year).month(month).date(date).add(1, Unit.Day).startOf(Unit.Day).valueOf();
    var nextOccurrenceStart = moment.tz(nextOccurrenceEnd, timezone).subtract(durationValue, durationUnit).valueOf();
    if (nextOccurrenceEnd <= nextOccurrenceStart || nextOccurrenceEnd > end) return;

    if (nextOccurrenceStart >= start) {
      return [nextOccurrenceStart, nextOccurrenceEnd - 1];
    }

    var nextDateCursor = isInitial ? mStartOfMonth.add(1, Unit.Month).valueOf() : mStartOfMonth.valueOf();
    dateCursor = nextDateCursor;
  }
}
//# sourceMappingURL=getNextXDayOfXWeekOfMonth.js.map