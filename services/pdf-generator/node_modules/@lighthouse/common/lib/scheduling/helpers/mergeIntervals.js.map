{"version":3,"sources":["../../../src/scheduling/helpers/mergeIntervals.ts"],"names":["first","isEmpty","reduce","mergeIntervals","intervals","sortedIntervals","sort","a","b","firstInterval","stack","accum","interval","top","length","topBeforeInterval","topOverlapsInterval","push","pop"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,OAAhB,EAAyBC,MAAzB,QAAuC,WAAvC;;AAIA;;;;;;;AAOA,OAAO,SAASC,cAAT,CAAwBC,SAAxB,EAAqE;AAC1E,MAAIH,OAAO,CAACG,SAAD,CAAX,EAAwB,OAAOA,SAAP;AAExB,MAAMC,eAAe,GAAGD,SAAS,CAACE,IAAV,CAAe,UAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAlB;AAAA,GAAf,CAAxB;AACA,MAAMC,aAAa,GAAGT,KAAK,CAACK,eAAD,CAA3B;AAEA,MAAMK,KAAK,GAAGR,MAAM,CAClB,UAACS,KAAD,EAAQC,QAAR,EAAqB;AACnB,QAAMC,GAAG,GAAGF,KAAK,CAACA,KAAK,CAACG,MAAN,GAAe,CAAhB,CAAjB;AACA,QAAMC,iBAAiB,GAAGF,GAAG,CAAC,CAAD,CAAH,GAASD,QAAQ,CAAC,CAAD,CAA3C;AACA,QAAMI,mBAAmB,GAAGH,GAAG,CAAC,CAAD,CAAH,GAASD,QAAQ,CAAC,CAAD,CAA7C;;AAEA,QAAIG,iBAAJ,EAAuB;AACrBJ,MAAAA,KAAK,CAACM,IAAN,CAAWL,QAAX;AACD,KAFD,MAEO,IAAII,mBAAJ,EAAyB;AAC9BL,MAAAA,KAAK,CAACO,GAAN;AACAP,MAAAA,KAAK,CAACM,IAAN,CAAW,CAACJ,GAAG,CAAC,CAAD,CAAJ,EAASD,QAAQ,CAAC,CAAD,CAAjB,CAAX;AACD;;AAED,WAAOD,KAAP;AACD,GAdiB,EAelB,CAACF,aAAD,CAfkB,EAgBlBJ,eAhBkB,CAApB;AAmBA,SAAOK,KAAP;AACD","sourcesContent":["import { first, isEmpty, reduce } from 'lodash/fp'\n\nimport { Interval } from '../scheduling.types'\n\n/**\n * Merges overlapping intervals\n * Accepts arrays of intervals and returns a flattened result of overlapping intervals\n *\n * mergeIntervals([[1,15], [11,25], [21,29], [40,1000]])\n * returns [[1,29], [40,1000]]\n */\nexport function mergeIntervals(intervals: Array<Interval>): Array<Interval> {\n  if (isEmpty(intervals)) return intervals\n\n  const sortedIntervals = intervals.sort((a, b) => a[0] - b[0])\n  const firstInterval = first(sortedIntervals)\n\n  const stack = reduce(\n    (accum, interval) => {\n      const top = accum[accum.length - 1]\n      const topBeforeInterval = top[1] < interval[0]\n      const topOverlapsInterval = top[1] < interval[1]\n\n      if (topBeforeInterval) {\n        accum.push(interval)\n      } else if (topOverlapsInterval) {\n        accum.pop()\n        accum.push([top[0], interval[1]])\n      }\n\n      return accum\n    },\n    [firstInterval],\n    sortedIntervals\n  )\n\n  return stack\n}\n"],"file":"mergeIntervals.js"}