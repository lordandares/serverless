import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { get, filter, isEmpty, map } from 'lodash';
import { buildTemplateContent, generateDefinition, getFormattedAddress, horizontalLine, table, text, threeColumnTable } from '../helpers';
import { getIssueDetails, getStatusDetails, getTimezoneAbbr, getTimezoneDatetime } from '../../helpers';
/**
 * buildIssuePdf
 *
 * @param {object} pdfOptions - the pdf options
 * @param {string} pdfOptions.fileTitle - pdf file title
 * @param {function} pdfOptions.footer - function executed to generate footer
 * @param {function} pdfOptions.header - function executed to generate header
 * @param {string} pdfOptions.logoUrl - pdf logo url
 * @param {array} pdfOptions.pageMargins - pdf page margins
 * @param {string} pdfOptions.pageOrientation - pdf page orientation
 * @param {string} pdfOptions.pageSize - pdf page size
 * @param {object} pdfOptions.styles - pdf styles
 * @param {object} pdfOptions.title - pdf title
 * @param {object} data - pdf data
 * @param {object} data.entity - issue document
 * @param {object} data.locations - locations documents
 * @param {object} data.settings - settings properties
 * @param {string} data.settings.awsS3BaseUrl - aws S3 base url
 * @param {string} data.settings.cloudinaryBaseUrl - cloudinary base url
 * @param {string} data.timezone - timezone string
 * @param {object} data.users - application user documents
 * @param {object} data.zones - zone documents
 * @returns {Promise} returns pdfmake definition object
 */

export function buildIssuePdf(pdfOptions, data) {
  var entity = data.entity,
      timezone = data.timezone;
  var timestamp = entity.createdAt;
  var title = entity.title || 'Unknown';
  var fileTitle = "Issue Report - ".concat(title);
  return generateContent(data).then(function (content) {
    return generateDefinition(_objectSpread({
      content: content,
      fileTitle: fileTitle,
      timestamp: timestamp,
      timezone: timezone,
      type: 'Issue'
    }, pdfOptions));
  });
}

function generateContent(data) {
  var entity = data.entity,
      timezone = data.timezone;
  var entry = entity.entry,
      _entity$gps = entity.gps,
      gps = _entity$gps === void 0 ? {} : _entity$gps,
      _entity$timeline = entity.timeline,
      timeline = _entity$timeline === void 0 ? [] : _entity$timeline,
      title = entity.title;
  var entityDetails = getIssueDetails(data);
  var assigneeNames = entityDetails.assigneeNames,
      gpsText = entityDetails.gpsText,
      locationText = entityDetails.locationText,
      statusColor = entityDetails.statusColor,
      statusText = entityDetails.statusText;
  var reverseGeocoded = gps.reverseGeocoded;
  var subTitle = "".concat(locationText || gpsText);
  var headerTitle = text(title, {
    style: 'title'
  });
  var headerSubTitle = text(subTitle, {
    style: 'subTitle'
  });
  var address = !isEmpty(reverseGeocoded) ? getFormattedAddress(reverseGeocoded) : '';
  var headerAddress = text(address, {
    style: 'small'
  });
  var body = !isEmpty(reverseGeocoded) ? [[headerTitle], [headerSubTitle], [headerAddress]] : [[headerTitle], [headerSubTitle]];
  var titleTable = table({
    body: body,
    layout: 'noBorders',
    style: 'titleTable'
  });
  var assigneeLabelText = text('Assignees', {
    bold: true
  });
  var assigneeValueText = text(assigneeNames);
  var statusLabelText = text('Status', {
    bold: true
  });
  var statusValueText = text(statusText, {
    color: statusColor
  });
  var metaTable = table({
    body: [[statusLabelText, statusValueText], [assigneeLabelText, assigneeValueText]],
    layout: 'noBorders',
    style: 'metaTable'
  });
  var timelineTitle = text('Timeline', {
    style: 'timelineTitle'
  });
  var timelineHorizontalLine = horizontalLine();
  var timelineTable = createTimelineTable(timeline, timezone);
  return buildTemplateContent(entry.formGroups, data).then(function (entry) {
    return [titleTable, metaTable, timelineTitle, timelineHorizontalLine, timelineTable].concat(_toConsumableArray(entry));
  });
}

function createTimelineTable(timeline, timezone) {
  var timezoneAbbr = getTimezoneAbbr(timezone);
  var timelineHeaderRow = [text('Activity', {
    bold: true
  }), text('User', {
    bold: true
  }), text("Timestamp (".concat(timezoneAbbr, ")"), {
    alignment: 'right',
    bold: true
  })];
  var statusUpdates = filter(timeline, ['meta.field', 'status']);
  var timelineBodyRows = isEmpty(statusUpdates) ? [text('No Timeline activity', {
    colSpan: 3
  })] : map(statusUpdates, function (item) {
    var _item$meta = item.meta,
        meta = _item$meta === void 0 ? {} : _item$meta,
        source = item.source,
        timestamp = item.timestamp,
        type = item.type;
    var next = get(meta, 'next');
    var firstName = get(source, 'meta.firstName');
    var lastName = get(source, 'meta.lastName');
    var fullName = firstName && lastName ? "".concat(firstName, " ").concat(lastName) : 'Unknown User';
    var isNew = type === 'issue-new';
    var isUpdate = type === 'issue-update';
    var isOpen = next === 'open';
    var statusDetails = getStatusDetails(next);
    var nextStatusText = statusDetails.text;
    var activity = isNew && isOpen ? 'Issue opened' : isNew && !isOpen ? "Issue opened with status ".concat(nextStatusText) : isUpdate ? "Issue updated to ".concat(nextStatusText) : 'Unknown status timeline change';
    var datetime = getTimezoneDatetime({
      format: 'h:mm a',
      showTzAbbr: false,
      timestamp: timestamp,
      timezone: timezone
    });
    return [text(activity), text(fullName), text(datetime, {
      alignment: 'right'
    })];
  });
  var timelineTable = threeColumnTable({
    body: [timelineHeaderRow].concat(_toConsumableArray(timelineBodyRows))
  });
  return timelineTable;
}
//# sourceMappingURL=index.js.map