{"version":3,"sources":["../../../../src/pdf/helpers/html-transformer/index.js"],"names":["compact","includes","isArray","isEmpty","isPlainObject","isString","map","reject","htmlparser2","LIST_KEY_MATCHER","NEW_LINE_MATCHER","WHITSPACE_MATCHER","convertToPdfMake","obj","children","data","name","type","trimmed","replace","filtered","parsed","key","text","length","getStyleAttributes","result","italics","decoration","bold","style","parseHtml","html","parseDOM","decodeEntities","toPdf","htmlString","arr"],"mappings":"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","sourcesContent":["import {\n  compact,\n  includes,\n  isArray,\n  isEmpty,\n  isPlainObject,\n  isString,\n  map,\n  reject,\n} from 'lodash'\nimport { htmlparser2 } from 'react-html-parser'\n\nconst LIST_KEY_MATCHER = ['ol', 'ul']\nconst NEW_LINE_MATCHER = /.*\\n.*/\n// NOTE: this will remove all whitespace except spaces\nconst WHITSPACE_MATCHER = /[\\t\\r\\n\\f]/g\n\nexport function convertToPdfMake(obj) {\n  if (!isPlainObject(obj)) {\n    return ''\n  }\n\n  const { children = [], data = '', name = '', type } = obj\n\n  if (type === 'text' && data) {\n    const trimmed = data.replace(WHITSPACE_MATCHER, '')\n\n    // NOTE: Originally tried to achieve this by using inline styles, however PDFMake\n    // does not support adding margins or padding when applying inline styles\n    // (bold/italics/underline).  The easiest way to get around this was to add\n    // an extra space after text.\n    return trimmed\n  }\n\n  // NOTE: Reject any children that are WYSIWYG carriage returns\n  const filtered = reject(children, ['data', NEW_LINE_MATCHER])\n  const parsed = compact(map(filtered, convertToPdfMake))\n\n  const key = includes(LIST_KEY_MATCHER, name) ? name : 'text'\n  // NOTE: If the child is an array with a single text string, we just need to return\n  // the string, so that the styles can be applied\n  const text =\n    isArray(parsed) && parsed.length === 1 && isString(parsed[0])\n      ? parsed[0]\n      : parsed\n\n  return {\n    ...getStyleAttributes(obj),\n    [key]: text,\n    preserveLeadingSpaces: true,\n  }\n}\n\nexport function getStyleAttributes({ name = '' }) {\n  const result = {}\n  if (name === 'em') result.italics = true\n  if (name === 'ins') result.decoration = 'underline'\n  if (name === 'strong') result.bold = true\n\n  if (!result.bold && !result.decoration && !result.italics) {\n    result.style = name\n  }\n\n  return result\n}\n\nexport function parseHtml(html) {\n  if (isEmpty(html) || !isString(html)) {\n    return ''\n  }\n\n  return htmlparser2.parseDOM(html, { decodeEntities: true })\n}\n\nexport function toPdf(htmlString) {\n  if (isEmpty(htmlString) || !isString(htmlString)) {\n    return []\n  }\n\n  const arr = parseHtml(htmlString)\n  return compact(map(arr, convertToPdfMake))\n}\n"],"file":"index.js"}