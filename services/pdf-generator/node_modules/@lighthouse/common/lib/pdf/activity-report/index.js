import _regeneratorRuntime from "@babel/runtime/regenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { filter, find, groupBy, isEmpty, map, size, sortBy, take, toString, reduce } from 'lodash';
import moment from 'moment-timezone';
import Promise from 'bluebird';
import { generateDefinition, buildLocationScansContent, buildLocationScansBoundaries, horizontalLine, summaryStatTable, summaryWrapperTable, table, summaryFieldsTable, text, zebraFillColor } from '../helpers';
import { getLocationReference, getTimezoneAbbr, getTimezoneDatetime } from '../../helpers';
import { launchIcon } from '../../images';
var DEFAULT_MAX_SCANS = 200;
var LIGHTHOUSE_BASE_URL = 'https://app.lighthouse.io';
/**
 * buildActivityPdf
 *
 * @param {object} pdfOptions - the pdf options
 * @param {string} pdfOptions.fileTitle - pdf file title
 * @param {function} pdfOptions.footer - function executed to generate footer
 * @param {function} pdfOptions.header - function executed to generate header
 * @param {string} pdfOptions.logoUrl - pdf logo url
 * @param {array} pdfOptions.pageMargins - pdf page margins
 * @param {string} pdfOptions.pageOrientation - pdf page orientation
 * @param {string} pdfOptions.pageSize - pdf page size
 * @param {object} pdfOptions.styles - pdf styles
 * @param {object} pdfOptions.title - pdf title
 * @param {object} data - pdf data
 * @param {array} data.audits - audit documents
 * @param {string} data.end - end datetime of summary report
 * @param {array} data.events - event documents
 * @param {object} data.location - location document
 * @param {array} data.locations - location documents
 * @param {array} data.issues - issue documents
 * @param {bool} data.maxScans - max scans to include in standard report
 * @param {bool} data.showAlternate - show alternate summary report
 * @param {string} data.start - start datetime of summary report
 * @param {object} data.settings - settings properties
 * @param {string} data.settings.awsS3BaseUrl - aws S3 base url
 * @param {string} data.settings.cloudinaryBaseUrl - cloudinary base url
 * @param {array} data.tasks - task documents
 * @param {string} data.timestamp - timestamp string
 * @param {string} data.timezone - timezone string
 * @param {array} data.zones - zone documents
 * @param {array} data.users - user documents
 * @returns {Promise} returns pdfmake definition object
 */

export function buildActivityPdf(_x, _x2) {
  return _buildActivityPdf.apply(this, arguments);
}

function _buildActivityPdf() {
  _buildActivityPdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(pdfOptions, data) {
    var timestamp, timezone, title, content;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            timestamp = data.timestamp, timezone = data.timezone;
            title = 'Daily Activity Report';
            _context.next = 4;
            return generateContent(data);

          case 4:
            content = _context.sent;
            return _context.abrupt("return", generateDefinition(_objectSpread({
              content: content,
              fileTitle: title,
              timestamp: timestamp,
              timezone: timezone,
              type: 'Activity Summary'
            }, pdfOptions)));

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _buildActivityPdf.apply(this, arguments);
}

function generateContent(_x3) {
  return _generateContent.apply(this, arguments);
}

function _generateContent() {
  _generateContent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(data) {
    var activitySection, summarySection, titleTable;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return buildActivitySection(data);

          case 2:
            activitySection = _context2.sent;
            summarySection = buildSummarySection(data);
            titleTable = buildTitleTable(data);
            return _context2.abrupt("return", [titleTable, summarySection, activitySection]);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _generateContent.apply(this, arguments);
}

function buildActivitySection(_x4) {
  return _buildActivitySection.apply(this, arguments);
}

function _buildActivitySection() {
  _buildActivitySection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(data) {
    var _data$showAlternate, showAlternate, locationScans, otherActivity, activitySummary;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _data$showAlternate = data.showAlternate, showAlternate = _data$showAlternate === void 0 ? false : _data$showAlternate;

            if (!showAlternate) {
              _context3.next = 7;
              break;
            }

            locationScans = buildLocationScansSection(data);
            _context3.next = 5;
            return buildOtherActivitySection(data);

          case 5:
            otherActivity = _context3.sent;
            return _context3.abrupt("return", [locationScans, otherActivity]);

          case 7:
            _context3.next = 9;
            return buildActivitySummarySection(data);

          case 9:
            activitySummary = _context3.sent;
            return _context3.abrupt("return", [activitySummary]);

          case 11:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _buildActivitySection.apply(this, arguments);
}

function buildActivitySummarySection(_x5) {
  return _buildActivitySummarySection.apply(this, arguments);
}

function _buildActivitySummarySection() {
  _buildActivitySummarySection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data) {
    var audits, events, issues, _data$maxScans, maxScans, settings, tasks, timezone, enterEvents, exceedsMaxScans, scans, auditRows, issueRows, scanRows, taskRows, rows, sortedRows, title, header, hLine, activityTable, activitySummarySection, maxScansText;

    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            audits = data.audits, events = data.events, issues = data.issues, _data$maxScans = data.maxScans, maxScans = _data$maxScans === void 0 ? DEFAULT_MAX_SCANS : _data$maxScans, settings = data.settings, tasks = data.tasks, timezone = data.timezone;
            enterEvents = filter(events, function (event) {
              return event.type === 'enter';
            });
            exceedsMaxScans = size(enterEvents) > maxScans;
            scans = take(enterEvents, maxScans);
            auditRows = map(audits, getFormRowData('audits', data));
            issueRows = map(issues, getFormRowData('issues', data));
            scanRows = map(scans, getScanRowData(data));
            taskRows = map(tasks, getFormRowData('tasks', data));
            rows = [].concat(_toConsumableArray(auditRows), _toConsumableArray(issueRows), _toConsumableArray(scanRows), _toConsumableArray(taskRows));
            sortedRows = sortBy(rows, ['timestamp'], ['asc']);
            title = text('Activity Summary', {
              style: 'summarySectionHeader'
            });
            header = table({
              body: [[title]],
              layout: 'noBorders',
              style: 'summaryHeaderTable'
            });
            hLine = horizontalLine();
            _context4.next = 15;
            return buildActivityTable({
              rows: sortedRows,
              settings: settings,
              timezone: timezone
            });

          case 15:
            activityTable = _context4.sent;
            activitySummarySection = [header, hLine, activityTable];

            if (exceedsMaxScans) {
              maxScansText = {
                text: [text("Location Scans in the Daily Activity Report are limited to a total of ".concat(maxScans, ".")), text(' To view all Location Scans visit '), text('the Events Report', {
                  link: "".concat(LIGHTHOUSE_BASE_URL, "/reports/events")
                }), text(' in the Lighthouse Management Console.')],
                style: 'small',
                margin: [0, 10, 0, 10]
              };
              activitySummarySection.push(maxScansText);
            }

            return _context4.abrupt("return", activitySummarySection);

          case 19:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _buildActivitySummarySection.apply(this, arguments);
}

function buildActivityTable(_x6) {
  return _buildActivityTable.apply(this, arguments);
}

function _buildActivityTable() {
  _buildActivityTable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref3) {
    var rows, settings, timezone, timezoneAbbr, activityTableHeader, activityTableRows, activityTableBody, activityTable;
    return _regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            rows = _ref3.rows, settings = _ref3.settings, timezone = _ref3.timezone;
            timezoneAbbr = getTimezoneAbbr(timezone);
            activityTableHeader = [text('Activity', {
              bold: true
            }), {
              text: ''
            }, // icon column
            text('Location', {
              bold: true
            }), text('User', {
              bold: true
            }), text("Timestamp (".concat(timezoneAbbr, ")"), {
              alignment: 'right',
              bold: true
            })];
            _context6.next = 5;
            return Promise.map(rows, /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(data) {
                var link, location, icon, name, summaryFields, timestamp, title, timezoneHour, iconCell, rows, hasSummaryFields, fieldsTable, activityTableRow;
                return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        link = data.link, location = data.location, icon = data.icon, name = data.name, summaryFields = data.summaryFields, timestamp = data.timestamp, title = data.title;
                        timezoneHour = getTimezoneDatetime({
                          format: 'ddd DD h:mm a',
                          showTzAbbr: false,
                          timestamp: timestamp,
                          timezone: timezone
                        });
                        iconCell = icon ? {
                          alignment: 'center',
                          fit: [8, 8],
                          image: icon,
                          link: link
                        } : {
                          text: ''
                        }; // NOTE: pass link to each column as
                        // we can't wrap the entire table row

                        rows = [[text(title, {
                          link: link
                        }), iconCell, text(location, {
                          link: link
                        }), text(name, {
                          link: link
                        }), text(timezoneHour, {
                          alignment: 'right',
                          link: link
                        })]];
                        hasSummaryFields = !isEmpty(summaryFields);

                        if (!hasSummaryFields) {
                          _context5.next = 10;
                          break;
                        }

                        _context5.next = 8;
                        return summaryFieldsTable({
                          fields: summaryFields,
                          settings: settings,
                          timezone: timezone
                        });

                      case 8:
                        fieldsTable = _context5.sent;
                        rows.push([fieldsTable]);

                      case 10:
                        // NOTE: we return a table per row which includes the entry details and the
                        // summary fields if relevant
                        activityTableRow = [table({
                          body: [].concat(rows),
                          colSpan: 5,
                          dontBreakRows: true,
                          headerRow: 0,
                          layout: {
                            hLineWidth: function hLineWidth() {
                              return 0;
                            },
                            paddingLeft: function paddingLeft() {
                              return 0;
                            },
                            paddingRight: function paddingRight() {
                              return 0;
                            },
                            paddingTop: function paddingTop() {
                              return 5;
                            },
                            paddingBottom: function paddingBottom() {
                              return 5;
                            },
                            vLineWidth: function vLineWidth() {
                              return 0;
                            }
                          },
                          // NOTE: the timestamp must fill up the rest of the table space as
                          // otherwise the padding would be off between this table and the parent
                          // table that wraps it
                          widths: [130, 25, 110, 110, '*']
                        })];
                        return _context5.abrupt("return", activityTableRow);

                      case 12:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function (_x8) {
                return _ref4.apply(this, arguments);
              };
            }());

          case 5:
            activityTableRows = _context6.sent;
            activityTableBody = isEmpty(activityTableRows) ? [[text('No other activity', {
              colSpan: 5
            })]] : activityTableRows;
            activityTable = table({
              body: [activityTableHeader].concat(_toConsumableArray(activityTableBody)),
              dontBreakRows: true,
              layout: {
                hLineWidth: function hLineWidth() {
                  return 0;
                },
                fillColor: zebraFillColor,
                paddingLeft: function paddingLeft() {
                  return 5;
                },
                paddingRight: function paddingRight() {
                  return 5;
                },
                paddingTop: function paddingTop() {
                  return 5;
                },
                paddingBottom: function paddingBottom() {
                  return 5;
                },
                vLineWidth: function vLineWidth() {
                  return 0;
                }
              },
              widths: [120, 15, 100, 100, '*']
            });
            return _context6.abrupt("return", activityTable);

          case 9:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _buildActivityTable.apply(this, arguments);
}

function buildLocationScansSection(data) {
  var events = data.events,
      start = data.start,
      timezone = data.timezone,
      zones = data.zones;
  var title = text('Location Scans', {
    style: 'summarySectionHeader'
  });
  var header = table({
    body: [[title]],
    layout: 'noBorders',
    style: 'summaryHeaderTable'
  }); // use start time and timezone to figure out the interval boundaries

  var hourIntervalBoundaries = buildLocationScansBoundaries(start, timezone); // pair interval boundaries into column headers for the table

  var hourIntervalColumnHeaders = hourIntervalBoundaries.reduce(function (columns, interval, index, intervals) {
    if (index < size(intervals) - 1) // skip the final iteration as it's just the end of the last interval
      columns.push(text("".concat(interval.format('h'), "-").concat(intervals[index + 1].format('hA')), {
        alignment: 'center',
        bold: true
      }));
    return columns;
  }, []);
  var scansTableHeader = [text('Location', {
    bold: true
  })].concat(_toConsumableArray(hourIntervalColumnHeaders), [text('Total', {
    alignment: 'right',
    bold: true
  })]);
  var hLine = horizontalLine(); // NOTE: only show the enter events within the summary table

  var enterEvents = filter(events, function (event) {
    return event.type === 'enter';
  });
  var sortedZones = sortBy(zones, ['name']);
  var groupedEventsByZone = reduce(sortedZones, function (memo, zone) {
    var zoneEvents = filter(enterEvents, function (event) {
      return event.zone && event.zone.toString() === zone._id.toString();
    });
    memo[zone._id] = zoneEvents;
    return memo;
  }, {});
  var scansTableRows = map(groupedEventsByZone, function (events) {
    var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var sortedGroup = sortBy(events, ['timestamp'], ['asc']); // put events into interval buckets

    var locationScansByInterval = buildLocationScansContent(hourIntervalBoundaries, events); // map the interval buckets to a format fit for the table

    var locationScansByIntervalContent = locationScansByInterval.map(function (interval) {
      return {
        alignment: 'center',
        text: size(interval)
      };
    });
    var totalEvents = size(sortedGroup);
    var zoneDoc = zone && find(zones, function (doc) {
      return doc._id.toString() === zone.toString();
    });
    var zoneName = zoneDoc && zoneDoc.name || 'Unknown Location';
    return [zoneName].concat(_toConsumableArray(locationScansByIntervalContent), [{
      alignment: 'right',
      bold: true,
      text: totalEvents
    }]);
  });
  var scansTableBody = isEmpty(scansTableRows) ? [[text('No location scans', {
    colSpan: 10
  })]] : scansTableRows;
  var scansTable = table({
    body: [scansTableHeader].concat(_toConsumableArray(scansTableBody)),
    widths: [100, '*', '*', '*', '*', '*', '*', '*', '*', '*']
  });
  return [header, hLine, scansTable];
}

function buildSummarySection(data) {
  var audits = data.audits,
      events = data.events,
      issues = data.issues,
      tasks = data.tasks; //const userEvents = groupBy(events, 'user')

  var eventsByType = groupBy(events, 'type');
  var enterEventsCount = size(eventsByType.enter); //const geoEventsCount = size(eventsByType.geo)

  var issuesCount = size(issues);
  var tasksCount = size(tasks);
  var auditsCount = size(audits); //const uniqueUsers = size(userEvents)

  var auditsText = text('AUDITS', {
    style: 'summaryText'
  }); //const geoText = text('GPS', { style: 'summaryText' })

  var issuesText = text('ISSUES', {
    style: 'summaryText'
  }); //const peopleText = text('PEOPLE', { style: 'summaryText' })

  var scansText = text('SCANS', {
    style: 'summaryText'
  });
  var tasksText = text('TASKS', {
    style: 'summaryText'
  });
  var auditsCountText = text(toString(auditsCount), {
    style: 'summaryCount'
  }); //const peopleCountText = text(toString(uniqueUsers), { style: 'summaryCount' })

  var scansCountText = text(toString(enterEventsCount), {
    style: 'summaryCount'
  }); //const geoCountText = text(toString(geoEventsCount), { style: 'summaryCount' })

  var issuesCountText = text(toString(issuesCount), {
    style: 'summaryCount'
  });
  var tasksCountText = text(toString(tasksCount), {
    style: 'summaryCount'
  });
  var auditTable = summaryStatTable({
    body: [[auditsText], [auditsCountText]]
  }); //const peopleTable = summaryStatTable({
  //  body: [[peopleText], [peopleCountText]],
  //})
  //const gpsTable = summaryStatTable({ body: [[geoText], [geoCountText]] })

  var scanTable = summaryStatTable({
    body: [[scansText], [scansCountText]]
  });
  var issueTable = summaryStatTable({
    body: [[issuesText], [issuesCountText]]
  });
  var taskTables = summaryStatTable({
    body: [[tasksText], [tasksCountText]]
  });
  var wrapperTable = summaryWrapperTable({
    body: [[
    /*peopleTable,*/

    /*gpsTable,*/
    scanTable, issueTable, taskTables, auditTable]]
  });
  return wrapperTable;
}

function buildOtherActivitySection(_x7) {
  return _buildOtherActivitySection.apply(this, arguments);
}

function _buildOtherActivitySection() {
  _buildOtherActivitySection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(data) {
    var audits, issues, tasks, settings, timezone, auditRows, issueRows, taskRows, rows, sortedRows, title, header, hLine, activityTable;
    return _regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            audits = data.audits, issues = data.issues, tasks = data.tasks, settings = data.settings, timezone = data.timezone;
            auditRows = map(audits, getFormRowData('audits', data));
            issueRows = map(issues, getFormRowData('issues', data));
            taskRows = map(tasks, getFormRowData('tasks', data));
            rows = [].concat(_toConsumableArray(auditRows), _toConsumableArray(issueRows), _toConsumableArray(taskRows));
            sortedRows = sortBy(rows, ['timestamp'], ['asc']);
            title = text('Other Activity', {
              style: 'summarySectionHeader'
            });
            header = table({
              body: [[title]],
              layout: 'noBorders',
              style: 'summaryHeaderTable'
            });
            hLine = horizontalLine();
            _context7.next = 11;
            return buildActivityTable({
              rows: sortedRows,
              settings: settings,
              timezone: timezone
            });

          case 11:
            activityTable = _context7.sent;
            return _context7.abrupt("return", [header, hLine, activityTable]);

          case 13:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _buildOtherActivitySection.apply(this, arguments);
}

function buildTitleTable(data) {
  var location = data.location,
      start = data.start,
      end = data.end,
      timezone = data.timezone;
  var _location$address = location.address,
      address = _location$address === void 0 ? {} : _location$address;
  var headerTitle = text('Daily Activity Report', {
    style: 'title'
  });
  var headerSubTitle = text(location.name, {
    style: 'subTitle'
  });
  var addressText = !isEmpty(address) ? "".concat(address.street, ", ").concat(address.city || '', " ").concat(address.state || '', " ").concat(address.postalCode || '') : '';
  var headerAddress = text(addressText, {
    style: 'small'
  });
  var mTimezoneStart = moment.tz(start, timezone);
  var mTimezoneEnd = moment.tz(end, timezone);
  var timezoneAbbr = getTimezoneAbbr(timezone);
  var rangeStart = moment(mTimezoneStart).format('MMM DD h:mma');
  var rangeEnd = moment(mTimezoneEnd).add(1, 'hour').startOf('hour').format('MMM DD h:mma');
  var headerRange = text("".concat(rangeStart, " - ").concat(rangeEnd, " (").concat(timezoneAbbr, ")"), {
    style: 'subTitle2'
  });
  var body = !isEmpty(address) ? [[headerTitle], [headerSubTitle], [headerAddress], [headerRange]] : [[headerTitle], [headerSubTitle], [headerRange]];
  return table({
    body: body,
    layout: 'noBorders',
    style: 'titleTable'
  });
}

function getFormRowData(collection, _ref) {
  var locations = _ref.locations,
      users = _ref.users,
      zones = _ref.zones;
  return function (document) {
    var _id = document._id,
        createdAt = document.createdAt,
        _document$entry = document.entry,
        entry = _document$entry === void 0 ? {} : _document$entry,
        _document$title = document.title,
        title = _document$title === void 0 ? 'Unknown' : _document$title,
        _document$user = document.user,
        user = _document$user === void 0 ? '' : _document$user;
    var location = getLocationReference({
      entity: document,
      locations: locations,
      zones: zones
    });
    var link = "".concat(LIGHTHOUSE_BASE_URL, "/reports/").concat(collection, "/").concat(_id);
    var timestamp = createdAt;
    var userDoc = find(users, function (doc) {
      return doc._id.toString() === user.toString();
    });
    var name = userDoc && "".concat(userDoc.firstName, " ").concat(userDoc.lastName) || 'Unknown User'; // NOTE: currently only issues and tasks will return summary fields, audits
    // aren't supported and will return an empty array here

    var summaryFields = entry.summaryFields || [];
    return {
      icon: launchIcon,
      location: location,
      link: link,
      name: name,
      summaryFields: summaryFields,
      timestamp: timestamp,
      title: title
    };
  };
}

function getScanRowData(_ref2) {
  var users = _ref2.users,
      zones = _ref2.zones;
  return function (document) {
    var timestamp = document.timestamp,
        _document$user2 = document.user,
        user = _document$user2 === void 0 ? '' : _document$user2,
        _document$zone = document.zone,
        zone = _document$zone === void 0 ? '' : _document$zone;
    var userDoc = user && find(users, function (doc) {
      return doc._id.toString() === user.toString();
    });
    var zoneDoc = zone && find(zones, function (doc) {
      return doc._id.toString() === zone.toString();
    });
    var zoneName = zoneDoc && zoneDoc.name;
    var location = zoneName || 'Unknown Location';
    var name = userDoc && "".concat(userDoc.firstName, " ").concat(userDoc.lastName) || 'Unknown User';
    var title = 'Location Scan';
    return {
      location: location,
      timestamp: timestamp,
      name: name,
      title: title
    };
  };
}
//# sourceMappingURL=index.js.map