import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import Promise from 'bluebird';
import { isEmpty } from 'lodash';
import { buildAuditContent, buildTemplateContent, generateDefinition, getFormattedAddress, horizontalLine, text, twoColumnTable } from '../helpers';
import { getAuditEntryDetails } from '../../helpers';
/**
 * buildAuditPdf
 *
 * @param {object} pdfOptions - the pdf options
 * @param {string} pdfOptions.fileTitle - pdf file title
 * @param {function} pdfOptions.footer - function executed to generate footer
 * @param {function} pdfOptions.header - function executed to generate header
 * @param {string} pdfOptions.logoUrl - pdf logo url
 * @param {array} pdfOptions.pageMargins - pdf page margins
 * @param {string} pdfOptions.pageOrientation - pdf page orientation
 * @param {string} pdfOptions.pageSize - pdf page size
 * @param {object} pdfOptions.styles - pdf styles
 * @param {object} pdfOptions.title - pdf title
 * @param {object} data - pdf data
 * @param {object} data.entity - audit document
 * @param {object} data.locations - locations documents
 * @param {object} data.settings - settings properties
 * @param {string} data.settings.awsS3BaseUrl - aws S3 base url
 * @param {string} data.settings.cloudinaryBaseUrl - cloudinary base url
 * @param {string} data.timezone - timezone string
 * @param {object} data.users - application user documents
 * @returns {Promise} returns pdfmake definition object
 */

export function buildAuditPdf(pdfOptions, data) {
  var entity = data.entity,
      timezone = data.timezone;
  var timestamp = entity.createdAt;
  var title = entity.title || 'Unknown';
  var fileTitle = "Audit Report - ".concat(title);
  return generateContent(data).then(function (content) {
    return generateDefinition(_objectSpread({
      content: content,
      fileTitle: fileTitle,
      timestamp: timestamp,
      timezone: timezone,
      type: 'Audit'
    }, pdfOptions));
  }).catch(function (err) {
    throw new Error("BuildAuditPdfError: ".concat(err.message));
  });
}

function generateContent(data) {
  var entity = data.entity;
  var _entity$footerFields = entity.footerFields,
      footerFields = _entity$footerFields === void 0 ? {} : _entity$footerFields,
      _entity$gps = entity.gps,
      gps = _entity$gps === void 0 ? {} : _entity$gps,
      _entity$headerFields = entity.headerFields,
      headerFields = _entity$headerFields === void 0 ? {} : _entity$headerFields,
      _entity$score = entity.score,
      score = _entity$score === void 0 ? {} : _entity$score,
      _entity$title = entity.title,
      title = _entity$title === void 0 ? 'Unknown' : _entity$title;
  var entityDetails = getAuditEntryDetails(data);
  var gpsText = entityDetails.gpsText,
      groupedData = entityDetails.groupedData,
      locationText = entityDetails.locationText,
      referenceValue = entityDetails.referenceValue,
      timezoneHourTime = entityDetails.timezoneHourTime,
      scoreText = entityDetails.scoreText;
  var reverseGeocoded = gps.reverseGeocoded;
  var subTitle = "".concat(locationText || gpsText, " - ").concat(timezoneHourTime, " by ").concat(referenceValue);
  var headerTitle = text(title, {
    style: 'title'
  });
  var headerScore = text(scoreText, {
    alignment: 'right',
    style: 'title'
  });
  var headerSubTitle = text(subTitle, {
    colSpan: 2,
    style: 'subTitle'
  });
  var address = !isEmpty(reverseGeocoded) ? getFormattedAddress(reverseGeocoded) : '';
  var headerAddress = text(address, {
    colSpan: 2,
    style: 'small'
  });
  var scoreBreakdown = text("".concat(score.actual, " / ").concat(score.max), {
    alignment: 'right',
    style: 'totalScore'
  });
  var scorePercentage = text(scoreText, {
    alignment: 'right',
    colSpan: 2,
    style: 'totalAuditScore'
  });
  var scoreTitle = text('Total Score', {
    style: 'totalScore'
  });
  var body = !isEmpty(reverseGeocoded) ? [[headerTitle, headerScore], [headerSubTitle], [headerAddress]] : [[headerTitle, headerScore], [headerSubTitle]];
  var titleTable = twoColumnTable({
    body: body,
    layout: 'noBorders',
    style: 'titleTable',
    widths: ['*', 80]
  });
  var totalScoreTable = twoColumnTable({
    body: [[scoreTitle, scoreBreakdown], [scorePercentage]],
    layout: 'noBorders',
    widths: ['*', 80]
  });
  var hLineTop = horizontalLine({
    margin: [0, 10, 0, 0]
  });
  var hLineBottom = horizontalLine();
  var promises = {
    entry: buildAuditContent(groupedData.items),
    footerTemplate: buildTemplateContent(footerFields.formGroups, data),
    headerTemplate: buildTemplateContent(headerFields.formGroups, data)
  };
  return Promise.props(promises).then(function (_ref) {
    var entry = _ref.entry,
        footerTemplate = _ref.footerTemplate,
        headerTemplate = _ref.headerTemplate;
    return [titleTable].concat(_toConsumableArray(headerTemplate), _toConsumableArray(entry), [hLineTop, totalScoreTable, hLineBottom], _toConsumableArray(footerTemplate));
  }).catch(function (err) {
    throw new Error("GenerateContentError: ".concat(err.message));
  });
}
//# sourceMappingURL=index.js.map