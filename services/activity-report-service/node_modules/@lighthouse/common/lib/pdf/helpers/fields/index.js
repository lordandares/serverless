import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { isArray, isEmpty, join, first, map, startsWith } from 'lodash';
import Promise from 'bluebird';
import moment from 'moment-timezone';
import { buildFetchUrl, fetchImage } from '../../../helpers';
import { imageNotFound } from '../../../images';
import { imageTables, parseValue, text, toPdf } from '../';
export function buildFile(_ref) {
  var file = _ref.file,
      settings = _ref.settings;
  var extension = file.extension,
      name = file.name,
      path = file.path;
  var awsS3BaseUrl = settings.awsS3BaseUrl;
  var link = "".concat(awsS3BaseUrl, "/").concat(path);
  return text("".concat(name, ".").concat(extension), {
    link: link,
    margin: [0, 0, 0, 10]
  });
}

function buildImage(options) {
  var _options$alignment = options.alignment,
      alignment = _options$alignment === void 0 ? 'center' : _options$alignment,
      filepath = options.filepath,
      _options$height = options.height,
      height = _options$height === void 0 ? 210 : _options$height,
      settings = options.settings,
      _options$width = options.width,
      width = _options$width === void 0 ? 210 : _options$width;
  var awsS3BaseUrl = settings.awsS3BaseUrl,
      cloudinaryBaseUrl = settings.cloudinaryBaseUrl;
  var url = buildFetchUrl(filepath, {
    awsS3BaseUrl: awsS3BaseUrl,
    cloudinaryBaseUrl: cloudinaryBaseUrl,
    fit: true,
    height: 880,
    width: 880
  });
  var link = "".concat(awsS3BaseUrl, "/").concat(filepath);
  return fetchImage(url).then(function (base64String) {
    return {
      alignment: alignment,
      fit: [width, height],
      image: base64String,
      link: link
    };
  }).catch(function () {
    return {
      alignment: alignment,
      fit: [width, height],
      image: imageNotFound
    };
  });
}

export function buildSummaryField(_ref2) {
  var field = _ref2.field,
      settings = _ref2.settings,
      timezone = _ref2.timezone;
  var fieldtype = field.fieldtype,
      _field$options = field.options,
      options = _field$options === void 0 ? {} : _field$options,
      value = field.value;
  var isDayFirstDateField = fieldtype === 'date' && options.format === 'DD/MM/YY';
  var isMonthFirstDateField = fieldtype === 'date' && options.format === 'MM/DD/YY';
  var isFileField = fieldtype === 'file';
  var isHtmlField = fieldtype === 'text' && options.type === 'html';
  var isNumberField = fieldtype === 'number';
  var isPhotoField = fieldtype === 'list' && options.type === 'media';
  var isSelectField = fieldtype === 'select' && options.type !== 'stars';
  var isSignatureField = fieldtype === 'text' && options.type === 'signature';
  var isStarField = fieldtype === 'select' && options.type === 'stars';
  var isSwitchField = fieldtype === 'switch';
  var isTextField = fieldtype === 'text';
  var is12HourTimeField = fieldtype === 'time' && options.format === 'h:mm a';
  var is24HourTimeField = fieldtype === 'time' && options.format === 'HH:mm'; // NOTE: html field is not supported for the summary fields but adding
  // logic to catch this and return empty text for completeness

  if (isHtmlField) {
    return {
      text: ''
    };
  }

  if (isSignatureField) {
    if (!value) return '-';

    if (isDataImage(value)) {
      return {
        alignment: 'left',
        image: value,
        width: 140
      };
    }

    return fetchImage(value).then(function (base64String) {
      return {
        alignment: 'left',
        image: base64String,
        width: 140
      };
    }).catch(function () {
      return {
        alignment: 'left',
        image: imageNotFound,
        width: 140
      };
    });
  }

  if (isPhotoField) {
    var filepath = first(value); // NOTE: if no filepath return empty text as user has not uploaded an image
    // for this field

    if (!filepath) {
      return {
        text: ''
      };
    }

    var image = buildImage({
      alignment: 'left',
      filepath: filepath,
      height: 140,
      width: 140,
      settings: settings
    });
    return image;
  }

  if (isFileField) {
    var fileList = map(value, function (file) {
      return buildFile({
        file: file,
        settings: settings
      });
    });
    return {
      ol: fileList
    };
  }

  if (isNumberField || isSelectField || isSwitchField || isTextField) {
    var parsedValue = parseValue(value);
    var displayValue = isArray(parsedValue) ? {
      text: join(parsedValue, ', '),
      fontSize: 7
    } : {
      text: parsedValue,
      fontSize: 7
    };
    return displayValue;
  }

  if (isStarField) {
    if (!value) return '-';

    var _displayValue = value === '1' ? "".concat(value, " star") : "".concat(value, " stars");

    return _displayValue;
  }

  if (isDayFirstDateField || isMonthFirstDateField || is12HourTimeField || is24HourTimeField) {
    var format = options.format;

    var _displayValue2 = moment(value).tz(timezone).format(format);

    return _displayValue2;
  } // NOTE: return empty text fallback value when no match


  return {
    text: ''
  };
}
export function buildTemplateFieldRow(_ref3) {
  var field = _ref3.field,
      settings = _ref3.settings,
      timezone = _ref3.timezone;
  var fieldtype = field.fieldtype,
      label = field.label,
      _field$options2 = field.options,
      options = _field$options2 === void 0 ? {} : _field$options2,
      value = field.value;
  var _options$showOnRead = options.showOnRead,
      showOnRead = _options$showOnRead === void 0 ? true : _options$showOnRead;
  var isDayFirstDateField = fieldtype === 'date' && options.format === 'DD/MM/YY';
  var isMonthFirstDateField = fieldtype === 'date' && options.format === 'MM/DD/YY';
  var isFileField = fieldtype === 'file';
  var isHtmlField = fieldtype === 'text' && options.type === 'html';
  var isNumberField = fieldtype === 'number';
  var isPhotoField = fieldtype === 'list' && options.type === 'media';
  var isSelectField = fieldtype === 'select' && options.type !== 'stars';
  var isSignatureField = fieldtype === 'text' && options.type === 'signature';
  var isStarField = fieldtype === 'select' && options.type === 'stars';
  var isSwitchField = fieldtype === 'switch';
  var isTextField = fieldtype === 'text';
  var is12HourTimeField = fieldtype === 'time' && options.format === 'h:mm a';
  var is24HourTimeField = fieldtype === 'time' && options.format === 'HH:mm';
  var isDisplayImageField = fieldtype === 'image-display' && showOnRead; // NOTE: only show field when show on read is true

  if (!showOnRead) return null;
  var labelText = [{
    text: label
  }];

  if (isHtmlField) {
    var parsed = value.replace(/<p><\/p>/g, '');
    return [labelText, toPdf(parsed)];
  }

  if (isSignatureField) {
    if (!value) return [labelText, '-'];
    return fetchImage(value).then(function (base64String) {
      var values = {
        alignment: 'left',
        image: base64String,
        width: 140
      };
      return [labelText, values];
    }).catch(function () {
      return [labelText, {
        alignment: 'left',
        image: imageNotFound,
        width: 140
      }];
    });
  }

  if (isDisplayImageField) {
    return Promise.map([value], function (filepath) {
      return buildImage({
        filepath: filepath,
        settings: settings
      });
    }).then(function (fieldImages) {
      return [fieldImages, {}];
    });
  }

  if (isPhotoField) {
    return Promise.map(value, function (filepath) {
      return buildImage({
        filepath: filepath,
        settings: settings
      });
    }).then(function (fieldImages) {
      var tables = !isEmpty(fieldImages) ? imageTables(fieldImages) : [];
      var imagesRow = {
        colSpan: 2,
        layout: {
          hLineWidth: function hLineWidth() {
            return 0;
          },
          paddingLeft: function paddingLeft() {
            return 0;
          },
          paddingRight: function paddingRight() {
            return 0;
          },
          paddingTop: function paddingTop() {
            return 0;
          },
          paddingBottom: function paddingBottom() {
            return 0;
          },
          vLineWidth: function vLineWidth() {
            return 0;
          }
        },
        table: {
          body: [labelText].concat(_toConsumableArray(tables)),
          widths: ['*']
        }
      }; // NOTE: pass empty value here as otherwise
      // we can accidentally hide content below
      // this row. Please see the following issue:
      // https://github.com/bpampuch/pdfmake/issues/1598

      return [imagesRow, {}];
    });
  }

  if (isFileField) {
    var fileList = map(value, function (file) {
      return buildFile({
        file: file,
        settings: settings
      });
    });
    return [labelText, {
      ol: fileList
    }];
  }

  if (isNumberField || isSelectField || isSwitchField || isTextField) {
    var parsedValue = parseValue(value);
    var displayValue = isArray(parsedValue) ? {
      text: join(parsedValue, ', ')
    } : {
      text: parsedValue
    };
    return [labelText, displayValue];
  }

  if (isStarField) {
    if (!value) return [labelText, '-'];

    var _displayValue3 = value === '1' ? "".concat(value, " star") : "".concat(value, " stars");

    return [labelText, _displayValue3];
  }

  if (isDayFirstDateField || isMonthFirstDateField || is12HourTimeField || is24HourTimeField) {
    var format = options.format;

    var _displayValue4 = value ? moment(value).tz(timezone).format(format) : '-';

    return [labelText, _displayValue4];
  } // NOTE: if no match above null values will be stripped within calling fn


  return null;
}

function isDataImage(string) {
  return startsWith(string, 'data:image/png;');
}
//# sourceMappingURL=index.js.map