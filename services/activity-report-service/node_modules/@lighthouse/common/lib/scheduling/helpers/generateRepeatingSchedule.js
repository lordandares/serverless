import _regeneratorRuntime from "@babel/runtime/regenerator";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";

var _marked = /*#__PURE__*/_regeneratorRuntime.mark(generateRepeatingSchedule);

import { includes } from 'lodash/fp';
import { generateScheduleEnd, hasValidStartAndEnd } from '.';
import { IntervalTypes, Unit } from '../scheduling.types';
import { occurrenceIntervalsGenerator, serviceIntervalsGenerator } from '../generators';
export var complyingServiceIntervalUnits = [Unit.Second, Unit.Minute, Unit.Hour];
/**
 * Generates repeating schedule service and occurrence intervals
 */

export function generateRepeatingSchedule(props) {
  var isInitial, serviceHours, start, strategy, end, frequency, frequencyUnit, frequencyValue, timezone, isStartAndEndValid, serviceIntervalSequence, complyToServiceHours, serviceIntervals, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, serviceInterval, occurrenceIntervalsSequence, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, occurrenceInterval;

  return _regeneratorRuntime.wrap(function generateRepeatingSchedule$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          isInitial = props.isInitial, serviceHours = props.serviceHours, start = props.start, strategy = props.strategy;
          end = props.end; // NOTE support never ending repeating schedule where no end date defined by
          // setting a custom end date using the frequency unit and value

          frequency = strategy.options.frequency;
          frequencyUnit = frequency.unit, frequencyValue = frequency.value;
          timezone = serviceHours.timezone;
          end = end || generateScheduleEnd({
            frequency: frequency,
            start: start,
            timezone: timezone
          });
          isStartAndEndValid = hasValidStartAndEnd({
            end: end,
            start: start
          });

          if (isStartAndEndValid) {
            _context.next = 9;
            break;
          }

          return _context.abrupt("return", []);

        case 9:
          serviceIntervalSequence = serviceIntervalsGenerator({
            end: end,
            serviceHours: serviceHours,
            start: start
          }); // NOTE: when repeating and is complying to service hours we iterate through
          // all service intervals otherwise service interval is from the start and end

          complyToServiceHours = includes(frequencyUnit, complyingServiceIntervalUnits);
          serviceIntervals = complyToServiceHours ? _toConsumableArray(serviceIntervalSequence) : [[start, end]];
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 15;
          _iterator = serviceIntervals[Symbol.iterator]();

        case 17:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 51;
            break;
          }

          serviceInterval = _step.value;
          _context.next = 21;
          return {
            interval: serviceInterval,
            type: IntervalTypes.Service
          };

        case 21:
          occurrenceIntervalsSequence = occurrenceIntervalsGenerator({
            isInitial: isInitial,
            serviceInterval: serviceInterval,
            strategy: strategy,
            timezone: timezone
          });
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 25;
          _iterator2 = occurrenceIntervalsSequence[Symbol.iterator]();

        case 27:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context.next = 34;
            break;
          }

          occurrenceInterval = _step2.value;
          _context.next = 31;
          return {
            interval: occurrenceInterval,
            type: IntervalTypes.Occurrence
          };

        case 31:
          _iteratorNormalCompletion2 = true;
          _context.next = 27;
          break;

        case 34:
          _context.next = 40;
          break;

        case 36:
          _context.prev = 36;
          _context.t0 = _context["catch"](25);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t0;

        case 40:
          _context.prev = 40;
          _context.prev = 41;

          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }

        case 43:
          _context.prev = 43;

          if (!_didIteratorError2) {
            _context.next = 46;
            break;
          }

          throw _iteratorError2;

        case 46:
          return _context.finish(43);

        case 47:
          return _context.finish(40);

        case 48:
          _iteratorNormalCompletion = true;
          _context.next = 17;
          break;

        case 51:
          _context.next = 57;
          break;

        case 53:
          _context.prev = 53;
          _context.t1 = _context["catch"](15);
          _didIteratorError = true;
          _iteratorError = _context.t1;

        case 57:
          _context.prev = 57;
          _context.prev = 58;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 60:
          _context.prev = 60;

          if (!_didIteratorError) {
            _context.next = 63;
            break;
          }

          throw _iteratorError;

        case 63:
          return _context.finish(60);

        case 64:
          return _context.finish(57);

        case 65:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[15, 53, 57, 65], [25, 36, 40, 48], [41,, 43, 47], [58,, 60, 64]]);
}
//# sourceMappingURL=generateRepeatingSchedule.js.map