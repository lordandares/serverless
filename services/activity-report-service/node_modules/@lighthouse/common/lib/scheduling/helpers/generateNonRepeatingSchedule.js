import _regeneratorRuntime from "@babel/runtime/regenerator";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";

var _marked = /*#__PURE__*/_regeneratorRuntime.mark(generateNonRepeatingSchedule);

import { isEmpty, first, last } from 'lodash/fp';
import { hasValidStartAndEnd } from '.';
import { IntervalTypes } from '../scheduling.types';
import { occurrenceIntervalsGenerator, serviceIntervalsGenerator } from '../generators';
/**
 * Generates non repeating schedule service and occurrence intervals
 */

export function generateNonRepeatingSchedule(props) {
  var end, isInitial, serviceHours, start, strategy, isStartAndEndValid, serviceIntervalSequence, hours, timezone, hasServiceHours, intervals, serviceIntervals, _i, _serviceIntervals, serviceInterval, occurrenceIntervalsSequence, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, occurrenceInterval;

  return _regeneratorRuntime.wrap(function generateNonRepeatingSchedule$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          end = props.end, isInitial = props.isInitial, serviceHours = props.serviceHours, start = props.start, strategy = props.strategy;
          isStartAndEndValid = hasValidStartAndEnd({
            end: end,
            start: start
          });

          if (isStartAndEndValid) {
            _context.next = 4;
            break;
          }

          return _context.abrupt("return", []);

        case 4:
          serviceIntervalSequence = serviceIntervalsGenerator({
            end: end,
            serviceHours: serviceHours,
            start: start
          });
          hours = serviceHours.hours, timezone = serviceHours.timezone;
          hasServiceHours = !isEmpty(hours);
          intervals = _toConsumableArray(serviceIntervalSequence); // NOTE: when non repeating and has service hours the service interval is
          // from the first and last service interval otherwise from the start and end

          serviceIntervals = !hasServiceHours ? [[start, end]] : !isEmpty(intervals) ? [[first(intervals)[0], last(intervals)[1]]] : [];
          _i = 0, _serviceIntervals = serviceIntervals;

        case 10:
          if (!(_i < _serviceIntervals.length)) {
            _context.next = 44;
            break;
          }

          serviceInterval = _serviceIntervals[_i];
          _context.next = 14;
          return {
            interval: serviceInterval,
            type: IntervalTypes.Service
          };

        case 14:
          occurrenceIntervalsSequence = occurrenceIntervalsGenerator({
            isInitial: isInitial,
            serviceInterval: serviceInterval,
            strategy: strategy,
            timezone: timezone
          });
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 18;
          _iterator = occurrenceIntervalsSequence[Symbol.iterator]();

        case 20:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 27;
            break;
          }

          occurrenceInterval = _step.value;
          _context.next = 24;
          return {
            interval: occurrenceInterval,
            type: IntervalTypes.Occurrence
          };

        case 24:
          _iteratorNormalCompletion = true;
          _context.next = 20;
          break;

        case 27:
          _context.next = 33;
          break;

        case 29:
          _context.prev = 29;
          _context.t0 = _context["catch"](18);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 33:
          _context.prev = 33;
          _context.prev = 34;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 36:
          _context.prev = 36;

          if (!_didIteratorError) {
            _context.next = 39;
            break;
          }

          throw _iteratorError;

        case 39:
          return _context.finish(36);

        case 40:
          return _context.finish(33);

        case 41:
          _i++;
          _context.next = 10;
          break;

        case 44:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[18, 29, 33, 41], [34,, 36, 40]]);
}
//# sourceMappingURL=generateNonRepeatingSchedule.js.map