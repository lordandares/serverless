import _regeneratorRuntime from "@babel/runtime/regenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

var _strategyTypeMap;

var _marked = /*#__PURE__*/_regeneratorRuntime.mark(occurrenceIntervalsGenerator);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { StrategyTypes } from '../scheduling.types';
import { getNext, getNextExactDateOfMonth, getNextLastDayOfMonth, getNextLastWeekdayOfMonth, getNextNoRepeat, getNextWeekday, getNextXDayOfXWeekOfMonth } from '../strategies';
export var strategyTypeMap = (_strategyTypeMap = {}, _defineProperty(_strategyTypeMap, StrategyTypes.ExactDateOfMonth, getNextExactDateOfMonth), _defineProperty(_strategyTypeMap, StrategyTypes.LastDayOfMonth, getNextLastDayOfMonth), _defineProperty(_strategyTypeMap, StrategyTypes.LastWeekdayOfMonth, getNextLastWeekdayOfMonth), _defineProperty(_strategyTypeMap, StrategyTypes.NoRepeat, getNextNoRepeat), _defineProperty(_strategyTypeMap, StrategyTypes.Stopwatch, getNext), _defineProperty(_strategyTypeMap, StrategyTypes.Weekdays, getNextWeekday), _defineProperty(_strategyTypeMap, StrategyTypes.Window, getNext), _defineProperty(_strategyTypeMap, StrategyTypes.XDayOfXWeekOfMonth, getNextXDayOfXWeekOfMonth), _strategyTypeMap);

/**
 * Generates occurrence intervals for service intervals using strategy
 */
export function occurrenceIntervalsGenerator(props) {
  var isInitial, serviceInterval, strategy, timezone, options, type, start, end, dateCursor, initial, duration, frequency, weekdays, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, weekday, weekdayDateCursor, weekdayIsInitial, nextOccurrence, getNextFn, _nextOccurrence;

  return _regeneratorRuntime.wrap(function occurrenceIntervalsGenerator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          isInitial = props.isInitial, serviceInterval = props.serviceInterval, strategy = props.strategy, timezone = props.timezone;
          options = strategy.options, type = strategy.type;
          start = serviceInterval[0];
          end = serviceInterval[1];
          dateCursor = start;
          initial = isInitial; // NOTE: weekdays strategy type must iterate through options independently

          if (!(type === StrategyTypes.Weekdays)) {
            _context.next = 45;
            break;
          }

          duration = options.duration, frequency = options.frequency, weekdays = options.weekdays;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 11;
          _iterator = weekdays[Symbol.iterator]();

        case 13:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 30;
            break;
          }

          weekday = _step.value;
          weekdayDateCursor = dateCursor;
          weekdayIsInitial = isInitial;

        case 17:
          if (!(weekdayDateCursor < end)) {
            _context.next = 27;
            break;
          }

          nextOccurrence = getNextWeekday({
            end: end,
            isInitial: weekdayIsInitial,
            start: weekdayDateCursor,
            options: _objectSpread({}, options, {
              weekday: weekday
            }),
            timezone: timezone
          });

          if (nextOccurrence) {
            _context.next = 21;
            break;
          }

          return _context.abrupt("break", 27);

        case 21:
          _context.next = 23;
          return nextOccurrence;

        case 23:
          weekdayDateCursor = nextOccurrence[1];
          weekdayIsInitial = false;
          _context.next = 17;
          break;

        case 27:
          _iteratorNormalCompletion = true;
          _context.next = 13;
          break;

        case 30:
          _context.next = 36;
          break;

        case 32:
          _context.prev = 32;
          _context.t0 = _context["catch"](11);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 36:
          _context.prev = 36;
          _context.prev = 37;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 39:
          _context.prev = 39;

          if (!_didIteratorError) {
            _context.next = 42;
            break;
          }

          throw _iteratorError;

        case 42:
          return _context.finish(39);

        case 43:
          return _context.finish(36);

        case 44:
          return _context.abrupt("return");

        case 45:
          getNextFn = strategyTypeMap[type];

          if (getNextFn) {
            _context.next = 48;
            break;
          }

          return _context.abrupt("return");

        case 48:
          if (!(dateCursor < end)) {
            _context.next = 58;
            break;
          }

          _nextOccurrence = getNextFn({
            end: end,
            isInitial: initial,
            start: dateCursor,
            options: options,
            timezone: timezone
          });

          if (_nextOccurrence) {
            _context.next = 52;
            break;
          }

          return _context.abrupt("return");

        case 52:
          _context.next = 54;
          return _nextOccurrence;

        case 54:
          initial = false;
          dateCursor = _nextOccurrence[1];
          _context.next = 48;
          break;

        case 58:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[11, 32, 36, 44], [37,, 39, 43]]);
}
//# sourceMappingURL=occurrenceIntervalsGenerator.js.map