import { array, number, object, string } from 'yup';
import { filter, first, isEmpty, isNil, last, orderBy, values } from 'lodash/fp';
import { some } from 'lodash';
var MAX_OFFSET_MS = 604800000;
export var Behaviours;

(function (Behaviours) {
  Behaviours["Open"] = "OPEN";
  Behaviours["Close"] = "CLOSE";
})(Behaviours || (Behaviours = {}));

export var Durations;

(function (Durations) {
  Durations[Durations["Second"] = 1000] = "Second";
  Durations[Durations["Minute"] = 60000] = "Minute";
  Durations[Durations["Hour"] = 3600000] = "Hour";
  Durations[Durations["Day"] = 86400000] = "Day";
  Durations[Durations["Week"] = 604800000] = "Week";
})(Durations || (Durations = {}));

export var Types;

(function (Types) {
  Types["Default"] = "DEFAULT";
  Types["Override"] = "OVERRIDE";
})(Types || (Types = {}));

export var Weekdays;

(function (Weekdays) {
  Weekdays["Monday"] = "MONDAY";
  Weekdays["Tuesday"] = "TUESDAY";
  Weekdays["Wednesday"] = "WEDNESDAY";
  Weekdays["Thursday"] = "THURSDAY";
  Weekdays["Friday"] = "FRIDAY";
  Weekdays["Saturday"] = "SATURDAY";
  Weekdays["Sunday"] = "SUNDAY";
})(Weekdays || (Weekdays = {}));

var hoursSchema = object({
  type: string().oneOf([Types.Default, Types.Override]).required(),
  start: number().min(0).required(),
  end: number().min(0).required().when('start', function (start, endSchema) {
    return endSchema.min(start);
  }),
  duration: number().integer().when(['start', 'end'], function (start, end, durationSchema) {
    // NOTE This is a bit of a hack to check the exact value, but I can't find
    // an API to check the exact value of a number
    var expectedDuration = end - start;
    var message = '${path} must be equal to ' + expectedDuration;
    return durationSchema.min(expectedDuration, message).max(expectedDuration, message);
  }),
  description: string(),
  behaviour: string().oneOf([Behaviours.Open, Behaviours.Close]).when('type', function (type, behaviourSchema) {
    return type === Types.Override ? behaviourSchema.required() : behaviourSchema.strip(true);
  })
});
export var schema = object({
  timezone: string().required(),
  options: object({
    startWeekday: string().oneOf(values(Weekdays))
  }),
  hours: array().of(hoursSchema).test('hasUndefinedHours', 'hours is a required field', function (value) {
    return !isNil(value);
  }).test('hasOverlappingDefaultHours', 'default hours must not overlap', function (value) {
    var defaultHours = filter({
      type: Types.Default
    }, value);
    var hasOverlappingHours = validateOverlappingHours({
      hoursArr: defaultHours
    }) !== -1;
    if (hasOverlappingHours) return false;
    return true;
  }).test('hasOverlappingOverrideHours', 'override hours must not overlap', function (value) {
    var overrideHours = filter({
      type: Types.Override
    }, value);
    var hasOverlappingHours = validateOverlappingHours({
      hoursArr: overrideHours,
      isUnix: true
    }) !== -1;
    if (hasOverlappingHours) return false;
    return true;
  })
});

/**
 * validateOverlappingHours
 * Validates that any hours do not overlap each other 
 * Validates default hours are within a week range
 */
export function validateOverlappingHours(options) {
  var hoursArr = options.hoursArr,
      isUnix = options.isUnix;
  var failingIndex = -1;

  if (isEmpty(hoursArr)) {
    return failingIndex;
  } // NOTE: when default hours and not override hours


  if (!isUnix) {
    var sortedHoursArr = orderBy(['start', 'end'], ['asc', 'asc'], hoursArr);

    var _first = first(sortedHoursArr),
        firstStart = _first.start;

    var _last = last(sortedHoursArr),
        lastEnd = _last.end; // NOTE: default service hour values are invalid if the first start and
    // last end exceed the MAX_OFFSET_MS which is a week


    var isRangeWithinWeek = lastEnd - firstStart <= MAX_OFFSET_MS;

    if (!isRangeWithinWeek) {
      failingIndex = 1;
      return failingIndex;
    }
  }

  some(hoursArr, function (thisHours, thisIndex) {
    var overlap = some(hoursArr, function (otherHours, otherIndex) {
      if (otherIndex === thisIndex) return false;
      var thisStart = thisHours.start,
          thisEnd = thisHours.end;
      var otherStart = otherHours.start,
          otherEnd = otherHours.end;
      var isMatching = otherStart === thisStart && otherEnd === thisEnd;
      var isWithin = thisStart > otherStart && thisEnd < otherEnd;
      var overlappingStart = thisStart < otherStart && thisEnd > otherStart;
      var overlappingEnd = thisStart < otherEnd && thisEnd > otherEnd;
      return isMatching || isWithin || overlappingStart || overlappingEnd;
    });

    if (overlap) {
      failingIndex = thisIndex;
      return true;
    }
  });
  return failingIndex;
}
export default schema;
//# sourceMappingURL=schema.js.map