"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildActivityPdf = buildActivityPdf;

var _lodash = require("lodash");

var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _helpers = require("../helpers");

var _helpers2 = require("../../helpers");

var _images = require("../../images");

const DEFAULT_MAX_SCANS = 200;
const LIGHTHOUSE_BASE_URL = 'https://app.lighthouse.io';
/**
 * buildActivityPdf
 *
 * @param {object} pdfOptions - the pdf options
 * @param {string} pdfOptions.fileTitle - pdf file title
 * @param {function} pdfOptions.footer - function executed to generate footer
 * @param {function} pdfOptions.header - function executed to generate header
 * @param {string} pdfOptions.logoUrl - pdf logo url
 * @param {array} pdfOptions.pageMargins - pdf page margins
 * @param {string} pdfOptions.pageOrientation - pdf page orientation
 * @param {string} pdfOptions.pageSize - pdf page size
 * @param {object} pdfOptions.styles - pdf styles
 * @param {object} pdfOptions.title - pdf title
 * @param {object} data - pdf data
 * @param {array} data.audits - audit documents
 * @param {string} data.end - end datetime of summary report
 * @param {array} data.events - event documents
 * @param {object} data.location - location document
 * @param {array} data.locations - location documents
 * @param {array} data.issues - issue documents
 * @param {bool} data.maxScans - max scans to include in standard report
 * @param {bool} data.showAlternate - show alternate summary report
 * @param {string} data.start - start datetime of summary report
 * @param {object} data.settings - settings properties
 * @param {string} data.settings.awsS3BaseUrl - aws S3 base url
 * @param {string} data.settings.cloudinaryBaseUrl - cloudinary base url
 * @param {array} data.tasks - task documents
 * @param {string} data.timestamp - timestamp string
 * @param {string} data.timezone - timezone string
 * @param {array} data.zones - zone documents
 * @param {array} data.users - user documents
 * @returns {Promise} returns pdfmake definition object
 */

async function buildActivityPdf(pdfOptions, data) {
  const {
    timestamp,
    timezone
  } = data;
  const title = 'Daily Activity Report';
  const content = await generateContent(data);
  return (0, _helpers.generateDefinition)({
    content,
    fileTitle: title,
    timestamp,
    timezone,
    type: 'Activity Summary',
    ...pdfOptions
  });
}

async function generateContent(data) {
  const activitySection = await buildActivitySection(data);
  const summarySection = buildSummarySection(data);
  const titleTable = buildTitleTable(data);
  return [titleTable, summarySection, activitySection];
}

async function buildActivitySection(data) {
  const {
    showAlternate = false
  } = data;

  if (showAlternate) {
    const locationScans = buildLocationScansSection(data);
    const otherActivity = await buildOtherActivitySection(data);
    return [locationScans, otherActivity];
  }

  const activitySummary = await buildActivitySummarySection(data);
  return [activitySummary];
}

async function buildActivitySummarySection(data) {
  const {
    audits,
    events,
    issues,
    maxScans = DEFAULT_MAX_SCANS,
    settings,
    tasks,
    timezone
  } = data;
  const enterEvents = (0, _lodash.filter)(events, event => event.type === 'enter');
  const exceedsMaxScans = (0, _lodash.size)(enterEvents) > maxScans;
  const scans = (0, _lodash.take)(enterEvents, maxScans);
  const auditRows = (0, _lodash.map)(audits, getFormRowData('audits', data));
  const issueRows = (0, _lodash.map)(issues, getFormRowData('issues', data));
  const scanRows = (0, _lodash.map)(scans, getScanRowData(data));
  const taskRows = (0, _lodash.map)(tasks, getFormRowData('tasks', data));
  const rows = [...auditRows, ...issueRows, ...scanRows, ...taskRows];
  const sortedRows = (0, _lodash.sortBy)(rows, ['timestamp'], ['asc']);
  const title = (0, _helpers.text)('Activity Summary', {
    style: 'summarySectionHeader'
  });
  const header = (0, _helpers.table)({
    body: [[title]],
    layout: 'noBorders',
    style: 'summaryHeaderTable'
  });
  const hLine = (0, _helpers.horizontalLine)();
  const activityTable = await buildActivityTable({
    rows: sortedRows,
    settings,
    timezone
  });
  const activitySummarySection = [header, hLine, activityTable];

  if (exceedsMaxScans) {
    const maxScansText = {
      text: [(0, _helpers.text)(`Location Scans in the Daily Activity Report are limited to a total of ${maxScans}.`), (0, _helpers.text)(' To view all Location Scans visit '), (0, _helpers.text)('the Events Report', {
        link: `${LIGHTHOUSE_BASE_URL}/reports/events`
      }), (0, _helpers.text)(' in the Lighthouse Management Console.')],
      style: 'small',
      margin: [0, 10, 0, 10]
    };
    activitySummarySection.push(maxScansText);
  }

  return activitySummarySection;
}

async function buildActivityTable({
  rows,
  settings,
  timezone
}) {
  const timezoneAbbr = (0, _helpers2.getTimezoneAbbr)(timezone);
  const activityTableHeader = [(0, _helpers.text)('Activity', {
    bold: true
  }), {
    text: ''
  }, // icon column
  (0, _helpers.text)('Location', {
    bold: true
  }), (0, _helpers.text)('User', {
    bold: true
  }), (0, _helpers.text)(`Timestamp (${timezoneAbbr})`, {
    alignment: 'right',
    bold: true
  })];
  const activityTableRows = await _bluebird.default.map(rows, async function (data) {
    const {
      link,
      location,
      icon,
      name,
      summaryFields,
      timestamp,
      title
    } = data;
    const timezoneHour = (0, _helpers2.getTimezoneDatetime)({
      format: 'ddd DD h:mm a',
      showTzAbbr: false,
      timestamp,
      timezone
    });
    const iconCell = icon ? {
      alignment: 'center',
      fit: [8, 8],
      image: icon,
      link
    } : {
      text: ''
    }; // NOTE: pass link to each column as
    // we can't wrap the entire table row

    const rows = [[(0, _helpers.text)(title, {
      link
    }), iconCell, (0, _helpers.text)(location, {
      link
    }), (0, _helpers.text)(name, {
      link
    }), (0, _helpers.text)(timezoneHour, {
      alignment: 'right',
      link
    })]];
    const hasSummaryFields = !(0, _lodash.isEmpty)(summaryFields);

    if (hasSummaryFields) {
      const fieldsTable = await (0, _helpers.summaryFieldsTable)({
        fields: summaryFields,
        settings,
        timezone
      });
      rows.push([fieldsTable]);
    } // NOTE: we return a table per row which includes the entry details and the
    // summary fields if relevant


    const activityTableRow = [(0, _helpers.table)({
      body: [...rows],
      colSpan: 5,
      dontBreakRows: true,
      headerRow: 0,
      layout: {
        hLineWidth: () => 0,
        paddingLeft: () => 0,
        paddingRight: () => 0,
        paddingTop: () => 5,
        paddingBottom: () => 5,
        vLineWidth: () => 0
      },
      // NOTE: the timestamp must fill up the rest of the table space as
      // otherwise the padding would be off between this table and the parent
      // table that wraps it
      widths: [130, 25, 110, 110, '*']
    })];
    return activityTableRow;
  });
  const activityTableBody = (0, _lodash.isEmpty)(activityTableRows) ? [[(0, _helpers.text)('No other activity', {
    colSpan: 5
  })]] : activityTableRows;
  const activityTable = (0, _helpers.table)({
    body: [activityTableHeader, ...activityTableBody],
    dontBreakRows: true,
    layout: {
      hLineWidth: () => 0,
      fillColor: _helpers.zebraFillColor,
      paddingLeft: () => 5,
      paddingRight: () => 5,
      paddingTop: () => 5,
      paddingBottom: () => 5,
      vLineWidth: () => 0
    },
    widths: [120, 15, 100, 100, '*']
  });
  return activityTable;
}

function buildLocationScansSection(data) {
  const {
    events,
    start,
    timezone,
    zones
  } = data;
  const title = (0, _helpers.text)('Location Scans', {
    style: 'summarySectionHeader'
  });
  const header = (0, _helpers.table)({
    body: [[title]],
    layout: 'noBorders',
    style: 'summaryHeaderTable'
  }); // use start time and timezone to figure out the interval boundaries

  const hourIntervalBoundaries = (0, _helpers.buildLocationScansBoundaries)(start, timezone); // pair interval boundaries into column headers for the table

  const hourIntervalColumnHeaders = hourIntervalBoundaries.reduce((columns, interval, index, intervals) => {
    if (index < (0, _lodash.size)(intervals) - 1) // skip the final iteration as it's just the end of the last interval
      columns.push((0, _helpers.text)(`${interval.format('h')}-${intervals[index + 1].format('hA')}`, {
        alignment: 'center',
        bold: true
      }));
    return columns;
  }, []);
  const scansTableHeader = [(0, _helpers.text)('Location', {
    bold: true
  }), ...hourIntervalColumnHeaders, (0, _helpers.text)('Total', {
    alignment: 'right',
    bold: true
  })];
  const hLine = (0, _helpers.horizontalLine)(); // NOTE: only show the enter events within the summary table

  const enterEvents = (0, _lodash.filter)(events, event => event.type === 'enter');
  const sortedZones = (0, _lodash.sortBy)(zones, ['name']);
  const groupedEventsByZone = (0, _lodash.reduce)(sortedZones, (memo, zone) => {
    const zoneEvents = (0, _lodash.filter)(enterEvents, event => event.zone && event.zone.toString() === zone._id.toString());
    memo[zone._id] = zoneEvents;
    return memo;
  }, {});
  const scansTableRows = (0, _lodash.map)(groupedEventsByZone, (events, zone = '') => {
    const sortedGroup = (0, _lodash.sortBy)(events, ['timestamp'], ['asc']); // put events into interval buckets

    const locationScansByInterval = (0, _helpers.buildLocationScansContent)(hourIntervalBoundaries, events); // map the interval buckets to a format fit for the table

    const locationScansByIntervalContent = locationScansByInterval.map(interval => {
      return {
        alignment: 'center',
        text: (0, _lodash.size)(interval)
      };
    });
    const totalEvents = (0, _lodash.size)(sortedGroup);
    const zoneDoc = zone && (0, _lodash.find)(zones, doc => doc._id.toString() === zone.toString());
    const zoneName = zoneDoc && zoneDoc.name || 'Unknown Location';
    return [zoneName, ...locationScansByIntervalContent, {
      alignment: 'right',
      bold: true,
      text: totalEvents
    }];
  });
  const scansTableBody = (0, _lodash.isEmpty)(scansTableRows) ? [[(0, _helpers.text)('No location scans', {
    colSpan: 10
  })]] : scansTableRows;
  const scansTable = (0, _helpers.table)({
    body: [scansTableHeader, ...scansTableBody],
    widths: [100, '*', '*', '*', '*', '*', '*', '*', '*', '*']
  });
  return [header, hLine, scansTable];
}

function buildSummarySection(data) {
  const {
    audits,
    events,
    issues,
    tasks
  } = data; //const userEvents = groupBy(events, 'user')

  const eventsByType = (0, _lodash.groupBy)(events, 'type');
  const enterEventsCount = (0, _lodash.size)(eventsByType.enter); //const geoEventsCount = size(eventsByType.geo)

  const issuesCount = (0, _lodash.size)(issues);
  const tasksCount = (0, _lodash.size)(tasks);
  const auditsCount = (0, _lodash.size)(audits); //const uniqueUsers = size(userEvents)

  const auditsText = (0, _helpers.text)('AUDITS', {
    style: 'summaryText'
  }); //const geoText = text('GPS', { style: 'summaryText' })

  const issuesText = (0, _helpers.text)('ISSUES', {
    style: 'summaryText'
  }); //const peopleText = text('PEOPLE', { style: 'summaryText' })

  const scansText = (0, _helpers.text)('SCANS', {
    style: 'summaryText'
  });
  const tasksText = (0, _helpers.text)('TASKS', {
    style: 'summaryText'
  });
  const auditsCountText = (0, _helpers.text)((0, _lodash.toString)(auditsCount), {
    style: 'summaryCount'
  }); //const peopleCountText = text(toString(uniqueUsers), { style: 'summaryCount' })

  const scansCountText = (0, _helpers.text)((0, _lodash.toString)(enterEventsCount), {
    style: 'summaryCount'
  }); //const geoCountText = text(toString(geoEventsCount), { style: 'summaryCount' })

  const issuesCountText = (0, _helpers.text)((0, _lodash.toString)(issuesCount), {
    style: 'summaryCount'
  });
  const tasksCountText = (0, _helpers.text)((0, _lodash.toString)(tasksCount), {
    style: 'summaryCount'
  });
  const auditTable = (0, _helpers.summaryStatTable)({
    body: [[auditsText], [auditsCountText]]
  }); //const peopleTable = summaryStatTable({
  //  body: [[peopleText], [peopleCountText]],
  //})
  //const gpsTable = summaryStatTable({ body: [[geoText], [geoCountText]] })

  const scanTable = (0, _helpers.summaryStatTable)({
    body: [[scansText], [scansCountText]]
  });
  const issueTable = (0, _helpers.summaryStatTable)({
    body: [[issuesText], [issuesCountText]]
  });
  const taskTables = (0, _helpers.summaryStatTable)({
    body: [[tasksText], [tasksCountText]]
  });
  const wrapperTable = (0, _helpers.summaryWrapperTable)({
    body: [[
    /*peopleTable,*/

    /*gpsTable,*/
    scanTable, issueTable, taskTables, auditTable]]
  });
  return wrapperTable;
}

async function buildOtherActivitySection(data) {
  const {
    audits,
    issues,
    tasks,
    settings,
    timezone
  } = data;
  const auditRows = (0, _lodash.map)(audits, getFormRowData('audits', data));
  const issueRows = (0, _lodash.map)(issues, getFormRowData('issues', data));
  const taskRows = (0, _lodash.map)(tasks, getFormRowData('tasks', data));
  const rows = [...auditRows, ...issueRows, ...taskRows];
  const sortedRows = (0, _lodash.sortBy)(rows, ['timestamp'], ['asc']);
  const title = (0, _helpers.text)('Other Activity', {
    style: 'summarySectionHeader'
  });
  const header = (0, _helpers.table)({
    body: [[title]],
    layout: 'noBorders',
    style: 'summaryHeaderTable'
  });
  const hLine = (0, _helpers.horizontalLine)();
  const activityTable = await buildActivityTable({
    rows: sortedRows,
    settings,
    timezone
  });
  return [header, hLine, activityTable];
}

function buildTitleTable(data) {
  const {
    location,
    start,
    end,
    timezone
  } = data;
  const {
    address = {}
  } = location;
  const headerTitle = (0, _helpers.text)('Daily Activity Report', {
    style: 'title'
  });
  const headerSubTitle = (0, _helpers.text)(location.name, {
    style: 'subTitle'
  });
  const addressText = !(0, _lodash.isEmpty)(address) ? `${address.street}, ${address.city || ''} ${address.state || ''} ${address.postalCode || ''}` : '';
  const headerAddress = (0, _helpers.text)(addressText, {
    style: 'small'
  });

  const mTimezoneStart = _momentTimezone.default.tz(start, timezone);

  const mTimezoneEnd = _momentTimezone.default.tz(end, timezone);

  const timezoneAbbr = (0, _helpers2.getTimezoneAbbr)(timezone);
  const rangeStart = (0, _momentTimezone.default)(mTimezoneStart).format('MMM DD h:mma');
  const rangeEnd = (0, _momentTimezone.default)(mTimezoneEnd).add(1, 'hour').startOf('hour').format('MMM DD h:mma');
  const headerRange = (0, _helpers.text)(`${rangeStart} - ${rangeEnd} (${timezoneAbbr})`, {
    style: 'subTitle2'
  });
  const body = !(0, _lodash.isEmpty)(address) ? [[headerTitle], [headerSubTitle], [headerAddress], [headerRange]] : [[headerTitle], [headerSubTitle], [headerRange]];
  return (0, _helpers.table)({
    body,
    layout: 'noBorders',
    style: 'titleTable'
  });
}

function getFormRowData(collection, {
  locations,
  users,
  zones
}) {
  return document => {
    const {
      _id,
      createdAt,
      entry = {},
      title = 'Unknown',
      user = ''
    } = document;
    const location = (0, _helpers2.getLocationReference)({
      entity: document,
      locations,
      zones
    });
    const link = `${LIGHTHOUSE_BASE_URL}/reports/${collection}/${_id}`;
    const timestamp = createdAt;
    const userDoc = (0, _lodash.find)(users, doc => doc._id.toString() === user.toString());
    const name = userDoc && `${userDoc.firstName} ${userDoc.lastName}` || 'Unknown User'; // NOTE: currently only issues and tasks will return summary fields, audits
    // aren't supported and will return an empty array here

    const summaryFields = entry.summaryFields || [];
    return {
      icon: _images.launchIcon,
      location,
      link,
      name,
      summaryFields,
      timestamp,
      title
    };
  };
}

function getScanRowData({
  users,
  zones
}) {
  return document => {
    const {
      timestamp,
      user = '',
      zone = ''
    } = document;
    const userDoc = user && (0, _lodash.find)(users, doc => doc._id.toString() === user.toString());
    const zoneDoc = zone && (0, _lodash.find)(zones, doc => doc._id.toString() === zone.toString());
    const zoneName = zoneDoc && zoneDoc.name;
    const location = zoneName || 'Unknown Location';
    const name = userDoc && `${userDoc.firstName} ${userDoc.lastName}` || 'Unknown User';
    const title = 'Location Scan';
    return {
      location,
      timestamp,
      name,
      title
    };
  };
}