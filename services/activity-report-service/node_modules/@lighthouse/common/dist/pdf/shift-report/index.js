"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildShiftPdf = buildShiftPdf;

var _bluebird = _interopRequireDefault(require("bluebird"));

var _lodash = require("lodash");

var _momentTimezone = _interopRequireWildcard(require("moment-timezone"));

var _helpers = require("../../helpers");

var _images = require("../../images");

var _helpers2 = require("../helpers");

const LIGHTHOUSE_BASE_URL = 'https://app.lighthouse.io';
/**
 * buildActivityPdf
 * @param {object} pdfOptions - the pdf options
 * @param {string} pdfOptions.fileTitle - pdf file title
 * @param {function} pdfOptions.footer - function executed to generate footer
 * @param {function} pdfOptions.header - function executed to generate header
 * @param {string} pdfOptions.logoUrl - pdf logo url
 * @param {array} pdfOptions.pageMargins - pdf page margins
 * @param {string} pdfOptions.pageOrientation - pdf page orientation
 * @param {string} pdfOptions.pageSize - pdf page size
 * @param {object} pdfOptions.styles - pdf styles
 * @param {object} pdfOptions.title - pdf title
 * @param {object} data - pdf data
 * @param {array} data.audits - audit documents
 * @param {array} data.events - event documents
 * @param {array} data.locations - location documents
 * @param {array} data.issues - issue documents
 * @param {array} data.audits - audit documents
 * @param {object} data.shift - shift document
 * @param {object} data.settings - settings properties
 * @param {string} data.settings.awsS3BaseUrl - aws S3 base url
 * @param {string} data.settings.cloudinaryBaseUrl - cloudinary base url
 * @param {array} data.tasks - task documents
 * @param {string} data.timestamp - timestamp string
 * @param {string} data.timezone - timezone string
 * @param {array} data.zones - zone documents
 * @param {array} data.user - user document
 * @returns {Promise} returns pdfmake definition object
 */

async function buildShiftPdf(pdfOptions, data) {
  const {
    timestamp,
    timezone
  } = data;
  const title = 'Daily Shift Report';
  const content = await generateContent(data);
  return (0, _helpers2.generateDefinition)({
    content,
    fileTitle: title,
    timestamp,
    timezone,
    type: 'Shift Report',
    ...pdfOptions
  });
}

async function generateContent(data) {
  const activitySection = await buildActivitySection(data);
  const summarySection = buildSummarySection(data);
  const titleTable = buildTitleTable(data);
  return [titleTable, summarySection, activitySection];
}

async function buildActivitySection(data) {
  const timeline = await buildTimelineTable(data);
  const activitySummary = await buildActivitySummarySection(data);
  return [timeline, activitySummary];
}

function buildTitleTable(data) {
  const {
    shift,
    timezone,
    user
  } = data;
  const {
    breaks,
    duration,
    end,
    start
  } = shift;
  const headerTitle = (0, _helpers2.text)('Daily Shift Report', {
    style: 'title'
  });
  const username = `${user.firstName} ${user.lastName}` || 'Unknown User';
  const headerSubTitle = (0, _helpers2.text)(`${username}`, {
    style: 'subTitle'
  });
  const mTimezoneStart = (0, _momentTimezone.default)(start.time).tz(timezone);
  const mTimezoneEnd = (0, _momentTimezone.default)(end.time).tz(timezone);
  const rangeStart = (0, _momentTimezone.default)(mTimezoneStart).format('MMM DD h:mma');
  const rangeEnd = (0, _momentTimezone.default)(mTimezoneEnd).format('MMM DD h:mma');
  const shiftDuration = getFineDuration(duration);
  const breakDuration = getBreakDuration(breaks);
  const header = !breakDuration ? `${rangeStart} - ${rangeEnd} | Duration: ${shiftDuration}` : `${rangeStart} - ${rangeEnd} | Duration: ${shiftDuration}, Break: ${breakDuration}`;
  const headerRange = (0, _helpers2.text)(header, {
    style: 'subTitle2'
  });
  return (0, _helpers2.table)({
    body: [[headerTitle], [headerSubTitle], [headerRange]],
    layout: 'noBorders',
    style: 'titleTable'
  });
}

function buildSummarySection(data) {
  const {
    audits,
    events,
    issues,
    tasks
  } = data;
  const eventsByType = (0, _lodash.groupBy)(events, 'type');
  const enterEventsCount = (0, _lodash.size)(eventsByType.enter);
  const issuesCount = (0, _lodash.size)(issues);
  const tasksCount = (0, _lodash.size)(tasks);
  const auditsCount = (0, _lodash.size)(audits);
  const scansText = (0, _helpers2.text)('SCANS', {
    style: 'summaryText'
  });
  const issuesText = (0, _helpers2.text)('ISSUES', {
    style: 'summaryText'
  });
  const tasksText = (0, _helpers2.text)('TASKS', {
    style: 'summaryText'
  });
  const auditsText = (0, _helpers2.text)('AUDITS', {
    style: 'summaryText'
  });
  const scansCountText = (0, _helpers2.text)((0, _lodash.toString)(enterEventsCount), {
    style: 'summaryCount'
  });
  const issuesCountText = (0, _helpers2.text)((0, _lodash.toString)(issuesCount), {
    style: 'summaryCount'
  });
  const tasksCountText = (0, _helpers2.text)((0, _lodash.toString)(tasksCount), {
    style: 'summaryCount'
  });
  const auditsCountText = (0, _helpers2.text)((0, _lodash.toString)(auditsCount), {
    style: 'summaryCount'
  });
  const scanTable = (0, _helpers2.summaryStatTable)({
    body: [[scansText], [scansCountText]]
  });
  const issueTable = (0, _helpers2.summaryStatTable)({
    body: [[issuesText], [issuesCountText]]
  });
  const taskTables = (0, _helpers2.summaryStatTable)({
    body: [[tasksText], [tasksCountText]]
  });
  const auditTable = (0, _helpers2.summaryStatTable)({
    body: [[auditsText], [auditsCountText]]
  });
  const wrapperTable = (0, _helpers2.summaryWrapperTable)({
    body: [[scanTable, issueTable, taskTables, auditTable]]
  });
  return wrapperTable;
}

async function buildActivitySummarySection(data) {
  const {
    audits,
    events,
    issues,
    settings,
    tasks,
    timezone
  } = data;
  const enterEvents = (0, _lodash.filter)(events, event => event.type === 'enter');
  const auditRows = (0, _lodash.map)(audits, getFormRowData('audits', data));
  const issueRows = (0, _lodash.map)(issues, getFormRowData('issues', data));
  const scanRows = (0, _lodash.map)(enterEvents, getScanRowData(data));
  const taskRows = (0, _lodash.map)(tasks, getFormRowData('tasks', data));
  const rows = [...auditRows, ...issueRows, ...scanRows, ...taskRows];
  const sortedRows = (0, _lodash.sortBy)(rows, ['timestamp'], ['asc']);
  const title = (0, _helpers2.text)('Activity Summary', {
    style: 'summarySectionHeader'
  });
  const header = (0, _helpers2.table)({
    body: [[title]],
    layout: 'noBorders',
    style: 'summaryHeaderTable'
  });
  const hLine = (0, _helpers2.horizontalLine)();
  const activityTable = await buildActivityTable({
    rows: sortedRows,
    settings,
    timezone
  });
  const activitySummarySection = [header, hLine, activityTable];
  return activitySummarySection;
}

async function buildActivityTable({
  rows,
  settings,
  timezone
}) {
  const timezoneAbbr = (0, _helpers.getTimezoneAbbr)(timezone);
  const activityTableHeader = [(0, _helpers2.text)('Activity', {
    bold: true
  }), {
    text: ''
  }, (0, _helpers2.text)('Location', {
    bold: true
  }), (0, _helpers2.text)(`Timestamp (${timezoneAbbr})`, {
    alignment: 'right',
    bold: true
  })];
  const activityTableRows = await _bluebird.default.map(rows, async function (data) {
    const {
      link,
      location,
      icon,
      summaryFields,
      timestamp,
      title
    } = data;
    const timezoneHour = (0, _helpers.getTimezoneDatetime)({
      format: 'ddd DD h:mm a',
      showTzAbbr: false,
      timestamp,
      timezone
    });
    const iconCell = icon ? {
      alignment: 'center',
      fit: [8, 8],
      image: icon,
      link
    } : {
      text: ''
    };
    const rows = [[(0, _helpers2.text)(title, {
      link
    }), iconCell, (0, _helpers2.text)(location, {
      link
    }), (0, _helpers2.text)(timezoneHour, {
      alignment: 'right',
      link
    })]];
    const hasSummaryFields = !(0, _lodash.isEmpty)(summaryFields);

    if (hasSummaryFields) {
      const fieldsTable = await (0, _helpers2.summaryFieldsTable)({
        fields: summaryFields,
        settings,
        timezone
      });
      rows.push([fieldsTable]);
    }

    const activityTableRow = [(0, _helpers2.table)({
      body: [...rows],
      colSpan: 5,
      dontBreakRows: true,
      headerRow: 0,
      layout: {
        hLineWidth: () => 0,
        paddingLeft: () => 0,
        paddingRight: () => 0,
        paddingTop: () => 5,
        paddingBottom: () => 5,
        vLineWidth: () => 0
      },
      widths: [120, 25, 200, 110, '*']
    })];
    return activityTableRow;
  });
  const activityTableBody = (0, _lodash.isEmpty)(activityTableRows) ? [[(0, _helpers2.text)('No other activity', {
    colSpan: 4
  })]] : activityTableRows;
  const activityTable = (0, _helpers2.table)({
    body: [activityTableHeader, ...activityTableBody],
    dontBreakRows: true,
    layout: {
      hLineWidth: () => 0,
      fillColor: _helpers2.zebraFillColor,
      paddingLeft: () => 5,
      paddingRight: () => 5,
      paddingTop: () => 5,
      paddingBottom: () => 5,
      vLineWidth: () => 0
    },
    widths: [110, 15, 230, 80, '*']
  });
  return activityTable;
}

function getFormRowData(collection, {
  locations,
  zones
}) {
  return document => {
    const {
      _id,
      createdAt,
      entry = {},
      title = 'Unknown'
    } = document;
    const location = (0, _helpers.getLocationReference)({
      entity: document,
      locations,
      zones
    });
    const link = `${LIGHTHOUSE_BASE_URL}/reports/${collection}/${_id}`;
    const timestamp = createdAt;
    const summaryFields = entry.summaryFields || [];
    return {
      icon: _images.launchIcon,
      location,
      link,
      summaryFields,
      timestamp,
      title
    };
  };
}

function getScanRowData({
  zones
}) {
  return document => {
    const {
      timestamp,
      zone = ''
    } = document;
    const zoneDoc = zone && (0, _lodash.find)(zones, doc => doc._id.toString() === zone.toString());
    const zoneName = zoneDoc && zoneDoc.name;
    const location = zoneName || 'Unknown Location';
    const title = 'Location Scan';
    return {
      location,
      timestamp,
      title
    };
  };
}

async function buildTimelineTable(data) {
  const {
    timezone
  } = data;
  const timezoneAbbr = (0, _helpers.getTimezoneAbbr)(timezone);
  const shiftRows = getShiftRowData(data);
  const sortedRows = (0, _lodash.sortBy)(shiftRows, ['timestamp'], ['asc']);
  const timeline = await _bluebird.default.map(sortedRows, async function (data) {
    const {
      location,
      timestamp,
      title
    } = data;
    const timezoneHour = (0, _helpers.getTimezoneDatetime)({
      format: 'ddd DD h:mm a',
      showTzAbbr: false,
      timestamp,
      timezone
    });
    const rows = [(0, _helpers2.text)(title), (0, _helpers2.text)(location), (0, _helpers2.text)(timezoneHour, {
      alignment: 'right'
    })];
    return rows;
  });
  const timelineHeaderRow = [(0, _helpers2.text)('Activity', {
    bold: true
  }), (0, _helpers2.text)('Location', {
    bold: true
  }), (0, _helpers2.text)(`Timestamp (${timezoneAbbr})`, {
    alignment: 'right',
    bold: true
  })];
  const timelineTable = (0, _helpers2.threeColumnTable)({
    body: [timelineHeaderRow, ...timeline]
  });
  const title = (0, _helpers2.text)('Timeline', {
    style: 'timelineTitle'
  });
  const header = (0, _helpers2.table)({
    body: [[title]],
    layout: 'noBorders',
    style: 'summaryHeaderTable'
  });
  const hLine = (0, _helpers2.horizontalLine)();
  const timelineSection = [header, hLine, timelineTable];
  return timelineSection;
}

function getShiftRowData({
  locations,
  shift,
  zones
}) {
  const {
    breaks,
    end,
    start
  } = shift;
  const startValues = getShiftValues(start, {
    locations,
    shift,
    zones
  });
  const startShift = {
    title: 'Shift Started',
    ...startValues
  };
  const endValues = getShiftValues(end, {
    locations,
    shift,
    zones
  });
  const endShift = {
    title: 'Shift Ended',
    ...endValues
  };
  const shiftData = [startShift, endShift];
  (0, _lodash.each)(breaks, function (data) {
    const {
      end,
      start
    } = data;
    const startValues = getShiftValues(start, {
      locations,
      shift,
      zones
    });
    const startBreak = {
      title: 'Break Started',
      ...startValues
    };
    const endValues = getShiftValues(end, {
      locations,
      shift,
      zones
    });
    const endBreak = {
      title: 'Break Ended',
      ...endValues
    };
    shiftData.push(startBreak);
    shiftData.push(endBreak);
  });
  return shiftData;
}

function getShiftValues(value, {
  locations,
  shift,
  zones
}) {
  const locationName = (0, _helpers.getLocationReference)({
    entity: value,
    locations,
    zones
  });
  const location = locationName === 'Unknown Location' ? (0, _helpers.getLocationReference)({
    entity: shift,
    locations,
    zones
  }) : locationName;
  return {
    timestamp: value.time,
    location
  };
}

function getFineDuration(durationValue) {
  const measurement = 'milliseconds';
  const durationByMeasurement = (0, _momentTimezone.duration)(durationValue, measurement);
  const hours = durationByMeasurement.get('hours');
  const minutes = durationByMeasurement.get('minutes');
  let fineDuration = '';
  fineDuration += hours !== 0 ? hours + 'h ' : '';
  fineDuration += minutes !== 0 ? minutes + 'm' : '';
  return fineDuration;
}

function getBreakDuration(breaks) {
  const duration = (0, _lodash.sum)((0, _lodash.map)(breaks, function (data) {
    const {
      end,
      start
    } = data;
    const endBreak = (0, _momentTimezone.default)(end.time);
    const startBreak = (0, _momentTimezone.default)(start.time);
    const breakDuration = endBreak.diff(startBreak);
    return breakDuration;
  }));
  const breakDuration = getFineDuration(duration);
  return breakDuration;
}