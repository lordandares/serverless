"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildFile = buildFile;
exports.buildSummaryField = buildSummaryField;
exports.buildTemplateFieldRow = buildTemplateFieldRow;

var _lodash = require("lodash");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _helpers = require("../../../helpers");

var _images = require("../../../images");

var _ = require("../");

function buildFile({
  file,
  settings
}) {
  const {
    extension,
    name,
    path
  } = file;
  const {
    awsS3BaseUrl
  } = settings;
  const link = `${awsS3BaseUrl}/${path}`;
  return (0, _.text)(`${name}.${extension}`, {
    link,
    margin: [0, 0, 0, 10]
  });
}

function buildImage(options) {
  const {
    alignment = 'center',
    filepath,
    height = 210,
    settings,
    width = 210
  } = options;
  const {
    awsS3BaseUrl,
    cloudinaryBaseUrl
  } = settings;
  const url = (0, _helpers.buildFetchUrl)(filepath, {
    awsS3BaseUrl,
    cloudinaryBaseUrl,
    fit: true,
    height: 880,
    width: 880
  });
  const link = `${awsS3BaseUrl}/${filepath}`;
  return (0, _helpers.fetchImage)(url).then(base64String => ({
    alignment,
    fit: [width, height],
    image: base64String,
    link
  })).catch(() => ({
    alignment,
    fit: [width, height],
    image: _images.imageNotFound
  }));
}

function buildSummaryField({
  field,
  settings,
  timezone
}) {
  const {
    fieldtype,
    options = {},
    value
  } = field;
  const isDayFirstDateField = fieldtype === 'date' && options.format === 'DD/MM/YY';
  const isMonthFirstDateField = fieldtype === 'date' && options.format === 'MM/DD/YY';
  const isFileField = fieldtype === 'file';
  const isHtmlField = fieldtype === 'text' && options.type === 'html';
  const isNumberField = fieldtype === 'number';
  const isPhotoField = fieldtype === 'list' && options.type === 'media';
  const isSelectField = fieldtype === 'select' && options.type !== 'stars';
  const isSignatureField = fieldtype === 'text' && options.type === 'signature';
  const isStarField = fieldtype === 'select' && options.type === 'stars';
  const isSwitchField = fieldtype === 'switch';
  const isTextField = fieldtype === 'text';
  const is12HourTimeField = fieldtype === 'time' && options.format === 'h:mm a';
  const is24HourTimeField = fieldtype === 'time' && options.format === 'HH:mm'; // NOTE: html field is not supported for the summary fields but adding
  // logic to catch this and return empty text for completeness

  if (isHtmlField) {
    return {
      text: ''
    };
  }

  if (isSignatureField) {
    if (!value) return '-';

    if (isDataImage(value)) {
      return {
        alignment: 'left',
        image: value,
        width: 140
      };
    }

    return (0, _helpers.fetchImage)(value).then(base64String => {
      return {
        alignment: 'left',
        image: base64String,
        width: 140
      };
    }).catch(() => {
      return {
        alignment: 'left',
        image: _images.imageNotFound,
        width: 140
      };
    });
  }

  if (isPhotoField) {
    const filepath = (0, _lodash.first)(value); // NOTE: if no filepath return empty text as user has not uploaded an image
    // for this field

    if (!filepath) {
      return {
        text: ''
      };
    }

    const image = buildImage({
      alignment: 'left',
      filepath,
      height: 140,
      width: 140,
      settings
    });
    return image;
  }

  if (isFileField) {
    const fileList = (0, _lodash.map)(value, file => buildFile({
      file,
      settings
    }));
    return {
      ol: fileList
    };
  }

  if (isNumberField || isSelectField || isSwitchField || isTextField) {
    const parsedValue = (0, _.parseValue)(value);
    const displayValue = (0, _lodash.isArray)(parsedValue) ? {
      text: (0, _lodash.join)(parsedValue, ', '),
      fontSize: 7
    } : {
      text: parsedValue,
      fontSize: 7
    };
    return displayValue;
  }

  if (isStarField) {
    if (!value) return '-';
    const displayValue = value === '1' ? `${value} star` : `${value} stars`;
    return displayValue;
  }

  if (isDayFirstDateField || isMonthFirstDateField || is12HourTimeField || is24HourTimeField) {
    const format = options.format;
    const displayValue = (0, _momentTimezone.default)(value).tz(timezone).format(format);
    return displayValue;
  } // NOTE: return empty text fallback value when no match


  return {
    text: ''
  };
}

function buildTemplateFieldRow({
  field,
  settings,
  timezone
}) {
  const {
    fieldtype,
    label,
    options = {},
    value
  } = field;
  const {
    showOnRead = true
  } = options;
  const isDayFirstDateField = fieldtype === 'date' && options.format === 'DD/MM/YY';
  const isMonthFirstDateField = fieldtype === 'date' && options.format === 'MM/DD/YY';
  const isFileField = fieldtype === 'file';
  const isHtmlField = fieldtype === 'text' && options.type === 'html';
  const isNumberField = fieldtype === 'number';
  const isPhotoField = fieldtype === 'list' && options.type === 'media';
  const isSelectField = fieldtype === 'select' && options.type !== 'stars';
  const isSignatureField = fieldtype === 'text' && options.type === 'signature';
  const isStarField = fieldtype === 'select' && options.type === 'stars';
  const isSwitchField = fieldtype === 'switch';
  const isTextField = fieldtype === 'text';
  const is12HourTimeField = fieldtype === 'time' && options.format === 'h:mm a';
  const is24HourTimeField = fieldtype === 'time' && options.format === 'HH:mm';
  const isDisplayImageField = fieldtype === 'image-display' && showOnRead; // NOTE: only show field when show on read is true

  if (!showOnRead) return null;
  const labelText = [{
    text: label
  }];

  if (isHtmlField) {
    const parsed = value.replace(/<p><\/p>/g, '');
    return [labelText, (0, _.toPdf)(parsed)];
  }

  if (isSignatureField) {
    if (!value) return [labelText, '-'];
    return (0, _helpers.fetchImage)(value).then(base64String => {
      const values = {
        alignment: 'left',
        image: base64String,
        width: 140
      };
      return [labelText, values];
    }).catch(() => [labelText, {
      alignment: 'left',
      image: _images.imageNotFound,
      width: 140
    }]);
  }

  if (isDisplayImageField) {
    return _bluebird.default.map([value], filepath => buildImage({
      filepath,
      settings
    })).then(fieldImages => [fieldImages, {}]);
  }

  if (isPhotoField) {
    return _bluebird.default.map(value, filepath => buildImage({
      filepath,
      settings
    })).then(fieldImages => {
      const tables = !(0, _lodash.isEmpty)(fieldImages) ? (0, _.imageTables)(fieldImages) : [];
      const imagesRow = {
        colSpan: 2,
        layout: {
          hLineWidth: () => 0,
          paddingLeft: () => 0,
          paddingRight: () => 0,
          paddingTop: () => 0,
          paddingBottom: () => 0,
          vLineWidth: () => 0
        },
        table: {
          body: [labelText, ...tables],
          widths: ['*']
        }
      }; // NOTE: pass empty value here as otherwise
      // we can accidentally hide content below
      // this row. Please see the following issue:
      // https://github.com/bpampuch/pdfmake/issues/1598

      return [imagesRow, {}];
    });
  }

  if (isFileField) {
    const fileList = (0, _lodash.map)(value, file => buildFile({
      file,
      settings
    }));
    return [labelText, {
      ol: fileList
    }];
  }

  if (isNumberField || isSelectField || isSwitchField || isTextField) {
    const parsedValue = (0, _.parseValue)(value);
    const displayValue = (0, _lodash.isArray)(parsedValue) ? {
      text: (0, _lodash.join)(parsedValue, ', ')
    } : {
      text: parsedValue
    };
    return [labelText, displayValue];
  }

  if (isStarField) {
    if (!value) return [labelText, '-'];
    const displayValue = value === '1' ? `${value} star` : `${value} stars`;
    return [labelText, displayValue];
  }

  if (isDayFirstDateField || isMonthFirstDateField || is12HourTimeField || is24HourTimeField) {
    const format = options.format;
    const displayValue = value ? (0, _momentTimezone.default)(value).tz(timezone).format(format) : '-';
    return [labelText, displayValue];
  } // NOTE: if no match above null values will be stripped within calling fn


  return null;
}

function isDataImage(string) {
  return (0, _lodash.startsWith)(string, 'data:image/png;');
}