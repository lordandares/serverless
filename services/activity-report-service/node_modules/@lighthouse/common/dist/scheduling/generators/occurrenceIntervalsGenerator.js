"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.occurrenceIntervalsGenerator = occurrenceIntervalsGenerator;
exports.strategyTypeMap = void 0;

var _scheduling = require("../scheduling.types");

var _strategies = require("../strategies");

const strategyTypeMap = {
  [_scheduling.StrategyTypes.ExactDateOfMonth]: _strategies.getNextExactDateOfMonth,
  [_scheduling.StrategyTypes.LastDayOfMonth]: _strategies.getNextLastDayOfMonth,
  [_scheduling.StrategyTypes.LastWeekdayOfMonth]: _strategies.getNextLastWeekdayOfMonth,
  [_scheduling.StrategyTypes.NoRepeat]: _strategies.getNextNoRepeat,
  [_scheduling.StrategyTypes.Stopwatch]: _strategies.getNext,
  [_scheduling.StrategyTypes.Weekdays]: _strategies.getNextWeekday,
  [_scheduling.StrategyTypes.Window]: _strategies.getNext,
  [_scheduling.StrategyTypes.XDayOfXWeekOfMonth]: _strategies.getNextXDayOfXWeekOfMonth
};
exports.strategyTypeMap = strategyTypeMap;

/**
 * Generates occurrence intervals for service intervals using strategy
 */
function* occurrenceIntervalsGenerator(props) {
  const {
    isInitial,
    serviceInterval,
    strategy,
    timezone
  } = props;
  const {
    options,
    type
  } = strategy;
  const start = serviceInterval[0];
  const end = serviceInterval[1];
  let dateCursor = start;
  let initial = isInitial; // NOTE: weekdays strategy type must iterate through options independently

  if (type === _scheduling.StrategyTypes.Weekdays) {
    const {
      duration,
      frequency,
      weekdays
    } = options;

    for (const weekday of weekdays) {
      let weekdayDateCursor = dateCursor;
      let weekdayIsInitial = isInitial;

      while (weekdayDateCursor < end) {
        const nextOccurrence = (0, _strategies.getNextWeekday)({
          end,
          isInitial: weekdayIsInitial,
          start: weekdayDateCursor,
          options: { ...options,
            weekday
          },
          timezone
        });
        if (!nextOccurrence) break;
        yield nextOccurrence;
        weekdayDateCursor = nextOccurrence[1];
        weekdayIsInitial = false;
      }
    }

    return;
  }

  const getNextFn = strategyTypeMap[type];
  if (!getNextFn) return;

  while (dateCursor < end) {
    const nextOccurrence = getNextFn({
      end,
      isInitial: initial,
      start: dateCursor,
      options,
      timezone
    });
    if (!nextOccurrence) return;
    yield nextOccurrence;
    initial = false;
    dateCursor = nextOccurrence[1];
  }
}