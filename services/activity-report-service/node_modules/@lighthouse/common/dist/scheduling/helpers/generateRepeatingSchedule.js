"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateRepeatingSchedule = generateRepeatingSchedule;
exports.complyingServiceIntervalUnits = void 0;

var _fp = require("lodash/fp");

var _ = require(".");

var _scheduling = require("../scheduling.types");

var _generators = require("../generators");

const complyingServiceIntervalUnits = [_scheduling.Unit.Second, _scheduling.Unit.Minute, _scheduling.Unit.Hour];
/**
 * Generates repeating schedule service and occurrence intervals
 */

exports.complyingServiceIntervalUnits = complyingServiceIntervalUnits;

function* generateRepeatingSchedule(props) {
  const {
    isInitial,
    serviceHours,
    start,
    strategy
  } = props;
  let {
    end
  } = props; // NOTE support never ending repeating schedule where no end date defined by
  // setting a custom end date using the frequency unit and value

  const {
    options: {
      frequency
    }
  } = strategy;
  const {
    unit: frequencyUnit,
    value: frequencyValue
  } = frequency;
  const {
    timezone
  } = serviceHours;
  end = end || (0, _.generateScheduleEnd)({
    frequency,
    start,
    timezone
  });
  const isStartAndEndValid = (0, _.hasValidStartAndEnd)({
    end,
    start
  });
  if (!isStartAndEndValid) return [];
  const serviceIntervalSequence = (0, _generators.serviceIntervalsGenerator)({
    end,
    serviceHours,
    start
  }); // NOTE: when repeating and is complying to service hours we iterate through
  // all service intervals otherwise service interval is from the start and end

  const complyToServiceHours = (0, _fp.includes)(frequencyUnit, complyingServiceIntervalUnits);
  const serviceIntervals = complyToServiceHours ? [...serviceIntervalSequence] : [[start, end]];

  for (const serviceInterval of serviceIntervals) {
    yield {
      interval: serviceInterval,
      type: _scheduling.IntervalTypes.Service
    };
    const occurrenceIntervalsSequence = (0, _generators.occurrenceIntervalsGenerator)({
      isInitial,
      serviceInterval,
      strategy,
      timezone
    });

    for (const occurrenceInterval of occurrenceIntervalsSequence) {
      yield {
        interval: occurrenceInterval,
        type: _scheduling.IntervalTypes.Occurrence
      };
    }
  }
}