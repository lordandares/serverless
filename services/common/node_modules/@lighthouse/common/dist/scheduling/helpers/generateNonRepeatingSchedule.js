"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateNonRepeatingSchedule = generateNonRepeatingSchedule;

var _fp = require("lodash/fp");

var _ = require(".");

var _scheduling = require("../scheduling.types");

var _generators = require("../generators");

/**
 * Generates non repeating schedule service and occurrence intervals
 */
function* generateNonRepeatingSchedule(props) {
  const {
    end,
    isInitial,
    serviceHours,
    start,
    strategy
  } = props;
  const isStartAndEndValid = (0, _.hasValidStartAndEnd)({
    end,
    start
  });
  if (!isStartAndEndValid) return [];
  const serviceIntervalSequence = (0, _generators.serviceIntervalsGenerator)({
    end,
    serviceHours,
    start
  });
  const {
    hours,
    timezone
  } = serviceHours;
  const hasServiceHours = !(0, _fp.isEmpty)(hours);
  const intervals = [...serviceIntervalSequence]; // NOTE: when non repeating and has service hours the service interval is
  // from the first and last service interval otherwise from the start and end

  const serviceIntervals = !hasServiceHours ? [[start, end]] : !(0, _fp.isEmpty)(intervals) ? [[(0, _fp.first)(intervals)[0], (0, _fp.last)(intervals)[1]]] : [];

  for (const serviceInterval of serviceIntervals) {
    yield {
      interval: serviceInterval,
      type: _scheduling.IntervalTypes.Service
    };
    const occurrenceIntervalsSequence = (0, _generators.occurrenceIntervalsGenerator)({
      isInitial,
      serviceInterval,
      strategy,
      timezone
    });

    for (const occurrenceInterval of occurrenceIntervalsSequence) {
      yield {
        interval: occurrenceInterval,
        type: _scheduling.IntervalTypes.Occurrence
      };
    }
  }
}