import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _typeof from "@babel/runtime/helpers/typeof";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { atob, btoa } from '@lighthouse/abab';
import fetchPonyfill from 'fetch-ponyfill';
import Promise from 'bluebird'; // NOTE use the native fetch if it's available in the browser, because the
// ponyfill (which actually uses the github polyfill) does not support all the
// same options as native fetch

var fetch = (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' && self.fetch || fetchPonyfill({
  Promise: Promise
}).fetch;
var contentTypes = {
  'image/png': 'png',
  'image/jpeg': 'jpeg'
};
var defaultOptions = {
  // NOTE The cache: no-cache option is important to avoid an issue with CORS
  // and caching on Chrome. Here's a good explanation of the issue:
  // https://stackoverflow.com/a/37455118
  // In our case, when loading the web version of a form, the signature image is
  // cached without the correct CORS headers. If the pdf is then generated,
  // there's a mismatch between the cached image headers and the CORS headers
  // sent from the fetch request, causing an error
  cache: 'no-cache'
};
export function fetchImage(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var fetchOptions = _objectSpread({}, defaultOptions, {}, options);

  return fetch(url, fetchOptions).then(function (response) {
    var contentHeader = response.headers.get('content-length');
    var contentType = response.headers.get('content-type'); // NOTE: the response will be ok but we won't be able to render any
    // image meaning pdfmake will error. Raise error here and return early.

    if (contentHeader === '0') {
      return Promise.reject(new Error("Failed to fetch image as no content length: ".concat(url)));
    }

    if (!response.ok) {
      return Promise.reject(new Error("Failed to fetch image: ".concat(url)));
    }

    var imageType = contentTypes[contentType];
    return response.arrayBuffer().then(function (buffer) {
      return {
        buffer: buffer,
        imageType: imageType
      };
    });
  }).then(function (_ref) {
    var buffer = _ref.buffer,
        imageType = _ref.imageType;
    var base64Flag = "data:image/".concat(imageType, ";base64,");
    var imageStr = arrayBufferToBase64(buffer);
    var base64 = "".concat(base64Flag).concat(imageStr);
    var isValid = validateBase64Image(base64);

    if (!isValid) {
      return Promise.reject(new Error('InvalidImageError'));
    }

    return base64;
  }).catch(function (error) {
    // NOTE: catch all error to log and then rethrow
    console.error(error);
    throw error;
  });
}

function arrayBufferToBase64(buffer) {
  var binary = '';
  var bytes = [].slice.call(new Uint8Array(buffer));
  bytes.forEach(function (b) {
    return binary += String.fromCharCode(b);
  });
  return btoa(binary);
}

export function validateBase64Image(base64String) {
  var isJpeg = base64String.startsWith('data:image/jpeg;base64,');
  if (isJpeg) return validateJpegImage(base64String);
  var isPng = base64String.startsWith('data:image/png;base64,');
  if (isPng) return validatePngImage(base64String);
  return false;
} // See SO for more info: https://stackoverflow.com/a/41635312
// Fiddle: https://jsfiddle.net/Lnyxuchw/

export function validateJpegImage(base64string) {
  var src = base64string;
  var imageData = Uint8Array.from(atob(src.replace('data:image/jpeg;base64,', '')), function (c) {
    return c.charCodeAt(0);
  });
  var imageCorrupted = imageData[imageData.length - 1] === 217 && imageData[imageData.length - 2] === 255;
  return imageCorrupted;
} // See SO for more info: https://stackoverflow.com/a/41635312
// Fiddle: https://jsfiddle.net/Lnyxuchw/

export function validatePngImage(base64string) {
  var src = base64string;
  var imageData = Uint8Array.from(atob(src.replace('data:image/png;base64,', '')), function (c) {
    return c.charCodeAt(0);
  });
  var sequence = [0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]; // in hex:
  //check last 12 elements of array so they contains needed values

  for (var i = 12; i > 0; i--) {
    if (imageData[imageData.length - i] !== sequence[12 - i]) {
      return false;
    }
  }

  return true;
}
//# sourceMappingURL=index.js.map