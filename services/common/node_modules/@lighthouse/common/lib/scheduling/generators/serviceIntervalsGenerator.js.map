{"version":3,"sources":["../../../src/scheduling/generators/serviceIntervalsGenerator.ts"],"names":["serviceIntervalsGenerator","filter","flow","forEach","map","moment","Behaviours","Durations","Types","Unit","convertToTimezone","intervalCovers","intervalOnlyIntersectsEnd","intervalOnlyIntersectsStart","intervalWithin","mergeIntervals","splitIntervals","props","end","serviceHours","start","timezone","hasValidStartAndEnd","mStart","tz","mEnd","mStartValid","isValid","mEndValid","hours","rangeInterval","closeOverrideHours","behaviour","Close","type","Override","defaultHours","Default","openOverrideHours","Open","closeIntervals","override","openIntervals","weekStart","startOf","Week","valueOf","defaultIntervals","hour","endOffset","startOffset","hourStart","hourEnd","interval","isIntervalIntersectingRangeEnd","isIntervalIntersectingRangeStart","isIntervalInsideRange","isRangeInsideInterval","shouldSkip","nextStart","nextEnd","push","getOverrideIntervalsForRange","intervalCoversRange","intervalIntersectsRangeEnd","intervalIntersectsRangeStart","intervalStart","intervalEnd","rangeOpenIntervals","rangeCloseIntervals","mergedIntervals","serviceIntervals"],"mappings":"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","sourcesContent":["import { filter, flow, forEach, map } from 'lodash/fp'\nimport moment from 'moment-timezone'\n\nimport {\n  Behaviours,\n  Durations,\n  Schema as ServiceHoursSchema,\n  Types,\n} from '../../service-hours'\nimport { Interval, Unit } from '../scheduling.types'\nimport {\n  convertToTimezone,\n  intervalCovers,\n  intervalOnlyIntersectsEnd,\n  intervalOnlyIntersectsStart,\n  intervalWithin,\n  mergeIntervals,\n  splitIntervals,\n} from '../helpers'\n\ninterface ServiceIntervalsGenerator {\n  readonly end: number\n  readonly serviceHours: ServiceHoursSchema\n  readonly start: number\n}\n\n/**\n * Generates service intervals between start and end range for service hours\n */\nexport function* serviceIntervalsGenerator(props: ServiceIntervalsGenerator) {\n  const { end, serviceHours, start } = props\n  const { timezone } = serviceHours\n\n  const hasValidStartAndEnd = end > start && start < end\n\n  if (!hasValidStartAndEnd) return []\n\n  const mStart = moment.tz(start, timezone)\n  const mEnd = moment.tz(end, timezone)\n  const mStartValid = mStart.isValid()\n  const mEndValid = mEnd.isValid()\n\n  if (!mStartValid || !mEndValid) return []\n\n  const { hours } = serviceHours\n  const rangeInterval = [start, end]\n\n  const closeOverrideHours = filter(\n    { behaviour: Behaviours.Close, type: Types.Override },\n    hours\n  )\n  const defaultHours = filter({ type: Types.Default }, hours)\n  const openOverrideHours = filter(\n    { behaviour: Behaviours.Open, type: Types.Override },\n    hours\n  )\n\n  // NOTE: we must apply the timezone to overrides as they are stored in UTC\n  // and must be converted to timestamps in the timezone before processing\n  const closeIntervals = map(override => {\n    const start = convertToTimezone(override.start, timezone)\n    const end = convertToTimezone(override.end, timezone)\n    return [start, end]\n  }, closeOverrideHours)\n\n  const openIntervals = map(override => {\n    const start = convertToTimezone(override.start, timezone)\n    const end = convertToTimezone(override.end, timezone)\n    return [start, end]\n  }, openOverrideHours)\n\n  let weekStart = mStart.startOf(Unit.Week).valueOf()\n\n  const defaultIntervals = []\n\n  while (weekStart < end) {\n    forEach((hour) => {\n      // NOTE: hour start and end values are the number of minutes from the\n      // start of the week so are simply offsets\n      const { end: endOffset, start: startOffset } = hour\n      const hourStart = weekStart + startOffset\n      const hourEnd = weekStart + endOffset\n\n      const interval = [hourStart, hourEnd]\n\n      const isIntervalIntersectingRangeEnd = intervalOnlyIntersectsEnd(interval, rangeInterval)\n      const isIntervalIntersectingRangeStart = intervalOnlyIntersectsStart(interval, rangeInterval)\n      const isIntervalInsideRange = intervalWithin(interval, rangeInterval)\n      const isRangeInsideInterval = intervalWithin(rangeInterval, interval)\n\n      const shouldSkip = \n        !isIntervalInsideRange &&\n        !isRangeInsideInterval && \n        !isIntervalIntersectingRangeStart &&\n        !isIntervalIntersectingRangeEnd\n\n      if (shouldSkip) return\n\n      const nextStart = isRangeInsideInterval || isIntervalIntersectingRangeStart\n        ? start \n        : hourStart\n\n      const nextEnd = isRangeInsideInterval || isIntervalIntersectingRangeEnd \n        ? end\n        : hourEnd\n\n      defaultIntervals.push([nextStart, nextEnd])\n    }, defaultHours)\n\n    weekStart = weekStart + Durations.Week\n  }\n\n  // NOTE: only include intervals which intersect our range and then map to\n  // ensure the intervals conform to the range interval\n  const getOverrideIntervalsForRange = flow(\n    filter(\n      (interval: Interval): boolean =>\n        interval[0] >= rangeInterval[0] || interval[0] <= rangeInterval[1]\n    ),\n    map(\n      (interval: Interval): Interval => {\n        const intervalCoversRange = intervalCovers(interval, rangeInterval)\n        const intervalIntersectsRangeEnd = intervalOnlyIntersectsEnd(\n          interval,\n          rangeInterval\n        )\n        const intervalIntersectsRangeStart = intervalOnlyIntersectsStart(\n          interval,\n          rangeInterval\n        )\n\n        const intervalStart = intervalIntersectsRangeStart\n          ? rangeInterval[0]\n          : interval[0]\n        const intervalEnd = intervalIntersectsRangeEnd\n          ? rangeInterval[1]\n          : interval[1]\n\n        return intervalCoversRange\n          ? rangeInterval\n          : [intervalStart, intervalEnd]\n      }\n    )\n  )\n\n  // NOTE: for simplicity we calculate all default service intervals and then\n  // apply the open and closed overrides, we can't do this as we iterate\n  // through the weeks as open and close overrides can potentially intersect\n  // across weeks\n  const rangeOpenIntervals = getOverrideIntervalsForRange(openIntervals)\n  const rangeCloseIntervals = getOverrideIntervalsForRange(closeIntervals)\n\n  const mergedIntervals = mergeIntervals([\n    ...defaultIntervals,\n    ...rangeOpenIntervals,\n  ])\n  const serviceIntervals = splitIntervals(mergedIntervals, rangeCloseIntervals)\n\n  for (let interval of serviceIntervals) yield interval\n}\n"],"file":"serviceIntervalsGenerator.js"}