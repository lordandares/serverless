import { Span as OpenCensusSpan } from '@opencensus/web-types';
import { Tracer as OpenCensusTracer } from '@opencensus/web-types';
import { TracerBase } from '@opencensus/web-types';

/** Defines a attributes interface. */
export declare interface Attributes {
    /**
     * Known attributes.
     */
    [attributeKey: string]: unknown;
}

/**
 * Formatter to serializing and deserializing a value with into a binary format.
 */
export declare interface BinaryFormat {
    /**
     * Serialize the given span context into a Buffer.
     * @param spanContext The span context to serialize.
     */
    toBytes(spanContext: SpanContext): ArrayBuffer;
    /**
     * Deseralize the given span context from binary encoding. If the input is a
     * Buffer of incorrect size or unexpected fields, then this function will
     * return `null`.
     * @param buffer The span context to deserialize.
     */
    fromBytes(buffer: ArrayBuffer): SpanContext | null;
}

/**
 * An enumeration of canonical status codes.
 *
 * TODO (revision): https://github.com/open-telemetry/opentelemetry-specification/issues/59
 */
export declare enum CanonicalCode {
    /**
     * Not an error; returned on success
     */
    OK = 0,
    /**
     * The operation was cancelled (typically by the caller).
     */
    CANCELLED = 1,
    /**
     * Unknown error.  An example of where this error may be returned is
     * if a status value received from another address space belongs to
     * an error-space that is not known in this address space.  Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     */
    UNKNOWN = 2,
    /**
     * Client specified an invalid argument.  Note that this differs
     * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     */
    INVALID_ARGUMENT = 3,
    /**
     * Deadline expired before operation could complete.  For operations
     * that change the state of the system, this error may be returned
     * even if the operation has completed successfully.  For example, a
     * successful response from a server could have been delayed long
     * enough for the deadline to expire.
     */
    DEADLINE_EXCEEDED = 4,
    /**
     * Some requested entity (e.g., file or directory) was not found.
     */
    NOT_FOUND = 5,
    /**
     * Some entity that we attempted to create (e.g., file or directory)
     * already exists.
     */
    ALREADY_EXISTS = 6,
    /**
     * The caller does not have permission to execute the specified
     * operation.  PERMISSION_DENIED must not be used for rejections
     * caused by exhausting some resource (use RESOURCE_EXHAUSTED
     * instead for those errors).  PERMISSION_DENIED must not be
     * used if the caller can not be identified (use UNAUTHENTICATED
     * instead for those errors).
     */
    PERMISSION_DENIED = 7,
    /**
     * Some resource has been exhausted, perhaps a per-user quota, or
     * perhaps the entire file system is out of space.
     */
    RESOURCE_EXHAUSTED = 8,
    /**
     * Operation was rejected because the system is not in a state
     * required for the operation's execution.  For example, directory
     * to be deleted may be non-empty, an rmdir operation is applied to
     * a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
     *
     *  - Use UNAVAILABLE if the client can retry just the failing call.
     *  - Use ABORTED if the client should retry at a higher-level
     *    (e.g., restarting a read-modify-write sequence).
     *  - Use FAILED_PRECONDITION if the client should not retry until
     *    the system state has been explicitly fixed.  E.g., if an "rmdir"
     *    fails because the directory is non-empty, FAILED_PRECONDITION
     *    should be returned since the client should not retry unless
     *    they have first fixed up the directory by deleting files from it.
     *  - Use FAILED_PRECONDITION if the client performs conditional
     *    REST Get/Update/Delete on a resource and the resource on the
     *    server does not match the condition. E.g., conflicting
     *    read-modify-write on the same resource.
     */
    FAILED_PRECONDITION = 9,
    /**
     * The operation was aborted, typically due to a concurrency issue
     * like sequencer check failures, transaction aborts, etc.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */
    ABORTED = 10,
    /**
     * Operation was attempted past the valid range.  E.g., seeking or
     * reading past end of file.
     *
     * Unlike INVALID_ARGUMENT, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate INVALID_ARGUMENT if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OUT_OF_RANGE if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FAILED_PRECONDITION and
     * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OUT_OF_RANGE error to detect when
     * they are done.
     */
    OUT_OF_RANGE = 11,
    /**
     * Operation is not implemented or not supported/enabled in this service.
     */
    UNIMPLEMENTED = 12,
    /**
     * Internal errors.  Means some invariants expected by underlying
     * system has been broken.  If you see one of these errors,
     * something is very broken.
     */
    INTERNAL = 13,
    /**
     * The service is currently unavailable.  This is a most likely a
     * transient condition and may be corrected by retrying with
     * a backoff.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */
    UNAVAILABLE = 14,
    /**
     * Unrecoverable data loss or corruption.
     */
    DATA_LOSS = 15,
    /**
     * The request does not have valid authentication credentials for the
     * operation.
     */
    UNAUTHENTICATED = 16
}

/** A text annotation with a set of attributes. */
export declare interface Event {
    /** The name of the event. */
    name: string;
    /** The attributes of the event. */
    attributes?: Attributes;
}

/**
 * Generates a `SpanContext` given a `traceparent` header value.
 * @param traceParent Serialized span context data as a `traceparent` header value.
 * @returns The `SpanContext` generated from the `traceparent` value.
 */
export declare function extractSpanContextFromTraceParentHeader(traceParentHeader: string): SpanContext | undefined;

/**
 * Generates a `traceparent` value given a span context.
 * @param spanContext Contains context for a specific span.
 * @returns The `spanContext` represented as a `traceparent` value.
 */
export declare function getTraceParentHeader(spanContext: SpanContext): string | undefined;

/**
 * Retrieves the active tracer, or returns a
 * no-op implementation if one is not set.
 */
export declare function getTracer(): Tracer;

/** High resolution HrTime: [seconds: number, nanoseconds: number] */
export declare type HrTime = [number, number];

/**
 * Injects and extracts a value as text into carriers that travel in-band
 * across process boundaries. Encoding is expected to conform to the HTTP
 * Header Field semantics. Values are often encoded as RPC/HTTP request headers.
 *
 * The carrier of propagated data on both the client (injector) and server
 * (extractor) side is usually an http request. Propagation is usually
 * implemented via library- specific request interceptors, where the
 * client-side injects values and the server-side extracts them.
 */
export declare interface HttpTextFormat {
    /**
     * Injects the given {@link SpanContext} instance to transmit over the wire.
     *
     * OpenTelemetry defines a common set of format values (BinaryFormat and
     * HTTPTextFormat), and each has an expected `carrier` type.
     *
     * @param spanContext the SpanContext to transmit over the wire.
     * @param format the format of the carrier.
     * @param carrier the carrier of propagation fields, such as an http request.
     */
    inject(spanContext: SpanContext, format: string, carrier: unknown): void;
    /**
     * Returns a {@link SpanContext} instance extracted from `carrier` in the
     * given format from upstream.
     *
     * @param format the format of the carrier.
     * @param carrier the carrier of propagation fields, such as an http request.
     * @returns SpanContext The extracted SpanContext, or null if no such
     *     SpanContext could be found in carrier.
     */
    extract(format: string, carrier: unknown): SpanContext | null;
}

/**
 * A pointer from the current {@link Span} to another span in the same trace or
 * in a different trace.
 */
export declare interface Link {
    /** The {@link SpanContext} of a linked span. */
    spanContext: SpanContext;
    /** A set of {@link Attributes} on the link. */
    attributes?: Attributes;
}

/**
 * A no-op implementation of Span that can safely be used without side-effects.
 */
export declare class NoOpSpan implements Span {
    /**
     * Returns the SpanContext associated with this Span.
     */
    context(): SpanContext;
    /**
     * Marks the end of Span execution.
     * @param _endTime The time to use as the Span's end time. Defaults to
     * the current time.
     */
    end(_endTime?: number): void;
    /**
     * Sets an attribute on the Span
     * @param _key the attribute key
     * @param _value the attribute value
     */
    setAttribute(_key: string, _value: unknown): this;
    /**
     * Sets attributes on the Span
     * @param _attributes the attributes to add
     */
    setAttributes(_attributes: Attributes): this;
    /**
     * Adds an event to the Span
     * @param _name The name of the event
     * @param _attributes The associated attributes to add for this event
     */
    addEvent(_name: string, _attributes?: Attributes): this;
    /**
     * Adds a link to the Span.
     * @param _spanContext the context of the linked span
     * @param _attributes attributes to be added that are associated with the link
     */
    addLink(_spanContext: SpanContext, _attributes?: Attributes): this;
    /**
     * Sets a status on the span. Overrides the default of CanonicalCode.OK.
     * @param _status The status to set.
     */
    setStatus(_status: Status): this;
    /**
     * Updates the name of the Span
     * @param _name the new Span name
     */
    updateName(_name: string): this;
    /**
     * Returns whether this span will be recorded
     */
    isRecordingEvents(): boolean;
}

/**
 * A no-op implementation of Tracer that can be used when tracing
 * is disabled.
 */
export declare class NoOpTracer implements Tracer {
    /**
     * Starts a new Span.
     * @param _name The name of the span.
     * @param _options The SpanOptions used during Span creation.
     */
    startSpan(_name: string, _options?: SpanOptions): Span;
    /**
     * Returns the current Span from the current context, if available.
     */
    getCurrentSpan(): Span;
    /**
     * Executes the given function within the context provided by a Span.
     * @param _span The span that provides the context.
     * @param fn The function to be executed.
     */
    withSpan<T extends (...args: unknown[]) => ReturnType<T>>(_span: Span, fn: T): ReturnType<T>;
    /**
     * Bind a Span as the target's scope
     * @param target An object to bind the scope.
     * @param _span A specific Span to use. Otherwise, use the current one.
     */
    bind<T>(target: T, _span?: Span): T;
    /**
     * Send a pre-populated Span object to the exporter.
     * @param _span The span to pass along.
     */
    recordSpanData(_span: Span): void;
    /**
     * Returns the BinaryFormat interface for serializing/deserializing Spans.
     */
    getBinaryFormat(): BinaryFormat;
    /**
     * Returns the HttpTextFormat interface for injecting/extracting Spans.
     */
    getHttpTextFormat(): HttpTextFormat;
}
export { OpenCensusSpan }

/**
 * An implementation of OpenTelemetry Span that wraps an OpenCensus Span.
 */
export declare class OpenCensusSpanWrapper implements Span {
    private _span;
    /**
     * The underlying OpenCensus Span
     */
    getWrappedSpan(): OpenCensusSpan;
    /**
     * Wraps an existing OpenCensus Span
     * @param span A Span or RootSpan from OpenCensus
     */
    constructor(span: OpenCensusSpan);
    /**
     * Create a new OpenCensus Span and wrap it.
     * @param tracer The OpenCensus tracer that has been wrapped in OpenCensusTracerWrapper
     * @param name The name of the Span
     * @param options Options for the Span
     */
    constructor(tracer: OpenCensusTracerWrapper, name: string, options?: SpanOptions);
    /**
     * Marks the end of Span execution.
     * @param endTime The time to use as the Span's end time. Defaults to
     * the current time.
     */
    end(_endTime?: number): void;
    /**
     * Returns the SpanContext associated with this Span.
     */
    context(): SpanContext;
    /**
     * Sets an attribute on the Span
     * @param key the attribute key
     * @param value the attribute value
     */
    setAttribute(key: string, value: unknown): this;
    /**
     * Sets attributes on the Span
     * @param attributes the attributes to add
     */
    setAttributes(attributes: Attributes): this;
    /**
     * Adds an event to the Span
     * @param name The name of the event
     * @param attributes The associated attributes to add for this event
     */
    addEvent(name: string, attributes?: Attributes): this;
    /**
     * Adds a link to the Span.
     * @param spanContext the context of the linked span
     * @param attributes attributes to be added that are associated with the link
     */
    addLink(spanContext: SpanContext, attributes?: Attributes): this;
    /**
     * Sets a status on the span. Overrides the default of CanonicalCode.OK.
     * @param status The status to set.
     */
    setStatus(status: Status): this;
    /**
     * Updates the name of the Span
     * @param name the new Span name
     */
    updateName(name: string): this;
    /**
     * Returns whether this span will be recorded
     */
    isRecordingEvents(): boolean;
}
export { OpenCensusTracer }

/**
 * An implementation of OpenTelemetry Tracer that wraps an OpenCensus Tracer.
 */
export declare class OpenCensusTracerWrapper implements Tracer {
    private _tracer;
    /**
     * The wrapped OpenCensus Tracer
     */
    getWrappedTracer(): TracerBase;
    /**
     * Create a new wrapper around a given OpenCensus Tracer.
     * @param tracer The OpenCensus Tracer to wrap.
     */
    constructor(tracer: TracerBase);
    /**
     * Starts a new Span.
     * @param name The name of the span.
     * @param options The SpanOptions used during Span creation.
     */
    startSpan(name: string, options?: SpanOptions): Span;
    /**
     * Returns the current Span from the current context, if available.
     */
    getCurrentSpan(): Span | null;
    /**
     * Executes the given function within the context provided by a Span.
     * @param span The span that provides the context.
     * @param fn The function to be executed.
     */
    withSpan<T extends (...args: unknown[]) => unknown>(span: Span, fn: T): ReturnType<T>;
    /**
     * Bind a Span as the target's scope
     * @param target An object to bind the scope.
     * @param span A specific Span to use. Otherwise, use the current one.
     */
    bind<T>(target: T, span?: Span): T;
    /**
     * Send a pre-populated Span object to the exporter.
     * @param span The span to pass along.
     */
    recordSpanData(span: Span): void;
    /**
     * Returns the BinaryFormat interface for serializing/deserializing Spans.
     */
    getBinaryFormat(): BinaryFormat;
    /**
     * Returns the HttpTextFormat interface for injecting/extracting Spans.
     */
    getHttpTextFormat(): HttpTextFormat;
}

/**
 * This interface represent a sampler. Sampling is a mechanism to control the
 * noise and overhead introduced by OpenTelemetry by reducing the number of
 * samples of traces collected and sent to the backend.
 */
export declare interface Sampler {
    /**
     * Checks whether span needs to be created and tracked.
     *
     * TODO: Consider to add required arguments https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/sampling-api.md#shouldsample
     * @param [parentContext] Parent span context. Typically taken from the wire.
     *     Can be null.
     * @returns whether span should be sampled or not.
     */
    shouldSample(parentContext?: SpanContext): boolean;
    /** Returns the sampler name or short description with the configuration. */
    toString(): string;
}

/**
 * Sets the global tracer, enabling tracing for the Azure SDK.
 * @param tracer An OpenTelemetry Tracer instance.
 */
export declare function setTracer(tracer: Tracer): void;

/**
 * An interface that represents a span. A span represents a single operation
 * within a trace. Examples of span might include remote procedure calls or a
 * in-process function calls to sub-components. A Trace has a single, top-level
 * "root" Span that in turn may have zero or more child Spans, which in turn
 * may have children.
 */
export declare interface Span {
    /**
     * Returns the {@link SpanContext} object associated with this Span.
     *
     * @returns the SpanContext object associated with this Span.
     */
    context(): SpanContext;
    /**
     * Sets an attribute to the span.
     *
     * @param key the key for this attribute.
     * @param value the value for this attribute.
     */
    setAttribute(key: string, value: unknown): this;
    /**
     * Sets attributes to the span.
     *
     * @param attributes the attributes that will be added.
     */
    setAttributes(attributes: Attributes): this;
    /**
     * Adds an event to the Span.
     *
     * @param name the name of the event.
     * @param [attributes] the attributes that will be added; these are
     *     associated with this event.
     */
    addEvent(name: string, attributes?: Attributes): this;
    /**
     * Adds a link to the Span.
     *
     * @param spanContext the context of the linked span.
     * @param [attributes] the attributes that will be added; these are
     *     associated with this link.
     */
    addLink(spanContext: SpanContext, attributes?: Attributes): this;
    /**
     * Sets a status to the span. If used, this will override the default Span
     * status. Default is {@link CanonicalCode.OK}.
     *
     * @param status the Status to set.
     */
    setStatus(status: Status): this;
    /**
     * Updates the Span name.
     *
     * TODO (revision): https://github.com/open-telemetry/opentelemetry-specification/issues/119
     *
     * @param name the Span name.
     */
    updateName(name: string): this;
    /**
     * Marks the end of Span execution.
     *
     * Call to End of a Span MUST not have any effects on child spans. Those may
     * still be running and can be ended later.
     *
     * Do not return `this`. The Span generally should not be used after it
     * is ended so chaining is not desired in this context.
     *
     * @param [endTime] the time to set as Span's end time. If not provided,
     *     use the current time as the span's end time.
     *     TODO (Add timestamp format): https://github.com/open-telemetry/opentelemetry-js/issues/19
     */
    end(endTime?: TimeInput): void;
    /**
     * Returns the flag whether this span will be recorded.
     *
     * @returns true if this Span is active and recording information like events
     * with the AddEvent operation and attributes using setAttributes.
     */
    isRecordingEvents(): boolean;
}

/**
 * A SpanContext represents the portion of a {@link Span} which must be
 * serialized and propagated along side of a distributed context.
 */
export declare interface SpanContext {
    /**
     * The ID of the trace that this span belongs to. It is worldwide unique
     * with practically sufficient probability by being made as 16 randomly
     * generated bytes, encoded as a 32 lowercase hex characters corresponding to
     * 128 bits.
     */
    traceId: string;
    /**
     * The ID of the Span. It is globally unique with practically sufficient
     * probability by being made as 8 randomly generated bytes, encoded as a 16
     * lowercase hex characters corresponding to 64 bits.
     */
    spanId: string;
    /**
     * Trace flags to propagate.
     *
     * It is represented as 1 byte (bitmap). Bit to represent whether trace is
     * sampled or not. When set, the least significant bit documents that the
     * caller may have recorded trace data. A caller who does not record trace
     * data out-of-band leaves this flag unset.
     *
     * SAMPLED = 0x1 and UNSAMPLED = 0x0;
     */
    traceFlags?: TraceFlags;
    /**
     * Tracing-system-specific info to propagate.
     *
     * The tracestate field value is a `list` as defined below. The `list` is a
     * series of `list-members` separated by commas `,`, and a list-member is a
     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
     * surrounding `list-members` are ignored. There can be a maximum of 32
     * `list-members` in a `list`.
     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field
     *
     * Examples:
     *     Single tracing system (generic format):
     *         tracestate: rojo=00f067aa0ba902b7
     *     Multiple tracing systems (with different formatting):
     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
     */
    traceState?: TraceState;
}

/**
 * Contains all the spans for a particular TraceID
 * starting at unparented roots
 */
export declare interface SpanGraph {
    /**
     * All Spans without a parentSpanId
     */
    roots: SpanGraphNode[];
}

/**
 * Simple representation of a Span that only has name and child relationships.
 * Children should be arranged in the order they were created.
 */
export declare interface SpanGraphNode {
    /**
     * The Span name
     */
    name: string;
    /**
     * All child Spans of this Span
     */
    children: SpanGraphNode[];
}

/**
 * Type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 */
export declare enum SpanKind {
    /** Default value. Indicates that the span is used internally. */
    INTERNAL = 0,
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SERVER = 1,
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    CLIENT = 2,
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    PRODUCER = 3,
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    CONSUMER = 4
}

/**
 * Options needed for span creation
 */
export declare interface SpanOptions {
    /** The SpanKind of a span */
    kind?: SpanKind;
    /** A spans attributes */
    attributes?: Attributes;
    /** Indicates that events are being recorded for a span */
    isRecordingEvents?: boolean;
    /**
     * A parent SpanContext (or Span, for convenience) that the newly-started
     * span will be the child of.
     */
    parent?: Span | SpanContext;
    /** A manually specified start time for the created Span object. */
    startTime?: number;
}

/**
 * The status of a Span by providing a standard CanonicalCode in conjunction
 * with an optional descriptive message.
 */
export declare interface Status {
    /** The canonical code of this message. */
    code: CanonicalCode;
    /** A developer-facing error message. */
    message?: string;
}

/**
 * A mock span useful for testing.
 */
export declare class TestSpan extends NoOpSpan {
    /**
     * The Span's current name
     */
    name: string;
    /**
     * The Span's current status
     */
    status: Status;
    /**
     * The Span's kind
     */
    kind: SpanKind;
    /**
     * True if end() has been called on the Span
     */
    endCalled: boolean;
    /**
     * The start time of the Span
     */
    readonly startTime: TimeInput;
    /**
     * The id of the parent Span, if any.
     */
    readonly parentSpanId?: string;
    private _context;
    private readonly _tracer;
    /**
     * Starts a new Span.
     * @param parentTracer The tracer that created this Span
     * @param name The name of the span.
     * @param context The SpanContext this span belongs to
     * @param kind The SpanKind of this Span
     * @param parentSpanId The identifier of the parent Span
     * @param startTime The startTime of the event (defaults to now)
     */
    constructor(parentTracer: TestTracer, name: string, context: SpanContext, kind: SpanKind, parentSpanId?: string, startTime?: TimeInput);
    /**
     * Returns the Tracer that created this Span
     */
    tracer(): Tracer;
    /**
     * Returns the SpanContext associated with this Span.
     */
    context(): SpanContext;
    /**
     * Marks the end of Span execution.
     * @param _endTime The time to use as the Span's end time. Defaults to
     * the current time.
     */
    end(_endTime?: number): void;
    /**
     * Sets a status on the span. Overrides the default of CanonicalCode.OK.
     * @param status The status to set.
     */
    setStatus(status: Status): this;
    /**
     * Returns whether this span will be recorded
     */
    isRecordingEvents(): boolean;
}

/**
 * A mock tracer useful for testing
 */
export declare class TestTracer extends NoOpTracer {
    private traceIdCounter;
    private getNextTraceId;
    private spanIdCounter;
    private getNextSpanId;
    private rootSpans;
    private knownSpans;
    /**
     * Returns all Spans that were created without a parent
     */
    getRootSpans(): TestSpan[];
    /**
     * Returns all Spans this Tracer knows about
     */
    getKnownSpans(): TestSpan[];
    /**
     * Returns all Spans where end() has not been called
     */
    getActiveSpans(): TestSpan[];
    /**
     * Return all Spans for a particular trace, grouped by their
     * parent Span in a tree-like structure
     * @param traceId The traceId to return the graph for
     */
    getSpanGraph(traceId: string): SpanGraph;
    /**
     * Starts a new Span.
     * @param name The name of the span.
     * @param options The SpanOptions used during Span creation.
     */
    startSpan(name: string, options?: SpanOptions): TestSpan;
    private _getParentContext;
}

/**
 * Represents a timed event.
 * A timed event is an event with a timestamp.
 */
export declare interface TimedEvent extends Event {
    /**
     * High resolution timestamp.
     */
    time: HrTime;
}

/**
 * Defines TimeInput.
 *
 * hrtime, expoch milliseconds, performance.now() or Date
 */
export declare type TimeInput = HrTime | number | Date;

/**
 * An enumeration that represents global trace flags. These flags are
 * propagated to all child {@link Span}. These determine features such as
 * whether a Span should be traced. It is implemented as a bitmask.
 */
export declare enum TraceFlags {
    /** Bit to represent whether trace is unsampled in trace flags. */
    UNSAMPLED = 0,
    /** Bit to represent whether trace is sampled in trace flags. */
    SAMPLED = 1
}

/**
 * Tracer provides an interface for creating {@link Span}s and propagating
 * context in-process.
 *
 * Users may choose to use manual or automatic Context propagation. Because of
 * that this class offers APIs to facilitate both usages.
 */
export declare interface Tracer {
    /**
     * Returns the current Span from the current context if available.
     *
     * If there is no Span associated with the current context, null is returned.
     *
     * @returns Span The currently active Span
     */
    getCurrentSpan(): Span | null;
    /**
     * Starts a new {@link Span}.
     * @param name The name of the span
     * @param [options] SpanOptions used for span creation
     * @returns Span The newly created span
     */
    startSpan(name: string, options?: SpanOptions): Span;
    /**
     * Executes the function given by fn within the context provided by Span
     *
     * @param span The span that provides the context
     * @param fn The function to be executed inside the provided context
     * @example
     * tracer.withSpan(span, function() { ... });
     */
    withSpan<T extends (...args: unknown[]) => ReturnType<T>>(span: Span, fn: T): ReturnType<T>;
    /**
     * Bind a span as the target's scope or propagate the current one.
     *
     * @param target Any object to which a scope need to be set
     * @param [span] Optionally specify the span which you want to assign
     */
    bind<T>(target: T, span?: Span): T;
    /**
     * Send a pre-populated span object to the exporter.
     * Sampling and recording decisions as well as other collection optimizations
     * are the responsibility of a caller.
     *
     * @todo: Pending API discussion. Revisit if Span or SpanData should be passed
     *        in here once this is sorted out.
     * @param span Span Data to be reported to all exporters.
     */
    recordSpanData(span: Span): void;
    /**
     * Returns the {@link BinaryFormat} interface which can serialize/deserialize
     * Spans.
     *
     * If no tracer implementation is provided, this defaults to the W3C Trace
     * Context binary format ({@link BinaryFormat}). For more details see
     * <a href="https://w3c.github.io/trace-context-binary/">W3C Trace Context
     * binary protocol</a>.
     */
    getBinaryFormat(): BinaryFormat;
    /**
     * Returns the {@link HttpTextFormat} interface which can inject/extract
     * Spans.
     *
     * If no tracer implementation is provided, this defaults to the W3C Trace
     * Context HTTP text format ({@link HttpTraceContext}). For more details see
     * <a href="https://w3c.github.io/trace-context/">W3C Trace Context</a>.
     */
    getHttpTextFormat(): HttpTextFormat;
}

/**
 * Tracestate carries system-specific configuration data, represented as a list
 * of key-value pairs. TraceState allows multiple tracing systems to
 * participate in the same trace.
 */
export declare interface TraceState {
    /**
     * Adds or updates the TraceState that has the given `key` if it is
     * present. The new State will always be added in the front of the
     * list of states.
     *
     * @param key key of the TraceState entry.
     * @param value value of the TraceState entry.
     */
    set(key: string, value: string): void;
    /**
     * Removes the TraceState Entry that has the given `key` if it is present.
     *
     * @param key the key for the TraceState Entry to be removed.
     */
    unset(key: string): void;
    /**
     * Returns the value to which the specified key is mapped, or `undefined` if
     * this map contains no mapping for the key.
     *
     * @param key with which the specified value is to be associated.
     * @returns the value to which the specified key is mapped, or `undefined` if
     *     this map contains no mapping for the key.
     */
    get(key: string): string | undefined;
    /**
     * Serializes the TraceState to a `list` as defined below. The `list` is a
     * series of `list-members` separated by commas `,`, and a list-member is a
     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
     * surrounding `list-members` are ignored. There can be a maximum of 32
     * `list-members` in a `list`.
     *
     * @returns the serialized string.
     */
    serialize(): string;
}

export { }
