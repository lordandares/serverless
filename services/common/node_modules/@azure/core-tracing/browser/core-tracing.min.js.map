{"version":3,"file":"core-tracing.min.js","sources":["../lib/tracers/noop/noOpSpan.ts","../lib/tracers/noop/noOpBinaryFormat.ts","../lib/tracers/noop/noOpHttpTextFormat.ts","../lib/tracers/noop/noOpTracer.ts","../lib/utils/cache.ts","../lib/utils/global.browser.ts","../lib/tracers/opencensus/openCensusTraceStateWrapper.ts","../lib/interfaces/status.ts","../lib/tracers/opencensus/openCensusSpanWrapper.ts","../lib/tracers/opencensus/openCensusTracerWrapper.ts","../../../../common/temp/node_modules/.registry.npmjs.org/tslib/1.10.0/node_modules/tslib/tslib.es6.js","../lib/interfaces/span_kind.ts","../lib/tracers/test/testSpan.ts","../lib/interfaces/trace_flags.ts","../lib/tracers/test/testTracer.ts","../lib/utils/traceParentHeader.ts","../lib/tracerProxy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { Span } from \"../../interfaces/span\";\nimport { SpanContext } from \"../../interfaces/span_context\";\nimport { Attributes } from \"../../interfaces/attributes\";\nimport { Status } from \"../../interfaces/status\";\n\n/**\n * A no-op implementation of Span that can safely be used without side-effects.\n */\nexport class NoOpSpan implements Span {\n\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  context(): SpanContext {\n    return {\n      spanId: \"\",\n      traceId: \"\"\n    };\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param _endTime The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    /* Noop */\n  }\n\n  /**\n   * Sets an attribute on the Span\n   * @param _key the attribute key\n   * @param _value the attribute value\n   */\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  /**\n   * Sets attributes on the Span\n   * @param _attributes the attributes to add\n   */\n  setAttributes(_attributes: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Adds an event to the Span\n   * @param _name The name of the event\n   * @param _attributes The associated attributes to add for this event\n   */\n  addEvent(_name: string, _attributes?: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Adds a link to the Span.\n   * @param _spanContext the context of the linked span\n   * @param _attributes attributes to be added that are associated with the link\n   */\n  addLink(_spanContext: SpanContext, _attributes?: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of CanonicalCode.OK.\n   * @param _status The status to set.\n   */\n  setStatus(_status: Status): this {\n    return this;\n  }\n\n  /**\n   * Updates the name of the Span\n   * @param _name the new Span name\n   */\n  updateName(_name: string): this {\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecordingEvents(): boolean {\n    return false;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { BinaryFormat } from \"../../interfaces/BinaryFormat\";\nimport { SpanContext } from \"../../interfaces/span_context\";\n\n/**\n * A no-op implementation of BinaryFormat to be used when tracing is disabled.\n */\nexport class NoOpBinaryFormat implements BinaryFormat {\n  /** Serialize the given SpanContext to a buffer */\n  toBytes(_spanContext: SpanContext): ArrayBuffer {\n    return new ArrayBuffer(0);\n  }\n\n  /** \n   * Deserialize a SpanContext from binary encoding. \n   * Returns null if the buffer does not contain a valid SpanContext.\n   */\n  fromBytes(_buffer: ArrayBuffer): SpanContext | null {\n    return null;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { HttpTextFormat } from \"../../interfaces/HttpTextFormat\";\nimport { SpanContext } from \"../../interfaces/span_context\";\n\n/**\n * A no-op implementation of HttpTextFormat to be used when tracing is disabled.\n */\nexport class NoOpHttpTextFormat implements HttpTextFormat {\n  /**\n   * Injects the given SpanContext for transmitting to a remote server.\n   * @param _spanContext The SpanContext to transmit\n   * @param _format The format of the carrier\n   * @param _carrier The carrier to propagate through, e.g. an HTTP request\n   */\n  inject(_spanContext: SpanContext, _format: string, _carrier: unknown): void { }\n  /**\n   * Returns a SpanContext intance extracted from the carrier.\n   * @param _format the format of the carrier\n   * @param _carrier The carrier being used for propagation, e.g. an HTTP request\n   */\n  extract(_format: string, _carrier: unknown): SpanContext | null {\n    return null;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { Tracer } from \"../../interfaces/tracer\";\nimport { Span } from \"../../interfaces/span\";\nimport { SpanOptions } from \"../../interfaces/SpanOptions\";\nimport { NoOpSpan } from \"./noOpSpan\";\nimport { BinaryFormat } from \"../../interfaces/BinaryFormat\";\nimport { HttpTextFormat } from \"../../interfaces/HttpTextFormat\";\nimport { NoOpBinaryFormat } from \"./noOpBinaryFormat\";\nimport { NoOpHttpTextFormat } from \"./noOpHttpTextFormat\";\n\n/**\n * A no-op implementation of Tracer that can be used when tracing\n * is disabled.\n */\nexport class NoOpTracer implements Tracer {\n\n  /**\n   * Starts a new Span.\n   * @param _name The name of the span.\n   * @param _options The SpanOptions used during Span creation.\n   */\n  startSpan(_name: string, _options?: SpanOptions): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Returns the current Span from the current context, if available.\n   */\n  getCurrentSpan(): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Executes the given function within the context provided by a Span.\n   * @param _span The span that provides the context.\n   * @param fn The function to be executed.\n   */\n  withSpan<T extends (...args: unknown[]) => ReturnType<T>>(\n    _span: Span,\n    fn: T\n  ): ReturnType<T> {\n    return fn();\n  }\n\n  /**\n   * Bind a Span as the target's scope\n   * @param target An object to bind the scope.\n   * @param _span A specific Span to use. Otherwise, use the current one.\n   */\n  bind<T>(target: T, _span?: Span): T {\n    return target;\n  }\n\n  /**\n   * Send a pre-populated Span object to the exporter.\n   * @param _span The span to pass along.\n   */\n  recordSpanData(_span: Span): void {\n    /* NOOP */\n  }\n\n  /**\n   * Returns the BinaryFormat interface for serializing/deserializing Spans.\n   */\n  getBinaryFormat(): BinaryFormat {\n    return new NoOpBinaryFormat();\n  }\n\n  /**\n   * Returns the HttpTextFormat interface for injecting/extracting Spans.\n   */\n  getHttpTextFormat(): HttpTextFormat {\n    return new NoOpHttpTextFormat();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tracer } from \"../interfaces/tracer\";\nimport { getGlobalObject } from \"./global\";\n\nconst GLOBAL_TRACER_VERSION = 1;\nconst GLOBAL_TRACER_SYMBOL = Symbol.for(\"@azure/core-tracing.tracerCache\");\n\nexport interface TracerCache {\n  version: number;\n  tracer?: Tracer;\n}\n\nlet cache: TracerCache;\n\nfunction loadTracerCache(): void {\n  const globalObj = getGlobalObject();\n  const existingCache: TracerCache = globalObj[GLOBAL_TRACER_SYMBOL];\n  if (existingCache) {\n    if (existingCache.version !== GLOBAL_TRACER_VERSION) {\n      throw new Error(\n        `Two incompatible versions of @azure/core-tracing have been loaded.\n         This library is ${GLOBAL_TRACER_VERSION}, existing is ${existingCache.version}.`\n      );\n    }\n    cache = existingCache;\n  } else {\n    cache = {\n      tracer: undefined,\n      version: GLOBAL_TRACER_VERSION\n    };\n    globalObj[GLOBAL_TRACER_SYMBOL] = cache;\n  }\n}\n\nexport function getCache(): TracerCache {\n  if (!cache) {\n    loadTracerCache();\n  }\n  return cache;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nexport function getGlobalObject(): any {\n  return self;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { TraceState } from \"../../interfaces/trace_state\";\n\n/**\n * @ignore\n * @internal\n */\nexport class OpenCensusTraceStateWrapper implements TraceState {\n  private readonly _state?: string;\n\n  constructor(state?: string) {\n    this._state = state;\n  }\n\n  get(key: string): string | undefined {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  set(key: string, value: string): void {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  unset(key: string): void {\n    throw new Error(\"Method not implemented\");\n  }\n\n  serialize(): string {\n    return this._state || \"\";\n  }\n}\n","/*!\n * Copyright 2019, OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The status of a Span by providing a standard CanonicalCode in conjunction\n * with an optional descriptive message.\n */\nexport interface Status {\n  /** The canonical code of this message. */\n  code: CanonicalCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of canonical status codes.\n *\n * TODO (revision): https://github.com/open-telemetry/opentelemetry-specification/issues/59\n */\nexport enum CanonicalCode {\n  /**\n   * Not an error; returned on success\n   */\n  OK = 0,\n  /**\n   * The operation was cancelled (typically by the caller).\n   */\n  CANCELLED = 1,\n  /**\n   * Unknown error.  An example of where this error may be returned is\n   * if a status value received from another address space belongs to\n   * an error-space that is not known in this address space.  Also\n   * errors raised by APIs that do not return enough error information\n   * may be converted to this error.\n   */\n  UNKNOWN = 2,\n  /**\n   * Client specified an invalid argument.  Note that this differs\n   * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments\n   * that are problematic regardless of the state of the system\n   * (e.g., a malformed file name).\n   */\n  INVALID_ARGUMENT = 3,\n  /**\n   * Deadline expired before operation could complete.  For operations\n   * that change the state of the system, this error may be returned\n   * even if the operation has completed successfully.  For example, a\n   * successful response from a server could have been delayed long\n   * enough for the deadline to expire.\n   */\n  DEADLINE_EXCEEDED = 4,\n  /**\n   * Some requested entity (e.g., file or directory) was not found.\n   */\n  NOT_FOUND = 5,\n  /**\n   * Some entity that we attempted to create (e.g., file or directory)\n   * already exists.\n   */\n  ALREADY_EXISTS = 6,\n  /**\n   * The caller does not have permission to execute the specified\n   * operation.  PERMISSION_DENIED must not be used for rejections\n   * caused by exhausting some resource (use RESOURCE_EXHAUSTED\n   * instead for those errors).  PERMISSION_DENIED must not be\n   * used if the caller can not be identified (use UNAUTHENTICATED\n   * instead for those errors).\n   */\n  PERMISSION_DENIED = 7,\n  /**\n   * Some resource has been exhausted, perhaps a per-user quota, or\n   * perhaps the entire file system is out of space.\n   */\n  RESOURCE_EXHAUSTED = 8,\n  /**\n   * Operation was rejected because the system is not in a state\n   * required for the operation's execution.  For example, directory\n   * to be deleted may be non-empty, an rmdir operation is applied to\n   * a non-directory, etc.\n   *\n   * A litmus test that may help a service implementor in deciding\n   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n   *\n   *  - Use UNAVAILABLE if the client can retry just the failing call.\n   *  - Use ABORTED if the client should retry at a higher-level\n   *    (e.g., restarting a read-modify-write sequence).\n   *  - Use FAILED_PRECONDITION if the client should not retry until\n   *    the system state has been explicitly fixed.  E.g., if an \"rmdir\"\n   *    fails because the directory is non-empty, FAILED_PRECONDITION\n   *    should be returned since the client should not retry unless\n   *    they have first fixed up the directory by deleting files from it.\n   *  - Use FAILED_PRECONDITION if the client performs conditional\n   *    REST Get/Update/Delete on a resource and the resource on the\n   *    server does not match the condition. E.g., conflicting\n   *    read-modify-write on the same resource.\n   */\n  FAILED_PRECONDITION = 9,\n  /**\n   * The operation was aborted, typically due to a concurrency issue\n   * like sequencer check failures, transaction aborts, etc.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION,\n   * ABORTED, and UNAVAILABLE.\n   */\n  ABORTED = 10,\n  /**\n   * Operation was attempted past the valid range.  E.g., seeking or\n   * reading past end of file.\n   *\n   * Unlike INVALID_ARGUMENT, this error indicates a problem that may\n   * be fixed if the system state changes. For example, a 32-bit file\n   * system will generate INVALID_ARGUMENT if asked to read at an\n   * offset that is not in the range [0,2^32-1], but it will generate\n   * OUT_OF_RANGE if asked to read from an offset past the current\n   * file size.\n   *\n   * There is a fair bit of overlap between FAILED_PRECONDITION and\n   * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific\n   * error) when it applies so that callers who are iterating through\n   * a space can easily look for an OUT_OF_RANGE error to detect when\n   * they are done.\n   */\n  OUT_OF_RANGE = 11,\n  /**\n   * Operation is not implemented or not supported/enabled in this service.\n   */\n  UNIMPLEMENTED = 12,\n  /**\n   * Internal errors.  Means some invariants expected by underlying\n   * system has been broken.  If you see one of these errors,\n   * something is very broken.\n   */\n  INTERNAL = 13,\n  /**\n   * The service is currently unavailable.  This is a most likely a\n   * transient condition and may be corrected by retrying with\n   * a backoff.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION,\n   * ABORTED, and UNAVAILABLE.\n   */\n  UNAVAILABLE = 14,\n  /**\n   * Unrecoverable data loss or corruption.\n   */\n  DATA_LOSS = 15,\n  /**\n   * The request does not have valid authentication credentials for the\n   * operation.\n   */\n  UNAUTHENTICATED = 16,\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { Span } from \"../../interfaces/span\";\nimport { SpanContext } from \"../../interfaces/span_context\";\nimport { Attributes } from \"../../interfaces/attributes\";\nimport { Status } from \"../../interfaces/status\";\nimport { OpenCensusTraceStateWrapper } from \"./openCensusTraceStateWrapper\";\nimport { SpanOptions } from \"../../interfaces/SpanOptions\";\nimport { OpenCensusTracerWrapper } from \"./openCensusTracerWrapper\";\nimport { Attributes as OpenCensusAttributes, Span as OpenCensusSpan } from \"@opencensus/web-types\";\n\nfunction isWrappedSpan(span?: Span | SpanContext): span is OpenCensusSpanWrapper {\n  return !!span && (span as OpenCensusSpanWrapper).getWrappedSpan !== undefined;\n}\n\nfunction isTracer(\n  tracerOrSpan: OpenCensusTracerWrapper | OpenCensusSpan\n): tracerOrSpan is OpenCensusTracerWrapper {\n  return (tracerOrSpan as OpenCensusTracerWrapper).getWrappedTracer !== undefined;\n}\n\n/**\n * An implementation of OpenTelemetry Span that wraps an OpenCensus Span.\n */\nexport class OpenCensusSpanWrapper implements Span {\n  private _span: OpenCensusSpan;\n\n  /**\n   * The underlying OpenCensus Span\n   */\n  public getWrappedSpan() {\n    return this._span;\n  }\n\n  /**\n   * Wraps an existing OpenCensus Span\n   * @param span A Span or RootSpan from OpenCensus\n   */\n  constructor(span: OpenCensusSpan);\n  /**\n   * Create a new OpenCensus Span and wrap it.\n   * @param tracer The OpenCensus tracer that has been wrapped in OpenCensusTracerWrapper\n   * @param name The name of the Span\n   * @param options Options for the Span\n   */\n  constructor(tracer: OpenCensusTracerWrapper, name: string, options?: SpanOptions);\n  constructor(\n    tracerOrSpan: OpenCensusTracerWrapper | OpenCensusSpan,\n    name: string = \"\",\n    options: SpanOptions = {}\n  ) {\n    if (isTracer(tracerOrSpan)) {\n      const parent = isWrappedSpan(options.parent) ? options.parent.getWrappedSpan() : undefined;\n      this._span = tracerOrSpan.getWrappedTracer().startChildSpan({\n        name,\n        childOf: parent\n      });\n      this._span.start();\n    } else {\n      this._span = tracerOrSpan;\n    }\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param endTime The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    this._span.end();\n  }\n\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  context(): SpanContext {\n    const openCensusSpanContext = this._span.spanContext;\n\n    return {\n      spanId: openCensusSpanContext.spanId,\n      traceId: openCensusSpanContext.traceId,\n      traceFlags: openCensusSpanContext.options,\n      traceState: new OpenCensusTraceStateWrapper(openCensusSpanContext.traceState)\n    };\n  }\n\n  /**\n   * Sets an attribute on the Span\n   * @param key the attribute key\n   * @param value the attribute value\n   */\n  setAttribute(key: string, value: unknown): this {\n    this._span.addAttribute(key, value as any);\n    return this;\n  }\n\n  /**\n   * Sets attributes on the Span\n   * @param attributes the attributes to add\n   */\n  setAttributes(attributes: Attributes): this {\n    this._span.attributes = attributes as OpenCensusAttributes;\n    return this;\n  }\n\n  /**\n   * Adds an event to the Span\n   * @param name The name of the event\n   * @param attributes The associated attributes to add for this event\n   */\n  addEvent(name: string, attributes?: Attributes): this {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Adds a link to the Span.\n   * @param spanContext the context of the linked span\n   * @param attributes attributes to be added that are associated with the link\n   */\n  addLink(spanContext: SpanContext, attributes?: Attributes): this {\n    // Since there is no way to specify the link relationship,\n    // it is set as Unspecified.\n    this._span.addLink(\n      spanContext.traceId,\n      spanContext.spanId,\n      0 /* LinkType.UNSPECIFIED */,\n      attributes as OpenCensusAttributes\n    );\n    return this;\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of CanonicalCode.OK.\n   * @param status The status to set.\n   */\n  setStatus(status: Status): this {\n    this._span.setStatus(status.code, status.message);\n    return this;\n  }\n\n  /**\n   * Updates the name of the Span\n   * @param name the new Span name\n   */\n  updateName(name: string): this {\n    this._span.name = name;\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecordingEvents(): boolean {\n    // NoRecordSpans have an empty traceId\n    return !!this._span.traceId;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { Tracer } from \"../../interfaces/tracer\";\nimport { SpanOptions } from \"../../interfaces/SpanOptions\";\nimport { Span } from \"../../interfaces/span\";\nimport { OpenCensusSpanWrapper } from \"./openCensusSpanWrapper\";\nimport { BinaryFormat } from \"../../interfaces/BinaryFormat\";\nimport { HttpTextFormat } from \"../../interfaces/HttpTextFormat\";\nimport { TracerBase as OpenCensusTracer } from \"@opencensus/web-types\";\n\n/**\n * An implementation of OpenTelemetry Tracer that wraps an OpenCensus Tracer.\n */\nexport class OpenCensusTracerWrapper implements Tracer {\n  private _tracer: OpenCensusTracer;\n\n  /**\n   * The wrapped OpenCensus Tracer\n   */\n  public getWrappedTracer() {\n    return this._tracer;\n  }\n\n  /**\n   * Create a new wrapper around a given OpenCensus Tracer.\n   * @param tracer The OpenCensus Tracer to wrap.\n   */\n  public constructor(tracer: OpenCensusTracer) {\n    this._tracer = tracer;\n  }\n\n  /**\n   * Starts a new Span.\n   * @param name The name of the span.\n   * @param options The SpanOptions used during Span creation.\n   */\n  startSpan(name: string, options?: SpanOptions): Span {\n    return new OpenCensusSpanWrapper(this, name, options);\n  }\n\n  /**\n   * Returns the current Span from the current context, if available.\n   */\n  getCurrentSpan(): Span | null {\n    return null;\n  }\n\n  /**\n   * Executes the given function within the context provided by a Span.\n   * @param span The span that provides the context.\n   * @param fn The function to be executed.\n   */\n  withSpan<T extends (...args: unknown[]) => unknown>(span: Span, fn: T): ReturnType<T> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Bind a Span as the target's scope\n   * @param target An object to bind the scope.\n   * @param span A specific Span to use. Otherwise, use the current one.\n   */\n  bind<T>(target: T, span?: Span): T {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Send a pre-populated Span object to the exporter.\n   * @param span The span to pass along.\n   */\n  recordSpanData(span: Span): void {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Returns the BinaryFormat interface for serializing/deserializing Spans.\n   */\n  getBinaryFormat(): BinaryFormat {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Returns the HttpTextFormat interface for injecting/extracting Spans.\n   */\n  getHttpTextFormat(): HttpTextFormat {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/*!\n * Copyright 2019, OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Type of span. Can be used to specify additional relationships between spans\n * in addition to a parent/child relationship.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { NoOpSpan } from \"../noop/noOpSpan\";\nimport { SpanOptions } from \"../../interfaces/SpanOptions\";\nimport { Status, CanonicalCode } from \"../../interfaces/status\";\nimport { SpanContext } from \"../../interfaces/span_context\";\nimport { TestTracer } from \"./testTracer\";\nimport { SpanKind } from \"../../interfaces/span_kind\";\nimport { TimeInput } from \"../../interfaces/Time\";\nimport { Tracer } from \"../../interfaces/tracer\";\n\n/**\n * A mock span useful for testing.\n */\nexport class TestSpan extends NoOpSpan {\n\n  /**\n   * The Span's current name\n   */\n  name: string;\n\n  /**\n   * The Span's current status\n   */\n  status: Status;\n\n  /**\n   * The Span's kind\n   */\n  kind: SpanKind;\n\n  /**\n   * True if end() has been called on the Span\n   */\n  endCalled: boolean;\n\n  /**\n   * The start time of the Span\n   */\n  readonly startTime: TimeInput;\n\n  /**\n   * The id of the parent Span, if any.\n   */\n  readonly parentSpanId?: string;\n\n  private _context: SpanContext;\n  private readonly _tracer: Tracer;\n\n  /**\n   * Starts a new Span.\n   * @param parentTracer The tracer that created this Span\n   * @param name The name of the span.\n   * @param context The SpanContext this span belongs to\n   * @param kind The SpanKind of this Span\n   * @param parentSpanId The identifier of the parent Span\n   * @param startTime The startTime of the event (defaults to now)\n   */\n  constructor(\n    parentTracer: TestTracer,\n    name: string,\n    context: SpanContext,\n    kind: SpanKind,\n    parentSpanId?: string,\n    startTime: TimeInput = Date.now()) {\n    super();\n    this._tracer = parentTracer;\n    this.name = name;\n    this.kind = kind;\n    this.startTime = startTime;\n    this.parentSpanId = parentSpanId;\n    this.status = {\n      code: CanonicalCode.OK\n    };\n    this.endCalled = false;\n    this._context = context;\n  }\n\n  /**\n   * Returns the Tracer that created this Span\n   */\n  tracer(): Tracer {\n    return this._tracer;\n  }\n\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  context(): SpanContext {\n    return this._context;\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param _endTime The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    this.endCalled = true;\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of CanonicalCode.OK.\n   * @param status The status to set.\n   */\n  setStatus(status: Status): this {\n    this.status = status;\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecordingEvents(): boolean {\n    return true;\n  }\n}\n","/*!\n * Copyright 2019, OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * An enumeration that represents global trace flags. These flags are\n * propagated to all child {@link Span}. These determine features such as\n * whether a Span should be traced. It is implemented as a bitmask.\n */\nexport enum TraceFlags {\n  /** Bit to represent whether trace is unsampled in trace flags. */\n  UNSAMPLED = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1,\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { NoOpTracer } from \"../noop/noOpTracer\";\nimport { SpanOptions } from \"../../interfaces/SpanOptions\";\nimport { TestSpan } from \"./testSpan\";\nimport { SpanContext } from \"../../interfaces/span_context\";\nimport { SpanKind } from \"../../interfaces/span_kind\";\n\n/**\n * Simple representation of a Span that only has name and child relationships.\n * Children should be arranged in the order they were created.\n */\nexport interface SpanGraphNode {\n  /**\n   * The Span name\n   */\n  name: string;\n  /**\n   * All child Spans of this Span\n   */\n  children: SpanGraphNode[];\n}\n\n/**\n * Contains all the spans for a particular TraceID\n * starting at unparented roots\n */\nexport interface SpanGraph {\n  /**\n   * All Spans without a parentSpanId\n   */\n  roots: SpanGraphNode[];\n}\n\n/**\n * A mock tracer useful for testing\n */\nexport class TestTracer extends NoOpTracer {\n\n  private traceIdCounter = 0;\n  private getNextTraceId(): string {\n    this.traceIdCounter++;\n    return String(this.traceIdCounter);\n  }\n\n  private spanIdCounter = 0;\n  private getNextSpanId(): string {\n    this.spanIdCounter++;\n    return String(this.spanIdCounter);\n  }\n\n  private rootSpans: TestSpan[] = [];\n  private knownSpans: TestSpan[] = [];\n\n  /**\n   * Returns all Spans that were created without a parent\n   */\n  getRootSpans(): TestSpan[] {\n    return this.rootSpans;\n  }\n\n  /**\n   * Returns all Spans this Tracer knows about\n   */\n  getKnownSpans(): TestSpan[] {\n    return this.knownSpans;\n  }\n\n  /**\n   * Returns all Spans where end() has not been called\n   */\n  getActiveSpans(): TestSpan[] {\n    return this.knownSpans.filter(span => {\n      return !span.endCalled;\n    });\n  }\n\n  /**\n   * Return all Spans for a particular trace, grouped by their\n   * parent Span in a tree-like structure\n   * @param traceId The traceId to return the graph for\n   */\n  getSpanGraph(traceId: string): SpanGraph {\n    const traceSpans = this.knownSpans.filter(span => {\n      return span.context().traceId === traceId;\n    });\n\n    const roots: SpanGraphNode[] = [];\n    const nodeMap: Map<string, SpanGraphNode> = new Map<string, SpanGraphNode>();\n\n    for (const span of traceSpans) {\n      const spanId = span.context().spanId;\n      const node: SpanGraphNode = {\n        name: span.name,\n        children: []\n      };\n      nodeMap.set(spanId, node);\n      if (span.parentSpanId) {\n        const parent = nodeMap.get(span.parentSpanId);\n        if (!parent) {\n          throw new Error(`Span with name ${node.name} has an unknown parentSpan with id ${span.parentSpanId}`);\n        }\n        parent.children.push(node);\n      } else {\n        roots.push(node);\n      }\n    }\n\n    return {\n      roots\n    };\n\n  }\n\n  /**\n   * Starts a new Span.\n   * @param name The name of the span.\n   * @param options The SpanOptions used during Span creation.\n   */\n  startSpan(name: string, options: SpanOptions = {}): TestSpan {\n\n    const parentContext = this._getParentContext(options);\n\n    let traceId: string;\n    let isRootSpan = false;\n\n    if (parentContext && parentContext.traceId) {\n      traceId = parentContext.traceId;\n    } else {\n      traceId = this.getNextTraceId();\n      isRootSpan = true;\n    }\n\n    const context: SpanContext = {\n      traceId,\n      spanId: this.getNextSpanId()\n    }\n    const span = new TestSpan(\n      this,\n      name,\n      context,\n      options.kind || SpanKind.INTERNAL,\n      parentContext ? parentContext.spanId : undefined,\n      options.startTime);\n    this.knownSpans.push(span);\n    if (isRootSpan) {\n      this.rootSpans.push(span);\n    }\n    return span;\n  }\n\n  private _getParentContext(options: SpanOptions): SpanContext | undefined {\n    const parent = options.parent;\n    if (parent) {\n      if ('traceId' in parent) {\n        return parent;\n      } else {\n        return parent.context();\n      }\n    }\n\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SpanContext } from \"../interfaces/span_context\";\nimport { TraceFlags } from \"../interfaces/trace_flags\";\n\nconst VERSION = \"00\";\n\n/**\n * Generates a `SpanContext` given a `traceparent` header value.\n * @param traceParent Serialized span context data as a `traceparent` header value.\n * @returns The `SpanContext` generated from the `traceparent` value.\n */\nexport function extractSpanContextFromTraceParentHeader(\n  traceParentHeader: string\n): SpanContext | undefined {\n  const parts = traceParentHeader.split(\"-\");\n\n  if (parts.length !== 4) {\n    return;\n  }\n\n  const [version, traceId, spanId, traceOptions] = parts;\n\n  if (version !== VERSION) {\n    return;\n  }\n\n  const traceFlags = parseInt(traceOptions, 16);\n\n  const spanContext: SpanContext = {\n    spanId,\n    traceId,\n    traceFlags\n  };\n\n  return spanContext;\n}\n\n/**\n * Generates a `traceparent` value given a span context.\n * @param spanContext Contains context for a specific span.\n * @returns The `spanContext` represented as a `traceparent` value.\n */\nexport function getTraceParentHeader(spanContext: SpanContext): string | undefined {\n  const missingFields: string[] = [];\n  if (!spanContext.traceId) {\n    missingFields.push(\"traceId\");\n  }\n  if (!spanContext.spanId) {\n    missingFields.push(\"spanId\");\n  }\n\n  if (missingFields.length) {\n    return;\n  }\n\n  const flags = spanContext.traceFlags || TraceFlags.UNSAMPLED;\n  const hexFlags = flags.toString(16);\n  const traceFlags = hexFlags.length === 1 ? `0${hexFlags}` : hexFlags;\n\n  // https://www.w3.org/TR/trace-context/#traceparent-header-field-values\n  return `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-${traceFlags}`;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { NoOpTracer } from \"./tracers/noop/noOpTracer\";\nimport { Tracer } from \"./interfaces/tracer\";\nimport { getCache } from \"./utils/cache\";\n\n/**\n * Sets the global tracer, enabling tracing for the Azure SDK.\n * @param tracer An OpenTelemetry Tracer instance.\n */\nexport function setTracer(tracer: Tracer) {\n  const cache = getCache();\n  cache.tracer = tracer;\n}\n\n/**\n * Retrieves the active tracer, or returns a\n * no-op implementation if one is not set.\n */\nexport function getTracer() {\n  const cache = getCache();\n  if (!cache.tracer) {\n    cache.tracer = new NoOpTracer();\n  }\n  return cache.tracer;\n}\n"],"names":["NoOpSpan","spanId","traceId","_endTime","_key","_value","this","_attributes","_name","_spanContext","_status","NoOpBinaryFormat","ArrayBuffer","_buffer","NoOpHttpTextFormat","_format","_carrier","NoOpTracer","_options","_span","fn","target","cache","GLOBAL_TRACER_VERSION","GLOBAL_TRACER_SYMBOL","Symbol","for","loadTracerCache","globalObj","self","existingCache","version","Error","tracer","undefined","getCache","state","_state","OpenCensusTraceStateWrapper","key","value","CanonicalCode","tracerOrSpan","name","options","getWrappedTracer","isTracer","parent_1","span","parent","getWrappedSpan","startChildSpan","childOf","start","OpenCensusSpanWrapper","end","openCensusSpanContext","spanContext","traceFlags","traceState","addAttribute","attributes","addLink","status","setStatus","code","message","_tracer","OpenCensusTracerWrapper","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","SpanKind","parentTracer","context","kind","parentSpanId","startTime","Date","now","_super","_this","OK","endCalled","_context","tslib_1.__extends","TestSpan","TraceFlags","TestTracer","traceIdCounter","String","spanIdCounter","rootSpans","knownSpans","filter","traceSpans","roots","nodeMap","Map","traceSpans_1","_i","node","children","set","get","push","parentContext","_getParentContext","isRootSpan","getNextTraceId","getNextSpanId","INTERNAL","VERSION","traceParentHeader","parts","split","length","traceOptions","parseInt","missingFields","hexFlags","UNSAMPLED","toString"],"mappings":"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"}