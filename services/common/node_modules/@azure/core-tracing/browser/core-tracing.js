(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory((global.Azure = global.Azure || {}, global.Azure.Core = global.Azure.Core || {}, global.Azure.Core.Tracing = {})));
}(this, function (exports) { 'use strict';

    /**
     * A no-op implementation of Span that can safely be used without side-effects.
     */
    var NoOpSpan = /** @class */ (function () {
        function NoOpSpan() {
        }
        /**
         * Returns the SpanContext associated with this Span.
         */
        NoOpSpan.prototype.context = function () {
            return {
                spanId: "",
                traceId: ""
            };
        };
        /**
         * Marks the end of Span execution.
         * @param _endTime The time to use as the Span's end time. Defaults to
         * the current time.
         */
        NoOpSpan.prototype.end = function (_endTime) {
            /* Noop */
        };
        /**
         * Sets an attribute on the Span
         * @param _key the attribute key
         * @param _value the attribute value
         */
        NoOpSpan.prototype.setAttribute = function (_key, _value) {
            return this;
        };
        /**
         * Sets attributes on the Span
         * @param _attributes the attributes to add
         */
        NoOpSpan.prototype.setAttributes = function (_attributes) {
            return this;
        };
        /**
         * Adds an event to the Span
         * @param _name The name of the event
         * @param _attributes The associated attributes to add for this event
         */
        NoOpSpan.prototype.addEvent = function (_name, _attributes) {
            return this;
        };
        /**
         * Adds a link to the Span.
         * @param _spanContext the context of the linked span
         * @param _attributes attributes to be added that are associated with the link
         */
        NoOpSpan.prototype.addLink = function (_spanContext, _attributes) {
            return this;
        };
        /**
         * Sets a status on the span. Overrides the default of CanonicalCode.OK.
         * @param _status The status to set.
         */
        NoOpSpan.prototype.setStatus = function (_status) {
            return this;
        };
        /**
         * Updates the name of the Span
         * @param _name the new Span name
         */
        NoOpSpan.prototype.updateName = function (_name) {
            return this;
        };
        /**
         * Returns whether this span will be recorded
         */
        NoOpSpan.prototype.isRecordingEvents = function () {
            return false;
        };
        return NoOpSpan;
    }());

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    /**
     * A no-op implementation of BinaryFormat to be used when tracing is disabled.
     */
    var NoOpBinaryFormat = /** @class */ (function () {
        function NoOpBinaryFormat() {
        }
        /** Serialize the given SpanContext to a buffer */
        NoOpBinaryFormat.prototype.toBytes = function (_spanContext) {
            return new ArrayBuffer(0);
        };
        /**
         * Deserialize a SpanContext from binary encoding.
         * Returns null if the buffer does not contain a valid SpanContext.
         */
        NoOpBinaryFormat.prototype.fromBytes = function (_buffer) {
            return null;
        };
        return NoOpBinaryFormat;
    }());

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    /**
     * A no-op implementation of HttpTextFormat to be used when tracing is disabled.
     */
    var NoOpHttpTextFormat = /** @class */ (function () {
        function NoOpHttpTextFormat() {
        }
        /**
         * Injects the given SpanContext for transmitting to a remote server.
         * @param _spanContext The SpanContext to transmit
         * @param _format The format of the carrier
         * @param _carrier The carrier to propagate through, e.g. an HTTP request
         */
        NoOpHttpTextFormat.prototype.inject = function (_spanContext, _format, _carrier) { };
        /**
         * Returns a SpanContext intance extracted from the carrier.
         * @param _format the format of the carrier
         * @param _carrier The carrier being used for propagation, e.g. an HTTP request
         */
        NoOpHttpTextFormat.prototype.extract = function (_format, _carrier) {
            return null;
        };
        return NoOpHttpTextFormat;
    }());

    /**
     * A no-op implementation of Tracer that can be used when tracing
     * is disabled.
     */
    var NoOpTracer = /** @class */ (function () {
        function NoOpTracer() {
        }
        /**
         * Starts a new Span.
         * @param _name The name of the span.
         * @param _options The SpanOptions used during Span creation.
         */
        NoOpTracer.prototype.startSpan = function (_name, _options) {
            return new NoOpSpan();
        };
        /**
         * Returns the current Span from the current context, if available.
         */
        NoOpTracer.prototype.getCurrentSpan = function () {
            return new NoOpSpan();
        };
        /**
         * Executes the given function within the context provided by a Span.
         * @param _span The span that provides the context.
         * @param fn The function to be executed.
         */
        NoOpTracer.prototype.withSpan = function (_span, fn) {
            return fn();
        };
        /**
         * Bind a Span as the target's scope
         * @param target An object to bind the scope.
         * @param _span A specific Span to use. Otherwise, use the current one.
         */
        NoOpTracer.prototype.bind = function (target, _span) {
            return target;
        };
        /**
         * Send a pre-populated Span object to the exporter.
         * @param _span The span to pass along.
         */
        NoOpTracer.prototype.recordSpanData = function (_span) {
            /* NOOP */
        };
        /**
         * Returns the BinaryFormat interface for serializing/deserializing Spans.
         */
        NoOpTracer.prototype.getBinaryFormat = function () {
            return new NoOpBinaryFormat();
        };
        /**
         * Returns the HttpTextFormat interface for injecting/extracting Spans.
         */
        NoOpTracer.prototype.getHttpTextFormat = function () {
            return new NoOpHttpTextFormat();
        };
        return NoOpTracer;
    }());

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    function getGlobalObject() {
        return self;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var GLOBAL_TRACER_VERSION = 1;
    var GLOBAL_TRACER_SYMBOL = Symbol.for("@azure/core-tracing.tracerCache");
    var cache;
    function loadTracerCache() {
        var globalObj = getGlobalObject();
        var existingCache = globalObj[GLOBAL_TRACER_SYMBOL];
        if (existingCache) {
            if (existingCache.version !== GLOBAL_TRACER_VERSION) {
                throw new Error("Two incompatible versions of @azure/core-tracing have been loaded.\n         This library is " + GLOBAL_TRACER_VERSION + ", existing is " + existingCache.version + ".");
            }
            cache = existingCache;
        }
        else {
            cache = {
                tracer: undefined,
                version: GLOBAL_TRACER_VERSION
            };
            globalObj[GLOBAL_TRACER_SYMBOL] = cache;
        }
    }
    function getCache() {
        if (!cache) {
            loadTracerCache();
        }
        return cache;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Sets the global tracer, enabling tracing for the Azure SDK.
     * @param tracer An OpenTelemetry Tracer instance.
     */
    function setTracer(tracer) {
        var cache = getCache();
        cache.tracer = tracer;
    }
    /**
     * Retrieves the active tracer, or returns a
     * no-op implementation if one is not set.
     */
    function getTracer() {
        var cache = getCache();
        if (!cache.tracer) {
            cache.tracer = new NoOpTracer();
        }
        return cache.tracer;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    /**
     * @ignore
     * @internal
     */
    var OpenCensusTraceStateWrapper = /** @class */ (function () {
        function OpenCensusTraceStateWrapper(state) {
            this._state = state;
        }
        OpenCensusTraceStateWrapper.prototype.get = function (key) {
            throw new Error("Method not implemented.");
        };
        OpenCensusTraceStateWrapper.prototype.set = function (key, value) {
            throw new Error("Method not implemented.");
        };
        OpenCensusTraceStateWrapper.prototype.unset = function (key) {
            throw new Error("Method not implemented");
        };
        OpenCensusTraceStateWrapper.prototype.serialize = function () {
            return this._state || "";
        };
        return OpenCensusTraceStateWrapper;
    }());

    function isWrappedSpan(span) {
        return !!span && span.getWrappedSpan !== undefined;
    }
    function isTracer(tracerOrSpan) {
        return tracerOrSpan.getWrappedTracer !== undefined;
    }
    /**
     * An implementation of OpenTelemetry Span that wraps an OpenCensus Span.
     */
    var OpenCensusSpanWrapper = /** @class */ (function () {
        function OpenCensusSpanWrapper(tracerOrSpan, name, options) {
            if (name === void 0) { name = ""; }
            if (options === void 0) { options = {}; }
            if (isTracer(tracerOrSpan)) {
                var parent_1 = isWrappedSpan(options.parent) ? options.parent.getWrappedSpan() : undefined;
                this._span = tracerOrSpan.getWrappedTracer().startChildSpan({
                    name: name,
                    childOf: parent_1
                });
                this._span.start();
            }
            else {
                this._span = tracerOrSpan;
            }
        }
        /**
         * The underlying OpenCensus Span
         */
        OpenCensusSpanWrapper.prototype.getWrappedSpan = function () {
            return this._span;
        };
        /**
         * Marks the end of Span execution.
         * @param endTime The time to use as the Span's end time. Defaults to
         * the current time.
         */
        OpenCensusSpanWrapper.prototype.end = function (_endTime) {
            this._span.end();
        };
        /**
         * Returns the SpanContext associated with this Span.
         */
        OpenCensusSpanWrapper.prototype.context = function () {
            var openCensusSpanContext = this._span.spanContext;
            return {
                spanId: openCensusSpanContext.spanId,
                traceId: openCensusSpanContext.traceId,
                traceFlags: openCensusSpanContext.options,
                traceState: new OpenCensusTraceStateWrapper(openCensusSpanContext.traceState)
            };
        };
        /**
         * Sets an attribute on the Span
         * @param key the attribute key
         * @param value the attribute value
         */
        OpenCensusSpanWrapper.prototype.setAttribute = function (key, value) {
            this._span.addAttribute(key, value);
            return this;
        };
        /**
         * Sets attributes on the Span
         * @param attributes the attributes to add
         */
        OpenCensusSpanWrapper.prototype.setAttributes = function (attributes) {
            this._span.attributes = attributes;
            return this;
        };
        /**
         * Adds an event to the Span
         * @param name The name of the event
         * @param attributes The associated attributes to add for this event
         */
        OpenCensusSpanWrapper.prototype.addEvent = function (name, attributes) {
            throw new Error("Method not implemented.");
        };
        /**
         * Adds a link to the Span.
         * @param spanContext the context of the linked span
         * @param attributes attributes to be added that are associated with the link
         */
        OpenCensusSpanWrapper.prototype.addLink = function (spanContext, attributes) {
            // Since there is no way to specify the link relationship,
            // it is set as Unspecified.
            this._span.addLink(spanContext.traceId, spanContext.spanId, 0 /* LinkType.UNSPECIFIED */, attributes);
            return this;
        };
        /**
         * Sets a status on the span. Overrides the default of CanonicalCode.OK.
         * @param status The status to set.
         */
        OpenCensusSpanWrapper.prototype.setStatus = function (status) {
            this._span.setStatus(status.code, status.message);
            return this;
        };
        /**
         * Updates the name of the Span
         * @param name the new Span name
         */
        OpenCensusSpanWrapper.prototype.updateName = function (name) {
            this._span.name = name;
            return this;
        };
        /**
         * Returns whether this span will be recorded
         */
        OpenCensusSpanWrapper.prototype.isRecordingEvents = function () {
            // NoRecordSpans have an empty traceId
            return !!this._span.traceId;
        };
        return OpenCensusSpanWrapper;
    }());

    /**
     * An implementation of OpenTelemetry Tracer that wraps an OpenCensus Tracer.
     */
    var OpenCensusTracerWrapper = /** @class */ (function () {
        /**
         * Create a new wrapper around a given OpenCensus Tracer.
         * @param tracer The OpenCensus Tracer to wrap.
         */
        function OpenCensusTracerWrapper(tracer) {
            this._tracer = tracer;
        }
        /**
         * The wrapped OpenCensus Tracer
         */
        OpenCensusTracerWrapper.prototype.getWrappedTracer = function () {
            return this._tracer;
        };
        /**
         * Starts a new Span.
         * @param name The name of the span.
         * @param options The SpanOptions used during Span creation.
         */
        OpenCensusTracerWrapper.prototype.startSpan = function (name, options) {
            return new OpenCensusSpanWrapper(this, name, options);
        };
        /**
         * Returns the current Span from the current context, if available.
         */
        OpenCensusTracerWrapper.prototype.getCurrentSpan = function () {
            return null;
        };
        /**
         * Executes the given function within the context provided by a Span.
         * @param span The span that provides the context.
         * @param fn The function to be executed.
         */
        OpenCensusTracerWrapper.prototype.withSpan = function (span, fn) {
            throw new Error("Method not implemented.");
        };
        /**
         * Bind a Span as the target's scope
         * @param target An object to bind the scope.
         * @param span A specific Span to use. Otherwise, use the current one.
         */
        OpenCensusTracerWrapper.prototype.bind = function (target, span) {
            throw new Error("Method not implemented.");
        };
        /**
         * Send a pre-populated Span object to the exporter.
         * @param span The span to pass along.
         */
        OpenCensusTracerWrapper.prototype.recordSpanData = function (span) {
            throw new Error("Method not implemented.");
        };
        /**
         * Returns the BinaryFormat interface for serializing/deserializing Spans.
         */
        OpenCensusTracerWrapper.prototype.getBinaryFormat = function () {
            throw new Error("Method not implemented.");
        };
        /**
         * Returns the HttpTextFormat interface for injecting/extracting Spans.
         */
        OpenCensusTracerWrapper.prototype.getHttpTextFormat = function () {
            throw new Error("Method not implemented.");
        };
        return OpenCensusTracerWrapper;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /*!
     * Copyright 2019, OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (function (CanonicalCode) {
        /**
         * Not an error; returned on success
         */
        CanonicalCode[CanonicalCode["OK"] = 0] = "OK";
        /**
         * The operation was cancelled (typically by the caller).
         */
        CanonicalCode[CanonicalCode["CANCELLED"] = 1] = "CANCELLED";
        /**
         * Unknown error.  An example of where this error may be returned is
         * if a status value received from another address space belongs to
         * an error-space that is not known in this address space.  Also
         * errors raised by APIs that do not return enough error information
         * may be converted to this error.
         */
        CanonicalCode[CanonicalCode["UNKNOWN"] = 2] = "UNKNOWN";
        /**
         * Client specified an invalid argument.  Note that this differs
         * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
         * that are problematic regardless of the state of the system
         * (e.g., a malformed file name).
         */
        CanonicalCode[CanonicalCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
        /**
         * Deadline expired before operation could complete.  For operations
         * that change the state of the system, this error may be returned
         * even if the operation has completed successfully.  For example, a
         * successful response from a server could have been delayed long
         * enough for the deadline to expire.
         */
        CanonicalCode[CanonicalCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
        /**
         * Some requested entity (e.g., file or directory) was not found.
         */
        CanonicalCode[CanonicalCode["NOT_FOUND"] = 5] = "NOT_FOUND";
        /**
         * Some entity that we attempted to create (e.g., file or directory)
         * already exists.
         */
        CanonicalCode[CanonicalCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
        /**
         * The caller does not have permission to execute the specified
         * operation.  PERMISSION_DENIED must not be used for rejections
         * caused by exhausting some resource (use RESOURCE_EXHAUSTED
         * instead for those errors).  PERMISSION_DENIED must not be
         * used if the caller can not be identified (use UNAUTHENTICATED
         * instead for those errors).
         */
        CanonicalCode[CanonicalCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
        /**
         * Some resource has been exhausted, perhaps a per-user quota, or
         * perhaps the entire file system is out of space.
         */
        CanonicalCode[CanonicalCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
        /**
         * Operation was rejected because the system is not in a state
         * required for the operation's execution.  For example, directory
         * to be deleted may be non-empty, an rmdir operation is applied to
         * a non-directory, etc.
         *
         * A litmus test that may help a service implementor in deciding
         * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
         *
         *  - Use UNAVAILABLE if the client can retry just the failing call.
         *  - Use ABORTED if the client should retry at a higher-level
         *    (e.g., restarting a read-modify-write sequence).
         *  - Use FAILED_PRECONDITION if the client should not retry until
         *    the system state has been explicitly fixed.  E.g., if an "rmdir"
         *    fails because the directory is non-empty, FAILED_PRECONDITION
         *    should be returned since the client should not retry unless
         *    they have first fixed up the directory by deleting files from it.
         *  - Use FAILED_PRECONDITION if the client performs conditional
         *    REST Get/Update/Delete on a resource and the resource on the
         *    server does not match the condition. E.g., conflicting
         *    read-modify-write on the same resource.
         */
        CanonicalCode[CanonicalCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
        /**
         * The operation was aborted, typically due to a concurrency issue
         * like sequencer check failures, transaction aborts, etc.
         *
         * See litmus test above for deciding between FAILED_PRECONDITION,
         * ABORTED, and UNAVAILABLE.
         */
        CanonicalCode[CanonicalCode["ABORTED"] = 10] = "ABORTED";
        /**
         * Operation was attempted past the valid range.  E.g., seeking or
         * reading past end of file.
         *
         * Unlike INVALID_ARGUMENT, this error indicates a problem that may
         * be fixed if the system state changes. For example, a 32-bit file
         * system will generate INVALID_ARGUMENT if asked to read at an
         * offset that is not in the range [0,2^32-1], but it will generate
         * OUT_OF_RANGE if asked to read from an offset past the current
         * file size.
         *
         * There is a fair bit of overlap between FAILED_PRECONDITION and
         * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
         * error) when it applies so that callers who are iterating through
         * a space can easily look for an OUT_OF_RANGE error to detect when
         * they are done.
         */
        CanonicalCode[CanonicalCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
        /**
         * Operation is not implemented or not supported/enabled in this service.
         */
        CanonicalCode[CanonicalCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
        /**
         * Internal errors.  Means some invariants expected by underlying
         * system has been broken.  If you see one of these errors,
         * something is very broken.
         */
        CanonicalCode[CanonicalCode["INTERNAL"] = 13] = "INTERNAL";
        /**
         * The service is currently unavailable.  This is a most likely a
         * transient condition and may be corrected by retrying with
         * a backoff.
         *
         * See litmus test above for deciding between FAILED_PRECONDITION,
         * ABORTED, and UNAVAILABLE.
         */
        CanonicalCode[CanonicalCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
        /**
         * Unrecoverable data loss or corruption.
         */
        CanonicalCode[CanonicalCode["DATA_LOSS"] = 15] = "DATA_LOSS";
        /**
         * The request does not have valid authentication credentials for the
         * operation.
         */
        CanonicalCode[CanonicalCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    })(exports.CanonicalCode || (exports.CanonicalCode = {}));

    /**
     * A mock span useful for testing.
     */
    var TestSpan = /** @class */ (function (_super) {
        __extends(TestSpan, _super);
        /**
         * Starts a new Span.
         * @param parentTracer The tracer that created this Span
         * @param name The name of the span.
         * @param context The SpanContext this span belongs to
         * @param kind The SpanKind of this Span
         * @param parentSpanId The identifier of the parent Span
         * @param startTime The startTime of the event (defaults to now)
         */
        function TestSpan(parentTracer, name, context, kind, parentSpanId, startTime) {
            if (startTime === void 0) { startTime = Date.now(); }
            var _this = _super.call(this) || this;
            _this._tracer = parentTracer;
            _this.name = name;
            _this.kind = kind;
            _this.startTime = startTime;
            _this.parentSpanId = parentSpanId;
            _this.status = {
                code: exports.CanonicalCode.OK
            };
            _this.endCalled = false;
            _this._context = context;
            return _this;
        }
        /**
         * Returns the Tracer that created this Span
         */
        TestSpan.prototype.tracer = function () {
            return this._tracer;
        };
        /**
         * Returns the SpanContext associated with this Span.
         */
        TestSpan.prototype.context = function () {
            return this._context;
        };
        /**
         * Marks the end of Span execution.
         * @param _endTime The time to use as the Span's end time. Defaults to
         * the current time.
         */
        TestSpan.prototype.end = function (_endTime) {
            this.endCalled = true;
        };
        /**
         * Sets a status on the span. Overrides the default of CanonicalCode.OK.
         * @param status The status to set.
         */
        TestSpan.prototype.setStatus = function (status) {
            this.status = status;
            return this;
        };
        /**
         * Returns whether this span will be recorded
         */
        TestSpan.prototype.isRecordingEvents = function () {
            return true;
        };
        return TestSpan;
    }(NoOpSpan));

    /*!
     * Copyright 2019, OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (function (SpanKind) {
        /** Default value. Indicates that the span is used internally. */
        SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
        /**
         * Indicates that the span covers server-side handling of an RPC or other
         * remote request.
         */
        SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
        /**
         * Indicates that the span covers the client-side wrapper around an RPC or
         * other remote request.
         */
        SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
        /**
         * Indicates that the span describes producer sending a message to a
         * broker. Unlike client and server, there is no direct critical path latency
         * relationship between producer and consumer spans.
         */
        SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
        /**
         * Indicates that the span describes consumer receiving a message from a
         * broker. Unlike client and server, there is no direct critical path latency
         * relationship between producer and consumer spans.
         */
        SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
    })(exports.SpanKind || (exports.SpanKind = {}));

    /**
     * A mock tracer useful for testing
     */
    var TestTracer = /** @class */ (function (_super) {
        __extends(TestTracer, _super);
        function TestTracer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.traceIdCounter = 0;
            _this.spanIdCounter = 0;
            _this.rootSpans = [];
            _this.knownSpans = [];
            return _this;
        }
        TestTracer.prototype.getNextTraceId = function () {
            this.traceIdCounter++;
            return String(this.traceIdCounter);
        };
        TestTracer.prototype.getNextSpanId = function () {
            this.spanIdCounter++;
            return String(this.spanIdCounter);
        };
        /**
         * Returns all Spans that were created without a parent
         */
        TestTracer.prototype.getRootSpans = function () {
            return this.rootSpans;
        };
        /**
         * Returns all Spans this Tracer knows about
         */
        TestTracer.prototype.getKnownSpans = function () {
            return this.knownSpans;
        };
        /**
         * Returns all Spans where end() has not been called
         */
        TestTracer.prototype.getActiveSpans = function () {
            return this.knownSpans.filter(function (span) {
                return !span.endCalled;
            });
        };
        /**
         * Return all Spans for a particular trace, grouped by their
         * parent Span in a tree-like structure
         * @param traceId The traceId to return the graph for
         */
        TestTracer.prototype.getSpanGraph = function (traceId) {
            var traceSpans = this.knownSpans.filter(function (span) {
                return span.context().traceId === traceId;
            });
            var roots = [];
            var nodeMap = new Map();
            for (var _i = 0, traceSpans_1 = traceSpans; _i < traceSpans_1.length; _i++) {
                var span = traceSpans_1[_i];
                var spanId = span.context().spanId;
                var node = {
                    name: span.name,
                    children: []
                };
                nodeMap.set(spanId, node);
                if (span.parentSpanId) {
                    var parent_1 = nodeMap.get(span.parentSpanId);
                    if (!parent_1) {
                        throw new Error("Span with name " + node.name + " has an unknown parentSpan with id " + span.parentSpanId);
                    }
                    parent_1.children.push(node);
                }
                else {
                    roots.push(node);
                }
            }
            return {
                roots: roots
            };
        };
        /**
         * Starts a new Span.
         * @param name The name of the span.
         * @param options The SpanOptions used during Span creation.
         */
        TestTracer.prototype.startSpan = function (name, options) {
            if (options === void 0) { options = {}; }
            var parentContext = this._getParentContext(options);
            var traceId;
            var isRootSpan = false;
            if (parentContext && parentContext.traceId) {
                traceId = parentContext.traceId;
            }
            else {
                traceId = this.getNextTraceId();
                isRootSpan = true;
            }
            var context = {
                traceId: traceId,
                spanId: this.getNextSpanId()
            };
            var span = new TestSpan(this, name, context, options.kind || exports.SpanKind.INTERNAL, parentContext ? parentContext.spanId : undefined, options.startTime);
            this.knownSpans.push(span);
            if (isRootSpan) {
                this.rootSpans.push(span);
            }
            return span;
        };
        TestTracer.prototype._getParentContext = function (options) {
            var parent = options.parent;
            if (parent) {
                if ('traceId' in parent) {
                    return parent;
                }
                else {
                    return parent.context();
                }
            }
        };
        return TestTracer;
    }(NoOpTracer));

    /*!
     * Copyright 2019, OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (function (TraceFlags) {
        /** Bit to represent whether trace is unsampled in trace flags. */
        TraceFlags[TraceFlags["UNSAMPLED"] = 0] = "UNSAMPLED";
        /** Bit to represent whether trace is sampled in trace flags. */
        TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
    })(exports.TraceFlags || (exports.TraceFlags = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var VERSION = "00";
    /**
     * Generates a `SpanContext` given a `traceparent` header value.
     * @param traceParent Serialized span context data as a `traceparent` header value.
     * @returns The `SpanContext` generated from the `traceparent` value.
     */
    function extractSpanContextFromTraceParentHeader(traceParentHeader) {
        var parts = traceParentHeader.split("-");
        if (parts.length !== 4) {
            return;
        }
        var version = parts[0], traceId = parts[1], spanId = parts[2], traceOptions = parts[3];
        if (version !== VERSION) {
            return;
        }
        var traceFlags = parseInt(traceOptions, 16);
        var spanContext = {
            spanId: spanId,
            traceId: traceId,
            traceFlags: traceFlags
        };
        return spanContext;
    }
    /**
     * Generates a `traceparent` value given a span context.
     * @param spanContext Contains context for a specific span.
     * @returns The `spanContext` represented as a `traceparent` value.
     */
    function getTraceParentHeader(spanContext) {
        var missingFields = [];
        if (!spanContext.traceId) {
            missingFields.push("traceId");
        }
        if (!spanContext.spanId) {
            missingFields.push("spanId");
        }
        if (missingFields.length) {
            return;
        }
        var flags = spanContext.traceFlags || exports.TraceFlags.UNSAMPLED;
        var hexFlags = flags.toString(16);
        var traceFlags = hexFlags.length === 1 ? "0" + hexFlags : hexFlags;
        // https://www.w3.org/TR/trace-context/#traceparent-header-field-values
        return VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-" + traceFlags;
    }

    exports.NoOpSpan = NoOpSpan;
    exports.NoOpTracer = NoOpTracer;
    exports.OpenCensusSpanWrapper = OpenCensusSpanWrapper;
    exports.OpenCensusTracerWrapper = OpenCensusTracerWrapper;
    exports.TestSpan = TestSpan;
    exports.TestTracer = TestTracer;
    exports.extractSpanContextFromTraceParentHeader = extractSpanContextFromTraceParentHeader;
    exports.getTraceParentHeader = getTraceParentHeader;
    exports.getTracer = getTracer;
    exports.setTracer = setTracer;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=core-tracing.js.map
