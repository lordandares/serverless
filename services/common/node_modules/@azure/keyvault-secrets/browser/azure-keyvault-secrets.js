/*!
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Azure KeyVault Secrets SDK for JavaScript - 4.0.0-preview.5
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.azurekeyvaultsecrets = {}));
}(this, function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    /**
     * A collection of HttpHeaders that can be sent with a HTTP request.
     */
    function getHeaderKey(headerName) {
        return headerName.toLowerCase();
    }
    /**
     * A collection of HTTP header key/value pairs.
     */
    var HttpHeaders = /** @class */ (function () {
        function HttpHeaders(rawHeaders) {
            this._headersMap = {};
            if (rawHeaders) {
                for (var headerName in rawHeaders) {
                    this.set(headerName, rawHeaders[headerName]);
                }
            }
        }
        /**
         * Set a header in this collection with the provided name and value. The name is
         * case-insensitive.
         * @param headerName The name of the header to set. This value is case-insensitive.
         * @param headerValue The value of the header to set.
         */
        HttpHeaders.prototype.set = function (headerName, headerValue) {
            this._headersMap[getHeaderKey(headerName)] = { name: headerName, value: headerValue.toString() };
        };
        /**
         * Get the header value for the provided header name, or undefined if no header exists in this
         * collection with the provided name.
         * @param headerName The name of the header.
         */
        HttpHeaders.prototype.get = function (headerName) {
            var header = this._headersMap[getHeaderKey(headerName)];
            return !header ? undefined : header.value;
        };
        /**
         * Get whether or not this header collection contains a header entry for the provided header name.
         */
        HttpHeaders.prototype.contains = function (headerName) {
            return !!this._headersMap[getHeaderKey(headerName)];
        };
        /**
         * Remove the header with the provided headerName. Return whether or not the header existed and
         * was removed.
         * @param headerName The name of the header to remove.
         */
        HttpHeaders.prototype.remove = function (headerName) {
            var result = this.contains(headerName);
            delete this._headersMap[getHeaderKey(headerName)];
            return result;
        };
        /**
         * Get the headers that are contained this collection as an object.
         */
        HttpHeaders.prototype.rawHeaders = function () {
            var result = {};
            for (var headerKey in this._headersMap) {
                var header = this._headersMap[headerKey];
                result[header.name.toLowerCase()] = header.value;
            }
            return result;
        };
        /**
         * Get the headers that are contained in this collection as an array.
         */
        HttpHeaders.prototype.headersArray = function () {
            var headers = [];
            for (var headerKey in this._headersMap) {
                headers.push(this._headersMap[headerKey]);
            }
            return headers;
        };
        /**
         * Get the header names that are contained in this collection.
         */
        HttpHeaders.prototype.headerNames = function () {
            var headerNames = [];
            var headers = this.headersArray();
            for (var i = 0; i < headers.length; ++i) {
                headerNames.push(headers[i].name);
            }
            return headerNames;
        };
        /**
         * Get the header names that are contained in this collection.
         */
        HttpHeaders.prototype.headerValues = function () {
            var headerValues = [];
            var headers = this.headersArray();
            for (var i = 0; i < headers.length; ++i) {
                headerValues.push(headers[i].value);
            }
            return headerValues;
        };
        /**
         * Get the JSON object representation of this HTTP header collection.
         */
        HttpHeaders.prototype.toJson = function () {
            return this.rawHeaders();
        };
        /**
         * Get the string representation of this HTTP header collection.
         */
        HttpHeaders.prototype.toString = function () {
            return JSON.stringify(this.toJson());
        };
        /**
         * Create a deep clone/copy of this HttpHeaders collection.
         */
        HttpHeaders.prototype.clone = function () {
            return new HttpHeaders(this.rawHeaders());
        };
        return HttpHeaders;
    }());

    // Copyright (c) Microsoft Corporation.
    /**
     * Encodes a byte array in base64 format.
     * @param value the Uint8Aray to encode
     */
    function encodeByteArray(value) {
        var str = "";
        for (var i = 0; i < value.length; i++) {
            str += String.fromCharCode(value[i]);
        }
        return btoa(str);
    }
    /**
     * Decodes a base64 string into a byte array.
     * @param value the base64 string to decode
     */
    function decodeString(value) {
        var byteString = atob(value);
        var arr = new Uint8Array(byteString.length);
        for (var i = 0; i < byteString.length; i++) {
            arr[i] = byteString.charCodeAt(i);
        }
        return arr;
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var rngBrowser = createCommonjsModule(function (module) {
    // Unique ID creation requires a high quality random # generator.  In the
    // browser this is a little complicated due to unknown quality of Math.random()
    // and inconsistent support for the `crypto` API.  We do the best we can via
    // feature-detection

    // getRandomValues needs to be invoked in a context where "this" is a Crypto
    // implementation. Also, find the complete implementation of crypto on IE11.
    var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                          (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

    if (getRandomValues) {
      // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
      var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      // Math.random()-based (RNG)
      //
      // If all else fails, use Math.random().  It's fast, but is of unspecified
      // quality.
      var rnds = new Array(16);

      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
          rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        }

        return rnds;
      };
    }
    });

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */
    var byteToHex = [];
    for (var i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 0x100).toString(16).substr(1);
    }

    function bytesToUuid(buf, offset) {
      var i = offset || 0;
      var bth = byteToHex;
      // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
      return ([bth[buf[i++]], bth[buf[i++]], 
    	bth[buf[i++]], bth[buf[i++]], '-',
    	bth[buf[i++]], bth[buf[i++]], '-',
    	bth[buf[i++]], bth[buf[i++]], '-',
    	bth[buf[i++]], bth[buf[i++]], '-',
    	bth[buf[i++]], bth[buf[i++]],
    	bth[buf[i++]], bth[buf[i++]],
    	bth[buf[i++]], bth[buf[i++]]]).join('');
    }

    var bytesToUuid_1 = bytesToUuid;

    function v4(options, buf, offset) {
      var i = buf && offset || 0;

      if (typeof(options) == 'string') {
        buf = options === 'binary' ? new Array(16) : null;
        options = null;
      }
      options = options || {};

      var rnds = options.random || (options.rng || rngBrowser)();

      // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
      rnds[6] = (rnds[6] & 0x0f) | 0x40;
      rnds[8] = (rnds[8] & 0x3f) | 0x80;

      // Copy bytes to buffer, if provided
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }

      return buf || bytesToUuid_1(rnds);
    }

    var v4_1 = v4;

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    var Constants = {
        /**
         * The core-http version
         * @const
         * @type {string}
         */
        coreHttpVersion: "1.0.0-preview.2",
        /**
         * Specifies HTTP.
         *
         * @const
         * @type {string}
         */
        HTTP: "http:",
        /**
         * Specifies HTTPS.
         *
         * @const
         * @type {string}
         */
        HTTPS: "https:",
        /**
         * Specifies HTTP Proxy.
         *
         * @const
         * @type {string}
         */
        HTTP_PROXY: "HTTP_PROXY",
        /**
         * Specifies HTTPS Proxy.
         *
         * @const
         * @type {string}
         */
        HTTPS_PROXY: "HTTPS_PROXY",
        HttpConstants: {
            /**
             * Http Verbs
             *
             * @const
             * @enum {string}
             */
            HttpVerbs: {
                PUT: "PUT",
                GET: "GET",
                DELETE: "DELETE",
                POST: "POST",
                MERGE: "MERGE",
                HEAD: "HEAD",
                PATCH: "PATCH"
            },
            StatusCodes: {
                TooManyRequests: 429
            }
        },
        /**
         * Defines constants for use with HTTP headers.
         */
        HeaderConstants: {
            /**
             * The Authorization header.
             *
             * @const
             * @type {string}
             */
            AUTHORIZATION: "authorization",
            AUTHORIZATION_SCHEME: "Bearer",
            /**
             * The Retry-After response-header field can be used with a 503 (Service
             * Unavailable) or 349 (Too Many Requests) responses to indicate how long
             * the service is expected to be unavailable to the requesting client.
             *
             * @const
             * @type {string}
             */
            RETRY_AFTER: "Retry-After",
            /**
             * The UserAgent header.
             *
             * @const
             * @type {string}
             */
            USER_AGENT: "User-Agent"
        }
    };

    // Copyright (c) Microsoft Corporation.
    /**
     * A constant that indicates whether the environment is node.js or browser based.
     */
    var isNode = typeof process !== "undefined" &&
        !!process.version &&
        !!process.versions &&
        !!process.versions.node;
    /**
     * Returns a stripped version of the Http Response which only contains body,
     * headers and the status.
     *
     * @param {HttpOperationResponse} response The Http Response
     *
     * @return {object} The stripped version of Http Response.
     */
    function stripResponse(response) {
        var strippedResponse = {};
        strippedResponse.body = response.bodyAsText;
        strippedResponse.headers = response.headers;
        strippedResponse.status = response.status;
        return strippedResponse;
    }
    /**
     * Returns a stripped version of the Http Request that does not contain the
     * Authorization header.
     *
     * @param {WebResource} request The Http Request object
     *
     * @return {WebResource} The stripped version of Http Request.
     */
    function stripRequest(request) {
        var strippedRequest = request.clone();
        if (strippedRequest.headers) {
            strippedRequest.headers.remove("authorization");
        }
        return strippedRequest;
    }
    /**
     * Validates the given uuid as a string
     *
     * @param {string} uuid The uuid as a string that needs to be validated
     *
     * @return {boolean} True if the uuid is valid; false otherwise.
     */
    function isValidUuid(uuid) {
        var validUuidRegex = new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$", "ig");
        return validUuidRegex.test(uuid);
    }
    /**
     * Generated UUID
     *
     * @return {string} RFC4122 v4 UUID.
     */
    function generateUuid() {
        return v4_1();
    }
    /**
     * A wrapper for setTimeout that resolves a promise after t milliseconds.
     * @param {number} t The number of milliseconds to be delayed.
     * @param {T} value The value to be resolved with after a timeout of t milliseconds.
     * @returns {Promise<T>} Resolved promise
     */
    function delay(t, value) {
        return new Promise(function (resolve) { return setTimeout(function () { return resolve(value); }, t); });
    }
    function prepareXMLRootList(obj, elementName) {
        var _a;
        if (!Array.isArray(obj)) {
            obj = [obj];
        }
        return _a = {}, _a[elementName] = obj, _a;
    }
    var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    /**
     * Indicates whether the given string is in ISO 8601 format.
     * @param {string} value The value to be validated for ISO 8601 duration format.
     * @return {boolean} `true` if valid, `false` otherwise.
     */
    function isDuration(value) {
        return validateISODuration.test(value);
    }
    /**
     * Replace all of the instances of searchValue in value with the provided replaceValue.
     * @param {string | undefined} value The value to search and replace in.
     * @param {string} searchValue The value to search for in the value argument.
     * @param {string} replaceValue The value to replace searchValue with in the value argument.
     * @returns {string | undefined} The value where each instance of searchValue was replaced with replacedValue.
     */
    function replaceAll(value, searchValue, replaceValue) {
        return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
    }
    /**
     * Determines whether the given enity is a basic/primitive type
     * (string, number, boolean, null, undefined).
     * @param value Any entity
     * @return boolean - true is it is primitive type, false otherwise.
     */
    function isPrimitiveType(value) {
        return (typeof value !== "object" && typeof value !== "function") || value === null;
    }

    // Copyright (c) Microsoft Corporation.
    var Serializer = /** @class */ (function () {
        function Serializer(modelMappers, isXML) {
            if (modelMappers === void 0) { modelMappers = {}; }
            this.modelMappers = modelMappers;
            this.isXML = isXML;
        }
        Serializer.prototype.validateConstraints = function (mapper, value, objectName) {
            var failValidation = function (constraintName, constraintValue) {
                throw new Error("\"" + objectName + "\" with value \"" + value + "\" should satisfy the constraint \"" + constraintName + "\": " + constraintValue + ".");
            };
            if (mapper.constraints && (value != undefined)) {
                var _a = mapper.constraints, ExclusiveMaximum = _a.ExclusiveMaximum, ExclusiveMinimum = _a.ExclusiveMinimum, InclusiveMaximum = _a.InclusiveMaximum, InclusiveMinimum = _a.InclusiveMinimum, MaxItems = _a.MaxItems, MaxLength = _a.MaxLength, MinItems = _a.MinItems, MinLength = _a.MinLength, MultipleOf = _a.MultipleOf, Pattern = _a.Pattern, UniqueItems = _a.UniqueItems;
                if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) {
                    failValidation("ExclusiveMaximum", ExclusiveMaximum);
                }
                if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) {
                    failValidation("ExclusiveMinimum", ExclusiveMinimum);
                }
                if (InclusiveMaximum != undefined && value > InclusiveMaximum) {
                    failValidation("InclusiveMaximum", InclusiveMaximum);
                }
                if (InclusiveMinimum != undefined && value < InclusiveMinimum) {
                    failValidation("InclusiveMinimum", InclusiveMinimum);
                }
                if (MaxItems != undefined && value.length > MaxItems) {
                    failValidation("MaxItems", MaxItems);
                }
                if (MaxLength != undefined && value.length > MaxLength) {
                    failValidation("MaxLength", MaxLength);
                }
                if (MinItems != undefined && value.length < MinItems) {
                    failValidation("MinItems", MinItems);
                }
                if (MinLength != undefined && value.length < MinLength) {
                    failValidation("MinLength", MinLength);
                }
                if (MultipleOf != undefined && value % MultipleOf !== 0) {
                    failValidation("MultipleOf", MultipleOf);
                }
                if (Pattern) {
                    var pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
                    if ((typeof value !== "string") || (value.match(pattern) === null)) {
                        failValidation("Pattern", Pattern);
                    }
                }
                if (UniqueItems && value.some(function (item, i, ar) { return ar.indexOf(item) !== i; })) {
                    failValidation("UniqueItems", UniqueItems);
                }
            }
        };
        /**
         * Serialize the given object based on its metadata defined in the mapper
         *
         * @param {Mapper} mapper The mapper which defines the metadata of the serializable object
         *
         * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized
         *
         * @param {string} objectName Name of the serialized object
         *
         * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object
         */
        Serializer.prototype.serialize = function (mapper, object, objectName) {
            var payload = {};
            var mapperType = mapper.type.name;
            if (!objectName) {
                objectName = mapper.serializedName;
            }
            if (mapperType.match(/^Sequence$/ig) !== null) {
                payload = [];
            }
            if (mapper.isConstant) {
                object = mapper.defaultValue;
            }
            // This table of allowed values should help explain
            // the mapper.required and mapper.nullable properties.
            // X means "neither undefined or null are allowed".
            //           || required
            //           || true      | false
            //  nullable || ==========================
            //      true || null      | undefined/null
            //     false || X         | undefined
            // undefined || X         | undefined/null
            var required = mapper.required, nullable = mapper.nullable;
            if (required && nullable && object === undefined) {
                throw new Error(objectName + " cannot be undefined.");
            }
            if (required && !nullable && object == undefined) {
                throw new Error(objectName + " cannot be null or undefined.");
            }
            if (!required && nullable === false && object === null) {
                throw new Error(objectName + " cannot be null.");
            }
            if (object == undefined) {
                payload = object;
            }
            else {
                // Validate Constraints if any
                this.validateConstraints(mapper, object, objectName);
                if (mapperType.match(/^any$/ig) !== null) {
                    payload = object;
                }
                else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/ig) !== null) {
                    payload = serializeBasicTypes(mapperType, objectName, object);
                }
                else if (mapperType.match(/^Enum$/ig) !== null) {
                    var enumMapper = mapper;
                    payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
                }
                else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/ig) !== null) {
                    payload = serializeDateTypes(mapperType, object, objectName);
                }
                else if (mapperType.match(/^ByteArray$/ig) !== null) {
                    payload = serializeByteArrayType(objectName, object);
                }
                else if (mapperType.match(/^Base64Url$/ig) !== null) {
                    payload = serializeBase64UrlType(objectName, object);
                }
                else if (mapperType.match(/^Sequence$/ig) !== null) {
                    payload = serializeSequenceType(this, mapper, object, objectName);
                }
                else if (mapperType.match(/^Dictionary$/ig) !== null) {
                    payload = serializeDictionaryType(this, mapper, object, objectName);
                }
                else if (mapperType.match(/^Composite$/ig) !== null) {
                    payload = serializeCompositeType(this, mapper, object, objectName);
                }
            }
            return payload;
        };
        /**
         * Deserialize the given object based on its metadata defined in the mapper
         *
         * @param {object} mapper The mapper which defines the metadata of the serializable object
         *
         * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized
         *
         * @param {string} objectName Name of the deserialized object
         *
         * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object
         */
        Serializer.prototype.deserialize = function (mapper, responseBody, objectName) {
            if (responseBody == undefined) {
                if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
                    // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
                    // between the list being empty versus being missing,
                    // so let's do the more user-friendly thing and return an empty list.
                    responseBody = [];
                }
                // specifically check for undefined as default value can be a falsey value `0, "", false, null`
                if (mapper.defaultValue !== undefined) {
                    responseBody = mapper.defaultValue;
                }
                return responseBody;
            }
            var payload;
            var mapperType = mapper.type.name;
            if (!objectName) {
                objectName = mapper.serializedName;
            }
            if (mapperType.match(/^Composite$/ig) !== null) {
                payload = deserializeCompositeType(this, mapper, responseBody, objectName);
            }
            else {
                if (this.isXML) {
                    /**
                     * If the mapper specifies this as a non-composite type value but the responseBody contains
                     * both header ("$") and body ("_") properties, then just reduce the responseBody value to
                     * the body ("_") property.
                     */
                    if (responseBody["$"] != undefined && responseBody["_"] != undefined) {
                        responseBody = responseBody["_"];
                    }
                }
                if (mapperType.match(/^Number$/ig) !== null) {
                    payload = parseFloat(responseBody);
                    if (isNaN(payload)) {
                        payload = responseBody;
                    }
                }
                else if (mapperType.match(/^Boolean$/ig) !== null) {
                    if (responseBody === "true") {
                        payload = true;
                    }
                    else if (responseBody === "false") {
                        payload = false;
                    }
                    else {
                        payload = responseBody;
                    }
                }
                else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/ig) !== null) {
                    payload = responseBody;
                }
                else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/ig) !== null) {
                    payload = new Date(responseBody);
                }
                else if (mapperType.match(/^UnixTime$/ig) !== null) {
                    payload = unixTimeToDate(responseBody);
                }
                else if (mapperType.match(/^ByteArray$/ig) !== null) {
                    payload = decodeString(responseBody);
                }
                else if (mapperType.match(/^Base64Url$/ig) !== null) {
                    payload = base64UrlToByteArray(responseBody);
                }
                else if (mapperType.match(/^Sequence$/ig) !== null) {
                    payload = deserializeSequenceType(this, mapper, responseBody, objectName);
                }
                else if (mapperType.match(/^Dictionary$/ig) !== null) {
                    payload = deserializeDictionaryType(this, mapper, responseBody, objectName);
                }
            }
            if (mapper.isConstant) {
                payload = mapper.defaultValue;
            }
            return payload;
        };
        return Serializer;
    }());
    function trimEnd(str, ch) {
        var len = str.length;
        while ((len - 1) >= 0 && str[len - 1] === ch) {
            --len;
        }
        return str.substr(0, len);
    }
    function bufferToBase64Url(buffer) {
        if (!buffer) {
            return undefined;
        }
        if (!(buffer instanceof Uint8Array)) {
            throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
        }
        // Uint8Array to Base64.
        var str = encodeByteArray(buffer);
        // Base64 to Base64Url.
        return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function base64UrlToByteArray(str) {
        if (!str) {
            return undefined;
        }
        if (str && typeof str.valueOf() !== "string") {
            throw new Error("Please provide an input of type string for converting to Uint8Array");
        }
        // Base64Url to Base64.
        str = str.replace(/\-/g, "+").replace(/\_/g, "/");
        // Base64 to Uint8Array.
        return decodeString(str);
    }
    function splitSerializeName(prop) {
        var classes = [];
        var partialclass = "";
        if (prop) {
            var subwords = prop.split(".");
            for (var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++) {
                var item = subwords_1[_i];
                if (item.charAt(item.length - 1) === "\\") {
                    partialclass += item.substr(0, item.length - 1) + ".";
                }
                else {
                    partialclass += item;
                    classes.push(partialclass);
                    partialclass = "";
                }
            }
        }
        return classes;
    }
    function dateToUnixTime(d) {
        if (!d) {
            return undefined;
        }
        if (typeof d.valueOf() === "string") {
            d = new Date(d);
        }
        return Math.floor(d.getTime() / 1000);
    }
    function unixTimeToDate(n) {
        if (!n) {
            return undefined;
        }
        return new Date(n * 1000);
    }
    function serializeBasicTypes(typeName, objectName, value) {
        if (value !== null && value !== undefined) {
            if (typeName.match(/^Number$/ig) !== null) {
                if (typeof value !== "number") {
                    throw new Error(objectName + " with value " + value + " must be of type number.");
                }
            }
            else if (typeName.match(/^String$/ig) !== null) {
                if (typeof value.valueOf() !== "string") {
                    throw new Error(objectName + " with value \"" + value + "\" must be of type string.");
                }
            }
            else if (typeName.match(/^Uuid$/ig) !== null) {
                if (!(typeof value.valueOf() === "string" && isValidUuid(value))) {
                    throw new Error(objectName + " with value \"" + value + "\" must be of type string and a valid uuid.");
                }
            }
            else if (typeName.match(/^Boolean$/ig) !== null) {
                if (typeof value !== "boolean") {
                    throw new Error(objectName + " with value " + value + " must be of type boolean.");
                }
            }
            else if (typeName.match(/^Stream$/ig) !== null) {
                var objectType = typeof value;
                if (objectType !== "string" &&
                    objectType !== "function" &&
                    !(value instanceof ArrayBuffer) &&
                    !ArrayBuffer.isView(value) &&
                    !(typeof Blob === "function" && value instanceof Blob)) {
                    throw new Error(objectName + " must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.");
                }
            }
        }
        return value;
    }
    function serializeEnumType(objectName, allowedValues, value) {
        if (!allowedValues) {
            throw new Error("Please provide a set of allowedValues to validate " + objectName + " as an Enum Type.");
        }
        var isPresent = allowedValues.some(function (item) {
            if (typeof item.valueOf() === "string") {
                return item.toLowerCase() === value.toLowerCase();
            }
            return item === value;
        });
        if (!isPresent) {
            throw new Error(value + " is not a valid value for " + objectName + ". The valid values are: " + JSON.stringify(allowedValues) + ".");
        }
        return value;
    }
    function serializeByteArrayType(objectName, value) {
        if (value != undefined) {
            if (!(value instanceof Uint8Array)) {
                throw new Error(objectName + " must be of type Uint8Array.");
            }
            value = encodeByteArray(value);
        }
        return value;
    }
    function serializeBase64UrlType(objectName, value) {
        if (value != undefined) {
            if (!(value instanceof Uint8Array)) {
                throw new Error(objectName + " must be of type Uint8Array.");
            }
            value = bufferToBase64Url(value);
        }
        return value;
    }
    function serializeDateTypes(typeName, value, objectName) {
        if (value != undefined) {
            if (typeName.match(/^Date$/ig) !== null) {
                if (!(value instanceof Date ||
                    (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                    throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
                }
                value = (value instanceof Date) ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
            }
            else if (typeName.match(/^DateTime$/ig) !== null) {
                if (!(value instanceof Date ||
                    (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                    throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
                }
                value = (value instanceof Date) ? value.toISOString() : new Date(value).toISOString();
            }
            else if (typeName.match(/^DateTimeRfc1123$/ig) !== null) {
                if (!(value instanceof Date ||
                    (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                    throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123 format.");
                }
                value = (value instanceof Date) ? value.toUTCString() : new Date(value).toUTCString();
            }
            else if (typeName.match(/^UnixTime$/ig) !== null) {
                if (!(value instanceof Date ||
                    (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
                    throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123/ISO8601 format " +
                        "for it to be serialized in UnixTime/Epoch format.");
                }
                value = dateToUnixTime(value);
            }
            else if (typeName.match(/^TimeSpan$/ig) !== null) {
                if (!isDuration(value)) {
                    throw new Error(objectName + " must be a string in ISO 8601 format. Instead was \"" + value + "\".");
                }
                value = value;
            }
        }
        return value;
    }
    function serializeSequenceType(serializer, mapper, object, objectName) {
        if (!Array.isArray(object)) {
            throw new Error(objectName + " must be of type Array.");
        }
        var elementType = mapper.type.element;
        if (!elementType || typeof elementType !== "object") {
            throw new Error("element\" metadata for an Array must be defined in the " +
                ("mapper and it must of type \"object\" in " + objectName + "."));
        }
        var tempArray = [];
        for (var i = 0; i < object.length; i++) {
            tempArray[i] = serializer.serialize(elementType, object[i], objectName);
        }
        return tempArray;
    }
    function serializeDictionaryType(serializer, mapper, object, objectName) {
        if (typeof object !== "object") {
            throw new Error(objectName + " must be of type object.");
        }
        var valueType = mapper.type.value;
        if (!valueType || typeof valueType !== "object") {
            throw new Error("\"value\" metadata for a Dictionary must be defined in the " +
                ("mapper and it must of type \"object\" in " + objectName + "."));
        }
        var tempDictionary = {};
        for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
            var key = _a[_i];
            tempDictionary[key] = serializer.serialize(valueType, object[key], objectName + "." + key);
        }
        return tempDictionary;
    }
    /**
     * Resolves a composite mapper's modelProperties.
     * @param serializer the serializer containing the entire set of mappers
     * @param mapper the composite mapper to resolve
     */
    function resolveModelProperties(serializer, mapper, objectName) {
        var modelProps = mapper.type.modelProperties;
        if (!modelProps) {
            var className = mapper.type.className;
            if (!className) {
                throw new Error("Class name for model \"" + objectName + "\" is not provided in the mapper \"" + JSON.stringify(mapper, undefined, 2) + "\".");
            }
            var modelMapper = serializer.modelMappers[className];
            if (!modelMapper) {
                throw new Error("mapper() cannot be null or undefined for model \"" + className + "\".");
            }
            modelProps = modelMapper.type.modelProperties;
            if (!modelProps) {
                throw new Error("modelProperties cannot be null or undefined in the " +
                    ("mapper \"" + JSON.stringify(modelMapper) + "\" of type \"" + className + "\" for object \"" + objectName + "\"."));
            }
        }
        return modelProps;
    }
    function serializeCompositeType(serializer, mapper, object, objectName) {
        var _a;
        if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
            mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
        }
        if (object != undefined) {
            var payload = {};
            var modelProps = resolveModelProperties(serializer, mapper, objectName);
            for (var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++) {
                var key = _b[_i];
                var propertyMapper = modelProps[key];
                if (propertyMapper.readOnly) {
                    continue;
                }
                var propName = void 0;
                var parentObject = payload;
                if (serializer.isXML) {
                    if (propertyMapper.xmlIsWrapped) {
                        propName = propertyMapper.xmlName;
                    }
                    else {
                        propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
                    }
                }
                else {
                    var paths = splitSerializeName(propertyMapper.serializedName);
                    propName = paths.pop();
                    for (var _c = 0, paths_1 = paths; _c < paths_1.length; _c++) {
                        var pathName = paths_1[_c];
                        var childObject = parentObject[pathName];
                        if ((childObject == undefined) && (object[key] != undefined)) {
                            parentObject[pathName] = {};
                        }
                        parentObject = parentObject[pathName];
                    }
                }
                if (parentObject != undefined) {
                    var propertyObjectName = propertyMapper.serializedName !== ""
                        ? objectName + "." + propertyMapper.serializedName
                        : objectName;
                    var toSerialize = object[key];
                    var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
                    if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {
                        toSerialize = mapper.serializedName;
                    }
                    var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName);
                    if (serializedValue !== undefined && propName != undefined) {
                        if (propertyMapper.xmlIsAttribute) {
                            // $ is the key attributes are kept under in xml2js.
                            // This keeps things simple while preventing name collision
                            // with names in user documents.
                            parentObject.$ = parentObject.$ || {};
                            parentObject.$[propName] = serializedValue;
                        }
                        else if (propertyMapper.xmlIsWrapped) {
                            parentObject[propName] = (_a = {}, _a[propertyMapper.xmlElementName] = serializedValue, _a);
                        }
                        else {
                            parentObject[propName] = serializedValue;
                        }
                    }
                }
            }
            var additionalPropertiesMapper = mapper.type.additionalProperties;
            if (additionalPropertiesMapper) {
                var propNames = Object.keys(modelProps);
                var _loop_1 = function (clientPropName) {
                    var isAdditionalProperty = propNames.every(function (pn) { return pn !== clientPropName; });
                    if (isAdditionalProperty) {
                        payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]');
                    }
                };
                for (var clientPropName in object) {
                    _loop_1(clientPropName);
                }
            }
            return payload;
        }
        return object;
    }
    function isSpecialXmlProperty(propertyName) {
        return ["$", "_"].includes(propertyName);
    }
    function deserializeCompositeType(serializer, mapper, responseBody, objectName) {
        if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
            mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
        }
        var modelProps = resolveModelProperties(serializer, mapper, objectName);
        var instance = {};
        var handledPropertyNames = [];
        for (var _i = 0, _a = Object.keys(modelProps); _i < _a.length; _i++) {
            var key = _a[_i];
            var propertyMapper = modelProps[key];
            var paths = splitSerializeName(modelProps[key].serializedName);
            handledPropertyNames.push(paths[0]);
            var serializedName = propertyMapper.serializedName, xmlName = propertyMapper.xmlName, xmlElementName = propertyMapper.xmlElementName;
            var propertyObjectName = objectName;
            if (serializedName !== "" && serializedName !== undefined) {
                propertyObjectName = objectName + "." + serializedName;
            }
            var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
            if (headerCollectionPrefix) {
                var dictionary = {};
                for (var _b = 0, _c = Object.keys(responseBody); _b < _c.length; _b++) {
                    var headerKey = _c[_b];
                    if (headerKey.startsWith(headerCollectionPrefix)) {
                        dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName);
                    }
                    handledPropertyNames.push(headerKey);
                }
                instance[key] = dictionary;
            }
            else if (serializer.isXML) {
                if (propertyMapper.xmlIsAttribute && responseBody.$) {
                    instance[key] = serializer.deserialize(propertyMapper, responseBody.$[xmlName], propertyObjectName);
                }
                else {
                    var propertyName = xmlElementName || xmlName || serializedName;
                    var unwrappedProperty = responseBody[propertyName];
                    if (propertyMapper.xmlIsWrapped) {
                        unwrappedProperty = responseBody[xmlName];
                        unwrappedProperty = unwrappedProperty && unwrappedProperty[xmlElementName];
                        var isEmptyWrappedList = unwrappedProperty === undefined;
                        if (isEmptyWrappedList) {
                            unwrappedProperty = [];
                        }
                    }
                    instance[key] = serializer.deserialize(propertyMapper, unwrappedProperty, propertyObjectName);
                }
            }
            else {
                // deserialize the property if it is present in the provided responseBody instance
                var propertyInstance = void 0;
                var res = responseBody;
                // traversing the object step by step.
                for (var _d = 0, paths_2 = paths; _d < paths_2.length; _d++) {
                    var item = paths_2[_d];
                    if (!res)
                        break;
                    res = res[item];
                }
                propertyInstance = res;
                var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
                // checking that the model property name (key)(ex: "fishtype") and the
                // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
                // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
                // is a better approach. The generator is not consistent with escaping '\.' in the
                // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
                // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
                // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
                // the transformation of model property name (ex: "fishtype") is done consistently.
                // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
                if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == undefined) {
                    propertyInstance = mapper.serializedName;
                }
                var serializedValue = void 0;
                // paging
                if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
                    propertyInstance = responseBody[key];
                    instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);
                }
                else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
                    serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);
                    instance[key] = serializedValue;
                }
            }
        }
        var additionalPropertiesMapper = mapper.type.additionalProperties;
        if (additionalPropertiesMapper) {
            var isAdditionalProperty = function (responsePropName) {
                for (var clientPropName in modelProps) {
                    var paths = splitSerializeName(modelProps[clientPropName].serializedName);
                    if (paths[0] === responsePropName) {
                        return false;
                    }
                }
                return true;
            };
            for (var responsePropName in responseBody) {
                if (isAdditionalProperty(responsePropName)) {
                    instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]');
                }
            }
        }
        else if (responseBody) {
            for (var _e = 0, _f = Object.keys(responseBody); _e < _f.length; _e++) {
                var key = _f[_e];
                if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key)) {
                    instance[key] = responseBody[key];
                }
            }
        }
        return instance;
    }
    function deserializeDictionaryType(serializer, mapper, responseBody, objectName) {
        /*jshint validthis: true */
        var value = mapper.type.value;
        if (!value || typeof value !== "object") {
            throw new Error("\"value\" metadata for a Dictionary must be defined in the " +
                ("mapper and it must of type \"object\" in " + objectName));
        }
        if (responseBody) {
            var tempDictionary = {};
            for (var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++) {
                var key = _a[_i];
                tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName);
            }
            return tempDictionary;
        }
        return responseBody;
    }
    function deserializeSequenceType(serializer, mapper, responseBody, objectName) {
        /*jshint validthis: true */
        var element = mapper.type.element;
        if (!element || typeof element !== "object") {
            throw new Error("element\" metadata for an Array must be defined in the " +
                ("mapper and it must of type \"object\" in " + objectName));
        }
        if (responseBody) {
            if (!Array.isArray(responseBody)) {
                // xml2js will interpret a single element array as just the element, so force it to be an array
                responseBody = [responseBody];
            }
            var tempArray = [];
            for (var i = 0; i < responseBody.length; i++) {
                tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + "[" + i + "]");
            }
            return tempArray;
        }
        return responseBody;
    }
    function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
        if (polymorphicDiscriminator) {
            var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
            if (discriminatorName != undefined) {
                var discriminatorValue = object[discriminatorName];
                if (discriminatorValue != undefined) {
                    var typeName = mapper.type.uberParent || mapper.type.className;
                    var indexDiscriminator = discriminatorValue === typeName
                        ? discriminatorValue
                        : typeName + "." + discriminatorValue;
                    var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];
                    if (polymorphicMapper) {
                        mapper = polymorphicMapper;
                    }
                }
            }
        }
        return mapper;
    }
    function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
        return mapper.type.polymorphicDiscriminator
            || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent)
            || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
    }
    function getPolymorphicDiscriminatorSafely(serializer, typeName) {
        return (typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator);
    }
    /**
     * Utility function to create a K:V from a list of strings
     */
    function strEnum(o) {
        var result = {};
        for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {
            var key = o_1[_i];
            result[key] = key;
        }
        return result;
    }
    var MapperType = strEnum([
        "Base64Url",
        "Boolean",
        "ByteArray",
        "Composite",
        "Date",
        "DateTime",
        "DateTimeRfc1123",
        "Dictionary",
        "Enum",
        "Number",
        "Object",
        "Sequence",
        "String",
        "Stream",
        "TimeSpan",
        "UnixTime"
    ]);

    // Copyright (c) Microsoft Corporation.
    /**
     * Creates a new WebResource object.
     *
     * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary
     * properties to initiate a request.
     *
     * @constructor
     */
    var WebResource = /** @class */ (function () {
        function WebResource(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive) {
            this.streamResponseBody = streamResponseBody;
            this.url = url || "";
            this.method = method || "GET";
            this.headers = headers instanceof HttpHeaders ? headers : new HttpHeaders(headers);
            this.body = body;
            this.query = query;
            this.formData = undefined;
            this.withCredentials = withCredentials || false;
            this.abortSignal = abortSignal;
            this.timeout = timeout || 0;
            this.onUploadProgress = onUploadProgress;
            this.onDownloadProgress = onDownloadProgress;
            this.proxySettings = proxySettings;
            this.keepAlive = keepAlive;
        }
        /**
         * Validates that the required properties such as method, url, headers["Content-Type"],
         * headers["accept-language"] are defined. It will throw an error if one of the above
         * mentioned properties are not defined.
         */
        WebResource.prototype.validateRequestProperties = function () {
            if (!this.method) {
                throw new Error("WebResource.method is required.");
            }
            if (!this.url) {
                throw new Error("WebResource.url is required.");
            }
        };
        /**
         * Prepares the request.
         * @param {RequestPrepareOptions} options Options to provide for preparing the request.
         * @returns {WebResource} Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.
         */
        WebResource.prototype.prepare = function (options) {
            if (!options) {
                throw new Error("options object is required");
            }
            if (options.method == undefined || typeof options.method.valueOf() !== "string") {
                throw new Error("options.method must be a string.");
            }
            if (options.url && options.pathTemplate) {
                throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
            }
            if ((options.pathTemplate == undefined || typeof options.pathTemplate.valueOf() !== "string") &&
                (options.url == undefined || typeof options.url.valueOf() !== "string")) {
                throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
            }
            // set the url if it is provided.
            if (options.url) {
                if (typeof options.url !== "string") {
                    throw new Error('options.url must be of type "string".');
                }
                this.url = options.url;
            }
            // set the method
            if (options.method) {
                var validMethods = ["GET", "PUT", "HEAD", "DELETE", "OPTIONS", "POST", "PATCH", "TRACE"];
                if (validMethods.indexOf(options.method.toUpperCase()) === -1) {
                    throw new Error('The provided method "' +
                        options.method +
                        '" is invalid. Supported HTTP methods are: ' +
                        JSON.stringify(validMethods));
                }
            }
            this.method = options.method.toUpperCase();
            // construct the url if path template is provided
            if (options.pathTemplate) {
                var pathTemplate_1 = options.pathTemplate, pathParameters_1 = options.pathParameters;
                if (typeof pathTemplate_1 !== "string") {
                    throw new Error('options.pathTemplate must be of type "string".');
                }
                if (!options.baseUrl) {
                    options.baseUrl = "https://management.azure.com";
                }
                var baseUrl = options.baseUrl;
                var url_1 = baseUrl +
                    (baseUrl.endsWith("/") ? "" : "/") +
                    (pathTemplate_1.startsWith("/") ? pathTemplate_1.slice(1) : pathTemplate_1);
                var segments = url_1.match(/({\w*\s*\w*})/gi);
                if (segments && segments.length) {
                    if (!pathParameters_1) {
                        throw new Error("pathTemplate: " + pathTemplate_1 + " has been provided. Hence, options.pathParameters must also be provided.");
                    }
                    segments.forEach(function (item) {
                        var pathParamName = item.slice(1, -1);
                        var pathParam = pathParameters_1[pathParamName];
                        if (pathParam === null ||
                            pathParam === undefined ||
                            !(typeof pathParam === "string" || typeof pathParam === "object")) {
                            var stringifiedPathParameters = JSON.stringify(pathParameters_1, undefined, 2);
                            throw new Error("pathTemplate: " + pathTemplate_1 + " contains the path parameter " + pathParamName +
                                (" however, it is not present in parameters: " + stringifiedPathParameters + ".") +
                                ("The value of the path parameter can either be a \"string\" of the form { " + pathParamName + ": \"some sample value\" } or ") +
                                ("it can be an \"object\" of the form { \"" + pathParamName + "\": { value: \"some sample value\", skipUrlEncoding: true } }."));
                        }
                        if (typeof pathParam.valueOf() === "string") {
                            url_1 = url_1.replace(item, encodeURIComponent(pathParam));
                        }
                        if (typeof pathParam.valueOf() === "object") {
                            if (!pathParam.value) {
                                throw new Error("options.pathParameters[" + pathParamName + "] is of type \"object\" but it does not contain a \"value\" property.");
                            }
                            if (pathParam.skipUrlEncoding) {
                                url_1 = url_1.replace(item, pathParam.value);
                            }
                            else {
                                url_1 = url_1.replace(item, encodeURIComponent(pathParam.value));
                            }
                        }
                    });
                }
                this.url = url_1;
            }
            // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.
            if (options.queryParameters) {
                var queryParameters = options.queryParameters;
                if (typeof queryParameters !== "object") {
                    throw new Error("options.queryParameters must be of type object. It should be a JSON object " +
                        "of \"query-parameter-name\" as the key and the \"query-parameter-value\" as the value. " +
                        "The \"query-parameter-value\" may be fo type \"string\" or an \"object\" of the form { value: \"query-parameter-value\", skipUrlEncoding: true }.");
                }
                // append question mark if it is not present in the url
                if (this.url && this.url.indexOf("?") === -1) {
                    this.url += "?";
                }
                // construct queryString
                var queryParams = [];
                // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().
                this.query = {};
                for (var queryParamName in queryParameters) {
                    var queryParam = queryParameters[queryParamName];
                    if (queryParam) {
                        if (typeof queryParam === "string") {
                            queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam));
                            this.query[queryParamName] = encodeURIComponent(queryParam);
                        }
                        else if (typeof queryParam === "object") {
                            if (!queryParam.value) {
                                throw new Error("options.queryParameters[" + queryParamName + "] is of type \"object\" but it does not contain a \"value\" property.");
                            }
                            if (queryParam.skipUrlEncoding) {
                                queryParams.push(queryParamName + "=" + queryParam.value);
                                this.query[queryParamName] = queryParam.value;
                            }
                            else {
                                queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value));
                                this.query[queryParamName] = encodeURIComponent(queryParam.value);
                            }
                        }
                    }
                } // end-of-for
                // append the queryString
                this.url += queryParams.join("&");
            }
            // add headers to the request if they are provided
            if (options.headers) {
                var headers = options.headers;
                for (var _i = 0, _a = Object.keys(options.headers); _i < _a.length; _i++) {
                    var headerName = _a[_i];
                    this.headers.set(headerName, headers[headerName]);
                }
            }
            // ensure accept-language is set correctly
            if (!this.headers.get("accept-language")) {
                this.headers.set("accept-language", "en-US");
            }
            // ensure the request-id is set correctly
            if (!this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId) {
                this.headers.set("x-ms-client-request-id", generateUuid());
            }
            // default
            if (!this.headers.get("Content-Type")) {
                this.headers.set("Content-Type", "application/json; charset=utf-8");
            }
            // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicilty
            this.body = options.body;
            if (options.body != undefined) {
                // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.
                if (options.bodyIsStream) {
                    if (!this.headers.get("Transfer-Encoding")) {
                        this.headers.set("Transfer-Encoding", "chunked");
                    }
                    if (this.headers.get("Content-Type") !== "application/octet-stream") {
                        this.headers.set("Content-Type", "application/octet-stream");
                    }
                }
                else {
                    if (options.serializationMapper) {
                        this.body = new Serializer(options.mappers).serialize(options.serializationMapper, options.body, "requestBody");
                    }
                    if (!options.disableJsonStringifyOnBody) {
                        this.body = JSON.stringify(options.body);
                    }
                }
            }
            this.abortSignal = options.abortSignal;
            this.onDownloadProgress = options.onDownloadProgress;
            this.onUploadProgress = options.onUploadProgress;
            return this;
        };
        /**
         * Clone this WebResource HTTP request object.
         * @returns {WebResource} The clone of this WebResource HTTP request object.
         */
        WebResource.prototype.clone = function () {
            var result = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive);
            if (this.formData) {
                result.formData = this.formData;
            }
            if (this.operationSpec) {
                result.operationSpec = this.operationSpec;
            }
            if (this.shouldDeserialize) {
                result.shouldDeserialize = this.shouldDeserialize;
            }
            if (this.operationResponseGetter) {
                result.operationResponseGetter = this.operationResponseGetter;
            }
            return result;
        };
        return WebResource;
    }());

    // Copyright (c) Microsoft Corporation.
    var RestError = /** @class */ (function (_super) {
        __extends(RestError, _super);
        function RestError(message, code, statusCode, request, response, body) {
            var _this = _super.call(this, message) || this;
            _this.code = code;
            _this.statusCode = statusCode;
            _this.request = request;
            _this.response = response;
            _this.body = body;
            Object.setPrototypeOf(_this, RestError.prototype);
            return _this;
        }
        RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
        RestError.REQUEST_ABORTED_ERROR = "REQUEST_ABORTED_ERROR";
        RestError.PARSE_ERROR = "PARSE_ERROR";
        return RestError;
    }(Error));

    // Copyright (c) Microsoft Corporation.
    /**
     * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.
     */
    var XhrHttpClient = /** @class */ (function () {
        function XhrHttpClient() {
        }
        XhrHttpClient.prototype.sendRequest = function (request) {
            var xhr = new XMLHttpRequest();
            if (request.proxySettings) {
                throw new Error("HTTP proxy is not supported in browser environment");
            }
            var abortSignal = request.abortSignal;
            if (abortSignal) {
                var listener_1 = function () {
                    xhr.abort();
                };
                abortSignal.addEventListener("abort", listener_1);
                xhr.addEventListener("readystatechange", function () {
                    if (xhr.readyState === XMLHttpRequest.DONE) {
                        abortSignal.removeEventListener("abort", listener_1);
                    }
                });
            }
            addProgressListener(xhr.upload, request.onUploadProgress);
            addProgressListener(xhr, request.onDownloadProgress);
            if (request.formData) {
                var formData = request.formData;
                var requestForm_1 = new FormData();
                var appendFormValue = function (key, value) {
                    if (value && value.hasOwnProperty("value") && value.hasOwnProperty("options")) {
                        requestForm_1.append(key, value.value, value.options);
                    }
                    else {
                        requestForm_1.append(key, value);
                    }
                };
                for (var _i = 0, _a = Object.keys(formData); _i < _a.length; _i++) {
                    var formKey = _a[_i];
                    var formValue = formData[formKey];
                    if (Array.isArray(formValue)) {
                        for (var j = 0; j < formValue.length; j++) {
                            appendFormValue(formKey, formValue[j]);
                        }
                    }
                    else {
                        appendFormValue(formKey, formValue);
                    }
                }
                request.body = requestForm_1;
                request.formData = undefined;
                var contentType = request.headers.get("Content-Type");
                if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
                    // browser will automatically apply a suitable content-type header
                    request.headers.remove("Content-Type");
                }
            }
            xhr.open(request.method, request.url);
            xhr.timeout = request.timeout;
            xhr.withCredentials = request.withCredentials;
            for (var _b = 0, _c = request.headers.headersArray(); _b < _c.length; _b++) {
                var header = _c[_b];
                xhr.setRequestHeader(header.name, header.value);
            }
            xhr.responseType = request.streamResponseBody ? "blob" : "text";
            // tslint:disable-next-line:no-null-keyword
            xhr.send(request.body === undefined ? null : request.body);
            if (request.streamResponseBody) {
                return new Promise(function (resolve, reject) {
                    xhr.addEventListener("readystatechange", function () {
                        // Resolve as soon as headers are loaded
                        if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                            var blobBody = new Promise(function (resolve, reject) {
                                xhr.addEventListener("load", function () {
                                    resolve(xhr.response);
                                });
                                rejectOnTerminalEvent(request, xhr, reject);
                            });
                            resolve({
                                request: request,
                                status: xhr.status,
                                headers: parseHeaders(xhr),
                                blobBody: blobBody
                            });
                        }
                    });
                    rejectOnTerminalEvent(request, xhr, reject);
                });
            }
            else {
                return new Promise(function (resolve, reject) {
                    xhr.addEventListener("load", function () { return resolve({
                        request: request,
                        status: xhr.status,
                        headers: parseHeaders(xhr),
                        bodyAsText: xhr.responseText
                    }); });
                    rejectOnTerminalEvent(request, xhr, reject);
                });
            }
        };
        return XhrHttpClient;
    }());
    function addProgressListener(xhr, listener) {
        if (listener) {
            xhr.addEventListener("progress", function (rawEvent) { return listener({
                loadedBytes: rawEvent.loaded
            }); });
        }
    }
    // exported locally for testing
    function parseHeaders(xhr) {
        var responseHeaders = new HttpHeaders();
        var headerLines = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/);
        for (var _i = 0, headerLines_1 = headerLines; _i < headerLines_1.length; _i++) {
            var line = headerLines_1[_i];
            var index = line.indexOf(":");
            var headerName = line.slice(0, index);
            var headerValue = line.slice(index + 2);
            responseHeaders.set(headerName, headerValue);
        }
        return responseHeaders;
    }
    function rejectOnTerminalEvent(request, xhr, reject) {
        xhr.addEventListener("error", function () { return reject(new RestError("Failed to send request to " + request.url, RestError.REQUEST_SEND_ERROR, undefined, request)); });
        xhr.addEventListener("abort", function () { return reject(new RestError("The request was aborted", RestError.REQUEST_ABORTED_ERROR, undefined, request)); });
        xhr.addEventListener("timeout", function () { return reject(new RestError("timeout of " + xhr.timeout + "ms exceeded", RestError.REQUEST_SEND_ERROR, undefined, request)); });
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    /**
     * The different levels of logs that can be used with the HttpPipelineLogger.
     */
    var HttpPipelineLogLevel;
    (function (HttpPipelineLogLevel) {
        /**
         * A log level that indicates that no logs will be logged.
         */
        HttpPipelineLogLevel[HttpPipelineLogLevel["OFF"] = 0] = "OFF";
        /**
         * An error log.
         */
        HttpPipelineLogLevel[HttpPipelineLogLevel["ERROR"] = 1] = "ERROR";
        /**
         * A warning log.
         */
        HttpPipelineLogLevel[HttpPipelineLogLevel["WARNING"] = 2] = "WARNING";
        /**
         * An information log.
         */
        HttpPipelineLogLevel[HttpPipelineLogLevel["INFO"] = 3] = "INFO";
    })(HttpPipelineLogLevel || (HttpPipelineLogLevel = {}));

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    /**
     * Tests an object to determine whether it implements TokenCredential.
     *
     * @param credential The assumed TokenCredential to be tested.
     */
    function isTokenCredential(credential) {
        // Check for an object with a 'getToken' function and possibly with
        // a 'signRequest' function.  We do this check to make sure that
        // a ServiceClientCredentials implementor (like TokenClientCredentials
        // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
        // it doesn't actually implement TokenCredential also.
        return credential
            && typeof credential.getToken === "function"
            && (credential.signRequest === undefined || credential.getToken.length > 0);
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    /**
     * Get the path to this parameter's value as a dotted string (a.b.c).
     * @param parameter The parameter to get the path string for.
     * @returns The path to this parameter's value as a dotted string.
     */
    function getPathStringFromParameter(parameter) {
        return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
    }
    function getPathStringFromParameterPath(parameterPath, mapper) {
        var result;
        if (typeof parameterPath === "string") {
            result = parameterPath;
        }
        else if (Array.isArray(parameterPath)) {
            result = parameterPath.join(".");
        }
        else {
            result = mapper.serializedName;
        }
        return result;
    }

    // Copyright (c) Microsoft Corporation.
    function isStreamOperation(operationSpec) {
        var result = false;
        for (var statusCode in operationSpec.responses) {
            var operationResponse = operationSpec.responses[statusCode];
            if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperType.Stream) {
                result = true;
                break;
            }
        }
        return result;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    var parser = new DOMParser();
    function parseXML(str) {
        try {
            var dom = parser.parseFromString(str, "application/xml");
            throwIfError(dom);
            var obj = domToObject(dom.childNodes[0]);
            return Promise.resolve(obj);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    var errorNS = "";
    try {
        errorNS = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0]
            .namespaceURI;
    }
    catch (ignored) {
        // Most browsers will return a document containing <parsererror>, but IE will throw.
    }
    function throwIfError(dom) {
        if (errorNS) {
            var parserErrors = dom.getElementsByTagNameNS(errorNS, "parsererror");
            if (parserErrors.length) {
                throw new Error(parserErrors.item(0).innerHTML);
            }
        }
    }
    function isElement(node) {
        return !!node.attributes;
    }
    /**
     * Get the Element-typed version of the provided Node if the provided node is an element with
     * attributes. If it isn't, then undefined is returned.
     */
    function asElementWithAttributes(node) {
        return isElement(node) && node.hasAttributes() ? node : undefined;
    }
    function domToObject(node) {
        var result = {};
        var childNodeCount = node.childNodes.length;
        var firstChildNode = node.childNodes[0];
        var onlyChildTextValue = (firstChildNode &&
            childNodeCount === 1 &&
            firstChildNode.nodeType === Node.TEXT_NODE &&
            firstChildNode.nodeValue) ||
            undefined;
        var elementWithAttributes = asElementWithAttributes(node);
        if (elementWithAttributes) {
            result["$"] = {};
            for (var i = 0; i < elementWithAttributes.attributes.length; i++) {
                var attr = elementWithAttributes.attributes[i];
                result["$"][attr.nodeName] = attr.nodeValue;
            }
            if (onlyChildTextValue) {
                result["_"] = onlyChildTextValue;
            }
        }
        else if (childNodeCount === 0) {
            result = "";
        }
        else if (onlyChildTextValue) {
            result = onlyChildTextValue;
        }
        if (!onlyChildTextValue) {
            for (var i = 0; i < childNodeCount; i++) {
                var child = node.childNodes[i];
                // Ignore leading/trailing whitespace nodes
                if (child.nodeType !== Node.TEXT_NODE) {
                    var childObject = domToObject(child);
                    if (!result[child.nodeName]) {
                        result[child.nodeName] = childObject;
                    }
                    else if (Array.isArray(result[child.nodeName])) {
                        result[child.nodeName].push(childObject);
                    }
                    else {
                        result[child.nodeName] = [result[child.nodeName], childObject];
                    }
                }
            }
        }
        return result;
    }
    // tslint:disable-next-line:no-null-keyword
    var doc = document.implementation.createDocument(null, null, null);
    var serializer = new XMLSerializer();
    function stringifyXML(obj, opts) {
        var rootName = (opts && opts.rootName) || "root";
        var dom = buildNode(obj, rootName)[0];
        return ('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + serializer.serializeToString(dom));
    }
    function buildAttributes(attrs) {
        var result = [];
        for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {
            var key = _a[_i];
            var attr = doc.createAttribute(key);
            attr.value = attrs[key].toString();
            result.push(attr);
        }
        return result;
    }
    function buildNode(obj, elementName) {
        if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
            var elem = doc.createElement(elementName);
            elem.textContent = obj.toString();
            return [elem];
        }
        else if (Array.isArray(obj)) {
            var result = [];
            for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {
                var arrayElem = obj_1[_i];
                for (var _a = 0, _b = buildNode(arrayElem, elementName); _a < _b.length; _a++) {
                    var child = _b[_a];
                    result.push(child);
                }
            }
            return result;
        }
        else if (typeof obj === "object") {
            var elem = doc.createElement(elementName);
            for (var _c = 0, _d = Object.keys(obj); _c < _d.length; _c++) {
                var key = _d[_c];
                if (key === "$") {
                    for (var _e = 0, _f = buildAttributes(obj[key]); _e < _f.length; _e++) {
                        var attr = _f[_e];
                        elem.attributes.setNamedItem(attr);
                    }
                }
                else {
                    for (var _g = 0, _h = buildNode(obj[key], key); _g < _h.length; _g++) {
                        var child = _h[_g];
                        elem.appendChild(child);
                    }
                }
            }
            return [elem];
        }
        else {
            throw new Error("Illegal value passed to buildObject: " + obj);
        }
    }

    // Copyright (c) Microsoft Corporation.
    var BaseRequestPolicy = /** @class */ (function () {
        function BaseRequestPolicy(_nextPolicy, _options) {
            this._nextPolicy = _nextPolicy;
            this._options = _options;
        }
        /**
         * Get whether or not a log with the provided log level should be logged.
         * @param logLevel The log level of the log that will be logged.
         * @returns Whether or not a log with the provided log level should be logged.
         */
        BaseRequestPolicy.prototype.shouldLog = function (logLevel) {
            return this._options.shouldLog(logLevel);
        };
        /**
         * Attempt to log the provided message to the provided logger. If no logger was provided or if
         * the log level does not meat the logger's threshold, then nothing will be logged.
         * @param logLevel The log level of this log.
         * @param message The message of this log.
         */
        BaseRequestPolicy.prototype.log = function (logLevel, message) {
            this._options.log(logLevel, message);
        };
        return BaseRequestPolicy;
    }());
    /**
     * Optional properties that can be used when creating a RequestPolicy.
     */
    var RequestPolicyOptions = /** @class */ (function () {
        function RequestPolicyOptions(_logger) {
            this._logger = _logger;
        }
        /**
         * Get whether or not a log with the provided log level should be logged.
         * @param logLevel The log level of the log that will be logged.
         * @returns Whether or not a log with the provided log level should be logged.
         */
        RequestPolicyOptions.prototype.shouldLog = function (logLevel) {
            return !!this._logger &&
                logLevel !== HttpPipelineLogLevel.OFF &&
                logLevel <= this._logger.minimumLogLevel;
        };
        /**
         * Attempt to log the provided message to the provided logger. If no logger was provided or if
         * the log level does not meat the logger's threshold, then nothing will be logged.
         * @param logLevel The log level of this log.
         * @param message The message of this log.
         */
        RequestPolicyOptions.prototype.log = function (logLevel, message) {
            if (this._logger && this.shouldLog(logLevel)) {
                this._logger.log(logLevel, message);
            }
        };
        return RequestPolicyOptions;
    }());

    // Copyright (c) Microsoft Corporation.
    /**
     * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they
     * pass through the HTTP pipeline.
     */
    function deserializationPolicy(deserializationContentTypes) {
        return {
            create: function (nextPolicy, options) {
                return new DeserializationPolicy(nextPolicy, deserializationContentTypes, options);
            }
        };
    }
    var defaultJsonContentTypes = ["application/json", "text/json", "text/plain"];
    var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    /**
     * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the
     * HTTP pipeline.
     */
    var DeserializationPolicy = /** @class */ (function (_super) {
        __extends(DeserializationPolicy, _super);
        function DeserializationPolicy(nextPolicy, deserializationContentTypes, options) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes;
            _this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes;
            return _this;
        }
        DeserializationPolicy.prototype.sendRequest = function (request) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, this._nextPolicy.sendRequest(request).then(function (response) { return deserializeResponseBody(_this.jsonContentTypes, _this.xmlContentTypes, response); })];
                });
            });
        };
        return DeserializationPolicy;
    }(BaseRequestPolicy));
    function getOperationResponse(parsedResponse) {
        var result;
        var request = parsedResponse.request;
        var operationSpec = request.operationSpec;
        if (operationSpec) {
            var operationResponseGetter = request.operationResponseGetter;
            if (!operationResponseGetter) {
                result = operationSpec.responses[parsedResponse.status];
            }
            else {
                result = operationResponseGetter(operationSpec, parsedResponse);
            }
        }
        return result;
    }
    function shouldDeserializeResponse(parsedResponse) {
        var shouldDeserialize = parsedResponse.request.shouldDeserialize;
        var result;
        if (shouldDeserialize === undefined) {
            result = true;
        }
        else if (typeof shouldDeserialize === "boolean") {
            result = shouldDeserialize;
        }
        else {
            result = shouldDeserialize(parsedResponse);
        }
        return result;
    }
    function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response) {
        return parse(jsonContentTypes, xmlContentTypes, response).then(function (parsedResponse) {
            var shouldDeserialize = shouldDeserializeResponse(parsedResponse);
            if (shouldDeserialize) {
                var operationSpec = parsedResponse.request.operationSpec;
                if (operationSpec && operationSpec.responses) {
                    var statusCode = parsedResponse.status;
                    var expectedStatusCodes = Object.keys(operationSpec.responses);
                    var hasNoExpectedStatusCodes = (expectedStatusCodes.length === 0 || (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default"));
                    var responseSpec = getOperationResponse(parsedResponse);
                    var isExpectedStatusCode = hasNoExpectedStatusCodes ? (200 <= statusCode && statusCode < 300) : !!responseSpec;
                    if (!isExpectedStatusCode) {
                        var defaultResponseSpec = operationSpec.responses.default;
                        if (defaultResponseSpec) {
                            var initialErrorMessage = isStreamOperation(operationSpec)
                                ? "Unexpected status code: " + statusCode
                                : parsedResponse.bodyAsText;
                            var error = new RestError(initialErrorMessage);
                            error.statusCode = statusCode;
                            error.request = stripRequest(parsedResponse.request);
                            error.response = stripResponse(parsedResponse);
                            var parsedErrorResponse = parsedResponse.parsedBody;
                            try {
                                if (parsedErrorResponse) {
                                    var defaultResponseBodyMapper = defaultResponseSpec.bodyMapper;
                                    if (defaultResponseBodyMapper && defaultResponseBodyMapper.serializedName === "CloudError") {
                                        if (parsedErrorResponse.error) {
                                            parsedErrorResponse = parsedErrorResponse.error;
                                        }
                                        if (parsedErrorResponse.code) {
                                            error.code = parsedErrorResponse.code;
                                        }
                                        if (parsedErrorResponse.message) {
                                            error.message = parsedErrorResponse.message;
                                        }
                                    }
                                    else {
                                        var internalError = parsedErrorResponse;
                                        if (parsedErrorResponse.error) {
                                            internalError = parsedErrorResponse.error;
                                        }
                                        error.code = internalError.code;
                                        if (internalError.message) {
                                            error.message = internalError.message;
                                        }
                                    }
                                    if (defaultResponseBodyMapper) {
                                        var valueToDeserialize = parsedErrorResponse;
                                        if (operationSpec.isXML && defaultResponseBodyMapper.type.name === MapperType.Sequence) {
                                            valueToDeserialize = typeof parsedErrorResponse === "object"
                                                ? parsedErrorResponse[defaultResponseBodyMapper.xmlElementName]
                                                : [];
                                        }
                                        error.body = operationSpec.serializer.deserialize(defaultResponseBodyMapper, valueToDeserialize, "error.body");
                                    }
                                }
                            }
                            catch (defaultError) {
                                error.message = "Error \"" + defaultError.message + "\" occurred in deserializing the responseBody - \"" + parsedResponse.bodyAsText + "\" for the default response.";
                            }
                            return Promise.reject(error);
                        }
                    }
                    else if (responseSpec) {
                        if (responseSpec.bodyMapper) {
                            var valueToDeserialize = parsedResponse.parsedBody;
                            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {
                                valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
                            }
                            try {
                                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody");
                            }
                            catch (error) {
                                var restError = new RestError("Error " + error + " occurred in deserializing the responseBody - " + parsedResponse.bodyAsText);
                                restError.request = stripRequest(parsedResponse.request);
                                restError.response = stripResponse(parsedResponse);
                                return Promise.reject(restError);
                            }
                        }
                        else if (operationSpec.httpMethod === "HEAD") {
                            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
                            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
                        }
                        if (responseSpec.headersMapper) {
                            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders");
                        }
                    }
                }
            }
            return Promise.resolve(parsedResponse);
        });
    }
    function parse(jsonContentTypes, xmlContentTypes, operationResponse) {
        var errorHandler = function (err) {
            var msg = "Error \"" + err + "\" occurred while parsing the response body - " + operationResponse.bodyAsText + ".";
            var errCode = err.code || RestError.PARSE_ERROR;
            var e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse, operationResponse.bodyAsText);
            return Promise.reject(e);
        };
        if (!operationResponse.request.streamResponseBody && operationResponse.bodyAsText) {
            var text_1 = operationResponse.bodyAsText;
            var contentType = operationResponse.headers.get("Content-Type") || "";
            var contentComponents = !contentType ? [] : contentType.split(";").map(function (component) { return component.toLowerCase(); });
            if (contentComponents.length === 0 || contentComponents.some(function (component) { return jsonContentTypes.indexOf(component) !== -1; })) {
                return new Promise(function (resolve) {
                    operationResponse.parsedBody = JSON.parse(text_1);
                    resolve(operationResponse);
                }).catch(errorHandler);
            }
            else if (contentComponents.some(function (component) { return xmlContentTypes.indexOf(component) !== -1; })) {
                return parseXML(text_1)
                    .then(function (body) {
                    operationResponse.parsedBody = body;
                    return operationResponse;
                })
                    .catch(errorHandler);
            }
        }
        return Promise.resolve(operationResponse);
    }

    // Copyright (c) Microsoft Corporation.
    function exponentialRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        return {
            create: function (nextPolicy, options) {
                return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
            }
        };
    }
    var DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;
    var DEFAULT_CLIENT_RETRY_COUNT = 3;
    var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;
    var DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;
    /**
     * @class
     * Instantiates a new "ExponentialRetryPolicyFilter" instance.
     */
    var ExponentialRetryPolicy = /** @class */ (function (_super) {
        __extends(ExponentialRetryPolicy, _super);
        /**
         * @constructor
         * @param {RequestPolicy} nextPolicy The next RequestPolicy in the pipeline chain.
         * @param {RequestPolicyOptions} options The options for this RequestPolicy.
         * @param {number} [retryCount]        The client retry count.
         * @param {number} [retryInterval]     The client retry interval, in milliseconds.
         * @param {number} [minRetryInterval]  The minimum retry interval, in milliseconds.
         * @param {number} [maxRetryInterval]  The maximum retry interval, in milliseconds.
         */
        function ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
            var _this = _super.call(this, nextPolicy, options) || this;
            function isNumber(n) { return typeof n === "number"; }
            _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
            _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
            _this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
            _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
            return _this;
        }
        ExponentialRetryPolicy.prototype.sendRequest = function (request) {
            var _this = this;
            return this._nextPolicy.sendRequest(request.clone())
                .then(function (response) { return retry(_this, request, response); })
                .catch(function (error) { return retry(_this, request, error.response, undefined, error); });
        };
        return ExponentialRetryPolicy;
    }(BaseRequestPolicy));
    /**
     * Determines if the operation should be retried and how long to wait until the next retry.
     *
     * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.
     * @param {number} statusCode The HTTP status code.
     * @param {RetryData} retryData  The retry data.
     * @return {boolean} True if the operation qualifies for a retry; false otherwise.
     */
    function shouldRetry(policy, statusCode, retryData) {
        if (statusCode == undefined || (statusCode < 500 && statusCode !== 408) || statusCode === 501 || statusCode === 505) {
            return false;
        }
        var currentCount;
        if (!retryData) {
            throw new Error("retryData for the ExponentialRetryPolicyFilter cannot be null.");
        }
        else {
            currentCount = (retryData && retryData.retryCount);
        }
        return (currentCount < policy.retryCount);
    }
    /**
     * Updates the retry data for the next attempt.
     *
     * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.
     * @param {RetryData} retryData  The retry data.
     * @param {RetryError} [err] The operation"s error, if any.
     */
    function updateRetryData(policy, retryData, err) {
        if (!retryData) {
            retryData = {
                retryCount: 0,
                retryInterval: 0
            };
        }
        if (err) {
            if (retryData.error) {
                err.innerError = retryData.error;
            }
            retryData.error = err;
        }
        // Adjust retry count
        retryData.retryCount++;
        // Adjust retry interval
        var incrementDelta = Math.pow(2, retryData.retryCount) - 1;
        var boundedRandDelta = policy.retryInterval * 0.8 +
            Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));
        incrementDelta *= boundedRandDelta;
        retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);
        return retryData;
    }
    function retry(policy, request, response, retryData, requestError) {
        retryData = updateRetryData(policy, retryData, requestError);
        var isAborted = request.abortSignal && request.abortSignal.aborted;
        if (!isAborted && shouldRetry(policy, response && response.status, retryData)) {
            return delay(retryData.retryInterval)
                .then(function () { return policy._nextPolicy.sendRequest(request.clone()); })
                .then(function (res) { return retry(policy, request, res, retryData, undefined); })
                .catch(function (err) { return retry(policy, request, response, retryData, err); });
        }
        else if (isAborted || requestError || !response) {
            // If the operation failed in the end, return all errors instead of just the last one
            var err = retryData.error ||
                new RestError("Failed to send the request.", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);
            return Promise.reject(err);
        }
        else {
            return Promise.resolve(response);
        }
    }

    // Copyright (c) Microsoft Corporation.
    function generateClientRequestIdPolicy(requestIdHeaderName) {
        if (requestIdHeaderName === void 0) { requestIdHeaderName = "x-ms-client-request-id"; }
        return {
            create: function (nextPolicy, options) {
                return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);
            }
        };
    }
    var GenerateClientRequestIdPolicy = /** @class */ (function (_super) {
        __extends(GenerateClientRequestIdPolicy, _super);
        function GenerateClientRequestIdPolicy(nextPolicy, options, _requestIdHeaderName) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this._requestIdHeaderName = _requestIdHeaderName;
            return _this;
        }
        GenerateClientRequestIdPolicy.prototype.sendRequest = function (request) {
            if (!request.headers.contains(this._requestIdHeaderName)) {
                request.headers.set(this._requestIdHeaderName, generateUuid());
            }
            return this._nextPolicy.sendRequest(request);
        };
        return GenerateClientRequestIdPolicy;
    }(BaseRequestPolicy));

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    function getDefaultUserAgentKey() {
        return "x-ms-command-name";
    }
    function getPlatformSpecificData() {
        var navigator = window.navigator;
        var osInfo = {
            key: "OS",
            value: (navigator.oscpu || navigator.platform).replace(" ", "")
        };
        return [osInfo];
    }

    // Copyright (c) Microsoft Corporation.
    function getRuntimeInfo() {
        var msRestRuntime = {
            key: "core-http",
            value: Constants.coreHttpVersion
        };
        return [msRestRuntime];
    }
    function getUserAgentString(telemetryInfo, keySeparator, valueSeparator) {
        if (keySeparator === void 0) { keySeparator = " "; }
        if (valueSeparator === void 0) { valueSeparator = "/"; }
        return telemetryInfo.map(function (info) {
            var value = info.value ? "" + valueSeparator + info.value : "";
            return "" + info.key + value;
        }).join(keySeparator);
    }
    var getDefaultUserAgentHeaderName = getDefaultUserAgentKey;
    function getDefaultUserAgentValue() {
        var runtimeInfo = getRuntimeInfo();
        var platformSpecificData = getPlatformSpecificData();
        var userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
        return userAgent;
    }
    function userAgentPolicy(userAgentData) {
        var key = (!userAgentData || userAgentData.key == undefined) ? getDefaultUserAgentKey() : userAgentData.key;
        var value = (!userAgentData || userAgentData.value == undefined) ? getDefaultUserAgentValue() : userAgentData.value;
        return {
            create: function (nextPolicy, options) {
                return new UserAgentPolicy(nextPolicy, options, key, value);
            }
        };
    }
    var UserAgentPolicy = /** @class */ (function (_super) {
        __extends(UserAgentPolicy, _super);
        function UserAgentPolicy(_nextPolicy, _options, headerKey, headerValue) {
            var _this = _super.call(this, _nextPolicy, _options) || this;
            _this._nextPolicy = _nextPolicy;
            _this._options = _options;
            _this.headerKey = headerKey;
            _this.headerValue = headerValue;
            return _this;
        }
        UserAgentPolicy.prototype.sendRequest = function (request) {
            this.addUserAgentHeader(request);
            return this._nextPolicy.sendRequest(request);
        };
        UserAgentPolicy.prototype.addUserAgentHeader = function (request) {
            if (!request.headers) {
                request.headers = new HttpHeaders();
            }
            if (!request.headers.get(this.headerKey) && this.headerValue) {
                request.headers.set(this.headerKey, this.headerValue);
            }
        };
        return UserAgentPolicy;
    }(BaseRequestPolicy));

    // Copyright (c) Microsoft Corporation.
    /**
     * A class that handles the query portion of a URLBuilder.
     */
    var URLQuery = /** @class */ (function () {
        function URLQuery() {
            this._rawQuery = {};
        }
        /**
         * Get whether or not there any query parameters in this URLQuery.
         */
        URLQuery.prototype.any = function () {
            return Object.keys(this._rawQuery).length > 0;
        };
        /**
         * Set a query parameter with the provided name and value. If the parameterValue is undefined or
         * empty, then this will attempt to remove an existing query parameter with the provided
         * parameterName.
         */
        URLQuery.prototype.set = function (parameterName, parameterValue) {
            if (parameterName) {
                if (parameterValue != undefined) {
                    var newValue = Array.isArray(parameterValue) ? parameterValue : parameterValue.toString();
                    this._rawQuery[parameterName] = newValue;
                }
                else {
                    delete this._rawQuery[parameterName];
                }
            }
        };
        /**
         * Get the value of the query parameter with the provided name. If no parameter exists with the
         * provided parameter name, then undefined will be returned.
         */
        URLQuery.prototype.get = function (parameterName) {
            return parameterName ? this._rawQuery[parameterName] : undefined;
        };
        /**
         * Get the string representation of this query. The return value will not start with a "?".
         */
        URLQuery.prototype.toString = function () {
            var result = "";
            for (var parameterName in this._rawQuery) {
                if (result) {
                    result += "&";
                }
                var parameterValue = this._rawQuery[parameterName];
                if (Array.isArray(parameterValue)) {
                    var parameterStrings = [];
                    for (var _i = 0, parameterValue_1 = parameterValue; _i < parameterValue_1.length; _i++) {
                        var parameterValueElement = parameterValue_1[_i];
                        parameterStrings.push(parameterName + "=" + parameterValueElement);
                    }
                    result += parameterStrings.join("&");
                }
                else {
                    result += parameterName + "=" + parameterValue;
                }
            }
            return result;
        };
        /**
         * Parse a URLQuery from the provided text.
         */
        URLQuery.parse = function (text) {
            var result = new URLQuery();
            if (text) {
                if (text.startsWith("?")) {
                    text = text.substring(1);
                }
                var currentState = "ParameterName";
                var parameterName = "";
                var parameterValue = "";
                for (var i = 0; i < text.length; ++i) {
                    var currentCharacter = text[i];
                    switch (currentState) {
                        case "ParameterName":
                            switch (currentCharacter) {
                                case "=":
                                    currentState = "ParameterValue";
                                    break;
                                case "&":
                                    parameterName = "";
                                    parameterValue = "";
                                    break;
                                default:
                                    parameterName += currentCharacter;
                                    break;
                            }
                            break;
                        case "ParameterValue":
                            switch (currentCharacter) {
                                case "=":
                                    parameterName = "";
                                    parameterValue = "";
                                    currentState = "Invalid";
                                    break;
                                case "&":
                                    result.set(parameterName, parameterValue);
                                    parameterName = "";
                                    parameterValue = "";
                                    currentState = "ParameterName";
                                    break;
                                default:
                                    parameterValue += currentCharacter;
                                    break;
                            }
                            break;
                        case "Invalid":
                            if (currentCharacter === "&") {
                                currentState = "ParameterName";
                            }
                            break;
                        default:
                            throw new Error("Unrecognized URLQuery parse state: " + currentState);
                    }
                }
                if (currentState === "ParameterValue") {
                    result.set(parameterName, parameterValue);
                }
            }
            return result;
        };
        return URLQuery;
    }());
    /**
     * A class that handles creating, modifying, and parsing URLs.
     */
    var URLBuilder = /** @class */ (function () {
        function URLBuilder() {
        }
        /**
         * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL
         * (such as a host, port, path, or query), those parts will be added to this URL as well.
         */
        URLBuilder.prototype.setScheme = function (scheme) {
            if (!scheme) {
                this._scheme = undefined;
            }
            else {
                this.set(scheme, "SCHEME");
            }
        };
        /**
         * Get the scheme that has been set in this URL.
         */
        URLBuilder.prototype.getScheme = function () {
            return this._scheme;
        };
        /**
         * Set the host for this URL. If the provided host contains other parts of a URL (such as a
         * port, path, or query), those parts will be added to this URL as well.
         */
        URLBuilder.prototype.setHost = function (host) {
            if (!host) {
                this._host = undefined;
            }
            else {
                this.set(host, "SCHEME_OR_HOST");
            }
        };
        /**
         * Get the host that has been set in this URL.
         */
        URLBuilder.prototype.getHost = function () {
            return this._host;
        };
        /**
         * Set the port for this URL. If the provided port contains other parts of a URL (such as a
         * path or query), those parts will be added to this URL as well.
         */
        URLBuilder.prototype.setPort = function (port) {
            if (port == undefined || port === "") {
                this._port = undefined;
            }
            else {
                this.set(port.toString(), "PORT");
            }
        };
        /**
         * Get the port that has been set in this URL.
         */
        URLBuilder.prototype.getPort = function () {
            return this._port;
        };
        /**
         * Set the path for this URL. If the provided path contains a query, then it will be added to
         * this URL as well.
         */
        URLBuilder.prototype.setPath = function (path) {
            if (!path) {
                this._path = undefined;
            }
            else {
                if (path.indexOf("://") !== -1) {
                    this.set(path, "SCHEME");
                }
                else {
                    this.set(path, "PATH");
                }
            }
        };
        /**
         * Append the provided path to this URL's existing path. If the provided path contains a query,
         * then it will be added to this URL as well.
         */
        URLBuilder.prototype.appendPath = function (path) {
            if (path) {
                var currentPath = this.getPath();
                if (currentPath) {
                    if (!currentPath.endsWith("/")) {
                        currentPath += "/";
                    }
                    if (path.startsWith("/")) {
                        path = path.substring(1);
                    }
                    path = currentPath + path;
                }
                this.set(path, "PATH");
            }
        };
        /**
         * Get the path that has been set in this URL.
         */
        URLBuilder.prototype.getPath = function () {
            return this._path;
        };
        /**
         * Set the query in this URL.
         */
        URLBuilder.prototype.setQuery = function (query) {
            if (!query) {
                this._query = undefined;
            }
            else {
                this._query = URLQuery.parse(query);
            }
        };
        /**
         * Set a query parameter with the provided name and value in this URL's query. If the provided
         * query parameter value is undefined or empty, then the query parameter will be removed if it
         * existed.
         */
        URLBuilder.prototype.setQueryParameter = function (queryParameterName, queryParameterValue) {
            if (queryParameterName) {
                if (!this._query) {
                    this._query = new URLQuery();
                }
                this._query.set(queryParameterName, queryParameterValue);
            }
        };
        /**
         * Get the value of the query parameter with the provided query parameter name. If no query
         * parameter exists with the provided name, then undefined will be returned.
         */
        URLBuilder.prototype.getQueryParameterValue = function (queryParameterName) {
            return this._query ? this._query.get(queryParameterName) : undefined;
        };
        /**
         * Get the query in this URL.
         */
        URLBuilder.prototype.getQuery = function () {
            return this._query ? this._query.toString() : undefined;
        };
        /**
         * Set the parts of this URL by parsing the provided text using the provided startState.
         */
        URLBuilder.prototype.set = function (text, startState) {
            var tokenizer = new URLTokenizer(text, startState);
            while (tokenizer.next()) {
                var token = tokenizer.current();
                if (token) {
                    switch (token.type) {
                        case "SCHEME":
                            this._scheme = token.text || undefined;
                            break;
                        case "HOST":
                            this._host = token.text || undefined;
                            break;
                        case "PORT":
                            this._port = token.text || undefined;
                            break;
                        case "PATH":
                            var tokenPath = token.text || undefined;
                            if (!this._path || this._path === "/" || tokenPath !== "/") {
                                this._path = tokenPath;
                            }
                            break;
                        case "QUERY":
                            this._query = URLQuery.parse(token.text);
                            break;
                        default:
                            throw new Error("Unrecognized URLTokenType: " + token.type);
                    }
                }
            }
        };
        URLBuilder.prototype.toString = function () {
            var result = "";
            if (this._scheme) {
                result += this._scheme + "://";
            }
            if (this._host) {
                result += this._host;
            }
            if (this._port) {
                result += ":" + this._port;
            }
            if (this._path) {
                if (!this._path.startsWith("/")) {
                    result += "/";
                }
                result += this._path;
            }
            if (this._query && this._query.any()) {
                result += "?" + this._query.toString();
            }
            return result;
        };
        /**
         * If the provided searchValue is found in this URLBuilder, then replace it with the provided
         * replaceValue.
         */
        URLBuilder.prototype.replaceAll = function (searchValue, replaceValue) {
            if (searchValue) {
                this.setScheme(replaceAll(this.getScheme(), searchValue, replaceValue));
                this.setHost(replaceAll(this.getHost(), searchValue, replaceValue));
                this.setPort(replaceAll(this.getPort(), searchValue, replaceValue));
                this.setPath(replaceAll(this.getPath(), searchValue, replaceValue));
                this.setQuery(replaceAll(this.getQuery(), searchValue, replaceValue));
            }
        };
        URLBuilder.parse = function (text) {
            var result = new URLBuilder();
            result.set(text, "SCHEME_OR_HOST");
            return result;
        };
        return URLBuilder;
    }());
    var URLToken = /** @class */ (function () {
        function URLToken(text, type) {
            this.text = text;
            this.type = type;
        }
        URLToken.scheme = function (text) {
            return new URLToken(text, "SCHEME");
        };
        URLToken.host = function (text) {
            return new URLToken(text, "HOST");
        };
        URLToken.port = function (text) {
            return new URLToken(text, "PORT");
        };
        URLToken.path = function (text) {
            return new URLToken(text, "PATH");
        };
        URLToken.query = function (text) {
            return new URLToken(text, "QUERY");
        };
        return URLToken;
    }());
    /**
     * Get whether or not the provided character (single character string) is an alphanumeric (letter or
     * digit) character.
     */
    function isAlphaNumericCharacter(character) {
        var characterCode = character.charCodeAt(0);
        return (48 /* '0' */ <= characterCode && characterCode <= 57 /* '9' */) ||
            (65 /* 'A' */ <= characterCode && characterCode <= 90 /* 'Z' */) ||
            (97 /* 'a' */ <= characterCode && characterCode <= 122 /* 'z' */);
    }
    /**
     * A class that tokenizes URL strings.
     */
    var URLTokenizer = /** @class */ (function () {
        function URLTokenizer(_text, state) {
            this._text = _text;
            this._textLength = _text ? _text.length : 0;
            this._currentState = state != undefined ? state : "SCHEME_OR_HOST";
            this._currentIndex = 0;
        }
        /**
         * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer
         * hasn't started or has finished tokenizing.
         */
        URLTokenizer.prototype.current = function () {
            return this._currentToken;
        };
        /**
         * Advance to the next URLToken and return whether or not a URLToken was found.
         */
        URLTokenizer.prototype.next = function () {
            if (!hasCurrentCharacter(this)) {
                this._currentToken = undefined;
            }
            else {
                switch (this._currentState) {
                    case "SCHEME":
                        nextScheme(this);
                        break;
                    case "SCHEME_OR_HOST":
                        nextSchemeOrHost(this);
                        break;
                    case "HOST":
                        nextHost(this);
                        break;
                    case "PORT":
                        nextPort(this);
                        break;
                    case "PATH":
                        nextPath(this);
                        break;
                    case "QUERY":
                        nextQuery(this);
                        break;
                    default:
                        throw new Error("Unrecognized URLTokenizerState: " + this._currentState);
                }
            }
            return !!this._currentToken;
        };
        return URLTokenizer;
    }());
    /**
     * Read the remaining characters from this Tokenizer's character stream.
     */
    function readRemaining(tokenizer) {
        var result = "";
        if (tokenizer._currentIndex < tokenizer._textLength) {
            result = tokenizer._text.substring(tokenizer._currentIndex);
            tokenizer._currentIndex = tokenizer._textLength;
        }
        return result;
    }
    /**
     * Whether or not this URLTokenizer has a current character.
     */
    function hasCurrentCharacter(tokenizer) {
        return tokenizer._currentIndex < tokenizer._textLength;
    }
    /**
     * Get the character in the text string at the current index.
     */
    function getCurrentCharacter(tokenizer) {
        return tokenizer._text[tokenizer._currentIndex];
    }
    /**
     * Advance to the character in text that is "step" characters ahead. If no step value is provided,
     * then step will default to 1.
     */
    function nextCharacter(tokenizer, step) {
        if (hasCurrentCharacter(tokenizer)) {
            if (!step) {
                step = 1;
            }
            tokenizer._currentIndex += step;
        }
    }
    /**
     * Starting with the current character, peek "charactersToPeek" number of characters ahead in this
     * Tokenizer's stream of characters.
     */
    function peekCharacters(tokenizer, charactersToPeek) {
        var endIndex = tokenizer._currentIndex + charactersToPeek;
        if (tokenizer._textLength < endIndex) {
            endIndex = tokenizer._textLength;
        }
        return tokenizer._text.substring(tokenizer._currentIndex, endIndex);
    }
    /**
     * Read characters from this Tokenizer until the end of the stream or until the provided condition
     * is false when provided the current character.
     */
    function readWhile(tokenizer, condition) {
        var result = "";
        while (hasCurrentCharacter(tokenizer)) {
            var currentCharacter = getCurrentCharacter(tokenizer);
            if (!condition(currentCharacter)) {
                break;
            }
            else {
                result += currentCharacter;
                nextCharacter(tokenizer);
            }
        }
        return result;
    }
    /**
     * Read characters from this Tokenizer until a non-alphanumeric character or the end of the
     * character stream is reached.
     */
    function readWhileLetterOrDigit(tokenizer) {
        return readWhile(tokenizer, function (character) { return isAlphaNumericCharacter(character); });
    }
    /**
     * Read characters from this Tokenizer until one of the provided terminating characters is read or
     * the end of the character stream is reached.
     */
    function readUntilCharacter(tokenizer) {
        var terminatingCharacters = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            terminatingCharacters[_i - 1] = arguments[_i];
        }
        return readWhile(tokenizer, function (character) { return terminatingCharacters.indexOf(character) === -1; });
    }
    function nextScheme(tokenizer) {
        var scheme = readWhileLetterOrDigit(tokenizer);
        tokenizer._currentToken = URLToken.scheme(scheme);
        if (!hasCurrentCharacter(tokenizer)) {
            tokenizer._currentState = "DONE";
        }
        else {
            tokenizer._currentState = "HOST";
        }
    }
    function nextSchemeOrHost(tokenizer) {
        var schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");
        if (!hasCurrentCharacter(tokenizer)) {
            tokenizer._currentToken = URLToken.host(schemeOrHost);
            tokenizer._currentState = "DONE";
        }
        else if (getCurrentCharacter(tokenizer) === ":") {
            if (peekCharacters(tokenizer, 3) === "://") {
                tokenizer._currentToken = URLToken.scheme(schemeOrHost);
                tokenizer._currentState = "HOST";
            }
            else {
                tokenizer._currentToken = URLToken.host(schemeOrHost);
                tokenizer._currentState = "PORT";
            }
        }
        else {
            tokenizer._currentToken = URLToken.host(schemeOrHost);
            if (getCurrentCharacter(tokenizer) === "/") {
                tokenizer._currentState = "PATH";
            }
            else {
                tokenizer._currentState = "QUERY";
            }
        }
    }
    function nextHost(tokenizer) {
        if (peekCharacters(tokenizer, 3) === "://") {
            nextCharacter(tokenizer, 3);
        }
        var host = readUntilCharacter(tokenizer, ":", "/", "?");
        tokenizer._currentToken = URLToken.host(host);
        if (!hasCurrentCharacter(tokenizer)) {
            tokenizer._currentState = "DONE";
        }
        else if (getCurrentCharacter(tokenizer) === ":") {
            tokenizer._currentState = "PORT";
        }
        else if (getCurrentCharacter(tokenizer) === "/") {
            tokenizer._currentState = "PATH";
        }
        else {
            tokenizer._currentState = "QUERY";
        }
    }
    function nextPort(tokenizer) {
        if (getCurrentCharacter(tokenizer) === ":") {
            nextCharacter(tokenizer);
        }
        var port = readUntilCharacter(tokenizer, "/", "?");
        tokenizer._currentToken = URLToken.port(port);
        if (!hasCurrentCharacter(tokenizer)) {
            tokenizer._currentState = "DONE";
        }
        else if (getCurrentCharacter(tokenizer) === "/") {
            tokenizer._currentState = "PATH";
        }
        else {
            tokenizer._currentState = "QUERY";
        }
    }
    function nextPath(tokenizer) {
        var path = readUntilCharacter(tokenizer, "?");
        tokenizer._currentToken = URLToken.path(path);
        if (!hasCurrentCharacter(tokenizer)) {
            tokenizer._currentState = "DONE";
        }
        else {
            tokenizer._currentState = "QUERY";
        }
    }
    function nextQuery(tokenizer) {
        if (getCurrentCharacter(tokenizer) === "?") {
            nextCharacter(tokenizer);
        }
        var query = readRemaining(tokenizer);
        tokenizer._currentToken = URLToken.query(query);
        tokenizer._currentState = "DONE";
    }

    // Copyright (c) Microsoft Corporation.
    function redirectPolicy(maximumRetries) {
        if (maximumRetries === void 0) { maximumRetries = 20; }
        return {
            create: function (nextPolicy, options) {
                return new RedirectPolicy(nextPolicy, options, maximumRetries);
            }
        };
    }
    var RedirectPolicy = /** @class */ (function (_super) {
        __extends(RedirectPolicy, _super);
        function RedirectPolicy(nextPolicy, options, maxRetries) {
            if (maxRetries === void 0) { maxRetries = 20; }
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.maxRetries = maxRetries;
            return _this;
        }
        RedirectPolicy.prototype.sendRequest = function (request) {
            var _this = this;
            return this._nextPolicy.sendRequest(request).then(function (response) { return handleRedirect(_this, response, 0); });
        };
        return RedirectPolicy;
    }(BaseRequestPolicy));
    function handleRedirect(policy, response, currentRetries) {
        var request = response.request, status = response.status;
        var locationHeader = response.headers.get("location");
        if (locationHeader &&
            (status === 300 || status === 307 || (status === 303 && request.method === "POST")) &&
            (!policy.maxRetries || currentRetries < policy.maxRetries)) {
            var builder = URLBuilder.parse(request.url);
            builder.setPath(locationHeader);
            request.url = builder.toString();
            // POST request with Status code 303 should be converted into a
            // redirected GET request if the redirect url is present in the location header
            if (status === 303) {
                request.method = "GET";
            }
            return policy._nextPolicy.sendRequest(request)
                .then(function (res) { return handleRedirect(policy, res, currentRetries + 1); });
        }
        return Promise.resolve(response);
    }

    function rpRegistrationPolicy(retryTimeout) {
        if (retryTimeout === void 0) { retryTimeout = 30; }
        return {
            create: function (nextPolicy, options) {
                return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);
            }
        };
    }
    var RPRegistrationPolicy = /** @class */ (function (_super) {
        __extends(RPRegistrationPolicy, _super);
        function RPRegistrationPolicy(nextPolicy, options, _retryTimeout) {
            if (_retryTimeout === void 0) { _retryTimeout = 30; }
            var _this = _super.call(this, nextPolicy, options) || this;
            _this._retryTimeout = _retryTimeout;
            return _this;
        }
        RPRegistrationPolicy.prototype.sendRequest = function (request) {
            var _this = this;
            return this._nextPolicy.sendRequest(request.clone())
                .then(function (response) { return registerIfNeeded(_this, request, response); });
        };
        return RPRegistrationPolicy;
    }(BaseRequestPolicy));
    function registerIfNeeded(policy, request, response) {
        if (response.status === 409) {
            var rpName = checkRPNotRegisteredError(response.bodyAsText);
            if (rpName) {
                var urlPrefix = extractSubscriptionUrl(request.url);
                return registerRP(policy, urlPrefix, rpName, request)
                    // Autoregistration of ${provider} failed for some reason. We will not return this error
                    // instead will return the initial response with 409 status code back to the user.
                    // do nothing here as we are returning the original response at the end of this method.
                    .catch(function () { return false; })
                    .then(function (registrationStatus) {
                    if (registrationStatus) {
                        // Retry the original request. We have to change the x-ms-client-request-id
                        // otherwise Azure endpoint will return the initial 409 (cached) response.
                        request.headers.set("x-ms-client-request-id", generateUuid());
                        return policy._nextPolicy.sendRequest(request.clone());
                    }
                    return response;
                });
            }
        }
        return Promise.resolve(response);
    }
    /**
     * Reuses the headers of the original request and url (if specified).
     * @param {WebResource} originalRequest The original request
     * @param {boolean} reuseUrlToo Should the url from the original request be reused as well. Default false.
     * @returns {object} A new request object with desired headers.
     */
    function getRequestEssentials(originalRequest, reuseUrlToo) {
        if (reuseUrlToo === void 0) { reuseUrlToo = false; }
        var reqOptions = originalRequest.clone();
        if (reuseUrlToo) {
            reqOptions.url = originalRequest.url;
        }
        // We have to change the x-ms-client-request-id otherwise Azure endpoint
        // will return the initial 409 (cached) response.
        reqOptions.headers.set("x-ms-client-request-id", generateUuid());
        // Set content-type to application/json
        reqOptions.headers.set("Content-Type", "application/json; charset=utf-8");
        return reqOptions;
    }
    /**
     * Validates the error code and message associated with 409 response status code. If it matches to that of
     * RP not registered then it returns the name of the RP else returns undefined.
     * @param {string} body The response body received after making the original request.
     * @returns {string} The name of the RP if condition is satisfied else undefined.
     */
    function checkRPNotRegisteredError(body) {
        var result, responseBody;
        if (body) {
            try {
                responseBody = JSON.parse(body);
            }
            catch (err) {
                // do nothing;
            }
            if (responseBody && responseBody.error && responseBody.error.message &&
                responseBody.error.code && responseBody.error.code === "MissingSubscriptionRegistration") {
                var matchRes = responseBody.error.message.match(/.*'(.*)'/i);
                if (matchRes) {
                    result = matchRes.pop();
                }
            }
        }
        return result;
    }
    /**
     * Extracts the first part of the URL, just after subscription:
     * https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
     * @param {string} url The original request url
     * @returns {string} The url prefix as explained above.
     */
    function extractSubscriptionUrl(url) {
        var result;
        var matchRes = url.match(/.*\/subscriptions\/[a-f0-9-]+\//ig);
        if (matchRes && matchRes[0]) {
            result = matchRes[0];
        }
        else {
            throw new Error("Unable to extract subscriptionId from the given url - " + url + ".");
        }
        return result;
    }
    /**
     * Registers the given provider.
     * @param {RPRegistrationPolicy} policy The RPRegistrationPolicy this function is being called against.
     * @param {string} urlPrefix https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
     * @param {string} provider The provider name to be registered.
     * @param {WebResource} originalRequest The original request sent by the user that returned a 409 response
     * with a message that the provider is not registered.
     * @param {registrationCallback} callback The callback that handles the RP registration
     */
    function registerRP(policy, urlPrefix, provider, originalRequest) {
        var postUrl = urlPrefix + "providers/" + provider + "/register?api-version=2016-02-01";
        var getUrl = urlPrefix + "providers/" + provider + "?api-version=2016-02-01";
        var reqOptions = getRequestEssentials(originalRequest);
        reqOptions.method = "POST";
        reqOptions.url = postUrl;
        return policy._nextPolicy.sendRequest(reqOptions)
            .then(function (response) {
            if (response.status !== 200) {
                throw new Error("Autoregistration of " + provider + " failed. Please try registering manually.");
            }
            return getRegistrationStatus(policy, getUrl, originalRequest);
        });
    }
    /**
     * Polls the registration status of the provider that was registered. Polling happens at an interval of 30 seconds.
     * Polling will happen till the registrationState property of the response body is "Registered".
     * @param {RPRegistrationPolicy} policy The RPRegistrationPolicy this function is being called against.
     * @param {string} url The request url for polling
     * @param {WebResource} originalRequest The original request sent by the user that returned a 409 response
     * with a message that the provider is not registered.
     * @returns {Promise<boolean>} True if RP Registration is successful.
     */
    function getRegistrationStatus(policy, url, originalRequest) {
        var reqOptions = getRequestEssentials(originalRequest);
        reqOptions.url = url;
        reqOptions.method = "GET";
        return policy._nextPolicy.sendRequest(reqOptions).then(function (res) {
            var obj = res.parsedBody;
            if (res.parsedBody && obj.registrationState && obj.registrationState === "Registered") {
                return true;
            }
            else {
                return delay(policy._retryTimeout * 1000).then(function () { return getRegistrationStatus(policy, url, originalRequest); });
            }
        });
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    /**
     * Defines the default token refresh buffer duration.
     */
    var TokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes
    /**
     * Provides an {@link AccessTokenCache} implementation which clears
     * the cached {@link AccessToken}'s after the expiresOnTimestamp has
     * passed.
     */
    var ExpiringAccessTokenCache = /** @class */ (function () {
        /**
         * Constructs an instance of {@link ExpiringAccessTokenCache} with
         * an optional expiration buffer time.
         */
        function ExpiringAccessTokenCache(tokenRefreshBufferMs) {
            if (tokenRefreshBufferMs === void 0) { tokenRefreshBufferMs = TokenRefreshBufferMs; }
            this.cachedToken = undefined;
            this.tokenRefreshBufferMs = tokenRefreshBufferMs;
        }
        ExpiringAccessTokenCache.prototype.setCachedToken = function (accessToken) {
            this.cachedToken = accessToken;
        };
        ExpiringAccessTokenCache.prototype.getCachedToken = function () {
            if (this.cachedToken &&
                Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp) {
                this.cachedToken = undefined;
            }
            return this.cachedToken;
        };
        return ExpiringAccessTokenCache;
    }());

    // Copyright (c) Microsoft Corporation.
    /**
     * Creates a new BearerTokenAuthenticationPolicy factory.
     *
     * @param credential The TokenCredential implementation that can supply the bearer token.
     * @param scopes The scopes for which the bearer token applies.
     */
    function bearerTokenAuthenticationPolicy(credential, scopes) {
        var tokenCache = new ExpiringAccessTokenCache();
        return {
            create: function (nextPolicy, options) {
                return new BearerTokenAuthenticationPolicy(nextPolicy, options, credential, scopes, tokenCache);
            }
        };
    }
    /**
     *
     * Provides a RequestPolicy that can request a token from a TokenCredential
     * implementation and then apply it to the Authorization header of a request
     * as a Bearer token.
     *
     */
    var BearerTokenAuthenticationPolicy = /** @class */ (function (_super) {
        __extends(BearerTokenAuthenticationPolicy, _super);
        /**
         * Creates a new BearerTokenAuthenticationPolicy object.
         *
         * @param nextPolicy The next RequestPolicy in the request pipeline.
         * @param options Options for this RequestPolicy.
         * @param credential The TokenCredential implementation that can supply the bearer token.
         * @param scopes The scopes for which the bearer token applies.
         * @param tokenCache The cache for the most recent AccessToken returned from the TokenCredential.
         */
        function BearerTokenAuthenticationPolicy(nextPolicy, options, credential, scopes, tokenCache) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.credential = credential;
            _this.scopes = scopes;
            _this.tokenCache = tokenCache;
            return _this;
        }
        /**
         * Applies the Bearer token to the request through the Authorization header.
         * @param webResource
         */
        BearerTokenAuthenticationPolicy.prototype.sendRequest = function (webResource) {
            return __awaiter(this, void 0, void 0, function () {
                var token;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!webResource.headers)
                                webResource.headers = new HttpHeaders();
                            return [4 /*yield*/, this.getToken({
                                    abortSignal: webResource.abortSignal
                                })];
                        case 1:
                            token = _a.sent();
                            webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, "Bearer " + token);
                            return [2 /*return*/, this._nextPolicy.sendRequest(webResource)];
                    }
                });
            });
        };
        BearerTokenAuthenticationPolicy.prototype.getToken = function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var accessToken;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            accessToken = this.tokenCache.getCachedToken();
                            if (!(accessToken === undefined)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.credential.getToken(this.scopes, options)];
                        case 1:
                            accessToken = (_a.sent()) || undefined;
                            this.tokenCache.setCachedToken(accessToken);
                            _a.label = 2;
                        case 2: return [2 /*return*/, accessToken ? accessToken.token : undefined];
                    }
                });
            });
        };
        return BearerTokenAuthenticationPolicy;
    }(BaseRequestPolicy));

    // Copyright (c) Microsoft Corporation.
    function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        return {
            create: function (nextPolicy, options) {
                return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
            }
        };
    }
    /**
     * @class
     * Instantiates a new "ExponentialRetryPolicyFilter" instance.
     *
     * @constructor
     * @param {number} retryCount        The client retry count.
     * @param {number} retryInterval     The client retry interval, in milliseconds.
     * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.
     * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.
     */
    var SystemErrorRetryPolicy = /** @class */ (function (_super) {
        __extends(SystemErrorRetryPolicy, _super);
        function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;
            _this.DEFAULT_CLIENT_RETRY_COUNT = 3;
            _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;
            _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;
            _this.retryCount = typeof retryCount === "number" ? retryCount : _this.DEFAULT_CLIENT_RETRY_COUNT;
            _this.retryInterval = typeof retryInterval === "number" ? retryInterval : _this.DEFAULT_CLIENT_RETRY_INTERVAL;
            _this.minRetryInterval = typeof minRetryInterval === "number" ? minRetryInterval : _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
            _this.maxRetryInterval = typeof maxRetryInterval === "number" ? maxRetryInterval : _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
            return _this;
        }
        SystemErrorRetryPolicy.prototype.sendRequest = function (request) {
            var _this = this;
            return this._nextPolicy.sendRequest(request.clone()).then(function (response) { return retry$1(_this, request, response); });
        };
        return SystemErrorRetryPolicy;
    }(BaseRequestPolicy));
    /**
     * Determines if the operation should be retried and how long to wait until the next retry.
     *
     * @param {number} statusCode The HTTP status code.
     * @param {RetryData} retryData  The retry data.
     * @return {boolean} True if the operation qualifies for a retry; false otherwise.
     */
    function shouldRetry$1(policy, retryData) {
        var currentCount;
        if (!retryData) {
            throw new Error("retryData for the SystemErrorRetryPolicyFilter cannot be null.");
        }
        else {
            currentCount = (retryData && retryData.retryCount);
        }
        return (currentCount < policy.retryCount);
    }
    /**
     * Updates the retry data for the next attempt.
     *
     * @param {RetryData} retryData  The retry data.
     * @param {object} err        The operation"s error, if any.
     */
    function updateRetryData$1(policy, retryData, err) {
        if (!retryData) {
            retryData = {
                retryCount: 0,
                retryInterval: 0
            };
        }
        if (err) {
            if (retryData.error) {
                err.innerError = retryData.error;
            }
            retryData.error = err;
        }
        // Adjust retry count
        retryData.retryCount++;
        // Adjust retry interval
        var incrementDelta = Math.pow(2, retryData.retryCount) - 1;
        var boundedRandDelta = policy.retryInterval * 0.8 +
            Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));
        incrementDelta *= boundedRandDelta;
        retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);
        return retryData;
    }
    function retry$1(policy, request, operationResponse, retryData, err) {
        retryData = updateRetryData$1(policy, retryData, err);
        if (err && err.code && shouldRetry$1(policy, retryData) &&
            (err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" ||
                err.code === "ECONNRESET" || err.code === "ENOENT")) {
            // If previous operation ended with an error and the policy allows a retry, do that
            return delay(retryData.retryInterval)
                .then(function () { return policy._nextPolicy.sendRequest(request.clone()); })
                .then(function (res) { return retry$1(policy, request, res, retryData, err); })
                .catch(function (err) { return retry$1(policy, request, operationResponse, retryData, err); });
        }
        else {
            if (err != undefined) {
                // If the operation failed in the end, return all errors instead of just the last one
                err = retryData.error;
                return Promise.reject(err);
            }
            return Promise.resolve(operationResponse);
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    /**
     * The format that will be used to join an array of values together for a query parameter value.
     */
    var QueryCollectionFormat;
    (function (QueryCollectionFormat) {
        QueryCollectionFormat["Csv"] = ",";
        QueryCollectionFormat["Ssv"] = " ";
        QueryCollectionFormat["Tsv"] = "\t";
        QueryCollectionFormat["Pipes"] = "|";
        QueryCollectionFormat["Multi"] = "Multi";
    })(QueryCollectionFormat || (QueryCollectionFormat = {}));

    // Copyright (c) Microsoft Corporation.
    var proxyNotSupportedInBrowser = new Error("ProxyPolicy is not supported in browser environment");
    function getDefaultProxySettings(_proxyUrl) {
        return undefined;
    }
    function proxyPolicy(_proxySettings) {
        return {
            create: function (_nextPolicy, _options) {
                throw proxyNotSupportedInBrowser;
            }
        };
    }
    var ProxyPolicy = /** @class */ (function (_super) {
        __extends(ProxyPolicy, _super);
        function ProxyPolicy(nextPolicy, options) {
            var _this = _super.call(this, nextPolicy, options) || this;
            throw proxyNotSupportedInBrowser;
            return _this;
        }
        ProxyPolicy.prototype.sendRequest = function (_request) {
            throw proxyNotSupportedInBrowser;
        };
        return ProxyPolicy;
    }(BaseRequestPolicy));

    // Copyright (c) Microsoft Corporation.
    var StatusCodes = Constants.HttpConstants.StatusCodes;
    function throttlingRetryPolicy() {
        return {
            create: function (nextPolicy, options) {
                return new ThrottlingRetryPolicy(nextPolicy, options);
            }
        };
    }
    /**
     * To learn more, please refer to
     * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,
     * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and
     * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
     */
    var ThrottlingRetryPolicy = /** @class */ (function (_super) {
        __extends(ThrottlingRetryPolicy, _super);
        function ThrottlingRetryPolicy(nextPolicy, options, _handleResponse) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this._handleResponse = _handleResponse || _this._defaultResponseHandler;
            return _this;
        }
        ThrottlingRetryPolicy.prototype.sendRequest = function (httpRequest) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, this._nextPolicy.sendRequest(httpRequest.clone()).then(function (response) {
                            if (response.status !== StatusCodes.TooManyRequests) {
                                return response;
                            }
                            else {
                                return _this._handleResponse(httpRequest, response);
                            }
                        })];
                });
            });
        };
        ThrottlingRetryPolicy.prototype._defaultResponseHandler = function (httpRequest, httpResponse) {
            return __awaiter(this, void 0, void 0, function () {
                var retryAfterHeader, delayInMs;
                var _this = this;
                return __generator(this, function (_a) {
                    retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);
                    if (retryAfterHeader) {
                        delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);
                        if (delayInMs) {
                            return [2 /*return*/, delay(delayInMs).then(function (_) { return _this._nextPolicy.sendRequest(httpRequest); })];
                        }
                    }
                    return [2 /*return*/, httpResponse];
                });
            });
        };
        ThrottlingRetryPolicy.parseRetryAfterHeader = function (headerValue) {
            var retryAfterInSeconds = Number(headerValue);
            if (Number.isNaN(retryAfterInSeconds)) {
                return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
            }
            else {
                return retryAfterInSeconds * 1000;
            }
        };
        ThrottlingRetryPolicy.parseDateRetryAfterHeader = function (headerValue) {
            try {
                var now = Date.now();
                var date = Date.parse(headerValue);
                var diff = date - now;
                return Number.isNaN(diff) ? undefined : diff;
            }
            catch (error) {
                return undefined;
            }
        };
        return ThrottlingRetryPolicy;
    }(BaseRequestPolicy));

    // Copyright (c) Microsoft Corporation.
    function signingPolicy(authenticationProvider) {
        return {
            create: function (nextPolicy, options) {
                return new SigningPolicy(nextPolicy, options, authenticationProvider);
            }
        };
    }
    var SigningPolicy = /** @class */ (function (_super) {
        __extends(SigningPolicy, _super);
        function SigningPolicy(nextPolicy, options, authenticationProvider) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.authenticationProvider = authenticationProvider;
            return _this;
        }
        SigningPolicy.prototype.signRequest = function (request) {
            return this.authenticationProvider.signRequest(request);
        };
        SigningPolicy.prototype.sendRequest = function (request) {
            var _this = this;
            return this.signRequest(request).then(function (nextRequest) { return _this._nextPolicy.sendRequest(nextRequest); });
        };
        return SigningPolicy;
    }(BaseRequestPolicy));

    // Copyright (c) Microsoft Corporation.
    /**
     * @class
     * Initializes a new instance of the ServiceClient.
     */
    var ServiceClient = /** @class */ (function () {
        /**
         * The ServiceClient constructor
         * @constructor
         * @param credentials The credentials used for authentication with the service.
         * @param options The service client options that govern the behavior of the client.
         */
        function ServiceClient(credentials, options) {
            var _this = this;
            if (!options) {
                options = {};
            }
            this._withCredentials = options.withCredentials || false;
            this._httpClient = options.httpClient || new XhrHttpClient();
            this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);
            var requestPolicyFactories;
            if (Array.isArray(options.requestPolicyFactories)) {
                requestPolicyFactories = options.requestPolicyFactories;
            }
            else {
                var authPolicyFactory = undefined;
                if (isTokenCredential(credentials)) {
                    // Create a wrapped RequestPolicyFactory here so that we can provide the
                    // correct scope to the BearerTokenAuthenticationPolicy at the first time
                    // one is requested.  This is needed because generated ServiceClient
                    // implementations do not set baseUri until after ServiceClient's constructor
                    // is finished, leaving baseUri empty at the time when it is needed to
                    // build the correct scope name.
                    var wrappedPolicyFactory = function () {
                        var bearerTokenPolicyFactory = undefined;
                        var serviceClient = _this;
                        return {
                            create: function (nextPolicy, options) {
                                if (bearerTokenPolicyFactory === undefined) {
                                    bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, (serviceClient.baseUri || "") + "/.default");
                                }
                                return bearerTokenPolicyFactory.create(nextPolicy, options);
                            }
                        };
                    };
                    authPolicyFactory = wrappedPolicyFactory();
                }
                else if (credentials && typeof credentials.signRequest === "function") {
                    authPolicyFactory = signingPolicy(credentials);
                }
                else if (credentials !== undefined) {
                    throw new Error("The credentials argument must implement the TokenCredential interface");
                }
                requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);
                if (options.requestPolicyFactories) {
                    // options.requestPolicyFactories can also be a function that manipulates
                    // the default requestPolicyFactories array
                    var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);
                    if (newRequestPolicyFactories) {
                        requestPolicyFactories = newRequestPolicyFactories;
                    }
                }
            }
            this._requestPolicyFactories = requestPolicyFactories;
        }
        /**
         * Send the provided httpRequest.
         */
        ServiceClient.prototype.sendRequest = function (options) {
            if (options === null || options === undefined || typeof options !== "object") {
                throw new Error("options cannot be null or undefined and it must be of type object.");
            }
            var httpRequest;
            try {
                if (options instanceof WebResource) {
                    options.validateRequestProperties();
                    httpRequest = options;
                }
                else {
                    httpRequest = new WebResource();
                    httpRequest = httpRequest.prepare(options);
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
            var httpPipeline = this._httpClient;
            if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {
                for (var i = this._requestPolicyFactories.length - 1; i >= 0; --i) {
                    httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
                }
            }
            return httpPipeline.sendRequest(httpRequest);
        };
        /**
         * Send an HTTP request that is populated using the provided OperationSpec.
         * @param {OperationArguments} operationArguments The arguments that the HTTP request's templated values will be populated from.
         * @param {OperationSpec} operationSpec The OperationSpec to use to populate the httpRequest.
         * @param {ServiceCallback} callback The callback to call when the response is received.
         */
        ServiceClient.prototype.sendOperationRequest = function (operationArguments, operationSpec, callback) {
            if (typeof operationArguments.options === "function") {
                callback = operationArguments.options;
                operationArguments.options = undefined;
            }
            var httpRequest = new WebResource();
            var result;
            try {
                var baseUri = operationSpec.baseUrl || this.baseUri;
                if (!baseUri) {
                    throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
                }
                httpRequest.method = operationSpec.httpMethod;
                httpRequest.operationSpec = operationSpec;
                var requestUrl = URLBuilder.parse(baseUri);
                if (operationSpec.path) {
                    requestUrl.appendPath(operationSpec.path);
                }
                if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {
                    for (var _i = 0, _a = operationSpec.urlParameters; _i < _a.length; _i++) {
                        var urlParameter = _a[_i];
                        var urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);
                        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter));
                        if (!urlParameter.skipEncoding) {
                            urlParameterValue = encodeURIComponent(urlParameterValue);
                        }
                        requestUrl.replaceAll("{" + (urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)) + "}", urlParameterValue);
                    }
                }
                if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {
                    for (var _b = 0, _c = operationSpec.queryParameters; _b < _c.length; _b++) {
                        var queryParameter = _c[_b];
                        var queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);
                        if (queryParameterValue != undefined) {
                            queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
                            if (queryParameter.collectionFormat != undefined) {
                                if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {
                                    if (queryParameterValue.length === 0) {
                                        queryParameterValue = "";
                                    }
                                    else {
                                        for (var index in queryParameterValue) {
                                            var item = queryParameterValue[index];
                                            queryParameterValue[index] = item == undefined ? "" : item.toString();
                                        }
                                    }
                                }
                                else {
                                    queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                                }
                            }
                            if (!queryParameter.skipEncoding) {
                                if (Array.isArray(queryParameterValue)) {
                                    for (var index in queryParameterValue) {
                                        queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);
                                    }
                                }
                                else {
                                    queryParameterValue = encodeURIComponent(queryParameterValue);
                                }
                            }
                            requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
                        }
                    }
                }
                httpRequest.url = requestUrl.toString();
                var contentType = operationSpec.contentType || this.requestContentType;
                if (contentType) {
                    httpRequest.headers.set("Content-Type", contentType);
                }
                if (operationSpec.headerParameters) {
                    for (var _d = 0, _e = operationSpec.headerParameters; _d < _e.length; _d++) {
                        var headerParameter = _e[_d];
                        var headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);
                        if (headerValue != undefined) {
                            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
                            var headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
                            if (headerCollectionPrefix) {
                                for (var _f = 0, _g = Object.keys(headerValue); _f < _g.length; _f++) {
                                    var key = _g[_f];
                                    httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
                                }
                            }
                            else {
                                httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
                            }
                        }
                    }
                }
                var options = operationArguments.options;
                if (options) {
                    if (options.customHeaders) {
                        for (var customHeaderName in options.customHeaders) {
                            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
                        }
                    }
                    if (options.abortSignal) {
                        httpRequest.abortSignal = options.abortSignal;
                    }
                    if (options.timeout) {
                        httpRequest.timeout = options.timeout;
                    }
                    if (options.onUploadProgress) {
                        httpRequest.onUploadProgress = options.onUploadProgress;
                    }
                    if (options.onDownloadProgress) {
                        httpRequest.onDownloadProgress = options.onDownloadProgress;
                    }
                    if (options.spanOptions) {
                        httpRequest.spanOptions = options.spanOptions;
                    }
                }
                httpRequest.withCredentials = this._withCredentials;
                serializeRequestBody(this, httpRequest, operationArguments, operationSpec);
                if (httpRequest.streamResponseBody == undefined) {
                    httpRequest.streamResponseBody = isStreamOperation(operationSpec);
                }
                result = this.sendRequest(httpRequest)
                    .then(function (res) { return flattenResponse(res, operationSpec.responses[res.status]); });
            }
            catch (error) {
                result = Promise.reject(error);
            }
            var cb = callback;
            if (cb) {
                result
                    // tslint:disable-next-line:no-null-keyword
                    .then(function (res) { return cb(null, res._response.parsedBody, res._response.request, res._response); })
                    .catch(function (err) { return cb(err); });
            }
            return result;
        };
        return ServiceClient;
    }());
    function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {
        if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
            httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
            var bodyMapper = operationSpec.requestBody.mapper;
            var required = bodyMapper.required, xmlName = bodyMapper.xmlName, xmlElementName = bodyMapper.xmlElementName, serializedName = bodyMapper.serializedName;
            var typeName = bodyMapper.type.name;
            try {
                if (httpRequest.body != undefined || required) {
                    var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
                    httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString);
                    var isStream = typeName === MapperType.Stream;
                    if (operationSpec.isXML) {
                        if (typeName === MapperType.Sequence) {
                            httpRequest.body = stringifyXML(prepareXMLRootList(httpRequest.body, xmlElementName || xmlName || serializedName), { rootName: xmlName || serializedName });
                        }
                        else if (!isStream) {
                            httpRequest.body = stringifyXML(httpRequest.body, { rootName: xmlName || serializedName });
                        }
                    }
                    else if (!isStream) {
                        httpRequest.body = JSON.stringify(httpRequest.body);
                    }
                }
            }
            catch (error) {
                throw new Error("Error \"" + error.message + "\" occurred in serializing the payload - " + JSON.stringify(serializedName, undefined, "  ") + ".");
            }
        }
        else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
            httpRequest.formData = {};
            for (var _i = 0, _a = operationSpec.formDataParameters; _i < _a.length; _i++) {
                var formDataParameter = _a[_i];
                var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);
                if (formDataParameterValue != undefined) {
                    var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
                    httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter));
                }
            }
        }
    }
    function getValueOrFunctionResult(value, defaultValueCreator) {
        var result;
        if (typeof value === "string") {
            result = value;
        }
        else {
            result = defaultValueCreator();
            if (typeof value === "function") {
                result = value(result);
            }
        }
        return result;
    }
    function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
        var factories = [];
        if (options.generateClientRequestIdHeader) {
            factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));
        }
        if (authPolicyFactory) {
            factories.push(authPolicyFactory);
        }
        var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);
        var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);
        if (userAgentHeaderName && userAgentHeaderValue) {
            factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));
        }
        factories.push(redirectPolicy());
        factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));
        if (!options.noRetryPolicy) {
            factories.push(exponentialRetryPolicy());
            factories.push(systemErrorRetryPolicy());
            factories.push(throttlingRetryPolicy());
        }
        factories.push(deserializationPolicy(options.deserializationContentTypes));
        var proxySettings = options.proxySettings || getDefaultProxySettings();
        if (proxySettings) {
            factories.push(proxyPolicy());
        }
        return factories;
    }
    function getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {
        return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);
    }
    function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {
        var value;
        if (typeof parameterPath === "string") {
            parameterPath = [parameterPath];
        }
        if (Array.isArray(parameterPath)) {
            if (parameterPath.length > 0) {
                if (parameterMapper.isConstant) {
                    value = parameterMapper.defaultValue;
                }
                else {
                    var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
                    if (!propertySearchResult.propertyFound) {
                        propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);
                    }
                    var useDefaultValue = false;
                    if (!propertySearchResult.propertyFound) {
                        useDefaultValue = parameterMapper.required || (parameterPath[0] === "options" && parameterPath.length === 2);
                    }
                    value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
                }
                // Serialize just for validation purposes.
                var parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);
                serializer.serialize(parameterMapper, value, parameterPathString);
            }
        }
        else {
            if (parameterMapper.required) {
                value = {};
            }
            for (var propertyName in parameterPath) {
                var propertyMapper = parameterMapper.type.modelProperties[propertyName];
                var propertyPath = parameterPath[propertyName];
                var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);
                // Serialize just for validation purposes.
                var propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);
                serializer.serialize(propertyMapper, propertyValue, propertyPathString);
                if (propertyValue !== undefined) {
                    if (!value) {
                        value = {};
                    }
                    value[propertyName] = propertyValue;
                }
            }
        }
        return value;
    }
    function getPropertyFromParameterPath(parent, parameterPath) {
        var result = { propertyFound: false };
        var i = 0;
        for (; i < parameterPath.length; ++i) {
            var parameterPathPart = parameterPath[i];
            // Make sure to check inherited properties too, so don't use hasOwnProperty().
            if (parent != undefined && parameterPathPart in parent) {
                parent = parent[parameterPathPart];
            }
            else {
                break;
            }
        }
        if (i === parameterPath.length) {
            result.propertyValue = parent;
            result.propertyFound = true;
        }
        return result;
    }
    function flattenResponse(_response, responseSpec) {
        var parsedHeaders = _response.parsedHeaders;
        var bodyMapper = responseSpec && responseSpec.bodyMapper;
        var addOperationResponse = function (obj) {
            return Object.defineProperty(obj, "_response", {
                value: _response
            });
        };
        if (bodyMapper) {
            var typeName = bodyMapper.type.name;
            if (typeName === "Stream") {
                return addOperationResponse(__assign({}, parsedHeaders, { blobBody: _response.blobBody, readableStreamBody: _response.readableStreamBody }));
            }
            var modelProperties_1 = typeName === "Composite" && bodyMapper.type.modelProperties || {};
            var isPageableResponse = Object.keys(modelProperties_1).some(function (k) { return modelProperties_1[k].serializedName === ""; });
            if (typeName === "Sequence" || isPageableResponse) {
                var arrayResponse = (_response.parsedBody || []).slice();
                for (var _i = 0, _a = Object.keys(modelProperties_1); _i < _a.length; _i++) {
                    var key = _a[_i];
                    if (modelProperties_1[key].serializedName) {
                        arrayResponse[key] = _response.parsedBody[key];
                    }
                }
                if (parsedHeaders) {
                    for (var _b = 0, _c = Object.keys(parsedHeaders); _b < _c.length; _b++) {
                        var key = _c[_b];
                        arrayResponse[key] = parsedHeaders[key];
                    }
                }
                addOperationResponse(arrayResponse);
                return arrayResponse;
            }
            if (typeName === "Composite" || typeName === "Dictionary") {
                return addOperationResponse(__assign({}, parsedHeaders, _response.parsedBody));
            }
        }
        if (bodyMapper || _response.request.method === "HEAD" || isPrimitiveType(_response.parsedBody)) {
            // primitive body types and HEAD booleans
            return addOperationResponse(__assign({}, parsedHeaders, { body: _response.parsedBody }));
        }
        return addOperationResponse(__assign({}, parsedHeaders, _response.parsedBody));
    }

    (function (SupportedPlugins) {
        SupportedPlugins[SupportedPlugins["OPENCENSUS"] = 0] = "OPENCENSUS";
        SupportedPlugins[SupportedPlugins["NOOP"] = 1] = "NOOP";
    })(exports.SupportedPlugins || (exports.SupportedPlugins = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License.
    /**
     * @ignore
     * @internal
     */
    var OpenCensusTraceStatePlugin = /** @class */ (function () {
        function OpenCensusTraceStatePlugin(state) {
            this._state = state;
        }
        OpenCensusTraceStatePlugin.prototype.get = function (key) {
            throw new Error("Method not implemented.");
        };
        OpenCensusTraceStatePlugin.prototype.set = function (key, value) {
            throw new Error("Method not implemented.");
        };
        OpenCensusTraceStatePlugin.prototype.unset = function (key) {
            throw new Error("Method not implemented");
        };
        OpenCensusTraceStatePlugin.prototype.serialize = function () {
            return this._state || "";
        };
        return OpenCensusTraceStatePlugin;
    }());

    var OpenCensusSpanPlugin = /** @class */ (function () {
        function OpenCensusSpanPlugin(span) {
            this._span = span;
        }
        OpenCensusSpanPlugin.prototype.getSpan = function () {
            return this._span;
        };
        OpenCensusSpanPlugin.prototype.end = function (endTime) {
            this._span.end(endTime);
        };
        OpenCensusSpanPlugin.prototype.start = function (startTime) {
            this._span.start(startTime);
        };
        OpenCensusSpanPlugin.prototype.context = function () {
            var openCensusSpanContext = this._span.spanContext;
            return {
                spanId: openCensusSpanContext.spanId,
                traceId: openCensusSpanContext.traceId,
                traceOptions: openCensusSpanContext.options,
                traceState: new OpenCensusTraceStatePlugin(openCensusSpanContext.traceState)
            };
        };
        OpenCensusSpanPlugin.prototype.setAttribute = function (key, value) {
            this._span.addAttribute(key, value);
            return this;
        };
        OpenCensusSpanPlugin.prototype.setAttributes = function (attributes) {
            throw new Error("Method not implemented.");
        };
        OpenCensusSpanPlugin.prototype.addEvent = function (name, attributes) {
            throw new Error("Method not implemented.");
        };
        OpenCensusSpanPlugin.prototype.addLink = function (spanContext, attributes) {
            // Since there is no way to specify the link relationship
            // It is set as Unspecified = 0
            this._span.addLink(spanContext.traceId, spanContext.spanId, 0, attributes);
            return this;
        };
        OpenCensusSpanPlugin.prototype.setStatus = function (status) {
            this._span.setStatus(status.code, status.message);
            return this;
        };
        OpenCensusSpanPlugin.prototype.updateName = function (name) {
            throw new Error("Method not implemented.");
        };
        OpenCensusSpanPlugin.prototype.isRecordingEvents = function () {
            throw new Error("Method not implemented.");
        };
        return OpenCensusSpanPlugin;
    }());

    var OpenCensusTracePlugin = /** @class */ (function () {
        function OpenCensusTracePlugin(tracer) {
            this.pluginType = exports.SupportedPlugins.OPENCENSUS;
            this._tracer = tracer;
        }
        OpenCensusTracePlugin.prototype.startSpan = function (name, options) {
            var parent = options
                ? options.parent
                    ? options.parent instanceof OpenCensusSpanPlugin
                        ? options.parent.getSpan()
                        : options.parent
                    : undefined
                : undefined;
            var span = this._tracer.startChildSpan({
                name: name,
                childOf: parent
            });
            var openCensusSpanPlugin = new OpenCensusSpanPlugin(span);
            return openCensusSpanPlugin;
        };
        OpenCensusTracePlugin.prototype.getCurrentSpan = function () {
            throw new Error("Method not implemented.");
        };
        OpenCensusTracePlugin.prototype.withSpan = function (span, fn) {
            throw new Error("Method not implemented.");
        };
        OpenCensusTracePlugin.prototype.recordSpanData = function (span) {
            throw new Error("Method not implemented.");
        };
        OpenCensusTracePlugin.prototype.getBinaryFormat = function () {
            throw new Error("Method not implemented.");
        };
        OpenCensusTracePlugin.prototype.getHttpTextFormat = function () {
            throw new Error("Method not implemented.");
        };
        return OpenCensusTracePlugin;
    }());

    var NoOpSpanPlugin = /** @class */ (function () {
        function NoOpSpanPlugin(span) {
            this._span = span;
        }
        NoOpSpanPlugin.prototype.context = function () {
            return {
                spanId: "",
                traceId: ""
            };
        };
        NoOpSpanPlugin.prototype.end = function (endTime) {
            this._span.end(endTime);
        };
        NoOpSpanPlugin.prototype.start = function (startTime) {
            this._span.start(startTime);
        };
        NoOpSpanPlugin.prototype.setAttribute = function (key, value) {
            throw new Error("Method not implemented.");
        };
        NoOpSpanPlugin.prototype.setAttributes = function (attributes) {
            throw new Error("Method not implemented.");
        };
        NoOpSpanPlugin.prototype.addEvent = function (name, attributes) {
            throw new Error("Method not implemented.");
        };
        NoOpSpanPlugin.prototype.addLink = function (spanContext, attributes) {
            throw new Error("Method not implemented.");
        };
        NoOpSpanPlugin.prototype.setStatus = function (status) {
            throw new Error("Method not implemented.");
        };
        NoOpSpanPlugin.prototype.updateName = function (name) {
            throw new Error("Method not implemented.");
        };
        NoOpSpanPlugin.prototype.isRecordingEvents = function () {
            throw new Error("Method not implemented.");
        };
        return NoOpSpanPlugin;
    }());

    var SpanNoOpImpl = /** @class */ (function () {
        function SpanNoOpImpl() {
        }
        SpanNoOpImpl.prototype.context = function () {
            throw new Error("Method not implemented.");
        };
        SpanNoOpImpl.prototype.setAttribute = function (key, value) {
            throw new Error("Method not implemented.");
        };
        SpanNoOpImpl.prototype.setAttributes = function (attributes) {
            throw new Error("Method not implemented.");
        };
        SpanNoOpImpl.prototype.addEvent = function (name, attributes) {
            throw new Error("Method not implemented.");
        };
        SpanNoOpImpl.prototype.addLink = function (spanContext, attributes) {
            throw new Error("Method not implemented.");
        };
        SpanNoOpImpl.prototype.setStatus = function (status) {
            throw new Error("Method not implemented.");
        };
        SpanNoOpImpl.prototype.updateName = function (name) {
            throw new Error("Method not implemented.");
        };
        SpanNoOpImpl.prototype.start = function (startTime) { };
        SpanNoOpImpl.prototype.end = function (endTime) { };
        SpanNoOpImpl.prototype.isRecordingEvents = function () {
            throw new Error("Method not implemented.");
        };
        return SpanNoOpImpl;
    }());

    var NoOpTracePlugin = /** @class */ (function () {
        function NoOpTracePlugin(tracer) {
            this.pluginType = exports.SupportedPlugins.NOOP;
            this._tracer = tracer;
        }
        NoOpTracePlugin.prototype.startSpan = function (name, options) {
            var span = new SpanNoOpImpl();
            var noOpSpanPlugin = new NoOpSpanPlugin(span);
            return noOpSpanPlugin;
        };
        NoOpTracePlugin.prototype.getCurrentSpan = function () {
            throw new Error("Method not implemented.");
        };
        NoOpTracePlugin.prototype.withSpan = function (span, fn) {
            throw new Error("Method not implemented.");
        };
        NoOpTracePlugin.prototype.recordSpanData = function (span) {
            throw new Error("Method not implemented.");
        };
        NoOpTracePlugin.prototype.getBinaryFormat = function () {
            throw new Error("Method not implemented.");
        };
        NoOpTracePlugin.prototype.getHttpTextFormat = function () {
            throw new Error("Method not implemented.");
        };
        return NoOpTracePlugin;
    }());

    var TracerNoOpImpl = /** @class */ (function () {
        function TracerNoOpImpl() {
            this.pluginType = exports.SupportedPlugins.NOOP;
        }
        TracerNoOpImpl.prototype.getCurrentSpan = function () {
            throw new Error("Method not implemented.");
        };
        TracerNoOpImpl.prototype.startSpan = function (name, options) {
            return new SpanNoOpImpl();
        };
        TracerNoOpImpl.prototype.withSpan = function (span, fn) {
            throw new Error("Method not implemented.");
        };
        TracerNoOpImpl.prototype.recordSpanData = function (span) {
            throw new Error("Method not implemented.");
        };
        TracerNoOpImpl.prototype.getBinaryFormat = function () {
            throw new Error("Method not implemented.");
        };
        TracerNoOpImpl.prototype.getHttpTextFormat = function () {
            throw new Error("Method not implemented.");
        };
        return TracerNoOpImpl;
    }());

    var TracerProxy = /** @class */ (function () {
        function TracerProxy() {
        }
        TracerProxy.setTracer = function (tracer, tracerPluginType) {
            if (tracerPluginType === exports.SupportedPlugins.OPENCENSUS) {
                TracerProxy._tracerPlugin = new OpenCensusTracePlugin(tracer);
            }
            else {
                TracerProxy._tracerPlugin = new NoOpTracePlugin(tracer);
            }
        };
        TracerProxy.getTracer = function () {
            if (!TracerProxy._tracerPlugin) {
                TracerProxy._tracerPlugin = new NoOpTracePlugin(new TracerNoOpImpl());
            }
            return TracerProxy._tracerPlugin;
        };
        return TracerProxy;
    }());

    /**
     * Copyright 2019, OpenTelemetry Authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * An enumeration that represents global trace options. These options are
     * propagated to all child {@link Span}. These determine features such as
     * whether a Span should be traced. It is implemented as a bitmask.
     */
    var TraceOptions;
    (function (TraceOptions) {
        /** Bit to represent whether trace is unsampled in trace options. */
        TraceOptions[TraceOptions["UNSAMPLED"] = 0] = "UNSAMPLED";
        /** Bit to represent whether trace is sampled in trace options. */
        TraceOptions[TraceOptions["SAMPLED"] = 1] = "SAMPLED";
    })(TraceOptions || (TraceOptions = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    function tracingPolicy() {
        return {
            create: function (nextPolicy, options) {
                return new TracingPolicy(nextPolicy, options);
            }
        };
    }
    var TracingPolicy = /** @class */ (function (_super) {
        __extends(TracingPolicy, _super);
        function TracingPolicy(nextPolicy, options) {
            return _super.call(this, nextPolicy, options) || this;
        }
        TracingPolicy.prototype.sendRequest = function (request) {
            return __awaiter(this, void 0, void 0, function () {
                var tracer, span, spanContext, traceState, response, err_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!request.spanOptions || !request.spanOptions.parent) {
                                return [2 /*return*/, this._nextPolicy.sendRequest(request)];
                            }
                            tracer = TracerProxy.getTracer();
                            span = tracer.startSpan("core-http", request.spanOptions);
                            span.start();
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            spanContext = span.context();
                            if (spanContext.spanId && spanContext.traceId) {
                                request.headers.set("traceparent", spanContext.traceId + "-" + spanContext.spanId + "-" + (spanContext.traceOptions || TraceOptions.UNSAMPLED));
                                traceState = spanContext.traceState && spanContext.traceState.serialize();
                                // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent
                                if (traceState) {
                                    request.headers.set("tracestate", traceState);
                                }
                            }
                            return [4 /*yield*/, this._nextPolicy.sendRequest(request)];
                        case 2:
                            response = _a.sent();
                            span.end();
                            return [2 /*return*/, response];
                        case 3:
                            err_1 = _a.sent();
                            span.end();
                            throw err_1;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        return TracingPolicy;
    }(BaseRequestPolicy));

    if (typeof Symbol === undefined || !Symbol.asyncIterator) {
        Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator");
    }

    var distEsm = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    });

    unwrapExports(distEsm);

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * A long-running operation polling strategy base class that other polling strategies should extend.
     */
    var LROPollStrategy = /** @class */ (function () {
        function LROPollStrategy(_azureServiceClient, _pollState) {
            this._azureServiceClient = _azureServiceClient;
            this._pollState = _pollState;
        }
        LROPollStrategy.prototype.getOperationStatus = function () {
            return this._pollState.state;
        };
        /**
         * Get whether or not this poll strategy's LRO is finished.
         * @returns Whether or not this poll strategy's LRO is finished.
         */
        LROPollStrategy.prototype.isFinished = function () {
            return isFinished(this._pollState.state);
        };
        /**
         * Send poll requests that check the LRO's status until it is determined that the LRO is finished.
         * @returns Whether or not the LRO succeeded.
         */
        LROPollStrategy.prototype.pollUntilFinished = function () {
            return __awaiter(this, void 0, void 0, function () {
                var delayInSeconds;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!!this.isFinished()) return [3 /*break*/, 3];
                            delayInSeconds = getDelayInSeconds(this._azureServiceClient, this._pollState.mostRecentResponse);
                            return [4 /*yield*/, delay(delayInSeconds * 1000)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.sendPollRequest()];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 0];
                        case 3: return [2 /*return*/, this.isFinalStatusAcceptable()];
                    }
                });
            });
        };
        LROPollStrategy.prototype.shouldDoFinalGetResourceRequest = function () {
            var initialRequestMethod = this._pollState.initialResponse.request.method;
            return !this._pollState.resource && (initialRequestMethod === "PUT" || initialRequestMethod === "PATCH" || initialRequestMethod === "POST");
        };
        LROPollStrategy.prototype.getMostRecentResponse = function () {
            return this._pollState.mostRecentResponse;
        };
        LROPollStrategy.prototype.getOperationResponse = function () {
            return __awaiter(this, void 0, void 0, function () {
                var response, result, resource;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.shouldDoFinalGetResourceRequest()) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.doFinalGetResourceRequest()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            response = this._pollState.mostRecentResponse;
                            result = __assign({}, response, { headers: response.headers.clone() });
                            resource = this._pollState.resource;
                            if (!resource) {
                                result.bodyAsText = response.bodyAsText;
                                result.parsedBody = response.parsedBody;
                            }
                            else if (typeof resource.valueOf() === "string") {
                                result.bodyAsText = resource;
                                result.parsedBody = JSON.parse(resource);
                            }
                            else {
                                result.bodyAsText = JSON.stringify(resource);
                                result.parsedBody = resource;
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        LROPollStrategy.prototype.getRestError = function () {
            var error = new RestError("");
            error.request = stripRequest(this._pollState.mostRecentRequest);
            error.response = this._pollState.mostRecentResponse;
            error.message = "Long running operation failed with status: \"" + this._pollState.state + "\".";
            error.body = this._pollState.resource;
            if (error.body) {
                var innerError = error.body.error;
                if (innerError) {
                    if (innerError.message) {
                        error.message = "Long running operation failed with error: \"" + innerError.message + "\".";
                    }
                    if (innerError.code) {
                        error.code = innerError.code;
                    }
                }
            }
            return error;
        };
        LROPollStrategy.prototype.updateState = function (url, shouldDeserialize) {
            var _this = this;
            return this.updateOperationStatus(url, shouldDeserialize).then(function (result) {
                _this._pollState.state = getProvisioningState(result.parsedBody) || "Succeeded";
                _this._pollState.mostRecentResponse = result;
                _this._pollState.mostRecentRequest = result.request;
                _this._pollState.resource = getResponseBody(result);
            }).catch(function (error) {
                var resultStatus;
                if (error.response && error.response.status) {
                    resultStatus = error.response.status;
                    if (_this._pollState.initialResponse.request.method !== "DELETE" || resultStatus < 400 || 499 < resultStatus) {
                        throw error;
                    }
                }
                else {
                    throw error;
                }
            });
        };
        /**
         * Retrieves operation status by querying the operation URL.
         * @param {string} statusUrl URL used to poll operation result.
         */
        LROPollStrategy.prototype.updateOperationStatus = function (statusUrl, shouldDeserialize) {
            var requestUrl = statusUrl.replace(" ", "%20");
            var httpRequest = new WebResource(requestUrl, "GET");
            var pollState = this._pollState;
            httpRequest.operationSpec = pollState.mostRecentRequest.operationSpec;
            httpRequest.shouldDeserialize = shouldDeserialize;
            httpRequest.operationResponseGetter = getOperationResponse$1;
            var options = pollState.options;
            if (options && options.customHeaders) {
                var customHeaders = options.customHeaders;
                for (var _i = 0, _a = Object.keys(customHeaders); _i < _a.length; _i++) {
                    var headerName = _a[_i];
                    httpRequest.headers.set(headerName, customHeaders[headerName]);
                }
            }
            return this._azureServiceClient.sendRequest(httpRequest);
        };
        LROPollStrategy.prototype.getPollState = function () {
            return this._pollState;
        };
        return LROPollStrategy;
    }());
    function getOperationResponse$1(operationSpec, response) {
        var statusCode = response.status;
        var operationResponses = operationSpec.responses;
        var result = operationResponses[statusCode];
        if (!result) {
            if (statusCode === 200) {
                result = operationResponses[201] || operationResponses[202];
            }
            else if (201 <= statusCode && statusCode <= 299) {
                result = {};
            }
        }
        return result;
    }
    function getDelayInSeconds(azureServiceClient, previousResponse) {
        var delayInSeconds = 30;
        if (azureServiceClient.longRunningOperationRetryTimeout != undefined) {
            delayInSeconds = azureServiceClient.longRunningOperationRetryTimeout;
        }
        else {
            var retryAfterHeaderValue = previousResponse.headers.get("retry-after");
            if (retryAfterHeaderValue) {
                var retryAfterDelayInSeconds = parseInt(retryAfterHeaderValue);
                if (!Number.isNaN(retryAfterDelayInSeconds)) {
                    delayInSeconds = retryAfterDelayInSeconds;
                }
            }
        }
        return delayInSeconds;
    }
    function getProvisioningState(responseBody) {
        var result;
        if (responseBody) {
            if (responseBody.provisioningState) {
                result = responseBody.provisioningState;
            }
            else if (responseBody.properties) {
                result = responseBody.properties.provisioningState;
            }
        }
        return result;
    }
    function getResponseBody(response) {
        var result;
        try {
            if (response.parsedBody) {
                result = response.parsedBody;
            }
            else if (response.bodyAsText && response.bodyAsText.length > 0) {
                result = JSON.parse(response.bodyAsText);
            }
        }
        catch (error) {
            var deserializationError = new RestError("Error \"" + error + "\" occurred in parsing the responseBody \" +\n      \"while creating the PollingState for Long Running Operation- \"" + response.bodyAsText + "\"");
            deserializationError.request = response.request;
            deserializationError.response = response;
            throw deserializationError;
        }
        return result;
    }
    function getStatusFromResponse(response, responseBody) {
        if (responseBody == undefined) {
            responseBody = getResponseBody(response);
        }
        var result;
        switch (response.status) {
            case 202:
                result = "InProgress";
                break;
            case 204:
                result = "Succeeded";
                break;
            case 201:
                result = getProvisioningState(responseBody) || "InProgress";
                break;
            case 200:
                var provisioningState = getProvisioningState(responseBody);
                if (provisioningState) {
                    result = provisioningState;
                }
                else if (getAzureAsyncOperationHeaderValue(response) || getLocationHeaderValue(response)) {
                    result = "InProgress";
                }
                else {
                    result = "Succeeded";
                }
                break;
            default:
                result = "Failed";
                break;
        }
        return result;
    }
    var terminalStates = ["Succeeded", "Failed", "Canceled", "Cancelled"];
    /**
     * Get whether or not a long-running operation with the provided status is finished.
     * @param status The current status of a long-running operation.
     * @returns Whether or not a long-running operation with the provided status is finished.
     */
    function isFinished(status) {
        var result = false;
        for (var _i = 0, terminalStates_1 = terminalStates; _i < terminalStates_1.length; _i++) {
            var terminalState = terminalStates_1[_i];
            if (longRunningOperationStatesEqual(status, terminalState)) {
                result = true;
                break;
            }
        }
        return result;
    }
    function longRunningOperationStatesEqual(lhs, rhs) {
        var lhsLowerCased = lhs && lhs.toLowerCase();
        var rhsLowerCased = rhs && rhs.toLowerCase();
        return lhsLowerCased === rhsLowerCased;
    }
    /**
     * Create a new long-running operation polling strategy based on the provided initial response.
     * @param initialResponse The initial response to the long-running operation's initial request.
     * @param azureServiceClient The AzureServiceClient that was used to send the initial request.
     * @param options Any options that were provided to the initial request.
     */
    function createLROPollStrategyFromInitialResponse(initialResponse, azureServiceClient, options) {
        var initialRequestMethod = initialResponse.request.method;
        var initialResponseStatus = initialResponse.status;
        var lroPollStrategyType;
        if (getAzureAsyncOperationHeaderValue(initialResponse)) {
            lroPollStrategyType = "AzureAsyncOperation";
        }
        else if (getLocationHeaderValue(initialResponse)) {
            lroPollStrategyType = "Location";
        }
        else if (initialRequestMethod === "PUT" || initialRequestMethod === "PATCH") {
            lroPollStrategyType = "GetResource";
        }
        else if (initialResponseStatus !== 201 && initialResponseStatus !== 202 && !isFinished(getStatusFromResponse(initialResponse))) {
            throw new Error("Can't determine long running operation polling strategy.");
        }
        var result;
        if (lroPollStrategyType) {
            var resource = getResponseBody(initialResponse);
            var lroPollState = {
                pollStrategyType: lroPollStrategyType,
                options: options,
                initialResponse: initialResponse,
                mostRecentResponse: initialResponse,
                mostRecentRequest: initialResponse.request,
                azureAsyncOperationHeaderValue: getAzureAsyncOperationHeaderValue(initialResponse),
                locationHeaderValue: getLocationHeaderValue(initialResponse),
                resource: resource,
                state: getStatusFromResponse(initialResponse, resource)
            };
            result = createLROPollStrategyFromPollState(azureServiceClient, lroPollState);
        }
        else {
            result = undefined;
        }
        return result;
    }
    function createLROPollStrategyFromPollState(azureServiceClient, lroPollState) {
        var result;
        switch (lroPollState.pollStrategyType) {
            case "AzureAsyncOperation":
                result = new AzureAsyncOperationLROPollStrategy(azureServiceClient, lroPollState);
                break;
            case "Location":
                result = new LocationLROPollStrategy(azureServiceClient, lroPollState);
                break;
            case "GetResource":
                result = new GetResourceLROPollStrategy(azureServiceClient, lroPollState);
                break;
            default:
                throw new Error("Unrecognized LRO poll strategy type: \"" + lroPollState.pollStrategyType + "\"");
                break;
        }
        return result;
    }
    function getLocationHeaderValue(response) {
        return response.headers.get("location");
    }
    /**
     * A long-running operation polling strategy that is based on the location header.
     */
    var LocationLROPollStrategy = /** @class */ (function (_super) {
        __extends(LocationLROPollStrategy, _super);
        function LocationLROPollStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LocationLROPollStrategy.prototype.locationStrategyShouldDeserialize = function (parsedResponse) {
            var shouldDeserialize = false;
            var initialResponse = this._pollState.initialResponse;
            var initialRequestMethod = initialResponse.request.method;
            var statusCode = parsedResponse.status;
            if (statusCode === 200 ||
                (statusCode === 201 && (initialRequestMethod === "PUT" || initialRequestMethod === "PATCH")) ||
                (statusCode === 204 && (initialRequestMethod === "DELETE" || initialRequestMethod === "POST"))) {
                shouldDeserialize = true;
            }
            return shouldDeserialize;
        };
        /**
         * Retrieve PUT operation status by polling from "location" header.
         * @param {string} method - The HTTP method.
         * @param {PollingState} pollingState - The object to persist current operation state.
         */
        LocationLROPollStrategy.prototype.sendPollRequest = function () {
            var lroPollState = this._pollState;
            return this.updateOperationStatus(lroPollState.locationHeaderValue, this.locationStrategyShouldDeserialize.bind(this)).then(function (result) {
                var locationHeaderValue = getLocationHeaderValue(result);
                if (locationHeaderValue) {
                    lroPollState.locationHeaderValue = locationHeaderValue;
                }
                lroPollState.mostRecentResponse = result;
                lroPollState.mostRecentRequest = result.request;
                var initialResponse = lroPollState.initialResponse;
                var initialRequestMethod = initialResponse.request.method;
                var initialResponseStatusCode = initialResponse.status;
                var statusCode = result.status;
                if (statusCode === 202) {
                    lroPollState.state = "InProgress";
                }
                else if (statusCode === 200 ||
                    (statusCode === 201 && (initialRequestMethod === "PUT" || initialRequestMethod === "PATCH")) ||
                    (statusCode === 204 && (initialRequestMethod === "DELETE" || initialRequestMethod === "POST"))) {
                    lroPollState.state = "Succeeded";
                    lroPollState.resource = getResponseBody(result);
                }
                else if (statusCode === 404 && initialRequestMethod === "POST" &&
                    (initialResponseStatusCode === 200 || initialResponseStatusCode === 201 || initialResponseStatusCode === 202)) {
                    lroPollState.state = "Failed";
                    lroPollState.resource = getResponseBody(result);
                }
                else if (400 <= statusCode && statusCode <= 499) {
                    var resultBody = result.bodyAsText;
                    var errorMessage = resultBody;
                    try {
                        var resultObject = JSON.parse(resultBody);
                        errorMessage = resultObject.message;
                    }
                    catch (parseError) {
                        // Ignore the exception, use resultBody as the error message
                    }
                    throw new RestError(errorMessage, undefined, statusCode, stripRequest(result.request), result, resultBody);
                }
                else {
                    throw new Error("The response with status code " + statusCode + " from polling for long running operation url \"" + lroPollState.locationHeaderValue + "\" is not valid.");
                }
            });
        };
        LocationLROPollStrategy.prototype.isFinalStatusAcceptable = function () {
            var lroPollState = this._pollState;
            var initialResponse = lroPollState.initialResponse;
            var initialResponseStatusCode = initialResponse.status;
            return longRunningOperationStatesEqual(lroPollState.state, "Succeeded") ||
                (initialResponse.request.method === "POST" && lroPollState.mostRecentResponse.status === 404 &&
                    (initialResponseStatusCode === 200 ||
                        initialResponseStatusCode === 201 ||
                        initialResponseStatusCode === 202));
        };
        LocationLROPollStrategy.prototype.shouldDoFinalGetResourceRequest = function () {
            var lroPollState = this._pollState;
            var initialResponse = lroPollState.initialResponse;
            var result;
            var initialRequestMethod = initialResponse.request.method;
            var initialResponseStatusCode = initialResponse.status;
            if (initialRequestMethod === "POST" && lroPollState.mostRecentResponse.status === 404 &&
                (initialResponseStatusCode === 200 ||
                    initialResponseStatusCode === 201 ||
                    initialResponseStatusCode === 202)) {
                result = false;
            }
            else {
                result = _super.prototype.shouldDoFinalGetResourceRequest.call(this) ||
                    (initialRequestMethod === "POST" && initialResponseStatusCode === 201);
            }
            return result;
        };
        LocationLROPollStrategy.prototype.doFinalGetResourceRequest = function () {
            var lroPollState = this._pollState;
            var initialResponse = lroPollState.initialResponse;
            var getResourceRequestUrl;
            var initialResponseStatusCode = initialResponse.status;
            var initialRequest = initialResponse.request;
            if (initialRequest.method === "POST" &&
                (initialResponseStatusCode === 200 ||
                    initialResponseStatusCode === 201 ||
                    initialResponseStatusCode === 202)) {
                getResourceRequestUrl = lroPollState.locationHeaderValue;
            }
            else {
                getResourceRequestUrl = initialRequest.url;
            }
            return this.updateState(getResourceRequestUrl, true);
        };
        return LocationLROPollStrategy;
    }(LROPollStrategy));
    function getAzureAsyncOperationHeaderValue(response) {
        return response.headers.get("azure-asyncoperation");
    }
    /**
     * A long-running operation polling strategy that is based on the azure-asyncoperation header.
     */
    var AzureAsyncOperationLROPollStrategy = /** @class */ (function (_super) {
        __extends(AzureAsyncOperationLROPollStrategy, _super);
        function AzureAsyncOperationLROPollStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Retrieve operation status by polling from "azure-asyncoperation" header.
         * @param {PollingState} pollingState - The object to persist current operation state.
         * @param {boolean} inPostOrDelete - Invoked by Post Or Delete operation.
         */
        AzureAsyncOperationLROPollStrategy.prototype.sendPollRequest = function () {
            var lroPollState = this._pollState;
            return this.updateOperationStatus(lroPollState.azureAsyncOperationHeaderValue, false).then(function (response) {
                var statusCode = response.status;
                var parsedResponse = response.parsedBody;
                if (statusCode !== 200 && statusCode !== 201 && statusCode !== 202 && statusCode !== 204) {
                    var error = new RestError("Invalid status code (" + statusCode + ") with response body \"" + response.bodyAsText + "\" occurred when polling for operation status.");
                    error.statusCode = statusCode;
                    error.request = stripRequest(response.request);
                    error.response = response;
                    error.body = parsedResponse;
                    throw error;
                }
                if (!parsedResponse) {
                    throw new Error("The response from long running operation does not contain a body.");
                }
                else if (!parsedResponse.status) {
                    throw new Error("The response \"" + response.bodyAsText + "\" from long running operation does not contain the status property.");
                }
                var azureAsyncOperationHeaderValue = getAzureAsyncOperationHeaderValue(response);
                if (azureAsyncOperationHeaderValue) {
                    lroPollState.azureAsyncOperationHeaderValue = azureAsyncOperationHeaderValue;
                }
                lroPollState.state = parsedResponse.status;
                lroPollState.mostRecentResponse = response;
                lroPollState.mostRecentRequest = response.request;
                lroPollState.resource = getResponseBody(response);
            });
        };
        AzureAsyncOperationLROPollStrategy.prototype.shouldDoFinalGetResourceRequest = function () {
            var lroPollState = this._pollState;
            var initialResponse = lroPollState.initialResponse;
            var initialRequestMethod = initialResponse.request.method;
            var result = false;
            if (initialRequestMethod === "PUT" || initialRequestMethod === "PATCH") {
                result = true;
            }
            else {
                if (lroPollState.locationHeaderValue) {
                    var initialResponseStatusCode = initialResponse.status;
                    if (initialRequestMethod === "POST") {
                        result = initialResponseStatusCode === 200 || initialResponseStatusCode === 201;
                    }
                    else if (initialRequestMethod === "DELETE") {
                        result = initialResponseStatusCode === 200 || initialResponseStatusCode === 202;
                    }
                }
            }
            return result;
        };
        AzureAsyncOperationLROPollStrategy.prototype.doFinalGetResourceRequest = function () {
            var lroPollState = this._pollState;
            var locationHeaderValue = lroPollState.locationHeaderValue;
            var initialResponse = lroPollState.initialResponse;
            var initialRequest = initialResponse.request;
            var getResourceRequestUrl = initialRequest.url;
            if (locationHeaderValue) {
                var initialRequestMethod = initialRequest.method;
                var initialResponseStatusCode = initialResponse.status;
                if (initialRequestMethod === "POST" && (initialResponseStatusCode === 200 || initialResponseStatusCode === 201 || initialResponseStatusCode === 202)) {
                    getResourceRequestUrl = locationHeaderValue;
                }
                else if (initialRequestMethod === "DELETE" && (initialResponseStatusCode === 200 || initialResponseStatusCode === 202)) {
                    getResourceRequestUrl = locationHeaderValue;
                }
            }
            return this.updateState(getResourceRequestUrl, true);
        };
        AzureAsyncOperationLROPollStrategy.prototype.isFinalStatusAcceptable = function () {
            var lroPollState = this._pollState;
            var initialResponse = lroPollState.initialResponse;
            var initialResponseStatusCode = initialResponse.status;
            return longRunningOperationStatesEqual(lroPollState.state, "Succeeded") ||
                (initialResponse.request.method === "POST" && (initialResponseStatusCode === 200 || initialResponseStatusCode === 201));
        };
        return AzureAsyncOperationLROPollStrategy;
    }(LROPollStrategy));
    /**
     * A long-running operation polling strategy that is based on the resource's provisioning state.
     */
    var GetResourceLROPollStrategy = /** @class */ (function (_super) {
        __extends(GetResourceLROPollStrategy, _super);
        function GetResourceLROPollStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GetResourceLROPollStrategy.prototype.sendPollRequest = function () {
            var lroPollState = this._pollState;
            return this.updateOperationStatus(lroPollState.initialResponse.request.url, false).then(function (result) {
                var statusCode = result.status;
                var responseBody = result.parsedBody;
                if (statusCode !== 200 && statusCode !== 201 && statusCode !== 202 && statusCode !== 204) {
                    var error = new RestError("Invalid status code with response body \"" + result.bodyAsText + "\" occurred when polling for operation status.");
                    error.statusCode = statusCode;
                    error.request = stripRequest(result.request);
                    error.response = result;
                    error.body = responseBody;
                    throw error;
                }
                if (!result.parsedBody) {
                    throw new Error("The response from long running operation does not contain a body.");
                }
                lroPollState.state = getProvisioningState(result.parsedBody) || "Succeeded";
                lroPollState.mostRecentResponse = result;
                lroPollState.mostRecentRequest = result.request;
                lroPollState.resource = getResponseBody(result);
            });
        };
        GetResourceLROPollStrategy.prototype.isFinalStatusAcceptable = function () {
            return longRunningOperationStatesEqual(this._pollState.state, "Succeeded");
        };
        GetResourceLROPollStrategy.prototype.doFinalGetResourceRequest = function () {
            return this.sendPollRequest();
        };
        return GetResourceLROPollStrategy;
    }(LROPollStrategy));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * An HTTP operation response that provides special methods for interacting with LROs (long running
     * operations).
     */
    var LROPoller = /** @class */ (function () {
        /**
         * Create a new HttpLongRunningOperationResponse.
         * @param _lroPollStrategy The LROPollStrategy that this HttpLongRunningOperationResponse will
         * use to interact with the LRO.
         */
        function LROPoller(_lroPollStrategy, _initialResponse) {
            this._lroPollStrategy = _lroPollStrategy;
            this._initialResponse = _initialResponse;
        }
        /**
         * Get the first response that the service sent back when the LRO was initiated.
         */
        LROPoller.prototype.getInitialResponse = function () {
            return this._initialResponse;
        };
        /**
         * Get the most recent response that the service sent back during this LRO.
         */
        LROPoller.prototype.getMostRecentResponse = function () {
            var lroPollStrategy = this._lroPollStrategy;
            return !lroPollStrategy ? this._initialResponse : lroPollStrategy.getMostRecentResponse();
        };
        /**
         * Get whether or not the LRO is finished.
         */
        LROPoller.prototype.isFinished = function () {
            var lroPollStrategy = this._lroPollStrategy;
            return !lroPollStrategy ? true : lroPollStrategy.isFinished();
        };
        /**
         * Get whether or not the LRO is finished and its final state is acceptable. If the LRO has not
         * finished yet, then undefined will be returned. An "acceptable" final state is determined by the
         * LRO strategy that the Azure service uses to perform long running operations.
         */
        LROPoller.prototype.isFinalStatusAcceptable = function () {
            var result;
            var lroPollStrategy = this._lroPollStrategy;
            if (!lroPollStrategy) {
                result = true;
            }
            else if (lroPollStrategy.isFinished()) {
                result = lroPollStrategy.isFinalStatusAcceptable();
            }
            return result;
        };
        /**
         * Get the current status of the LRO.
         */
        LROPoller.prototype.getOperationStatus = function () {
            var lroPollStrategy = this._lroPollStrategy;
            return !lroPollStrategy ? "Succeeded" : lroPollStrategy.getOperationStatus();
        };
        /**
         * If the LRO is finished and in an acceptable state, then return the HttpOperationResponse. If
         * the LRO is finished and not in an acceptable state, then throw the error that the LRO produced.
         * If the LRO is not finished, then return undefined.
         */
        LROPoller.prototype.getOperationResponse = function () {
            var result;
            var lroPollStrategy = this._lroPollStrategy;
            if (!lroPollStrategy) {
                result = Promise.resolve(this._initialResponse);
            }
            else if (!lroPollStrategy.isFinished()) {
                result = Promise.resolve(undefined);
            }
            else if (lroPollStrategy.isFinalStatusAcceptable()) {
                result = lroPollStrategy.getOperationResponse();
            }
            else {
                throw lroPollStrategy.getRestError();
            }
            return result;
        };
        /**
         * Send a single poll request and return the LRO's state.
         */
        LROPoller.prototype.poll = function () {
            var result;
            var lroPollStrategy = this._lroPollStrategy;
            if (!lroPollStrategy) {
                result = Promise.resolve("Succeeded");
            }
            else {
                result = lroPollStrategy.sendPollRequest().then(function () {
                    return lroPollStrategy.getOperationStatus();
                });
            }
            return result;
        };
        /**
         * Send poll requests that check the LRO's status until it is determined that the LRO is finished.
         */
        LROPoller.prototype.pollUntilFinished = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result, lroPollStrategy;
                return __generator(this, function (_a) {
                    lroPollStrategy = this._lroPollStrategy;
                    if (!lroPollStrategy) {
                        result = Promise.resolve(flattenAzureResponse(this._initialResponse));
                    }
                    else {
                        result = lroPollStrategy.pollUntilFinished().then(function (succeeded) {
                            if (succeeded) {
                                return lroPollStrategy.getOperationResponse().then(flattenAzureResponse);
                            }
                            else {
                                throw lroPollStrategy.getRestError();
                            }
                        });
                    }
                    return [2 /*return*/, result];
                });
            });
        };
        /**
         * Get an LROPollState object that can be used to poll this LRO in a different context (such as on
         * a different process or a different machine). If the LRO couldn't produce an LRO polling
         * strategy, then this will return undefined.
         */
        LROPoller.prototype.getPollState = function () {
            var lroPollStrategy = this._lroPollStrategy;
            return !lroPollStrategy ? undefined : lroPollStrategy.getPollState();
        };
        return LROPoller;
    }());
    function createLROPollerFromInitialResponse(azureServiceClient, initialResponse, options) {
        var lroPollStrategy = createLROPollStrategyFromInitialResponse(initialResponse, azureServiceClient, options);
        return new LROPoller(lroPollStrategy, initialResponse);
    }
    function createLROPollerFromPollState(azureServiceClient, lroMemento) {
        var lroPollStrategy = createLROPollStrategyFromPollState(azureServiceClient, lroMemento);
        return new LROPoller(lroPollStrategy, lroMemento.initialResponse);
    }
    function flattenAzureResponse(response) {
        var _a = response.request, operationResponseGetter = _a.operationResponseGetter, operationSpec = _a.operationSpec;
        return flattenResponse(response, operationResponseGetter && operationSpec && operationResponseGetter(operationSpec, response));
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License. See License.txt in the project root for license information.
    /**
     * The default language in the request header.
     *
     * @const
     * @type {string}
     */
    var DEFAULT_LANGUAGE = "en-us";
    /**
     * The core-arm version.
     * @const
     * @type {string}
     */
    var coreArmVersion = "1.0.0-preview.1";

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @class
     * Initializes a new instance of the AzureServiceClient class.
     * @constructor
     *
     * @param credentials The credentials used for authentication with the service.
     * @param options The parameter options used by AzureServiceClient.
     */
    var AzureServiceClient = /** @class */ (function (_super) {
        __extends(AzureServiceClient, _super);
        function AzureServiceClient(credentials, options) {
            var _this = _super.call(this, credentials, options = updateOptionsWithDefaultValues(options)) || this;
            _this.acceptLanguage = DEFAULT_LANGUAGE;
            // For convenience, if the credentials have an associated AzureEnvironment,
            // automatically use the baseUri from that environment.
            var env = credentials.environment;
            if (env && !_this.baseUri) {
                _this.baseUri = env.resourceManagerEndpointUrl;
            }
            if (options.acceptLanguage != undefined) {
                _this.acceptLanguage = options.acceptLanguage;
            }
            if (options.longRunningOperationRetryTimeout != undefined) {
                _this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
            }
            return _this;
        }
        /**
         * Send the initial request of a LRO (long running operation) and get back an
         * LROPoller that provides methods for polling the LRO and checking if the LRO is finished.
         * @param operationArguments The arguments to the operation.
         * @param operationSpec The specification for the operation.
         * @param options Additional options to be sent while making the request.
         * @returns The LROPoller object that provides methods for interacting with the LRO.
         */
        AzureServiceClient.prototype.sendLRORequest = function (operationArguments, operationSpec, options) {
            var _this = this;
            return this.sendOperationRequest(operationArguments, operationSpec)
                .then(function (initialResponse) { return createLROPollerFromInitialResponse(_this, initialResponse._response, options); });
        };
        /**
         * Provides a mechanism to make a request that will poll and provide the final result.
         * @param {RequestPrepareOptions | WebResource} request - The request object
         * @param {AzureRequestOptionsBase} [options] Additional options to be sent while making the request
         * @returns {Promise<HttpOperationResponse>} The HttpOperationResponse containing the final polling request, response and the responseBody.
         */
        AzureServiceClient.prototype.sendLongRunningRequest = function (request, options) {
            return this.beginLongRunningRequest(request, options)
                .then(function (lroResponse) { return lroResponse.pollUntilFinished(); })
                .then(function (res) { return res._response; });
        };
        /**
         * Send the initial request of a LRO (long running operation) and get back an
         * HttpLongRunningOperationResponse that provides methods for polling the LRO and checking if the
         * LRO is finished.
         * @param {RequestPrepareOptions | WebResource} request - The request object
         * @param {AzureRequestOptionsBase} [options] Additional options to be sent while making the request
         * @returns {Promise<LROPoller>} The HttpLongRunningOperationResponse
         * that provides methods for interacting with the LRO.
         */
        AzureServiceClient.prototype.beginLongRunningRequest = function (request, options) {
            var _this = this;
            return this.sendRequest(request)
                .then(function (initialResponse) { return createLROPollerFromInitialResponse(_this, initialResponse, options); });
        };
        /**
         * Restore an LROPoller from the provided LROPollState. This method can be used to recreate an
         * LROPoller on a different process or machine.
         */
        AzureServiceClient.prototype.restoreLROPoller = function (lroPollState) {
            return createLROPollerFromPollState(this, lroPollState);
        };
        return AzureServiceClient;
    }(ServiceClient));
    function getDefaultUserAgentValue$1() {
        var defaultUserAgent = getDefaultUserAgentValue();
        return "core-arm/" + coreArmVersion + " " + defaultUserAgent;
    }
    function updateOptionsWithDefaultValues(options) {
        if (!options) {
            options = {};
        }
        if (options.generateClientRequestIdHeader == undefined) {
            options.generateClientRequestIdHeader = true;
        }
        if (!options.userAgent) {
            options.userAgent = getDefaultUserAgentValue$1();
        }
        return options;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License. See License.txt in the project root for license information.
    var BaseResourceMapper = {
        serializedName: "BaseResource",
        type: {
            name: "Composite",
            className: "BaseResource",
            modelProperties: {}
        }
    };

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License. See License.txt in the project root for license information.
    var CloudErrorMapper = {
        serializedName: "CloudError",
        type: {
            name: "Composite",
            className: "CloudError",
            modelProperties: {
                code: {
                    required: true,
                    serializedName: "code",
                    type: {
                        name: "String"
                    }
                },
                message: {
                    required: true,
                    serializedName: "message",
                    type: {
                        name: "String"
                    }
                },
                target: {
                    serializedName: "target",
                    type: {
                        name: "String"
                    }
                },
                details: {
                    serializedName: "details",
                    type: {
                        name: "Sequence",
                        element: {
                            serializedName: "CloudErrorElementType",
                            type: {
                                name: "Composite",
                                className: "CloudError"
                            }
                        }
                    }
                },
                innerError: {
                    required: false,
                    serializedName: "innererror",
                    type: {
                        name: "Object"
                    }
                },
                additionalInfo: {
                    required: false,
                    serializedName: "additionalInfo",
                    type: {
                        name: "Composite",
                        className: "AdditionalInfoElement",
                        modelProperties: {
                            type: {
                                required: true,
                                serializedName: "type",
                                type: {
                                    name: "String"
                                }
                            },
                            info: {
                                required: false,
                                serializedName: "info",
                                type: {
                                    name: "Object"
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     *
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is regenerated.
     */
    var CloudError = CloudErrorMapper;
    var BaseResource = BaseResourceMapper;
    var Attributes = {
        serializedName: "Attributes",
        type: {
            name: "Composite",
            className: "Attributes",
            modelProperties: {
                enabled: {
                    serializedName: "enabled",
                    type: {
                        name: "Boolean"
                    }
                },
                notBefore: {
                    serializedName: "nbf",
                    type: {
                        name: "UnixTime"
                    }
                },
                expires: {
                    serializedName: "exp",
                    type: {
                        name: "UnixTime"
                    }
                },
                created: {
                    readOnly: true,
                    serializedName: "created",
                    type: {
                        name: "UnixTime"
                    }
                },
                updated: {
                    readOnly: true,
                    serializedName: "updated",
                    type: {
                        name: "UnixTime"
                    }
                }
            }
        }
    };
    var JsonWebKey = {
        serializedName: "JsonWebKey",
        type: {
            name: "Composite",
            className: "JsonWebKey",
            modelProperties: {
                kid: {
                    serializedName: "kid",
                    type: {
                        name: "String"
                    }
                },
                kty: {
                    serializedName: "kty",
                    type: {
                        name: "String"
                    }
                },
                keyOps: {
                    serializedName: "key_ops",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                n: {
                    serializedName: "n",
                    type: {
                        name: "Base64Url"
                    }
                },
                e: {
                    serializedName: "e",
                    type: {
                        name: "Base64Url"
                    }
                },
                d: {
                    serializedName: "d",
                    type: {
                        name: "Base64Url"
                    }
                },
                dp: {
                    serializedName: "dp",
                    type: {
                        name: "Base64Url"
                    }
                },
                dq: {
                    serializedName: "dq",
                    type: {
                        name: "Base64Url"
                    }
                },
                qi: {
                    serializedName: "qi",
                    type: {
                        name: "Base64Url"
                    }
                },
                p: {
                    serializedName: "p",
                    type: {
                        name: "Base64Url"
                    }
                },
                q: {
                    serializedName: "q",
                    type: {
                        name: "Base64Url"
                    }
                },
                k: {
                    serializedName: "k",
                    type: {
                        name: "Base64Url"
                    }
                },
                t: {
                    serializedName: "key_hsm",
                    type: {
                        name: "Base64Url"
                    }
                },
                crv: {
                    serializedName: "crv",
                    type: {
                        name: "String"
                    }
                },
                x: {
                    serializedName: "x",
                    type: {
                        name: "Base64Url"
                    }
                },
                y: {
                    serializedName: "y",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var KeyAttributes = {
        serializedName: "KeyAttributes",
        type: {
            name: "Composite",
            className: "KeyAttributes",
            modelProperties: __assign({}, Attributes.type.modelProperties, { recoveryLevel: {
                    nullable: false,
                    readOnly: true,
                    serializedName: "recoveryLevel",
                    type: {
                        name: "String"
                    }
                } })
        }
    };
    var KeyBundle = {
        serializedName: "KeyBundle",
        type: {
            name: "Composite",
            className: "KeyBundle",
            modelProperties: {
                key: {
                    serializedName: "key",
                    type: {
                        name: "Composite",
                        className: "JsonWebKey"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "KeyAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                managed: {
                    readOnly: true,
                    serializedName: "managed",
                    type: {
                        name: "Boolean"
                    }
                }
            }
        }
    };
    var KeyItem = {
        serializedName: "KeyItem",
        type: {
            name: "Composite",
            className: "KeyItem",
            modelProperties: {
                kid: {
                    serializedName: "kid",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "KeyAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                managed: {
                    readOnly: true,
                    serializedName: "managed",
                    type: {
                        name: "Boolean"
                    }
                }
            }
        }
    };
    var DeletedKeyBundle = {
        serializedName: "DeletedKeyBundle",
        type: {
            name: "Composite",
            className: "DeletedKeyBundle",
            modelProperties: __assign({}, KeyBundle.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var DeletedKeyItem = {
        serializedName: "DeletedKeyItem",
        type: {
            name: "Composite",
            className: "DeletedKeyItem",
            modelProperties: __assign({}, KeyItem.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var SecretAttributes = {
        serializedName: "SecretAttributes",
        type: {
            name: "Composite",
            className: "SecretAttributes",
            modelProperties: __assign({}, Attributes.type.modelProperties, { recoveryLevel: {
                    nullable: false,
                    readOnly: true,
                    serializedName: "recoveryLevel",
                    type: {
                        name: "String"
                    }
                } })
        }
    };
    var SecretBundle = {
        serializedName: "SecretBundle",
        type: {
            name: "Composite",
            className: "SecretBundle",
            modelProperties: {
                value: {
                    serializedName: "value",
                    type: {
                        name: "String"
                    }
                },
                id: {
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                contentType: {
                    serializedName: "contentType",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "SecretAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                kid: {
                    readOnly: true,
                    serializedName: "kid",
                    type: {
                        name: "String"
                    }
                },
                managed: {
                    readOnly: true,
                    serializedName: "managed",
                    type: {
                        name: "Boolean"
                    }
                }
            }
        }
    };
    var SecretItem = {
        serializedName: "SecretItem",
        type: {
            name: "Composite",
            className: "SecretItem",
            modelProperties: {
                id: {
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "SecretAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                contentType: {
                    serializedName: "contentType",
                    type: {
                        name: "String"
                    }
                },
                managed: {
                    readOnly: true,
                    serializedName: "managed",
                    type: {
                        name: "Boolean"
                    }
                }
            }
        }
    };
    var DeletedSecretBundle = {
        serializedName: "DeletedSecretBundle",
        type: {
            name: "Composite",
            className: "DeletedSecretBundle",
            modelProperties: __assign({}, SecretBundle.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var DeletedSecretItem = {
        serializedName: "DeletedSecretItem",
        type: {
            name: "Composite",
            className: "DeletedSecretItem",
            modelProperties: __assign({}, SecretItem.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var SecretRestoreParameters = {
        serializedName: "SecretRestoreParameters",
        type: {
            name: "Composite",
            className: "SecretRestoreParameters",
            modelProperties: {
                secretBundleBackup: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var StorageRestoreParameters = {
        serializedName: "StorageRestoreParameters",
        type: {
            name: "Composite",
            className: "StorageRestoreParameters",
            modelProperties: {
                storageBundleBackup: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var CertificateAttributes = {
        serializedName: "CertificateAttributes",
        type: {
            name: "Composite",
            className: "CertificateAttributes",
            modelProperties: __assign({}, Attributes.type.modelProperties, { recoveryLevel: {
                    nullable: false,
                    readOnly: true,
                    serializedName: "recoveryLevel",
                    type: {
                        name: "String"
                    }
                } })
        }
    };
    var CertificateItem = {
        serializedName: "CertificateItem",
        type: {
            name: "Composite",
            className: "CertificateItem",
            modelProperties: {
                id: {
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "CertificateAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                x509Thumbprint: {
                    serializedName: "x5t",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var CertificateIssuerItem = {
        serializedName: "CertificateIssuerItem",
        type: {
            name: "Composite",
            className: "CertificateIssuerItem",
            modelProperties: {
                id: {
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                provider: {
                    serializedName: "provider",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var KeyProperties = {
        serializedName: "KeyProperties",
        type: {
            name: "Composite",
            className: "KeyProperties",
            modelProperties: {
                exportable: {
                    serializedName: "exportable",
                    type: {
                        name: "Boolean"
                    }
                },
                keyType: {
                    serializedName: "kty",
                    type: {
                        name: "String"
                    }
                },
                keySize: {
                    serializedName: "key_size",
                    type: {
                        name: "Number"
                    }
                },
                reuseKey: {
                    serializedName: "reuse_key",
                    type: {
                        name: "Boolean"
                    }
                },
                curve: {
                    serializedName: "crv",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var SecretProperties = {
        serializedName: "SecretProperties",
        type: {
            name: "Composite",
            className: "SecretProperties",
            modelProperties: {
                contentType: {
                    serializedName: "contentType",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var SubjectAlternativeNames = {
        serializedName: "SubjectAlternativeNames",
        type: {
            name: "Composite",
            className: "SubjectAlternativeNames",
            modelProperties: {
                emails: {
                    serializedName: "emails",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                dnsNames: {
                    serializedName: "dns_names",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                upns: {
                    serializedName: "upns",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var X509CertificateProperties = {
        serializedName: "X509CertificateProperties",
        type: {
            name: "Composite",
            className: "X509CertificateProperties",
            modelProperties: {
                subject: {
                    serializedName: "subject",
                    type: {
                        name: "String"
                    }
                },
                ekus: {
                    serializedName: "ekus",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                subjectAlternativeNames: {
                    serializedName: "sans",
                    type: {
                        name: "Composite",
                        className: "SubjectAlternativeNames"
                    }
                },
                keyUsage: {
                    serializedName: "key_usage",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                validityInMonths: {
                    serializedName: "validity_months",
                    constraints: {
                        InclusiveMinimum: 0
                    },
                    type: {
                        name: "Number"
                    }
                }
            }
        }
    };
    var Trigger = {
        serializedName: "Trigger",
        type: {
            name: "Composite",
            className: "Trigger",
            modelProperties: {
                lifetimePercentage: {
                    serializedName: "lifetime_percentage",
                    constraints: {
                        InclusiveMaximum: 99,
                        InclusiveMinimum: 1
                    },
                    type: {
                        name: "Number"
                    }
                },
                daysBeforeExpiry: {
                    serializedName: "days_before_expiry",
                    type: {
                        name: "Number"
                    }
                }
            }
        }
    };
    var Action = {
        serializedName: "Action",
        type: {
            name: "Composite",
            className: "Action",
            modelProperties: {
                actionType: {
                    serializedName: "action_type",
                    type: {
                        name: "Enum",
                        allowedValues: ["EmailContacts", "AutoRenew"]
                    }
                }
            }
        }
    };
    var LifetimeAction = {
        serializedName: "LifetimeAction",
        type: {
            name: "Composite",
            className: "LifetimeAction",
            modelProperties: {
                trigger: {
                    serializedName: "trigger",
                    type: {
                        name: "Composite",
                        className: "Trigger"
                    }
                },
                action: {
                    serializedName: "action",
                    type: {
                        name: "Composite",
                        className: "Action"
                    }
                }
            }
        }
    };
    var IssuerParameters = {
        serializedName: "IssuerParameters",
        type: {
            name: "Composite",
            className: "IssuerParameters",
            modelProperties: {
                name: {
                    serializedName: "name",
                    type: {
                        name: "String"
                    }
                },
                certificateType: {
                    serializedName: "cty",
                    type: {
                        name: "String"
                    }
                },
                certificateTransparency: {
                    serializedName: "cert_transparency",
                    type: {
                        name: "Boolean"
                    }
                }
            }
        }
    };
    var CertificatePolicy = {
        serializedName: "CertificatePolicy",
        type: {
            name: "Composite",
            className: "CertificatePolicy",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                keyProperties: {
                    serializedName: "key_props",
                    type: {
                        name: "Composite",
                        className: "KeyProperties"
                    }
                },
                secretProperties: {
                    serializedName: "secret_props",
                    type: {
                        name: "Composite",
                        className: "SecretProperties"
                    }
                },
                x509CertificateProperties: {
                    serializedName: "x509_props",
                    type: {
                        name: "Composite",
                        className: "X509CertificateProperties"
                    }
                },
                lifetimeActions: {
                    serializedName: "lifetime_actions",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "LifetimeAction"
                            }
                        }
                    }
                },
                issuerParameters: {
                    serializedName: "issuer",
                    type: {
                        name: "Composite",
                        className: "IssuerParameters"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "CertificateAttributes"
                    }
                }
            }
        }
    };
    var CertificateBundle = {
        serializedName: "CertificateBundle",
        type: {
            name: "Composite",
            className: "CertificateBundle",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                kid: {
                    readOnly: true,
                    serializedName: "kid",
                    type: {
                        name: "String"
                    }
                },
                sid: {
                    readOnly: true,
                    serializedName: "sid",
                    type: {
                        name: "String"
                    }
                },
                x509Thumbprint: {
                    readOnly: true,
                    serializedName: "x5t",
                    type: {
                        name: "Base64Url"
                    }
                },
                policy: {
                    readOnly: true,
                    serializedName: "policy",
                    type: {
                        name: "Composite",
                        className: "CertificatePolicy"
                    }
                },
                cer: {
                    serializedName: "cer",
                    type: {
                        name: "ByteArray"
                    }
                },
                contentType: {
                    serializedName: "contentType",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "CertificateAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var DeletedCertificateBundle = {
        serializedName: "DeletedCertificateBundle",
        type: {
            name: "Composite",
            className: "DeletedCertificateBundle",
            modelProperties: __assign({}, CertificateBundle.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var DeletedCertificateItem = {
        serializedName: "DeletedCertificateItem",
        type: {
            name: "Composite",
            className: "DeletedCertificateItem",
            modelProperties: __assign({}, CertificateItem.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var ErrorModel = {
        serializedName: "Error",
        type: {
            name: "Composite",
            className: "ErrorModel",
            modelProperties: {
                code: {
                    readOnly: true,
                    serializedName: "code",
                    type: {
                        name: "String"
                    }
                },
                message: {
                    readOnly: true,
                    serializedName: "message",
                    type: {
                        name: "String"
                    }
                },
                innerError: {
                    readOnly: true,
                    serializedName: "innererror",
                    type: {
                        name: "Composite",
                        className: "ErrorModel"
                    }
                }
            }
        }
    };
    var CertificateOperation = {
        serializedName: "CertificateOperation",
        type: {
            name: "Composite",
            className: "CertificateOperation",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                issuerParameters: {
                    serializedName: "issuer",
                    type: {
                        name: "Composite",
                        className: "IssuerParameters"
                    }
                },
                csr: {
                    serializedName: "csr",
                    type: {
                        name: "ByteArray"
                    }
                },
                cancellationRequested: {
                    serializedName: "cancellation_requested",
                    type: {
                        name: "Boolean"
                    }
                },
                status: {
                    serializedName: "status",
                    type: {
                        name: "String"
                    }
                },
                statusDetails: {
                    serializedName: "status_details",
                    type: {
                        name: "String"
                    }
                },
                error: {
                    serializedName: "error",
                    type: {
                        name: "Composite",
                        className: "ErrorModel"
                    }
                },
                target: {
                    serializedName: "target",
                    type: {
                        name: "String"
                    }
                },
                requestId: {
                    serializedName: "request_id",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var IssuerCredentials = {
        serializedName: "IssuerCredentials",
        type: {
            name: "Composite",
            className: "IssuerCredentials",
            modelProperties: {
                accountId: {
                    serializedName: "account_id",
                    type: {
                        name: "String"
                    }
                },
                password: {
                    serializedName: "pwd",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var AdministratorDetails = {
        serializedName: "AdministratorDetails",
        type: {
            name: "Composite",
            className: "AdministratorDetails",
            modelProperties: {
                firstName: {
                    serializedName: "first_name",
                    type: {
                        name: "String"
                    }
                },
                lastName: {
                    serializedName: "last_name",
                    type: {
                        name: "String"
                    }
                },
                emailAddress: {
                    serializedName: "email",
                    type: {
                        name: "String"
                    }
                },
                phone: {
                    serializedName: "phone",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var OrganizationDetails = {
        serializedName: "OrganizationDetails",
        type: {
            name: "Composite",
            className: "OrganizationDetails",
            modelProperties: {
                id: {
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                adminDetails: {
                    serializedName: "admin_details",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "AdministratorDetails"
                            }
                        }
                    }
                }
            }
        }
    };
    var IssuerAttributes = {
        serializedName: "IssuerAttributes",
        type: {
            name: "Composite",
            className: "IssuerAttributes",
            modelProperties: {
                enabled: {
                    serializedName: "enabled",
                    type: {
                        name: "Boolean"
                    }
                },
                created: {
                    readOnly: true,
                    serializedName: "created",
                    type: {
                        name: "UnixTime"
                    }
                },
                updated: {
                    readOnly: true,
                    serializedName: "updated",
                    type: {
                        name: "UnixTime"
                    }
                }
            }
        }
    };
    var IssuerBundle = {
        serializedName: "IssuerBundle",
        type: {
            name: "Composite",
            className: "IssuerBundle",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                provider: {
                    serializedName: "provider",
                    type: {
                        name: "String"
                    }
                },
                credentials: {
                    serializedName: "credentials",
                    type: {
                        name: "Composite",
                        className: "IssuerCredentials"
                    }
                },
                organizationDetails: {
                    serializedName: "org_details",
                    type: {
                        name: "Composite",
                        className: "OrganizationDetails"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "IssuerAttributes"
                    }
                }
            }
        }
    };
    var Contact = {
        serializedName: "Contact",
        type: {
            name: "Composite",
            className: "Contact",
            modelProperties: {
                emailAddress: {
                    serializedName: "email",
                    type: {
                        name: "String"
                    }
                },
                name: {
                    serializedName: "name",
                    type: {
                        name: "String"
                    }
                },
                phone: {
                    serializedName: "phone",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var Contacts = {
        serializedName: "Contacts",
        type: {
            name: "Composite",
            className: "Contacts",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                contactList: {
                    serializedName: "contacts",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "Contact"
                            }
                        }
                    }
                }
            }
        }
    };
    var KeyCreateParameters = {
        serializedName: "KeyCreateParameters",
        type: {
            name: "Composite",
            className: "KeyCreateParameters",
            modelProperties: {
                kty: {
                    required: true,
                    serializedName: "kty",
                    constraints: {
                        MinLength: 1
                    },
                    type: {
                        name: "String"
                    }
                },
                keySize: {
                    serializedName: "key_size",
                    type: {
                        name: "Number"
                    }
                },
                keyOps: {
                    serializedName: "key_ops",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                keyAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "KeyAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                curve: {
                    serializedName: "crv",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var KeyImportParameters = {
        serializedName: "KeyImportParameters",
        type: {
            name: "Composite",
            className: "KeyImportParameters",
            modelProperties: {
                hsm: {
                    serializedName: "Hsm",
                    type: {
                        name: "Boolean"
                    }
                },
                key: {
                    required: true,
                    serializedName: "key",
                    type: {
                        name: "Composite",
                        className: "JsonWebKey"
                    }
                },
                keyAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "KeyAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var KeyOperationsParameters = {
        serializedName: "KeyOperationsParameters",
        type: {
            name: "Composite",
            className: "KeyOperationsParameters",
            modelProperties: {
                algorithm: {
                    required: true,
                    serializedName: "alg",
                    constraints: {
                        MinLength: 1
                    },
                    type: {
                        name: "String"
                    }
                },
                value: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var KeySignParameters = {
        serializedName: "KeySignParameters",
        type: {
            name: "Composite",
            className: "KeySignParameters",
            modelProperties: {
                algorithm: {
                    required: true,
                    serializedName: "alg",
                    constraints: {
                        MinLength: 1
                    },
                    type: {
                        name: "String"
                    }
                },
                value: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var KeyVerifyParameters = {
        serializedName: "KeyVerifyParameters",
        type: {
            name: "Composite",
            className: "KeyVerifyParameters",
            modelProperties: {
                algorithm: {
                    required: true,
                    serializedName: "alg",
                    constraints: {
                        MinLength: 1
                    },
                    type: {
                        name: "String"
                    }
                },
                digest: {
                    required: true,
                    serializedName: "digest",
                    type: {
                        name: "Base64Url"
                    }
                },
                signature: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var KeyUpdateParameters = {
        serializedName: "KeyUpdateParameters",
        type: {
            name: "Composite",
            className: "KeyUpdateParameters",
            modelProperties: {
                keyOps: {
                    serializedName: "key_ops",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                keyAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "KeyAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var KeyRestoreParameters = {
        serializedName: "KeyRestoreParameters",
        type: {
            name: "Composite",
            className: "KeyRestoreParameters",
            modelProperties: {
                keyBundleBackup: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var SecretSetParameters = {
        serializedName: "SecretSetParameters",
        type: {
            name: "Composite",
            className: "SecretSetParameters",
            modelProperties: {
                value: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "String"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                },
                contentType: {
                    serializedName: "contentType",
                    type: {
                        name: "String"
                    }
                },
                secretAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "SecretAttributes"
                    }
                }
            }
        }
    };
    var SecretUpdateParameters = {
        serializedName: "SecretUpdateParameters",
        type: {
            name: "Composite",
            className: "SecretUpdateParameters",
            modelProperties: {
                contentType: {
                    serializedName: "contentType",
                    type: {
                        name: "String"
                    }
                },
                secretAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "SecretAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var CertificateCreateParameters = {
        serializedName: "CertificateCreateParameters",
        type: {
            name: "Composite",
            className: "CertificateCreateParameters",
            modelProperties: {
                certificatePolicy: {
                    serializedName: "policy",
                    type: {
                        name: "Composite",
                        className: "CertificatePolicy"
                    }
                },
                certificateAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "CertificateAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var CertificateImportParameters = {
        serializedName: "CertificateImportParameters",
        type: {
            name: "Composite",
            className: "CertificateImportParameters",
            modelProperties: {
                base64EncodedCertificate: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "String"
                    }
                },
                password: {
                    serializedName: "pwd",
                    type: {
                        name: "String"
                    }
                },
                certificatePolicy: {
                    serializedName: "policy",
                    type: {
                        name: "Composite",
                        className: "CertificatePolicy"
                    }
                },
                certificateAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "CertificateAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var CertificateUpdateParameters = {
        serializedName: "CertificateUpdateParameters",
        type: {
            name: "Composite",
            className: "CertificateUpdateParameters",
            modelProperties: {
                certificatePolicy: {
                    serializedName: "policy",
                    type: {
                        name: "Composite",
                        className: "CertificatePolicy"
                    }
                },
                certificateAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "CertificateAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var CertificateMergeParameters = {
        serializedName: "CertificateMergeParameters",
        type: {
            name: "Composite",
            className: "CertificateMergeParameters",
            modelProperties: {
                x509Certificates: {
                    required: true,
                    serializedName: "x5c",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "ByteArray"
                            }
                        }
                    }
                },
                certificateAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "CertificateAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var CertificateIssuerSetParameters = {
        serializedName: "CertificateIssuerSetParameters",
        type: {
            name: "Composite",
            className: "CertificateIssuerSetParameters",
            modelProperties: {
                provider: {
                    required: true,
                    serializedName: "provider",
                    type: {
                        name: "String"
                    }
                },
                credentials: {
                    serializedName: "credentials",
                    type: {
                        name: "Composite",
                        className: "IssuerCredentials"
                    }
                },
                organizationDetails: {
                    serializedName: "org_details",
                    type: {
                        name: "Composite",
                        className: "OrganizationDetails"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "IssuerAttributes"
                    }
                }
            }
        }
    };
    var CertificateIssuerUpdateParameters = {
        serializedName: "CertificateIssuerUpdateParameters",
        type: {
            name: "Composite",
            className: "CertificateIssuerUpdateParameters",
            modelProperties: {
                provider: {
                    serializedName: "provider",
                    type: {
                        name: "String"
                    }
                },
                credentials: {
                    serializedName: "credentials",
                    type: {
                        name: "Composite",
                        className: "IssuerCredentials"
                    }
                },
                organizationDetails: {
                    serializedName: "org_details",
                    type: {
                        name: "Composite",
                        className: "OrganizationDetails"
                    }
                },
                attributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "IssuerAttributes"
                    }
                }
            }
        }
    };
    var CertificateOperationUpdateParameter = {
        serializedName: "CertificateOperationUpdateParameter",
        type: {
            name: "Composite",
            className: "CertificateOperationUpdateParameter",
            modelProperties: {
                cancellationRequested: {
                    required: true,
                    serializedName: "cancellation_requested",
                    type: {
                        name: "Boolean"
                    }
                }
            }
        }
    };
    var KeyOperationResult = {
        serializedName: "KeyOperationResult",
        type: {
            name: "Composite",
            className: "KeyOperationResult",
            modelProperties: {
                kid: {
                    readOnly: true,
                    serializedName: "kid",
                    type: {
                        name: "String"
                    }
                },
                result: {
                    readOnly: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var KeyVerifyResult = {
        serializedName: "KeyVerifyResult",
        type: {
            name: "Composite",
            className: "KeyVerifyResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "value",
                    type: {
                        name: "Boolean"
                    }
                }
            }
        }
    };
    var BackupKeyResult = {
        serializedName: "BackupKeyResult",
        type: {
            name: "Composite",
            className: "BackupKeyResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var BackupSecretResult = {
        serializedName: "BackupSecretResult",
        type: {
            name: "Composite",
            className: "BackupSecretResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var BackupStorageResult = {
        serializedName: "BackupStorageResult",
        type: {
            name: "Composite",
            className: "BackupStorageResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var PendingCertificateSigningRequestResult = {
        serializedName: "PendingCertificateSigningRequestResult",
        type: {
            name: "Composite",
            className: "PendingCertificateSigningRequestResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "value",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var StorageAccountAttributes = {
        serializedName: "StorageAccountAttributes",
        type: {
            name: "Composite",
            className: "StorageAccountAttributes",
            modelProperties: {
                enabled: {
                    serializedName: "enabled",
                    type: {
                        name: "Boolean"
                    }
                },
                created: {
                    readOnly: true,
                    serializedName: "created",
                    type: {
                        name: "UnixTime"
                    }
                },
                updated: {
                    readOnly: true,
                    serializedName: "updated",
                    type: {
                        name: "UnixTime"
                    }
                },
                recoveryLevel: {
                    nullable: false,
                    readOnly: true,
                    serializedName: "recoveryLevel",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var StorageBundle = {
        serializedName: "StorageBundle",
        type: {
            name: "Composite",
            className: "StorageBundle",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                resourceId: {
                    readOnly: true,
                    serializedName: "resourceId",
                    type: {
                        name: "String"
                    }
                },
                activeKeyName: {
                    readOnly: true,
                    serializedName: "activeKeyName",
                    type: {
                        name: "String"
                    }
                },
                autoRegenerateKey: {
                    readOnly: true,
                    serializedName: "autoRegenerateKey",
                    type: {
                        name: "Boolean"
                    }
                },
                regenerationPeriod: {
                    readOnly: true,
                    serializedName: "regenerationPeriod",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    readOnly: true,
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "StorageAccountAttributes"
                    }
                },
                tags: {
                    readOnly: true,
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var DeletedStorageBundle = {
        serializedName: "DeletedStorageBundle",
        type: {
            name: "Composite",
            className: "DeletedStorageBundle",
            modelProperties: __assign({}, StorageBundle.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var StorageAccountCreateParameters = {
        serializedName: "StorageAccountCreateParameters",
        type: {
            name: "Composite",
            className: "StorageAccountCreateParameters",
            modelProperties: {
                resourceId: {
                    required: true,
                    serializedName: "resourceId",
                    type: {
                        name: "String"
                    }
                },
                activeKeyName: {
                    required: true,
                    serializedName: "activeKeyName",
                    type: {
                        name: "String"
                    }
                },
                autoRegenerateKey: {
                    required: true,
                    serializedName: "autoRegenerateKey",
                    type: {
                        name: "Boolean"
                    }
                },
                regenerationPeriod: {
                    serializedName: "regenerationPeriod",
                    type: {
                        name: "String"
                    }
                },
                storageAccountAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "StorageAccountAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var StorageAccountUpdateParameters = {
        serializedName: "StorageAccountUpdateParameters",
        type: {
            name: "Composite",
            className: "StorageAccountUpdateParameters",
            modelProperties: {
                activeKeyName: {
                    serializedName: "activeKeyName",
                    type: {
                        name: "String"
                    }
                },
                autoRegenerateKey: {
                    serializedName: "autoRegenerateKey",
                    type: {
                        name: "Boolean"
                    }
                },
                regenerationPeriod: {
                    serializedName: "regenerationPeriod",
                    type: {
                        name: "String"
                    }
                },
                storageAccountAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "StorageAccountAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var StorageAccountRegenerteKeyParameters = {
        serializedName: "StorageAccountRegenerteKeyParameters",
        type: {
            name: "Composite",
            className: "StorageAccountRegenerteKeyParameters",
            modelProperties: {
                keyName: {
                    required: true,
                    serializedName: "keyName",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var StorageAccountItem = {
        serializedName: "StorageAccountItem",
        type: {
            name: "Composite",
            className: "StorageAccountItem",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                resourceId: {
                    readOnly: true,
                    serializedName: "resourceId",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    readOnly: true,
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "StorageAccountAttributes"
                    }
                },
                tags: {
                    readOnly: true,
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var DeletedStorageAccountItem = {
        serializedName: "DeletedStorageAccountItem",
        type: {
            name: "Composite",
            className: "DeletedStorageAccountItem",
            modelProperties: __assign({}, StorageAccountItem.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var SasDefinitionAttributes = {
        serializedName: "SasDefinitionAttributes",
        type: {
            name: "Composite",
            className: "SasDefinitionAttributes",
            modelProperties: {
                enabled: {
                    serializedName: "enabled",
                    type: {
                        name: "Boolean"
                    }
                },
                created: {
                    readOnly: true,
                    serializedName: "created",
                    type: {
                        name: "UnixTime"
                    }
                },
                updated: {
                    readOnly: true,
                    serializedName: "updated",
                    type: {
                        name: "UnixTime"
                    }
                },
                recoveryLevel: {
                    nullable: false,
                    readOnly: true,
                    serializedName: "recoveryLevel",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var SasDefinitionBundle = {
        serializedName: "SasDefinitionBundle",
        type: {
            name: "Composite",
            className: "SasDefinitionBundle",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                secretId: {
                    readOnly: true,
                    serializedName: "sid",
                    type: {
                        name: "String"
                    }
                },
                templateUri: {
                    readOnly: true,
                    serializedName: "templateUri",
                    type: {
                        name: "String"
                    }
                },
                sasType: {
                    readOnly: true,
                    serializedName: "sasType",
                    type: {
                        name: "String"
                    }
                },
                validityPeriod: {
                    readOnly: true,
                    serializedName: "validityPeriod",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    readOnly: true,
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "SasDefinitionAttributes"
                    }
                },
                tags: {
                    readOnly: true,
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var DeletedSasDefinitionBundle = {
        serializedName: "DeletedSasDefinitionBundle",
        type: {
            name: "Composite",
            className: "DeletedSasDefinitionBundle",
            modelProperties: __assign({}, SasDefinitionBundle.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var SasDefinitionItem = {
        serializedName: "SasDefinitionItem",
        type: {
            name: "Composite",
            className: "SasDefinitionItem",
            modelProperties: {
                id: {
                    readOnly: true,
                    serializedName: "id",
                    type: {
                        name: "String"
                    }
                },
                secretId: {
                    readOnly: true,
                    serializedName: "sid",
                    type: {
                        name: "String"
                    }
                },
                attributes: {
                    readOnly: true,
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "SasDefinitionAttributes"
                    }
                },
                tags: {
                    readOnly: true,
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var DeletedSasDefinitionItem = {
        serializedName: "DeletedSasDefinitionItem",
        type: {
            name: "Composite",
            className: "DeletedSasDefinitionItem",
            modelProperties: __assign({}, SasDefinitionItem.type.modelProperties, { recoveryId: {
                    serializedName: "recoveryId",
                    type: {
                        name: "String"
                    }
                }, scheduledPurgeDate: {
                    readOnly: true,
                    serializedName: "scheduledPurgeDate",
                    type: {
                        name: "UnixTime"
                    }
                }, deletedDate: {
                    readOnly: true,
                    serializedName: "deletedDate",
                    type: {
                        name: "UnixTime"
                    }
                } })
        }
    };
    var SasDefinitionCreateParameters = {
        serializedName: "SasDefinitionCreateParameters",
        type: {
            name: "Composite",
            className: "SasDefinitionCreateParameters",
            modelProperties: {
                templateUri: {
                    required: true,
                    serializedName: "templateUri",
                    type: {
                        name: "String"
                    }
                },
                sasType: {
                    required: true,
                    serializedName: "sasType",
                    type: {
                        name: "String"
                    }
                },
                validityPeriod: {
                    required: true,
                    serializedName: "validityPeriod",
                    type: {
                        name: "String"
                    }
                },
                sasDefinitionAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "SasDefinitionAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var SasDefinitionUpdateParameters = {
        serializedName: "SasDefinitionUpdateParameters",
        type: {
            name: "Composite",
            className: "SasDefinitionUpdateParameters",
            modelProperties: {
                templateUri: {
                    serializedName: "templateUri",
                    type: {
                        name: "String"
                    }
                },
                sasType: {
                    serializedName: "sasType",
                    type: {
                        name: "String"
                    }
                },
                validityPeriod: {
                    serializedName: "validityPeriod",
                    type: {
                        name: "String"
                    }
                },
                sasDefinitionAttributes: {
                    serializedName: "attributes",
                    type: {
                        name: "Composite",
                        className: "SasDefinitionAttributes"
                    }
                },
                tags: {
                    serializedName: "tags",
                    type: {
                        name: "Dictionary",
                        value: {
                            type: {
                                name: "String"
                            }
                        }
                    }
                }
            }
        }
    };
    var KeyVaultError = {
        serializedName: "KeyVaultError",
        type: {
            name: "Composite",
            className: "KeyVaultError",
            modelProperties: {
                error: {
                    readOnly: true,
                    serializedName: "error",
                    type: {
                        name: "Composite",
                        className: "ErrorModel"
                    }
                }
            }
        }
    };
    var CertificateRestoreParameters = {
        serializedName: "CertificateRestoreParameters",
        type: {
            name: "Composite",
            className: "CertificateRestoreParameters",
            modelProperties: {
                certificateBundleBackup: {
                    required: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var BackupCertificateResult = {
        serializedName: "BackupCertificateResult",
        type: {
            name: "Composite",
            className: "BackupCertificateResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "value",
                    type: {
                        name: "Base64Url"
                    }
                }
            }
        }
    };
    var KeyListResult = {
        serializedName: "KeyListResult",
        type: {
            name: "Composite",
            className: "KeyListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "KeyItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var DeletedKeyListResult = {
        serializedName: "DeletedKeyListResult",
        type: {
            name: "Composite",
            className: "DeletedKeyListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "DeletedKeyItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var SecretListResult = {
        serializedName: "SecretListResult",
        type: {
            name: "Composite",
            className: "SecretListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "SecretItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var DeletedSecretListResult = {
        serializedName: "DeletedSecretListResult",
        type: {
            name: "Composite",
            className: "DeletedSecretListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "DeletedSecretItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var CertificateListResult = {
        serializedName: "CertificateListResult",
        type: {
            name: "Composite",
            className: "CertificateListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "CertificateItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var CertificateIssuerListResult = {
        serializedName: "CertificateIssuerListResult",
        type: {
            name: "Composite",
            className: "CertificateIssuerListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "CertificateIssuerItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var DeletedCertificateListResult = {
        serializedName: "DeletedCertificateListResult",
        type: {
            name: "Composite",
            className: "DeletedCertificateListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "DeletedCertificateItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var StorageListResult = {
        serializedName: "StorageListResult",
        type: {
            name: "Composite",
            className: "StorageListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "StorageAccountItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var DeletedStorageListResult = {
        serializedName: "DeletedStorageListResult",
        type: {
            name: "Composite",
            className: "DeletedStorageListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "DeletedStorageAccountItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var SasDefinitionListResult = {
        serializedName: "SasDefinitionListResult",
        type: {
            name: "Composite",
            className: "SasDefinitionListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "SasDefinitionItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };
    var DeletedSasDefinitionListResult = {
        serializedName: "DeletedSasDefinitionListResult",
        type: {
            name: "Composite",
            className: "DeletedSasDefinitionListResult",
            modelProperties: {
                value: {
                    readOnly: true,
                    serializedName: "",
                    type: {
                        name: "Sequence",
                        element: {
                            type: {
                                name: "Composite",
                                className: "DeletedSasDefinitionItem"
                            }
                        }
                    }
                },
                nextLink: {
                    readOnly: true,
                    serializedName: "nextLink",
                    type: {
                        name: "String"
                    }
                }
            }
        }
    };

    var Mappers = /*#__PURE__*/Object.freeze({
        CloudError: CloudError,
        BaseResource: BaseResource,
        Attributes: Attributes,
        JsonWebKey: JsonWebKey,
        KeyAttributes: KeyAttributes,
        KeyBundle: KeyBundle,
        KeyItem: KeyItem,
        DeletedKeyBundle: DeletedKeyBundle,
        DeletedKeyItem: DeletedKeyItem,
        SecretAttributes: SecretAttributes,
        SecretBundle: SecretBundle,
        SecretItem: SecretItem,
        DeletedSecretBundle: DeletedSecretBundle,
        DeletedSecretItem: DeletedSecretItem,
        SecretRestoreParameters: SecretRestoreParameters,
        StorageRestoreParameters: StorageRestoreParameters,
        CertificateAttributes: CertificateAttributes,
        CertificateItem: CertificateItem,
        CertificateIssuerItem: CertificateIssuerItem,
        KeyProperties: KeyProperties,
        SecretProperties: SecretProperties,
        SubjectAlternativeNames: SubjectAlternativeNames,
        X509CertificateProperties: X509CertificateProperties,
        Trigger: Trigger,
        Action: Action,
        LifetimeAction: LifetimeAction,
        IssuerParameters: IssuerParameters,
        CertificatePolicy: CertificatePolicy,
        CertificateBundle: CertificateBundle,
        DeletedCertificateBundle: DeletedCertificateBundle,
        DeletedCertificateItem: DeletedCertificateItem,
        ErrorModel: ErrorModel,
        CertificateOperation: CertificateOperation,
        IssuerCredentials: IssuerCredentials,
        AdministratorDetails: AdministratorDetails,
        OrganizationDetails: OrganizationDetails,
        IssuerAttributes: IssuerAttributes,
        IssuerBundle: IssuerBundle,
        Contact: Contact,
        Contacts: Contacts,
        KeyCreateParameters: KeyCreateParameters,
        KeyImportParameters: KeyImportParameters,
        KeyOperationsParameters: KeyOperationsParameters,
        KeySignParameters: KeySignParameters,
        KeyVerifyParameters: KeyVerifyParameters,
        KeyUpdateParameters: KeyUpdateParameters,
        KeyRestoreParameters: KeyRestoreParameters,
        SecretSetParameters: SecretSetParameters,
        SecretUpdateParameters: SecretUpdateParameters,
        CertificateCreateParameters: CertificateCreateParameters,
        CertificateImportParameters: CertificateImportParameters,
        CertificateUpdateParameters: CertificateUpdateParameters,
        CertificateMergeParameters: CertificateMergeParameters,
        CertificateIssuerSetParameters: CertificateIssuerSetParameters,
        CertificateIssuerUpdateParameters: CertificateIssuerUpdateParameters,
        CertificateOperationUpdateParameter: CertificateOperationUpdateParameter,
        KeyOperationResult: KeyOperationResult,
        KeyVerifyResult: KeyVerifyResult,
        BackupKeyResult: BackupKeyResult,
        BackupSecretResult: BackupSecretResult,
        BackupStorageResult: BackupStorageResult,
        PendingCertificateSigningRequestResult: PendingCertificateSigningRequestResult,
        StorageAccountAttributes: StorageAccountAttributes,
        StorageBundle: StorageBundle,
        DeletedStorageBundle: DeletedStorageBundle,
        StorageAccountCreateParameters: StorageAccountCreateParameters,
        StorageAccountUpdateParameters: StorageAccountUpdateParameters,
        StorageAccountRegenerteKeyParameters: StorageAccountRegenerteKeyParameters,
        StorageAccountItem: StorageAccountItem,
        DeletedStorageAccountItem: DeletedStorageAccountItem,
        SasDefinitionAttributes: SasDefinitionAttributes,
        SasDefinitionBundle: SasDefinitionBundle,
        DeletedSasDefinitionBundle: DeletedSasDefinitionBundle,
        SasDefinitionItem: SasDefinitionItem,
        DeletedSasDefinitionItem: DeletedSasDefinitionItem,
        SasDefinitionCreateParameters: SasDefinitionCreateParameters,
        SasDefinitionUpdateParameters: SasDefinitionUpdateParameters,
        KeyVaultError: KeyVaultError,
        CertificateRestoreParameters: CertificateRestoreParameters,
        BackupCertificateResult: BackupCertificateResult,
        KeyListResult: KeyListResult,
        DeletedKeyListResult: DeletedKeyListResult,
        SecretListResult: SecretListResult,
        DeletedSecretListResult: DeletedSecretListResult,
        CertificateListResult: CertificateListResult,
        CertificateIssuerListResult: CertificateIssuerListResult,
        DeletedCertificateListResult: DeletedCertificateListResult,
        StorageListResult: StorageListResult,
        DeletedStorageListResult: DeletedStorageListResult,
        SasDefinitionListResult: SasDefinitionListResult,
        DeletedSasDefinitionListResult: DeletedSasDefinitionListResult
    });

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for
     * license information.
     *
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    var acceptLanguage = {
        parameterPath: "acceptLanguage",
        mapper: {
            serializedName: "accept-language",
            defaultValue: "en-US",
            type: {
                name: "String"
            }
        }
    };
    var apiVersion = {
        parameterPath: "apiVersion",
        mapper: {
            required: true,
            serializedName: "api-version",
            type: {
                name: "String"
            }
        }
    };
    var certificateName0 = {
        parameterPath: "certificateName",
        mapper: {
            required: true,
            serializedName: "certificate-name",
            type: {
                name: "String"
            }
        }
    };
    var certificateName1 = {
        parameterPath: "certificateName",
        mapper: {
            required: true,
            serializedName: "certificate-name",
            constraints: {
                Pattern: /^[0-9a-zA-Z-]+$/
            },
            type: {
                name: "String"
            }
        }
    };
    var certificateVersion = {
        parameterPath: "certificateVersion",
        mapper: {
            required: true,
            serializedName: "certificate-version",
            type: {
                name: "String"
            }
        }
    };
    var includePending = {
        parameterPath: ["options", "includePending"],
        mapper: {
            serializedName: "includePending",
            type: {
                name: "Boolean"
            }
        }
    };
    var issuerName = {
        parameterPath: "issuerName",
        mapper: {
            required: true,
            serializedName: "issuer-name",
            type: {
                name: "String"
            }
        }
    };
    var keyName0 = {
        parameterPath: "keyName",
        mapper: {
            required: true,
            serializedName: "key-name",
            constraints: {
                Pattern: /^[0-9a-zA-Z-]+$/
            },
            type: {
                name: "String"
            }
        }
    };
    var keyName1 = {
        parameterPath: "keyName",
        mapper: {
            required: true,
            serializedName: "key-name",
            type: {
                name: "String"
            }
        }
    };
    var keyVersion = {
        parameterPath: "keyVersion",
        mapper: {
            required: true,
            serializedName: "key-version",
            type: {
                name: "String"
            }
        }
    };
    var maxresults = {
        parameterPath: ["options", "maxresults"],
        mapper: {
            serializedName: "maxresults",
            constraints: {
                InclusiveMaximum: 25,
                InclusiveMinimum: 1
            },
            type: {
                name: "Number"
            }
        }
    };
    var nextPageLink = {
        parameterPath: "nextPageLink",
        mapper: {
            required: true,
            serializedName: "nextLink",
            type: {
                name: "String"
            }
        },
        skipEncoding: true
    };
    var sasDefinitionName = {
        parameterPath: "sasDefinitionName",
        mapper: {
            required: true,
            serializedName: "sas-definition-name",
            constraints: {
                Pattern: /^[0-9a-zA-Z]+$/
            },
            type: {
                name: "String"
            }
        }
    };
    var secretName0 = {
        parameterPath: "secretName",
        mapper: {
            required: true,
            serializedName: "secret-name",
            constraints: {
                Pattern: /^[0-9a-zA-Z-]+$/
            },
            type: {
                name: "String"
            }
        }
    };
    var secretName1 = {
        parameterPath: "secretName",
        mapper: {
            required: true,
            serializedName: "secret-name",
            type: {
                name: "String"
            }
        }
    };
    var secretVersion = {
        parameterPath: "secretVersion",
        mapper: {
            required: true,
            serializedName: "secret-version",
            type: {
                name: "String"
            }
        }
    };
    var storageAccountName0 = {
        parameterPath: "storageAccountName",
        mapper: {
            required: true,
            serializedName: "storage-account-name",
            constraints: {
                Pattern: /^[0-9a-zA-Z]+$/
            },
            type: {
                name: "String"
            }
        }
    };
    var storageAccountName1 = {
        parameterPath: "storageAccountName",
        mapper: {
            required: true,
            serializedName: "storage-account-name",
            type: {
                name: "String"
            }
        }
    };
    var vaultBaseUrl = {
        parameterPath: "vaultBaseUrl",
        mapper: {
            required: true,
            serializedName: "vaultBaseUrl",
            defaultValue: "",
            type: {
                name: "String"
            }
        },
        skipEncoding: true
    };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for
     * license information.
     *
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    var packageName = "@azure/keyvault-secrets";
    var packageVersion = "4.0.0-preview.5";
    var KeyVaultClientContext = /** @class */ (function (_super) {
        __extends(KeyVaultClientContext, _super);
        /**
         * Initializes a new instance of the KeyVaultClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        function KeyVaultClientContext(credentials, options) {
            var _this = this;
            if (credentials == undefined) {
                throw new Error("'credentials' cannot be null.");
            }
            if (!options) {
                options = {};
            }
            if (!options.userAgent) {
                var defaultUserAgent = getDefaultUserAgentValue$1();
                options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
            }
            _this = _super.call(this, credentials, options) || this;
            _this.apiVersion = "7.0";
            _this.acceptLanguage = "en-US";
            _this.longRunningOperationRetryTimeout = 30;
            _this.baseUri = "{vaultBaseUrl}";
            _this.requestContentType = "application/json; charset=utf-8";
            _this.credentials = credentials;
            if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
                _this.acceptLanguage = options.acceptLanguage;
            }
            if (options.longRunningOperationRetryTimeout !== null &&
                options.longRunningOperationRetryTimeout !== undefined) {
                _this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
            }
            return _this;
        }
        return KeyVaultClientContext;
    }(AzureServiceClient));

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for
     * license information.
     *
     * Code generated by Microsoft (R) AutoRest Code Generator.
     * Changes may cause incorrect behavior and will be lost if the code is
     * regenerated.
     */
    var KeyVaultClient = /** @class */ (function (_super) {
        __extends(KeyVaultClient, _super);
        /**
         * Initializes a new instance of the KeyVaultClient class.
         * @param credentials Credentials needed for the client to connect to Azure.
         * @param [options] The parameter options
         */
        function KeyVaultClient(credentials, options) {
            return _super.call(this, credentials, options) || this;
        }
        KeyVaultClient.prototype.createKey = function (vaultBaseUrl, keyName, kty, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                kty: kty,
                options: options
            }, createKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.importKey = function (vaultBaseUrl, keyName, key, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                key: key,
                options: options
            }, importKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.deleteKey = function (vaultBaseUrl, keyName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                options: options
            }, deleteKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.updateKey = function (vaultBaseUrl, keyName, keyVersion, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                keyVersion: keyVersion,
                options: options
            }, updateKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.getKey = function (vaultBaseUrl, keyName, keyVersion, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                keyVersion: keyVersion,
                options: options
            }, getKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.getKeyVersions = function (vaultBaseUrl, keyName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                options: options
            }, getKeyVersionsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getKeys = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getKeysOperationSpec, callback);
        };
        KeyVaultClient.prototype.backupKey = function (vaultBaseUrl, keyName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                options: options
            }, backupKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.restoreKey = function (vaultBaseUrl, keyBundleBackup, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyBundleBackup: keyBundleBackup,
                options: options
            }, restoreKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.encrypt = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                keyVersion: keyVersion,
                algorithm: algorithm,
                value: value,
                options: options
            }, encryptOperationSpec, callback);
        };
        KeyVaultClient.prototype.decrypt = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                keyVersion: keyVersion,
                algorithm: algorithm,
                value: value,
                options: options
            }, decryptOperationSpec, callback);
        };
        KeyVaultClient.prototype.sign = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                keyVersion: keyVersion,
                algorithm: algorithm,
                value: value,
                options: options
            }, signOperationSpec, callback);
        };
        KeyVaultClient.prototype.verify = function (vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                keyVersion: keyVersion,
                algorithm: algorithm,
                digest: digest,
                signature: signature,
                options: options
            }, verifyOperationSpec, callback);
        };
        KeyVaultClient.prototype.wrapKey = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                keyVersion: keyVersion,
                algorithm: algorithm,
                value: value,
                options: options
            }, wrapKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.unwrapKey = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                keyVersion: keyVersion,
                algorithm: algorithm,
                value: value,
                options: options
            }, unwrapKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedKeys = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getDeletedKeysOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                options: options
            }, getDeletedKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.purgeDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                options: options
            }, purgeDeletedKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.recoverDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                keyName: keyName,
                options: options
            }, recoverDeletedKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.setSecret = function (vaultBaseUrl, secretName, value, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                value: value,
                options: options
            }, setSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.deleteSecret = function (vaultBaseUrl, secretName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                options: options
            }, deleteSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.updateSecret = function (vaultBaseUrl, secretName, secretVersion, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                secretVersion: secretVersion,
                options: options
            }, updateSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.getSecret = function (vaultBaseUrl, secretName, secretVersion, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                secretVersion: secretVersion,
                options: options
            }, getSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.getSecrets = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getSecretsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getSecretVersions = function (vaultBaseUrl, secretName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                options: options
            }, getSecretVersionsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedSecrets = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getDeletedSecretsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                options: options
            }, getDeletedSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.purgeDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                options: options
            }, purgeDeletedSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.recoverDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                options: options
            }, recoverDeletedSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.backupSecret = function (vaultBaseUrl, secretName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretName: secretName,
                options: options
            }, backupSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.restoreSecret = function (vaultBaseUrl, secretBundleBackup, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                secretBundleBackup: secretBundleBackup,
                options: options
            }, restoreSecretOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificates = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getCertificatesOperationSpec, callback);
        };
        KeyVaultClient.prototype.deleteCertificate = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, deleteCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.setCertificateContacts = function (vaultBaseUrl, contacts, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                contacts: contacts,
                options: options
            }, setCertificateContactsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificateContacts = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getCertificateContactsOperationSpec, callback);
        };
        KeyVaultClient.prototype.deleteCertificateContacts = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, deleteCertificateContactsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificateIssuers = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getCertificateIssuersOperationSpec, callback);
        };
        KeyVaultClient.prototype.setCertificateIssuer = function (vaultBaseUrl, issuerName, provider, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                issuerName: issuerName,
                provider: provider,
                options: options
            }, setCertificateIssuerOperationSpec, callback);
        };
        KeyVaultClient.prototype.updateCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                issuerName: issuerName,
                options: options
            }, updateCertificateIssuerOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                issuerName: issuerName,
                options: options
            }, getCertificateIssuerOperationSpec, callback);
        };
        KeyVaultClient.prototype.deleteCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                issuerName: issuerName,
                options: options
            }, deleteCertificateIssuerOperationSpec, callback);
        };
        KeyVaultClient.prototype.createCertificate = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, createCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.importCertificate = function (vaultBaseUrl, certificateName, base64EncodedCertificate, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                base64EncodedCertificate: base64EncodedCertificate,
                options: options
            }, importCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificateVersions = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, getCertificateVersionsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificatePolicy = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, getCertificatePolicyOperationSpec, callback);
        };
        KeyVaultClient.prototype.updateCertificatePolicy = function (vaultBaseUrl, certificateName, certificatePolicy, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                certificatePolicy: certificatePolicy,
                options: options
            }, updateCertificatePolicyOperationSpec, callback);
        };
        KeyVaultClient.prototype.updateCertificate = function (vaultBaseUrl, certificateName, certificateVersion, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                certificateVersion: certificateVersion,
                options: options
            }, updateCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificate = function (vaultBaseUrl, certificateName, certificateVersion, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                certificateVersion: certificateVersion,
                options: options
            }, getCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.updateCertificateOperation = function (vaultBaseUrl, certificateName, cancellationRequested, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                cancellationRequested: cancellationRequested,
                options: options
            }, updateCertificateOperationOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificateOperation = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, getCertificateOperationOperationSpec, callback);
        };
        KeyVaultClient.prototype.deleteCertificateOperation = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, deleteCertificateOperationOperationSpec, callback);
        };
        KeyVaultClient.prototype.mergeCertificate = function (vaultBaseUrl, certificateName, x509Certificates, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                x509Certificates: x509Certificates,
                options: options
            }, mergeCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.backupCertificate = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, backupCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.restoreCertificate = function (vaultBaseUrl, certificateBundleBackup, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateBundleBackup: certificateBundleBackup,
                options: options
            }, restoreCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedCertificates = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getDeletedCertificatesOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, getDeletedCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.purgeDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, purgeDeletedCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.recoverDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                certificateName: certificateName,
                options: options
            }, recoverDeletedCertificateOperationSpec, callback);
        };
        KeyVaultClient.prototype.getStorageAccounts = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getStorageAccountsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedStorageAccounts = function (vaultBaseUrl, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                options: options
            }, getDeletedStorageAccountsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, getDeletedStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.purgeDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, purgeDeletedStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.recoverDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, recoverDeletedStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.backupStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, backupStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.restoreStorageAccount = function (vaultBaseUrl, storageBundleBackup, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageBundleBackup: storageBundleBackup,
                options: options
            }, restoreStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.deleteStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, deleteStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.getStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, getStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.setStorageAccount = function (vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                resourceId: resourceId,
                activeKeyName: activeKeyName,
                autoRegenerateKey: autoRegenerateKey,
                options: options
            }, setStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.updateStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, updateStorageAccountOperationSpec, callback);
        };
        KeyVaultClient.prototype.regenerateStorageAccountKey = function (vaultBaseUrl, storageAccountName, keyName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                keyName: keyName,
                options: options
            }, regenerateStorageAccountKeyOperationSpec, callback);
        };
        KeyVaultClient.prototype.getSasDefinitions = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, getSasDefinitionsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedSasDefinitions = function (vaultBaseUrl, storageAccountName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                options: options
            }, getDeletedSasDefinitionsOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                sasDefinitionName: sasDefinitionName,
                options: options
            }, getDeletedSasDefinitionOperationSpec, callback);
        };
        KeyVaultClient.prototype.recoverDeletedSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                sasDefinitionName: sasDefinitionName,
                options: options
            }, recoverDeletedSasDefinitionOperationSpec, callback);
        };
        KeyVaultClient.prototype.deleteSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                sasDefinitionName: sasDefinitionName,
                options: options
            }, deleteSasDefinitionOperationSpec, callback);
        };
        KeyVaultClient.prototype.getSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                sasDefinitionName: sasDefinitionName,
                options: options
            }, getSasDefinitionOperationSpec, callback);
        };
        KeyVaultClient.prototype.setSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, templateUri, sasType, validityPeriod, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                sasDefinitionName: sasDefinitionName,
                templateUri: templateUri,
                sasType: sasType,
                validityPeriod: validityPeriod,
                options: options
            }, setSasDefinitionOperationSpec, callback);
        };
        KeyVaultClient.prototype.updateSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
            return this.sendOperationRequest({
                vaultBaseUrl: vaultBaseUrl,
                storageAccountName: storageAccountName,
                sasDefinitionName: sasDefinitionName,
                options: options
            }, updateSasDefinitionOperationSpec, callback);
        };
        KeyVaultClient.prototype.getKeyVersionsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getKeyVersionsNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getKeysNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getKeysNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedKeysNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getDeletedKeysNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getSecretsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getSecretsNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getSecretVersionsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getSecretVersionsNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedSecretsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getDeletedSecretsNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificatesNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getCertificatesNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificateIssuersNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getCertificateIssuersNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getCertificateVersionsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getCertificateVersionsNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedCertificatesNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getDeletedCertificatesNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getStorageAccountsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getStorageAccountsNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedStorageAccountsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getDeletedStorageAccountsNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getSasDefinitionsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getSasDefinitionsNextOperationSpec, callback);
        };
        KeyVaultClient.prototype.getDeletedSasDefinitionsNext = function (nextPageLink, options, callback) {
            return this.sendOperationRequest({
                nextPageLink: nextPageLink,
                options: options
            }, getDeletedSasDefinitionsNextOperationSpec, callback);
        };
        return KeyVaultClient;
    }(KeyVaultClientContext));
    // Operation Specifications
    var serializer$1 = new Serializer(Mappers);
    var createKeyOperationSpec = {
        httpMethod: "POST",
        path: "keys/{key-name}/create",
        urlParameters: [vaultBaseUrl, keyName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                kty: "kty",
                keySize: ["options", "keySize"],
                keyOps: ["options", "keyOps"],
                keyAttributes: ["options", "keyAttributes"],
                tags: ["options", "tags"],
                curve: ["options", "curve"]
            },
            mapper: __assign({}, KeyCreateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var importKeyOperationSpec = {
        httpMethod: "PUT",
        path: "keys/{key-name}",
        urlParameters: [vaultBaseUrl, keyName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                hsm: ["options", "hsm"],
                key: "key",
                keyAttributes: ["options", "keyAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, KeyImportParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var deleteKeyOperationSpec = {
        httpMethod: "DELETE",
        path: "keys/{key-name}",
        urlParameters: [vaultBaseUrl, keyName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedKeyBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var updateKeyOperationSpec = {
        httpMethod: "PATCH",
        path: "keys/{key-name}/{key-version}",
        urlParameters: [vaultBaseUrl, keyName1, keyVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                keyOps: ["options", "keyOps"],
                keyAttributes: ["options", "keyAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, KeyUpdateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getKeyOperationSpec = {
        httpMethod: "GET",
        path: "keys/{key-name}/{key-version}",
        urlParameters: [vaultBaseUrl, keyName1, keyVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: KeyBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getKeyVersionsOperationSpec = {
        httpMethod: "GET",
        path: "keys/{key-name}/versions",
        urlParameters: [vaultBaseUrl, keyName1],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: KeyListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getKeysOperationSpec = {
        httpMethod: "GET",
        path: "keys",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: KeyListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var backupKeyOperationSpec = {
        httpMethod: "POST",
        path: "keys/{key-name}/backup",
        urlParameters: [vaultBaseUrl, keyName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: BackupKeyResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var restoreKeyOperationSpec = {
        httpMethod: "POST",
        path: "keys/restore",
        urlParameters: [vaultBaseUrl],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                keyBundleBackup: "keyBundleBackup"
            },
            mapper: __assign({}, KeyRestoreParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var encryptOperationSpec = {
        httpMethod: "POST",
        path: "keys/{key-name}/{key-version}/encrypt",
        urlParameters: [vaultBaseUrl, keyName1, keyVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                algorithm: "algorithm",
                value: "value"
            },
            mapper: __assign({}, KeyOperationsParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyOperationResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var decryptOperationSpec = {
        httpMethod: "POST",
        path: "keys/{key-name}/{key-version}/decrypt",
        urlParameters: [vaultBaseUrl, keyName1, keyVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                algorithm: "algorithm",
                value: "value"
            },
            mapper: __assign({}, KeyOperationsParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyOperationResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var signOperationSpec = {
        httpMethod: "POST",
        path: "keys/{key-name}/{key-version}/sign",
        urlParameters: [vaultBaseUrl, keyName1, keyVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                algorithm: "algorithm",
                value: "value"
            },
            mapper: __assign({}, KeySignParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyOperationResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var verifyOperationSpec = {
        httpMethod: "POST",
        path: "keys/{key-name}/{key-version}/verify",
        urlParameters: [vaultBaseUrl, keyName1, keyVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                algorithm: "algorithm",
                digest: "digest",
                signature: "signature"
            },
            mapper: __assign({}, KeyVerifyParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyVerifyResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var wrapKeyOperationSpec = {
        httpMethod: "POST",
        path: "keys/{key-name}/{key-version}/wrapkey",
        urlParameters: [vaultBaseUrl, keyName1, keyVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                algorithm: "algorithm",
                value: "value"
            },
            mapper: __assign({}, KeyOperationsParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyOperationResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var unwrapKeyOperationSpec = {
        httpMethod: "POST",
        path: "keys/{key-name}/{key-version}/unwrapkey",
        urlParameters: [vaultBaseUrl, keyName1, keyVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                algorithm: "algorithm",
                value: "value"
            },
            mapper: __assign({}, KeyOperationsParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: KeyOperationResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedKeysOperationSpec = {
        httpMethod: "GET",
        path: "deletedkeys",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedKeyListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedKeyOperationSpec = {
        httpMethod: "GET",
        path: "deletedkeys/{key-name}",
        urlParameters: [vaultBaseUrl, keyName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedKeyBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var purgeDeletedKeyOperationSpec = {
        httpMethod: "DELETE",
        path: "deletedkeys/{key-name}",
        urlParameters: [vaultBaseUrl, keyName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            204: {},
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var recoverDeletedKeyOperationSpec = {
        httpMethod: "POST",
        path: "deletedkeys/{key-name}/recover",
        urlParameters: [vaultBaseUrl, keyName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: KeyBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var setSecretOperationSpec = {
        httpMethod: "PUT",
        path: "secrets/{secret-name}",
        urlParameters: [vaultBaseUrl, secretName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                value: "value",
                tags: ["options", "tags"],
                contentType: ["options", "contentType"],
                secretAttributes: ["options", "secretAttributes"]
            },
            mapper: __assign({}, SecretSetParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: SecretBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var deleteSecretOperationSpec = {
        httpMethod: "DELETE",
        path: "secrets/{secret-name}",
        urlParameters: [vaultBaseUrl, secretName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedSecretBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var updateSecretOperationSpec = {
        httpMethod: "PATCH",
        path: "secrets/{secret-name}/{secret-version}",
        urlParameters: [vaultBaseUrl, secretName1, secretVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                contentType: ["options", "contentType"],
                secretAttributes: ["options", "secretAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, SecretUpdateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: SecretBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getSecretOperationSpec = {
        httpMethod: "GET",
        path: "secrets/{secret-name}/{secret-version}",
        urlParameters: [vaultBaseUrl, secretName1, secretVersion],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SecretBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getSecretsOperationSpec = {
        httpMethod: "GET",
        path: "secrets",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SecretListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getSecretVersionsOperationSpec = {
        httpMethod: "GET",
        path: "secrets/{secret-name}/versions",
        urlParameters: [vaultBaseUrl, secretName1],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SecretListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedSecretsOperationSpec = {
        httpMethod: "GET",
        path: "deletedsecrets",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedSecretListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedSecretOperationSpec = {
        httpMethod: "GET",
        path: "deletedsecrets/{secret-name}",
        urlParameters: [vaultBaseUrl, secretName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedSecretBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var purgeDeletedSecretOperationSpec = {
        httpMethod: "DELETE",
        path: "deletedsecrets/{secret-name}",
        urlParameters: [vaultBaseUrl, secretName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            204: {},
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var recoverDeletedSecretOperationSpec = {
        httpMethod: "POST",
        path: "deletedsecrets/{secret-name}/recover",
        urlParameters: [vaultBaseUrl, secretName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SecretBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var backupSecretOperationSpec = {
        httpMethod: "POST",
        path: "secrets/{secret-name}/backup",
        urlParameters: [vaultBaseUrl, secretName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: BackupSecretResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var restoreSecretOperationSpec = {
        httpMethod: "POST",
        path: "secrets/restore",
        urlParameters: [vaultBaseUrl],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                secretBundleBackup: "secretBundleBackup"
            },
            mapper: __assign({}, SecretRestoreParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: SecretBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificatesOperationSpec = {
        httpMethod: "GET",
        path: "certificates",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, includePending, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var deleteCertificateOperationSpec = {
        httpMethod: "DELETE",
        path: "certificates/{certificate-name}",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedCertificateBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var setCertificateContactsOperationSpec = {
        httpMethod: "PUT",
        path: "certificates/contacts",
        urlParameters: [vaultBaseUrl],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: "contacts",
            mapper: __assign({}, Contacts, { required: true })
        },
        responses: {
            200: {
                bodyMapper: Contacts
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificateContactsOperationSpec = {
        httpMethod: "GET",
        path: "certificates/contacts",
        urlParameters: [vaultBaseUrl],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: Contacts
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var deleteCertificateContactsOperationSpec = {
        httpMethod: "DELETE",
        path: "certificates/contacts",
        urlParameters: [vaultBaseUrl],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: Contacts
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificateIssuersOperationSpec = {
        httpMethod: "GET",
        path: "certificates/issuers",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateIssuerListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var setCertificateIssuerOperationSpec = {
        httpMethod: "PUT",
        path: "certificates/issuers/{issuer-name}",
        urlParameters: [vaultBaseUrl, issuerName],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                provider: "provider",
                credentials: ["options", "credentials"],
                organizationDetails: ["options", "organizationDetails"],
                attributes: ["options", "attributes"]
            },
            mapper: __assign({}, CertificateIssuerSetParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: IssuerBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var updateCertificateIssuerOperationSpec = {
        httpMethod: "PATCH",
        path: "certificates/issuers/{issuer-name}",
        urlParameters: [vaultBaseUrl, issuerName],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                provider: ["options", "provider"],
                credentials: ["options", "credentials"],
                organizationDetails: ["options", "organizationDetails"],
                attributes: ["options", "attributes"]
            },
            mapper: __assign({}, CertificateIssuerUpdateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: IssuerBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificateIssuerOperationSpec = {
        httpMethod: "GET",
        path: "certificates/issuers/{issuer-name}",
        urlParameters: [vaultBaseUrl, issuerName],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: IssuerBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var deleteCertificateIssuerOperationSpec = {
        httpMethod: "DELETE",
        path: "certificates/issuers/{issuer-name}",
        urlParameters: [vaultBaseUrl, issuerName],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: IssuerBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var createCertificateOperationSpec = {
        httpMethod: "POST",
        path: "certificates/{certificate-name}/create",
        urlParameters: [vaultBaseUrl, certificateName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                certificatePolicy: ["options", "certificatePolicy"],
                certificateAttributes: ["options", "certificateAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, CertificateCreateParameters, { required: true })
        },
        responses: {
            202: {
                bodyMapper: CertificateOperation
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var importCertificateOperationSpec = {
        httpMethod: "POST",
        path: "certificates/{certificate-name}/import",
        urlParameters: [vaultBaseUrl, certificateName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                base64EncodedCertificate: "base64EncodedCertificate",
                password: ["options", "password"],
                certificatePolicy: ["options", "certificatePolicy"],
                certificateAttributes: ["options", "certificateAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, CertificateImportParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: CertificateBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificateVersionsOperationSpec = {
        httpMethod: "GET",
        path: "certificates/{certificate-name}/versions",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificatePolicyOperationSpec = {
        httpMethod: "GET",
        path: "certificates/{certificate-name}/policy",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificatePolicy
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var updateCertificatePolicyOperationSpec = {
        httpMethod: "PATCH",
        path: "certificates/{certificate-name}/policy",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: "certificatePolicy",
            mapper: __assign({}, CertificatePolicy, { required: true })
        },
        responses: {
            200: {
                bodyMapper: CertificatePolicy
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var updateCertificateOperationSpec = {
        httpMethod: "PATCH",
        path: "certificates/{certificate-name}/{certificate-version}",
        urlParameters: [
            vaultBaseUrl,
            certificateName0,
            certificateVersion
        ],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                certificatePolicy: ["options", "certificatePolicy"],
                certificateAttributes: ["options", "certificateAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, CertificateUpdateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: CertificateBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificateOperationSpec = {
        httpMethod: "GET",
        path: "certificates/{certificate-name}/{certificate-version}",
        urlParameters: [
            vaultBaseUrl,
            certificateName0,
            certificateVersion
        ],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var updateCertificateOperationOperationSpec = {
        httpMethod: "PATCH",
        path: "certificates/{certificate-name}/pending",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                cancellationRequested: "cancellationRequested"
            },
            mapper: __assign({}, CertificateOperationUpdateParameter, { required: true })
        },
        responses: {
            200: {
                bodyMapper: CertificateOperation
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificateOperationOperationSpec = {
        httpMethod: "GET",
        path: "certificates/{certificate-name}/pending",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateOperation
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var deleteCertificateOperationOperationSpec = {
        httpMethod: "DELETE",
        path: "certificates/{certificate-name}/pending",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateOperation
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var mergeCertificateOperationSpec = {
        httpMethod: "POST",
        path: "certificates/{certificate-name}/pending/merge",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                x509Certificates: "x509Certificates",
                certificateAttributes: ["options", "certificateAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, CertificateMergeParameters, { required: true })
        },
        responses: {
            201: {
                bodyMapper: CertificateBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var backupCertificateOperationSpec = {
        httpMethod: "POST",
        path: "certificates/{certificate-name}/backup",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: BackupCertificateResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var restoreCertificateOperationSpec = {
        httpMethod: "POST",
        path: "certificates/restore",
        urlParameters: [vaultBaseUrl],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                certificateBundleBackup: "certificateBundleBackup"
            },
            mapper: __assign({}, CertificateRestoreParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: CertificateBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedCertificatesOperationSpec = {
        httpMethod: "GET",
        path: "deletedcertificates",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, includePending, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedCertificateListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedCertificateOperationSpec = {
        httpMethod: "GET",
        path: "deletedcertificates/{certificate-name}",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedCertificateBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var purgeDeletedCertificateOperationSpec = {
        httpMethod: "DELETE",
        path: "deletedcertificates/{certificate-name}",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            204: {},
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var recoverDeletedCertificateOperationSpec = {
        httpMethod: "POST",
        path: "deletedcertificates/{certificate-name}/recover",
        urlParameters: [vaultBaseUrl, certificateName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getStorageAccountsOperationSpec = {
        httpMethod: "GET",
        path: "storage",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: StorageListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedStorageAccountsOperationSpec = {
        httpMethod: "GET",
        path: "deletedstorage",
        urlParameters: [vaultBaseUrl],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedStorageListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedStorageAccountOperationSpec = {
        httpMethod: "GET",
        path: "deletedstorage/{storage-account-name}",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedStorageBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var purgeDeletedStorageAccountOperationSpec = {
        httpMethod: "DELETE",
        path: "deletedstorage/{storage-account-name}",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            204: {},
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var recoverDeletedStorageAccountOperationSpec = {
        httpMethod: "POST",
        path: "deletedstorage/{storage-account-name}/recover",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: StorageBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var backupStorageAccountOperationSpec = {
        httpMethod: "POST",
        path: "storage/{storage-account-name}/backup",
        urlParameters: [vaultBaseUrl, storageAccountName1],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: BackupStorageResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var restoreStorageAccountOperationSpec = {
        httpMethod: "POST",
        path: "storage/restore",
        urlParameters: [vaultBaseUrl],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                storageBundleBackup: "storageBundleBackup"
            },
            mapper: __assign({}, StorageRestoreParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: StorageBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var deleteStorageAccountOperationSpec = {
        httpMethod: "DELETE",
        path: "storage/{storage-account-name}",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedStorageBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getStorageAccountOperationSpec = {
        httpMethod: "GET",
        path: "storage/{storage-account-name}",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: StorageBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var setStorageAccountOperationSpec = {
        httpMethod: "PUT",
        path: "storage/{storage-account-name}",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                resourceId: "resourceId",
                activeKeyName: "activeKeyName",
                autoRegenerateKey: "autoRegenerateKey",
                regenerationPeriod: ["options", "regenerationPeriod"],
                storageAccountAttributes: ["options", "storageAccountAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, StorageAccountCreateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: StorageBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var updateStorageAccountOperationSpec = {
        httpMethod: "PATCH",
        path: "storage/{storage-account-name}",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                activeKeyName: ["options", "activeKeyName"],
                autoRegenerateKey: ["options", "autoRegenerateKey"],
                regenerationPeriod: ["options", "regenerationPeriod"],
                storageAccountAttributes: ["options", "storageAccountAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, StorageAccountUpdateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: StorageBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var regenerateStorageAccountKeyOperationSpec = {
        httpMethod: "POST",
        path: "storage/{storage-account-name}/regeneratekey",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                keyName: "keyName"
            },
            mapper: __assign({}, StorageAccountRegenerteKeyParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: StorageBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getSasDefinitionsOperationSpec = {
        httpMethod: "GET",
        path: "storage/{storage-account-name}/sas",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SasDefinitionListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedSasDefinitionsOperationSpec = {
        httpMethod: "GET",
        path: "deletedstorage/{storage-account-name}/sas",
        urlParameters: [vaultBaseUrl, storageAccountName0],
        queryParameters: [maxresults, apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedSasDefinitionListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedSasDefinitionOperationSpec = {
        httpMethod: "GET",
        path: "deletedstorage/{storage-account-name}/sas/{sas-definition-name}",
        urlParameters: [
            vaultBaseUrl,
            storageAccountName0,
            sasDefinitionName
        ],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedSasDefinitionBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var recoverDeletedSasDefinitionOperationSpec = {
        httpMethod: "POST",
        path: "deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover",
        urlParameters: [
            vaultBaseUrl,
            storageAccountName0,
            sasDefinitionName
        ],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SasDefinitionBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var deleteSasDefinitionOperationSpec = {
        httpMethod: "DELETE",
        path: "storage/{storage-account-name}/sas/{sas-definition-name}",
        urlParameters: [
            vaultBaseUrl,
            storageAccountName0,
            sasDefinitionName
        ],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedSasDefinitionBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getSasDefinitionOperationSpec = {
        httpMethod: "GET",
        path: "storage/{storage-account-name}/sas/{sas-definition-name}",
        urlParameters: [
            vaultBaseUrl,
            storageAccountName0,
            sasDefinitionName
        ],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SasDefinitionBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var setSasDefinitionOperationSpec = {
        httpMethod: "PUT",
        path: "storage/{storage-account-name}/sas/{sas-definition-name}",
        urlParameters: [
            vaultBaseUrl,
            storageAccountName0,
            sasDefinitionName
        ],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                templateUri: "templateUri",
                sasType: "sasType",
                validityPeriod: "validityPeriod",
                sasDefinitionAttributes: ["options", "sasDefinitionAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, SasDefinitionCreateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: SasDefinitionBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var updateSasDefinitionOperationSpec = {
        httpMethod: "PATCH",
        path: "storage/{storage-account-name}/sas/{sas-definition-name}",
        urlParameters: [
            vaultBaseUrl,
            storageAccountName0,
            sasDefinitionName
        ],
        queryParameters: [apiVersion],
        headerParameters: [acceptLanguage],
        requestBody: {
            parameterPath: {
                templateUri: ["options", "templateUri"],
                sasType: ["options", "sasType"],
                validityPeriod: ["options", "validityPeriod"],
                sasDefinitionAttributes: ["options", "sasDefinitionAttributes"],
                tags: ["options", "tags"]
            },
            mapper: __assign({}, SasDefinitionUpdateParameters, { required: true })
        },
        responses: {
            200: {
                bodyMapper: SasDefinitionBundle
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getKeyVersionsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: KeyListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getKeysNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: KeyListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedKeysNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedKeyListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getSecretsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SecretListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getSecretVersionsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SecretListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedSecretsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedSecretListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificatesNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificateIssuersNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateIssuerListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getCertificateVersionsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: CertificateListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedCertificatesNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedCertificateListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getStorageAccountsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: StorageListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedStorageAccountsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedStorageListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getSasDefinitionsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: SasDefinitionListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };
    var getDeletedSasDefinitionsNextOperationSpec = {
        httpMethod: "GET",
        baseUrl: "{vaultBaseUrl}",
        path: "{nextLink}",
        urlParameters: [nextPageLink],
        headerParameters: [acceptLanguage],
        responses: {
            200: {
                bodyMapper: DeletedSasDefinitionListResult
            },
            default: {
                bodyMapper: KeyVaultError
            }
        },
        serializer: serializer$1
    };

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License. See License.txt in the project root for license information.
    var SDK_VERSION = "4.0.0-preview.5";
    var RetryConstants = {
        MIN_RETRY_INTERVAL_MS: 3000
    };

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var TokenRefreshBufferMs$1 = 2 * 60 * 1000; // 2 Minutes
    /**
     * Creates a new ChallengeBasedAuthenticationPolicy factory.
     *
     * @param credential The TokenCredential implementation that can supply the challenge token.
     */
    function challengeBasedAuthenticationPolicy(credential) {
        return {
            create: function (nextPolicy, options) {
                return new ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential);
            }
        };
    }
    var AuthenticationChallenge = /** @class */ (function () {
        function AuthenticationChallenge(scopes) {
            this.scopes = scopes;
        }
        return AuthenticationChallenge;
    }());
    /**
     *
     * Provides a RequestPolicy that can request a token from a TokenCredential
     * implementation and then apply it to the Authorization header of a request
     * as a Bearer token.
     *
     */
    var ChallengeBasedAuthenticationPolicy = /** @class */ (function (_super) {
        __extends(ChallengeBasedAuthenticationPolicy, _super);
        /**
         * Creates a new ChallengeBasedAuthenticationPolicy object.
         *
         * @param nextPolicy The next RequestPolicy in the request pipeline.
         * @param options Options for this RequestPolicy.
         * @param credential The TokenCredential implementation that can supply the bearer token.
         * @param scopes The scopes for which the bearer token applies.
         */
        function ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, refreshOn) {
            if (refreshOn === void 0) { refreshOn = Date.now(); }
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.credential = credential;
            _this.refreshOn = refreshOn;
            _this.cachedToken = undefined;
            _this.challenge = undefined;
            return _this;
        }
        ChallengeBasedAuthenticationPolicy.prototype.parseWWWAuthenticate = function (www_authenticate) {
            // Parses an authentication message like:
            // ```
            // Bearer authorization="some_authorization", resource="https://some.url"
            // ```
            var authenticateArray = www_authenticate.split(" ");
            // Remove the "Bearer" piece
            delete authenticateArray[0];
            // Split the KV comma-separated list
            var commaSep = authenticateArray.join().split(",");
            for (var _i = 0, commaSep_1 = commaSep; _i < commaSep_1.length; _i++) {
                var item = commaSep_1[_i];
                // Split the key/value pairs
                var kv = item.split("=");
                if (kv[0].trim() == "resource") {
                    // Remove the quotations around the string
                    var resource = kv[1].trim().replace(/['"]+/g, '');
                    return resource;
                }
            }
            return "";
        };
        /**
         * Applies the Bearer token to the request through the Authorization header.
         * @param webResource
         */
        ChallengeBasedAuthenticationPolicy.prototype.sendRequest = function (webResource) {
            return __awaiter(this, void 0, void 0, function () {
                var originalBody, response, www_authenticate, resource, challenge;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!webResource.headers)
                                webResource.headers = new HttpHeaders();
                            originalBody = webResource.body;
                            if (!(this.challenge == undefined)) return [3 /*break*/, 1];
                            // Use a blank to start the challenge
                            webResource.body = "";
                            return [3 /*break*/, 3];
                        case 1: 
                        // or use the cached token if we have one
                        return [4 /*yield*/, this.authenticateRequest(webResource)];
                        case 2:
                            // or use the cached token if we have one
                            _a.sent();
                            _a.label = 3;
                        case 3: return [4 /*yield*/, this._nextPolicy.sendRequest(webResource)];
                        case 4:
                            response = _a.sent();
                            if (!(response.status == 401)) return [3 /*break*/, 7];
                            webResource.body = originalBody;
                            www_authenticate = response.headers.get("WWW-Authenticate");
                            if (!www_authenticate) return [3 /*break*/, 6];
                            resource = this.parseWWWAuthenticate(www_authenticate);
                            challenge = new AuthenticationChallenge(resource + "/.default");
                            if (!(this.challenge != challenge)) return [3 /*break*/, 6];
                            this.challenge = challenge;
                            this.cachedToken = undefined;
                            return [4 /*yield*/, this.authenticateRequest(webResource)];
                        case 5:
                            _a.sent();
                            _a.label = 6;
                        case 6: return [2 /*return*/, this._nextPolicy.sendRequest(webResource)];
                        case 7: return [2 /*return*/, response];
                    }
                });
            });
        };
        ChallengeBasedAuthenticationPolicy.prototype.authenticateRequest = function (webResource) {
            return __awaiter(this, void 0, void 0, function () {
                var token;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(this.cachedToken &&
                                (Date.now() < this.refreshOn))) return [3 /*break*/, 1];
                            webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, "Bearer " + this.cachedToken.token);
                            return [3 /*break*/, 3];
                        case 1: return [4 /*yield*/, this.credential.getToken(this.challenge.scopes)];
                        case 2:
                            token = _a.sent();
                            if (token) {
                                this.cachedToken = token;
                                this.refreshOn = token.expiresOnTimestamp - TokenRefreshBufferMs$1;
                                webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, "Bearer " + token.token);
                            }
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        return ChallengeBasedAuthenticationPolicy;
    }(BaseRequestPolicy));

    var punycode = createCommonjsModule(function (module, exports) {
    (function(root) {

    	/** Detect free variables */
    	var freeExports =  exports &&
    		!exports.nodeType && exports;
    	var freeModule =  module &&
    		!module.nodeType && module;
    	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
    	if (
    		freeGlobal.global === freeGlobal ||
    		freeGlobal.window === freeGlobal ||
    		freeGlobal.self === freeGlobal
    	) {
    		root = freeGlobal;
    	}

    	/**
    	 * The `punycode` object.
    	 * @name punycode
    	 * @type Object
    	 */
    	var punycode,

    	/** Highest positive signed 32-bit float value */
    	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

    	/** Bootstring parameters */
    	base = 36,
    	tMin = 1,
    	tMax = 26,
    	skew = 38,
    	damp = 700,
    	initialBias = 72,
    	initialN = 128, // 0x80
    	delimiter = '-', // '\x2D'

    	/** Regular expressions */
    	regexPunycode = /^xn--/,
    	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
    	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

    	/** Error messages */
    	errors = {
    		'overflow': 'Overflow: input needs wider integers to process',
    		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    		'invalid-input': 'Invalid input'
    	},

    	/** Convenience shortcuts */
    	baseMinusTMin = base - tMin,
    	floor = Math.floor,
    	stringFromCharCode = String.fromCharCode,

    	/** Temporary variable */
    	key;

    	/*--------------------------------------------------------------------------*/

    	/**
    	 * A generic error utility function.
    	 * @private
    	 * @param {String} type The error type.
    	 * @returns {Error} Throws a `RangeError` with the applicable error message.
    	 */
    	function error(type) {
    		throw RangeError(errors[type]);
    	}

    	/**
    	 * A generic `Array#map` utility function.
    	 * @private
    	 * @param {Array} array The array to iterate over.
    	 * @param {Function} callback The function that gets called for every array
    	 * item.
    	 * @returns {Array} A new array of values returned by the callback function.
    	 */
    	function map(array, fn) {
    		var length = array.length;
    		var result = [];
    		while (length--) {
    			result[length] = fn(array[length]);
    		}
    		return result;
    	}

    	/**
    	 * A simple `Array#map`-like wrapper to work with domain name strings or email
    	 * addresses.
    	 * @private
    	 * @param {String} domain The domain name or email address.
    	 * @param {Function} callback The function that gets called for every
    	 * character.
    	 * @returns {Array} A new string of characters returned by the callback
    	 * function.
    	 */
    	function mapDomain(string, fn) {
    		var parts = string.split('@');
    		var result = '';
    		if (parts.length > 1) {
    			// In email addresses, only the domain name should be punycoded. Leave
    			// the local part (i.e. everything up to `@`) intact.
    			result = parts[0] + '@';
    			string = parts[1];
    		}
    		// Avoid `split(regex)` for IE8 compatibility. See #17.
    		string = string.replace(regexSeparators, '\x2E');
    		var labels = string.split('.');
    		var encoded = map(labels, fn).join('.');
    		return result + encoded;
    	}

    	/**
    	 * Creates an array containing the numeric code points of each Unicode
    	 * character in the string. While JavaScript uses UCS-2 internally,
    	 * this function will convert a pair of surrogate halves (each of which
    	 * UCS-2 exposes as separate characters) into a single code point,
    	 * matching UTF-16.
    	 * @see `punycode.ucs2.encode`
    	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
    	 * @memberOf punycode.ucs2
    	 * @name decode
    	 * @param {String} string The Unicode input string (UCS-2).
    	 * @returns {Array} The new array of code points.
    	 */
    	function ucs2decode(string) {
    		var output = [],
    		    counter = 0,
    		    length = string.length,
    		    value,
    		    extra;
    		while (counter < length) {
    			value = string.charCodeAt(counter++);
    			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
    				// high surrogate, and there is a next character
    				extra = string.charCodeAt(counter++);
    				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
    					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    				} else {
    					// unmatched surrogate; only append this code unit, in case the next
    					// code unit is the high surrogate of a surrogate pair
    					output.push(value);
    					counter--;
    				}
    			} else {
    				output.push(value);
    			}
    		}
    		return output;
    	}

    	/**
    	 * Creates a string based on an array of numeric code points.
    	 * @see `punycode.ucs2.decode`
    	 * @memberOf punycode.ucs2
    	 * @name encode
    	 * @param {Array} codePoints The array of numeric code points.
    	 * @returns {String} The new Unicode string (UCS-2).
    	 */
    	function ucs2encode(array) {
    		return map(array, function(value) {
    			var output = '';
    			if (value > 0xFFFF) {
    				value -= 0x10000;
    				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
    				value = 0xDC00 | value & 0x3FF;
    			}
    			output += stringFromCharCode(value);
    			return output;
    		}).join('');
    	}

    	/**
    	 * Converts a basic code point into a digit/integer.
    	 * @see `digitToBasic()`
    	 * @private
    	 * @param {Number} codePoint The basic numeric code point value.
    	 * @returns {Number} The numeric value of a basic code point (for use in
    	 * representing integers) in the range `0` to `base - 1`, or `base` if
    	 * the code point does not represent a value.
    	 */
    	function basicToDigit(codePoint) {
    		if (codePoint - 48 < 10) {
    			return codePoint - 22;
    		}
    		if (codePoint - 65 < 26) {
    			return codePoint - 65;
    		}
    		if (codePoint - 97 < 26) {
    			return codePoint - 97;
    		}
    		return base;
    	}

    	/**
    	 * Converts a digit/integer into a basic code point.
    	 * @see `basicToDigit()`
    	 * @private
    	 * @param {Number} digit The numeric value of a basic code point.
    	 * @returns {Number} The basic code point whose value (when used for
    	 * representing integers) is `digit`, which needs to be in the range
    	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
    	 * used; else, the lowercase form is used. The behavior is undefined
    	 * if `flag` is non-zero and `digit` has no uppercase form.
    	 */
    	function digitToBasic(digit, flag) {
    		//  0..25 map to ASCII a..z or A..Z
    		// 26..35 map to ASCII 0..9
    		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    	}

    	/**
    	 * Bias adaptation function as per section 3.4 of RFC 3492.
    	 * http://tools.ietf.org/html/rfc3492#section-3.4
    	 * @private
    	 */
    	function adapt(delta, numPoints, firstTime) {
    		var k = 0;
    		delta = firstTime ? floor(delta / damp) : delta >> 1;
    		delta += floor(delta / numPoints);
    		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
    			delta = floor(delta / baseMinusTMin);
    		}
    		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    	}

    	/**
    	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
    	 * symbols.
    	 * @memberOf punycode
    	 * @param {String} input The Punycode string of ASCII-only symbols.
    	 * @returns {String} The resulting string of Unicode symbols.
    	 */
    	function decode(input) {
    		// Don't use UCS-2
    		var output = [],
    		    inputLength = input.length,
    		    out,
    		    i = 0,
    		    n = initialN,
    		    bias = initialBias,
    		    basic,
    		    j,
    		    index,
    		    oldi,
    		    w,
    		    k,
    		    digit,
    		    t,
    		    /** Cached calculation results */
    		    baseMinusT;

    		// Handle the basic code points: let `basic` be the number of input code
    		// points before the last delimiter, or `0` if there is none, then copy
    		// the first basic code points to the output.

    		basic = input.lastIndexOf(delimiter);
    		if (basic < 0) {
    			basic = 0;
    		}

    		for (j = 0; j < basic; ++j) {
    			// if it's not a basic code point
    			if (input.charCodeAt(j) >= 0x80) {
    				error('not-basic');
    			}
    			output.push(input.charCodeAt(j));
    		}

    		// Main decoding loop: start just after the last delimiter if any basic code
    		// points were copied; start at the beginning otherwise.

    		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

    			// `index` is the index of the next character to be consumed.
    			// Decode a generalized variable-length integer into `delta`,
    			// which gets added to `i`. The overflow checking is easier
    			// if we increase `i` as we go, then subtract off its starting
    			// value at the end to obtain `delta`.
    			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

    				if (index >= inputLength) {
    					error('invalid-input');
    				}

    				digit = basicToDigit(input.charCodeAt(index++));

    				if (digit >= base || digit > floor((maxInt - i) / w)) {
    					error('overflow');
    				}

    				i += digit * w;
    				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

    				if (digit < t) {
    					break;
    				}

    				baseMinusT = base - t;
    				if (w > floor(maxInt / baseMinusT)) {
    					error('overflow');
    				}

    				w *= baseMinusT;

    			}

    			out = output.length + 1;
    			bias = adapt(i - oldi, out, oldi == 0);

    			// `i` was supposed to wrap around from `out` to `0`,
    			// incrementing `n` each time, so we'll fix that now:
    			if (floor(i / out) > maxInt - n) {
    				error('overflow');
    			}

    			n += floor(i / out);
    			i %= out;

    			// Insert `n` at position `i` of the output
    			output.splice(i++, 0, n);

    		}

    		return ucs2encode(output);
    	}

    	/**
    	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
    	 * Punycode string of ASCII-only symbols.
    	 * @memberOf punycode
    	 * @param {String} input The string of Unicode symbols.
    	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
    	 */
    	function encode(input) {
    		var n,
    		    delta,
    		    handledCPCount,
    		    basicLength,
    		    bias,
    		    j,
    		    m,
    		    q,
    		    k,
    		    t,
    		    currentValue,
    		    output = [],
    		    /** `inputLength` will hold the number of code points in `input`. */
    		    inputLength,
    		    /** Cached calculation results */
    		    handledCPCountPlusOne,
    		    baseMinusT,
    		    qMinusT;

    		// Convert the input in UCS-2 to Unicode
    		input = ucs2decode(input);

    		// Cache the length
    		inputLength = input.length;

    		// Initialize the state
    		n = initialN;
    		delta = 0;
    		bias = initialBias;

    		// Handle the basic code points
    		for (j = 0; j < inputLength; ++j) {
    			currentValue = input[j];
    			if (currentValue < 0x80) {
    				output.push(stringFromCharCode(currentValue));
    			}
    		}

    		handledCPCount = basicLength = output.length;

    		// `handledCPCount` is the number of code points that have been handled;
    		// `basicLength` is the number of basic code points.

    		// Finish the basic string - if it is not empty - with a delimiter
    		if (basicLength) {
    			output.push(delimiter);
    		}

    		// Main encoding loop:
    		while (handledCPCount < inputLength) {

    			// All non-basic code points < n have been handled already. Find the next
    			// larger one:
    			for (m = maxInt, j = 0; j < inputLength; ++j) {
    				currentValue = input[j];
    				if (currentValue >= n && currentValue < m) {
    					m = currentValue;
    				}
    			}

    			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    			// but guard against overflow
    			handledCPCountPlusOne = handledCPCount + 1;
    			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
    				error('overflow');
    			}

    			delta += (m - n) * handledCPCountPlusOne;
    			n = m;

    			for (j = 0; j < inputLength; ++j) {
    				currentValue = input[j];

    				if (currentValue < n && ++delta > maxInt) {
    					error('overflow');
    				}

    				if (currentValue == n) {
    					// Represent delta as a generalized variable-length integer
    					for (q = delta, k = base; /* no condition */; k += base) {
    						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
    						if (q < t) {
    							break;
    						}
    						qMinusT = q - t;
    						baseMinusT = base - t;
    						output.push(
    							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
    						);
    						q = floor(qMinusT / baseMinusT);
    					}

    					output.push(stringFromCharCode(digitToBasic(q, 0)));
    					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
    					delta = 0;
    					++handledCPCount;
    				}
    			}

    			++delta;
    			++n;

    		}
    		return output.join('');
    	}

    	/**
    	 * Converts a Punycode string representing a domain name or an email address
    	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
    	 * it doesn't matter if you call it on a string that has already been
    	 * converted to Unicode.
    	 * @memberOf punycode
    	 * @param {String} input The Punycoded domain name or email address to
    	 * convert to Unicode.
    	 * @returns {String} The Unicode representation of the given Punycode
    	 * string.
    	 */
    	function toUnicode(input) {
    		return mapDomain(input, function(string) {
    			return regexPunycode.test(string)
    				? decode(string.slice(4).toLowerCase())
    				: string;
    		});
    	}

    	/**
    	 * Converts a Unicode string representing a domain name or an email address to
    	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
    	 * i.e. it doesn't matter if you call it with a domain that's already in
    	 * ASCII.
    	 * @memberOf punycode
    	 * @param {String} input The domain name or email address to convert, as a
    	 * Unicode string.
    	 * @returns {String} The Punycode representation of the given domain name or
    	 * email address.
    	 */
    	function toASCII(input) {
    		return mapDomain(input, function(string) {
    			return regexNonASCII.test(string)
    				? 'xn--' + encode(string)
    				: string;
    		});
    	}

    	/*--------------------------------------------------------------------------*/

    	/** Define the public API */
    	punycode = {
    		/**
    		 * A string representing the current Punycode.js version number.
    		 * @memberOf punycode
    		 * @type String
    		 */
    		'version': '1.3.2',
    		/**
    		 * An object of methods to convert from JavaScript's internal character
    		 * representation (UCS-2) to Unicode code points, and back.
    		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
    		 * @memberOf punycode
    		 * @type Object
    		 */
    		'ucs2': {
    			'decode': ucs2decode,
    			'encode': ucs2encode
    		},
    		'decode': decode,
    		'encode': encode,
    		'toASCII': toASCII,
    		'toUnicode': toUnicode
    	};

    	/** Expose `punycode` */
    	// Some AMD build optimizers, like r.js, check for specific condition patterns
    	// like the following:
    	if (freeExports && freeModule) {
    		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
    			freeModule.exports = punycode;
    		} else { // in Narwhal or RingoJS v0.7.0-
    			for (key in punycode) {
    				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
    			}
    		}
    	} else { // in Rhino or a web browser
    		root.punycode = punycode;
    	}

    }(commonjsGlobal));
    });

    var util = {
      isString: function(arg) {
        return typeof(arg) === 'string';
      },
      isObject: function(arg) {
        return typeof(arg) === 'object' && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };

    // Copyright Joyent, Inc. and other Node contributors.

    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var decode = function(qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};

      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }

      var regexp = /\+/g;
      qs = qs.split(sep);

      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }

      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }

      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr, vstr, k, v;

        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }

      return obj;
    };

    // Copyright Joyent, Inc. and other Node contributors.

    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case 'string':
          return v;

        case 'boolean':
          return v ? 'true' : 'false';

        case 'number':
          return isFinite(v) ? v : '';

        default:
          return '';
      }
    };

    var encode = function(obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }

      if (typeof obj === 'object') {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);

      }

      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq +
             encodeURIComponent(stringifyPrimitive(obj));
    };

    var querystring = createCommonjsModule(function (module, exports) {

    exports.decode = exports.parse = decode;
    exports.encode = exports.stringify = encode;
    });
    var querystring_1 = querystring.decode;
    var querystring_2 = querystring.parse;
    var querystring_3 = querystring.encode;
    var querystring_4 = querystring.stringify;

    var parse$1 = urlParse;

    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }

    // Reference: RFC 3986, RFC 1808, RFC 2396

    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,

        // Special case for a simple path URL
        simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

        // RFC 2396: characters reserved for delimiting URLs.
        // We actually just auto-escape these.
        delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

        // RFC 2396: characters not allowed for various reasons.
        unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
        autoEscape = ['\''].concat(unwise),
        // Characters that are never ever allowed in a hostname.
        // Note that any invalid chars are also handled, but these
        // are the ones that are *expected* to be seen, so we fast-path
        // them.
        nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
        hostEndingChars = ['/', '?', '#'],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        // protocols that can allow "unsafe" and "unwise" chars.
        unsafeProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that never have a hostname.
        hostlessProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that always contain a // bit.
        slashedProtocol = {
          'http': true,
          'https': true,
          'ftp': true,
          'gopher': true,
          'file': true,
          'http:': true,
          'https:': true,
          'ftp:': true,
          'gopher:': true,
          'file:': true
        };

    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url) return url;

      var u = new Url;
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }

    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }

      // Copy chrome, IE, opera backslash-handling behavior.
      // Back slashes before the query string get converted to forward slashes
      // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
          splitter =
              (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
          uSplit = url.split(splitter),
          slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, '/');
      url = uSplit.join(splitter);

      var rest = url;

      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();

      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = '';
            this.query = {};
          }
          return this;
        }
      }

      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }

      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }

      if (!hostlessProtocol[proto] &&
          (slashes || (proto && !slashedProtocol[proto]))) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1)
          hostEnd = rest.length;

        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost();

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' &&
            this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                this.hostname = validParts.join('.');
                break;
              }
            }
          }
        }

        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = '';
        } else {
          // hostnames are always lower case.
          this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
          // IDNA Support: Returns a punycoded representation of "domain".
          // It only converts parts of the domain name that
          // have non-ASCII characters, i.e. it doesn't matter if
          // you call it with a domain that already is ASCII-only.
          this.hostname = punycode.toASCII(this.hostname);
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }

      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }


      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
      }
      if (rest) this.pathname = rest;
      if (slashedProtocol[lowerProto] &&
          this.hostname && !this.pathname) {
        this.pathname = '/';
      }

      //to support http.request
      if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
      }

      // finally, reconstruct the href based on what has been validated.
      this.href = this.format();
      return this;
    };

    Url.prototype.format = function() {
      var auth = this.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }

      var protocol = this.protocol || '',
          pathname = this.pathname || '',
          hash = this.hash || '',
          host = false,
          query = '';

      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ?
            this.hostname :
            '[' + this.hostname + ']');
        if (this.port) {
          host += ':' + this.port;
        }
      }

      if (this.query &&
          util.isObject(this.query) &&
          Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }

      var search = this.search || (query && ('?' + query)) || '';

      if (protocol && protocol.substr(-1) !== ':') protocol += ':';

      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (this.slashes ||
          (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }

      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;

      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');

      return protocol + host + pathname + search + hash;
    };

    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };

    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }

      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }

      // hash is always overridden, no matter what.
      // even href="" will remove it.
      result.hash = relative.hash;

      // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format();
        return result;
      }

      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== 'protocol')
            result[rkey] = relative[rkey];
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] &&
            result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
      }

      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }

      var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
          isRelAbs = (
              relative.host ||
              relative.pathname && relative.pathname.charAt(0) === '/'
          ),
          mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname)),
          removeAllDots = mustEndAbs,
          srcPath = result.pathname && result.pathname.split('/') || [],
          relPath = relative.pathname && relative.pathname.split('/') || [],
          psychotic = result.protocol && !slashedProtocol[result.protocol];

      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;
          else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;
            else relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }

      if (isRelAbs) {
        // it's absolute.
        result.host = (relative.host || relative.host === '') ?
                      relative.host : result.host;
        result.hostname = (relative.hostname || relative.hostname === '') ?
                          relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0 ?
                           result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') +
                        (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
      }

      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }

      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (
          (result.host || relative.host || srcPath.length > 1) &&
          (last === '.' || last === '..') || last === '');

      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }

      if (mustEndAbs && srcPath[0] !== '' &&
          (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }

      if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
        srcPath.push('');
      }

      var isAbsolute = srcPath[0] === '' ||
          (srcPath[0] && srcPath[0].charAt(0) === '/');

      // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' :
                                        srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ?
                         result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }

      mustEndAbs = mustEndAbs || (result.host && srcPath.length);

      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }

      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      }

      //to support request.http
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
                      (result.search ? result.search : '');
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };

    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) this.hostname = host;
    };

    function parseKeyvaultIdentifier(collection, identifier) {
        if (typeof collection != "string" || !(collection = collection.trim())) {
            throw new Error("Invalid collection argument");
        }
        if (typeof identifier != "string" || !(identifier = identifier.trim())) {
            throw new Error("Invalid identifier argument");
        }
        var baseUri;
        try {
            baseUri = parse$1(identifier, true, true);
        }
        catch (e) {
            throw new Error("Invalid " + collection + " identifier: " + identifier + ". Not a valid URI");
        }
        // Path is of the form '/collection/name[/version]'
        var segments = (baseUri.pathname || "").split("/");
        if (segments.length !== 3 && segments.length !== 4) {
            throw new Error("Invalid " + collection + " identifier: " + identifier + ". Bad number of segments: " + segments.length);
        }
        if (collection !== segments[1]) {
            throw new Error("Invalid " + collection + " identifier: " + identifier + ". segment [1] should be \"" + collection + "\", found \"" + segments[1] + "\"");
        }
        var vaultUrl = baseUri.protocol + "//" + baseUri.host;
        var name = segments[2];
        var version = segments.length === 4 ? segments[3] : undefined;
        return {
            vaultUrl: vaultUrl,
            name: name,
            version: version
        };
    }

    function isNewPipelineOptions(pipelineOrOptions) {
        // An empty object is consider options
        function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && obj.constructor === Object;
        }
        var options = pipelineOrOptions;
        return (isEmptyObject(pipelineOrOptions) ||
            !!(options.retryOptions || options.proxyOptions || options.logger || options.HTTPClient));
    }

    // Copyright (c) Microsoft Corporation.
    /**
     * The client to interact with the KeyVault secrets functionality
     */
    var SecretsClient = /** @class */ (function () {
        /**
         * Creates an instance of SecretsClient.
         *
         * Example usage:
         * ```ts
         * import { SecretsClient } from "@azure/keyvault-secrets";
         * import { DefaultAzureCredential } from "@azure/identity";
         *
         * let url = `https://<MY KEYVAULT HERE>.vault.azure.net`;
         * let credentials = new DefaultAzureCredential();
         *
         * let client = new SecretsClient(url, credentials);
         * ```
         * @param {string} url the base url to the key vault.
         * @param {TokenCredential} The credential to use for API requests.
         * @param {(Pipeline | NewPipelineOptions)} [pipelineOrOptions={}] Optional. A Pipeline, or options to create a default Pipeline instance.
         *                                                                 Omitting this parameter to create the default Pipeline instance.
         * @memberof SecretsClient
         */
        function SecretsClient(url, credential, pipelineOrOptions) {
            if (pipelineOrOptions === void 0) { pipelineOrOptions = {}; }
            this.vaultBaseUrl = url;
            this.credential = credential;
            if (isNewPipelineOptions(pipelineOrOptions)) {
                this.pipeline = SecretsClient.getDefaultPipeline(credential, pipelineOrOptions);
            }
            else {
                this.pipeline = pipelineOrOptions;
            }
            this.client = new KeyVaultClient(credential, this.pipeline);
        }
        /**
         * A static method used to create a new Pipeline object with the provided Credential.
         * @static
         * @param {TokenCredential} The credential to use for API requests.
         * @param {NewPipelineOptions} [pipelineOptions] Optional. Options.
         * @returns {Pipeline} A new Pipeline object.
         * @memberof SecretsClient
         */
        SecretsClient.getDefaultPipeline = function (credential, pipelineOptions) {
            if (pipelineOptions === void 0) { pipelineOptions = {}; }
            // Order is important. Closer to the API at the top & closer to the network at the bottom.
            // The credential's policy factory must appear close to the wire so it can sign any
            // changes made by other factories (like UniqueRequestIDPolicyFactory)
            var retryOptions = pipelineOptions.retryOptions || {};
            var userAgentString = SecretsClient.getUserAgentString(pipelineOptions.telemetry);
            var requestPolicyFactories = [];
            requestPolicyFactories = requestPolicyFactories.concat([
                tracingPolicy(),
                userAgentPolicy({ value: userAgentString }),
                generateClientRequestIdPolicy(),
                deserializationPolicy(),
                throttlingRetryPolicy(),
                systemErrorRetryPolicy(),
                exponentialRetryPolicy(retryOptions.retryCount, retryOptions.retryIntervalInMS, RetryConstants.MIN_RETRY_INTERVAL_MS, // Minimum retry interval to prevent frequent retries
                retryOptions.maxRetryDelayInMs),
                redirectPolicy(),
                isTokenCredential(credential)
                    ? challengeBasedAuthenticationPolicy(credential)
                    : signingPolicy(credential)
            ]);
            return {
                httpClient: pipelineOptions.HTTPClient,
                httpPipelineLogger: pipelineOptions.logger,
                requestPolicyFactories: requestPolicyFactories
            };
        };
        SecretsClient.getUserAgentString = function (telemetry) {
            var userAgentInfo = [];
            if (telemetry) {
                if (userAgentInfo.indexOf(telemetry.value) === -1) {
                    userAgentInfo.push(telemetry.value);
                }
            }
            var libInfo = "azsdk-js-keyvault-secrets/" + SDK_VERSION;
            if (userAgentInfo.indexOf(libInfo) === -1) {
                userAgentInfo.push(libInfo);
            }
            var defaultUserAgentInfo = getDefaultUserAgentValue();
            if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {
                userAgentInfo.push(defaultUserAgentInfo);
            }
            return userAgentInfo.join(" ");
        };
        // TODO: do we want Aborter as well?
        /**
         * The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
         * Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
         * permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * await client.setSecret("MySecretName", "ABC123");
         * ```
         * @summary Adds a secret in a specified key vault.
         * @param secretName The name of the secret.
         * @param value The value of the secret.
         * @param [options] The optional parameters
         * @returns Promise<Secret>
         */
        SecretsClient.prototype.setSecret = function (secretName, value, options) {
            return __awaiter(this, void 0, void 0, function () {
                var unflattenedAttributes, unflattenedOptions, span_1, response, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!options) return [3 /*break*/, 2];
                            unflattenedAttributes = {
                                enabled: options.enabled,
                                notBefore: options.notBefore,
                                expires: options.expires
                            };
                            unflattenedOptions = __assign({}, options, (options.requestOptions ? options.requestOptions : {}), { secretAttributes: unflattenedAttributes });
                            delete unflattenedOptions.enabled;
                            delete unflattenedOptions.notBefore;
                            delete unflattenedOptions.expires;
                            delete unflattenedOptions.requestOptions;
                            span_1 = this.createSpan("setSecret", unflattenedOptions);
                            span_1.start();
                            return [4 /*yield*/, this.client.setSecret(this.vaultBaseUrl, secretName, value, unflattenedOptions).catch(function (err) {
                                    span_1.end();
                                    throw err;
                                })];
                        case 1:
                            response = _a.sent();
                            span_1.end();
                            return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                        case 2: return [4 /*yield*/, this.client.setSecret(this.vaultBaseUrl, secretName, value, options)];
                        case 3:
                            response = _a.sent();
                            return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    }
                });
            });
        };
        /**
         * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
         * to an individual version of a secret. This operation requires the secrets/delete permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * await client.deleteSecret("MySecretName");
         * ```
         * @summary Deletes a secret from a specified key vault.
         * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
         * @param secretName The name of the secret.
         * @param [options] The optional parameters
         * @returns Promise<DeletedSecret>
         */
        SecretsClient.prototype.deleteSecret = function (secretName, options) {
            return __awaiter(this, void 0, void 0, function () {
                var span, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            span = this.createSpan("deleteSecret", options);
                            span.start();
                            return [4 /*yield*/, this.client.deleteSecret(this.vaultBaseUrl, secretName, options)
                                    .catch(function (err) {
                                    span.end();
                                    throw err;
                                })];
                        case 1:
                            response = _a.sent();
                            span.end();
                            return [2 /*return*/, this.getDeletedSecretFromDeletedSecretBundle(response)];
                    }
                });
            });
        };
        /**
         * The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
         * are not specified in the request are left unchanged. The value of a secret itself cannot be
         * changed. This operation requires the secrets/set permission.
         *
         * Example usage:
         * ```ts
         * let secretName = "MySecretName";
         * let client = new SecretsClient(url, credentials);
         * let secret = await client.getSecret(secretName);
         * await client.updateSecret(secretName, secret.version, { enabled: false });
         * ```
         * @summary Updates the attributes associated with a specified secret in a given key vault.
         * @param secretName The name of the secret.
         * @param secretVersion The version of the secret.
         * @param [options] The optional parameters
         * @returns Promise<Secret>
         */
        SecretsClient.prototype.updateSecretAttributes = function (secretName, secretVersion, options) {
            return __awaiter(this, void 0, void 0, function () {
                var unflattenedAttributes, unflattenedOptions, span_2, response, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!options) return [3 /*break*/, 2];
                            unflattenedAttributes = {
                                enabled: options.enabled,
                                notBefore: options.notBefore,
                                expires: options.expires
                            };
                            unflattenedOptions = __assign({}, options, (options.requestOptions ? options.requestOptions : {}), { secretAttributes: unflattenedAttributes });
                            delete unflattenedOptions.enabled;
                            delete unflattenedOptions.notBefore;
                            delete unflattenedOptions.expires;
                            delete unflattenedOptions.requestOptions;
                            span_2 = this.createSpan("updateSecretAttributes", unflattenedOptions);
                            span_2.start();
                            return [4 /*yield*/, this.client.updateSecret(this.vaultBaseUrl, secretName, secretVersion, unflattenedOptions)
                                    .catch(function (err) {
                                    span_2.end();
                                    throw err;
                                })];
                        case 1:
                            response = _a.sent();
                            span_2.end();
                            return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                        case 2: return [4 /*yield*/, this.client.updateSecret(this.vaultBaseUrl, secretName, secretVersion, options)];
                        case 3:
                            response = _a.sent();
                            return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    }
                });
            });
        };
        /**
         * The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires
         * the secrets/get permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * let secret = await client.getSecret("MySecretName");
         * ```
         * @summary Get a specified secret from a given key vault.
         * @param secretName The name of the secret.
         * @param [options] The optional parameters
         * @returns Promise<Secret>
         */
        SecretsClient.prototype.getSecret = function (secretName, options) {
            return __awaiter(this, void 0, void 0, function () {
                var span, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            span = this.createSpan("getSecret", options && options.requestOptions);
                            span.start();
                            return [4 /*yield*/, this.client.getSecret(this.vaultBaseUrl, secretName, options && options.version ? options.version : "", options ? options.requestOptions : undefined)
                                    .catch(function (err) {
                                    span.end();
                                    throw err;
                                })];
                        case 1:
                            response = _a.sent();
                            span.end();
                            return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    }
                });
            });
        };
        /**
         * The Get Deleted Secret operation returns the specified deleted secret along with its attributes.
         * This operation requires the secrets/get permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * await client.getDeletedSecret("MyDeletedSecret");
         * ```
         * @summary Gets the specified deleted secret.
         * @param secretName The name of the secret.
         * @param [options] The optional parameters
         * @returns Promise<DeletedSecret>
         */
        SecretsClient.prototype.getDeletedSecret = function (secretName, options) {
            return __awaiter(this, void 0, void 0, function () {
                var span, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            span = this.createSpan("getDeletedSecret", options);
                            span.start();
                            return [4 /*yield*/, this.client.getDeletedSecret(this.vaultBaseUrl, secretName, options)
                                    .catch(function (err) {
                                    span.end();
                                    throw err;
                                })];
                        case 1:
                            response = _a.sent();
                            span.end();
                            return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    }
                });
            });
        };
        /**
         * The purge deleted secret operation removes the secret permanently, without the possibility of
         * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
         * requires the secrets/purge permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * await client.deleteSecret("MySecretName");
         * await client.purgeDeletedSecret("MySecretName");
         * ```
         * @summary Permanently deletes the specified secret.
         * @param secretName The name of the secret.
         * @param [options] The optional parameters
         * @returns Promise<void>
         */
        SecretsClient.prototype.purgeDeletedSecret = function (secretName, options) {
            return __awaiter(this, void 0, void 0, function () {
                var span;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            span = this.createSpan("purgeDeletedSecret", options);
                            span.start();
                            return [4 /*yield*/, this.client.purgeDeletedSecret(this.vaultBaseUrl, secretName, options)
                                    .catch(function (err) {
                                    span.end();
                                    throw err;
                                })];
                        case 1:
                            _a.sent();
                            span.end();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Recovers the deleted secret in the specified vault. This operation can only be performed on a
         * soft-delete enabled vault. This operation requires the secrets/recover permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * await client.deleteSecret("MySecretName");
         * await client.recoverDeletedSecret("MySecretName");
         * ```
         * @summary Recovers the deleted secret to the latest version.
         * @param secretName The name of the deleted secret.
         * @param [options] The optional parameters
         * @returns Promise<Secret>
         */
        SecretsClient.prototype.recoverDeletedSecret = function (secretName, options) {
            return __awaiter(this, void 0, void 0, function () {
                var span, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            span = this.createSpan("recoverDeletedSecret", options);
                            span.start();
                            return [4 /*yield*/, this.client.recoverDeletedSecret(this.vaultBaseUrl, secretName, options)
                                    .catch(function (err) {
                                    span.end();
                                    throw err;
                                })];
                        case 1:
                            response = _a.sent();
                            span.end();
                            return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    }
                });
            });
        };
        /**
         * Requests that a backup of the specified secret be downloaded to the client. All versions of the
         * secret will be downloaded. This operation requires the secrets/backup permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * let backupResult = await client.backupSecret("MySecretName");
         * ```
         * @summary Backs up the specified secret.
         * @param secretName The name of the secret.
         * @param [options] The optional parameters
         * @returns Promise<Uint8Array | undefined>
         */
        SecretsClient.prototype.backupSecret = function (secretName, options) {
            return __awaiter(this, void 0, void 0, function () {
                var span, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            span = this.createSpan("backupSecret", options);
                            span.start();
                            return [4 /*yield*/, this.client.backupSecret(this.vaultBaseUrl, secretName, options)
                                    .catch(function (err) {
                                    span.end();
                                    throw err;
                                })];
                        case 1:
                            response = _a.sent();
                            span.end();
                            return [2 /*return*/, response.value];
                    }
                });
            });
        };
        /**
         * Restores a backed up secret, and all its versions, to a vault. This operation requires the
         * secrets/restore permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * let mySecretBundle = await client.backupSecret("MySecretName");
         * // ...
         * await client.restoreSecret(mySecretBundle);
         * ```
         * @summary Restores a backed up secret to a vault.
         * @param secretBundleBackup The backup blob associated with a secret bundle.
         * @param [options] The optional parameters
         * @returns Promise<Secret>
         */
        SecretsClient.prototype.restoreSecret = function (secretBundleBackup, options) {
            return __awaiter(this, void 0, void 0, function () {
                var span, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            span = this.createSpan("restoreSecret", options);
                            span.start();
                            return [4 /*yield*/, this.client.restoreSecret(this.vaultBaseUrl, secretBundleBackup, options)
                                    .catch(function (err) {
                                    span.end();
                                    throw err;
                                })];
                        case 1:
                            response = _a.sent();
                            span.end();
                            return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    }
                });
            });
        };
        SecretsClient.prototype.listSecretVersionsPage = function (secretName, continuationState, options) {
            return __asyncGenerator(this, arguments, function listSecretVersionsPage_1() {
                var optionsComplete, currentSetResponse, currentSetResponse;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                            optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                            return [4 /*yield*/, __await(this.client.getSecretVersions(this.vaultBaseUrl, secretName, optionsComplete))];
                        case 1:
                            currentSetResponse = _a.sent();
                            continuationState.continuationToken = currentSetResponse.nextLink;
                            return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                        case 2: return [4 /*yield*/, _a.sent()];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4:
                            if (!continuationState.continuationToken) return [3 /*break*/, 8];
                            return [4 /*yield*/, __await(this.client.getSecretVersionsNext(continuationState.continuationToken, options))];
                        case 5:
                            currentSetResponse = _a.sent();
                            continuationState.continuationToken = currentSetResponse.nextLink;
                            return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                        case 6: return [4 /*yield*/, _a.sent()];
                        case 7:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 8: return [2 /*return*/];
                    }
                });
            });
        };
        SecretsClient.prototype.listSecretVersionsAll = function (secretName, options) {
            return __asyncGenerator(this, arguments, function listSecretVersionsAll_1() {
                var f, _a, _b, page, _i, page_1, item, e_1_1;
                var e_1, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            f = {};
                            _d.label = 1;
                        case 1:
                            _d.trys.push([1, 10, 11, 16]);
                            _a = __asyncValues(this.listSecretVersionsPage(secretName, f, options));
                            _d.label = 2;
                        case 2: return [4 /*yield*/, __await(_a.next())];
                        case 3:
                            if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                            page = _b.value;
                            _i = 0, page_1 = page;
                            _d.label = 4;
                        case 4:
                            if (!(_i < page_1.length)) return [3 /*break*/, 8];
                            item = page_1[_i];
                            return [4 /*yield*/, __await(item)];
                        case 5: return [4 /*yield*/, _d.sent()];
                        case 6:
                            _d.sent();
                            _d.label = 7;
                        case 7:
                            _i++;
                            return [3 /*break*/, 4];
                        case 8: return [3 /*break*/, 2];
                        case 9: return [3 /*break*/, 16];
                        case 10:
                            e_1_1 = _d.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 16];
                        case 11:
                            _d.trys.push([11, , 14, 15]);
                            if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                            return [4 /*yield*/, __await(_c.call(_a))];
                        case 12:
                            _d.sent();
                            _d.label = 13;
                        case 13: return [3 /*break*/, 15];
                        case 14:
                            if (e_1) throw e_1.error;
                            return [7 /*endfinally*/];
                        case 15: return [7 /*endfinally*/];
                        case 16: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
         * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * for await (const secretAttr of client.listSecretVersions("MySecretName")) {
         *   const secret = await client.getSecret(secretAttr.name);
         *   console.log("secret version: ", secret);
         * }
         * ```
         * @param secretName Name of the secret to fetch versions for
         * @param [options] The optional parameters
         * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
         */
        SecretsClient.prototype.listSecretVersions = function (secretName, options) {
            var _a;
            var _this = this;
            var span = this.createSpan("listSecretVersions", options && options.requestOptions);
            span.start();
            var iter = this.listSecretVersionsAll(secretName, options);
            span.end();
            return _a = {
                    next: function () {
                        return iter.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.listSecretVersionsPage(secretName, settings, options);
                },
                _a;
        };
        SecretsClient.prototype.listSecretsPage = function (continuationState, options) {
            return __asyncGenerator(this, arguments, function listSecretsPage_1() {
                var optionsComplete, currentSetResponse, currentSetResponse;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                            optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                            return [4 /*yield*/, __await(this.client.getSecrets(this.vaultBaseUrl, optionsComplete))];
                        case 1:
                            currentSetResponse = _a.sent();
                            continuationState.continuationToken = currentSetResponse.nextLink;
                            return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                        case 2: return [4 /*yield*/, _a.sent()];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4:
                            if (!continuationState.continuationToken) return [3 /*break*/, 8];
                            return [4 /*yield*/, __await(this.client.getSecretsNext(continuationState.continuationToken, options))];
                        case 5:
                            currentSetResponse = _a.sent();
                            continuationState.continuationToken = currentSetResponse.nextLink;
                            return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                        case 6: return [4 /*yield*/, _a.sent()];
                        case 7:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 8: return [2 /*return*/];
                    }
                });
            });
        };
        SecretsClient.prototype.listSecretsAll = function (options) {
            return __asyncGenerator(this, arguments, function listSecretsAll_1() {
                var f, _a, _b, page, _i, page_2, item, e_2_1;
                var e_2, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            f = {};
                            _d.label = 1;
                        case 1:
                            _d.trys.push([1, 10, 11, 16]);
                            _a = __asyncValues(this.listSecretsPage(f, options));
                            _d.label = 2;
                        case 2: return [4 /*yield*/, __await(_a.next())];
                        case 3:
                            if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                            page = _b.value;
                            _i = 0, page_2 = page;
                            _d.label = 4;
                        case 4:
                            if (!(_i < page_2.length)) return [3 /*break*/, 8];
                            item = page_2[_i];
                            return [4 /*yield*/, __await(item)];
                        case 5: return [4 /*yield*/, _d.sent()];
                        case 6:
                            _d.sent();
                            _d.label = 7;
                        case 7:
                            _i++;
                            return [3 /*break*/, 4];
                        case 8: return [3 /*break*/, 2];
                        case 9: return [3 /*break*/, 16];
                        case 10:
                            e_2_1 = _d.sent();
                            e_2 = { error: e_2_1 };
                            return [3 /*break*/, 16];
                        case 11:
                            _d.trys.push([11, , 14, 15]);
                            if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                            return [4 /*yield*/, __await(_c.call(_a))];
                        case 12:
                            _d.sent();
                            _d.label = 13;
                        case 13: return [3 /*break*/, 15];
                        case 14:
                            if (e_2) throw e_2.error;
                            return [7 /*endfinally*/];
                        case 15: return [7 /*endfinally*/];
                        case 16: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
         * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * for await (const secretAttr of client.listSecrets()) {
         *   const secret = await client.getSecret(secretAttr.name);
         *   console.log("secret: ", secret);
         * }
         * ```
         * @summary List all secrets in the vault
         * @param [options] The optional parameters
         * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
         */
        SecretsClient.prototype.listSecrets = function (options) {
            var _a;
            var _this = this;
            var span = this.createSpan("listSecrets", options && options.requestOptions);
            span.start();
            var iter = this.listSecretsAll(options);
            span.end();
            return _a = {
                    next: function () {
                        return iter.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.listSecretsPage(settings, options);
                },
                _a;
        };
        SecretsClient.prototype.listDeletedSecretsPage = function (continuationState, options) {
            return __asyncGenerator(this, arguments, function listDeletedSecretsPage_1() {
                var optionsComplete, currentSetResponse, currentSetResponse;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                            optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                            return [4 /*yield*/, __await(this.client.getDeletedSecrets(this.vaultBaseUrl, optionsComplete))];
                        case 1:
                            currentSetResponse = _a.sent();
                            continuationState.continuationToken = currentSetResponse.nextLink;
                            return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                        case 2: return [4 /*yield*/, _a.sent()];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4:
                            if (!continuationState.continuationToken) return [3 /*break*/, 8];
                            return [4 /*yield*/, __await(this.client.getDeletedSecretsNext(continuationState.continuationToken, options))];
                        case 5:
                            currentSetResponse = _a.sent();
                            continuationState.continuationToken = currentSetResponse.nextLink;
                            return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                        case 6: return [4 /*yield*/, _a.sent()];
                        case 7:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 8: return [2 /*return*/];
                    }
                });
            });
        };
        SecretsClient.prototype.listDeletedSecretsAll = function (options) {
            return __asyncGenerator(this, arguments, function listDeletedSecretsAll_1() {
                var f, _a, _b, page, _i, page_3, item, e_3_1;
                var e_3, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            f = {};
                            _d.label = 1;
                        case 1:
                            _d.trys.push([1, 10, 11, 16]);
                            _a = __asyncValues(this.listDeletedSecretsPage(f, options));
                            _d.label = 2;
                        case 2: return [4 /*yield*/, __await(_a.next())];
                        case 3:
                            if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                            page = _b.value;
                            _i = 0, page_3 = page;
                            _d.label = 4;
                        case 4:
                            if (!(_i < page_3.length)) return [3 /*break*/, 8];
                            item = page_3[_i];
                            return [4 /*yield*/, __await(item)];
                        case 5: return [4 /*yield*/, _d.sent()];
                        case 6:
                            _d.sent();
                            _d.label = 7;
                        case 7:
                            _i++;
                            return [3 /*break*/, 4];
                        case 8: return [3 /*break*/, 2];
                        case 9: return [3 /*break*/, 16];
                        case 10:
                            e_3_1 = _d.sent();
                            e_3 = { error: e_3_1 };
                            return [3 /*break*/, 16];
                        case 11:
                            _d.trys.push([11, , 14, 15]);
                            if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                            return [4 /*yield*/, __await(_c.call(_a))];
                        case 12:
                            _d.sent();
                            _d.label = 13;
                        case 13: return [3 /*break*/, 15];
                        case 14:
                            if (e_3) throw e_3.error;
                            return [7 /*endfinally*/];
                        case 15: return [7 /*endfinally*/];
                        case 16: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
         * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
         *
         * Example usage:
         * ```ts
         * let client = new SecretsClient(url, credentials);
         * for await (const secretAttr of client.listDeletedSecrets()) {
         *   const deletedSecret = await client.getSecret(secretAttr.name);
         *   console.log("deleted secret: ", deletedSecret);
         * }
         * ```
         * @summary List all secrets in the vault
         * @param [options] The optional parameters
         * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
         */
        SecretsClient.prototype.listDeletedSecrets = function (options) {
            var _a;
            var _this = this;
            var span = this.createSpan("listDeletedSecrets", options && options.requestOptions);
            span.start();
            var iter = this.listDeletedSecretsAll(options);
            span.end();
            return _a = {
                    next: function () {
                        return iter.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.listDeletedSecretsPage(settings, options);
                },
                _a;
        };
        SecretsClient.prototype.getSecretFromSecretBundle = function (secretBundle) {
            var parsedId = parseKeyvaultIdentifier("secrets", secretBundle.id);
            var resultObject;
            if (secretBundle.attributes) {
                resultObject = __assign({}, secretBundle, parsedId, secretBundle.attributes);
                delete resultObject.attributes;
            }
            else {
                resultObject = __assign({}, secretBundle, parsedId);
            }
            return resultObject;
        };
        SecretsClient.prototype.getDeletedSecretFromDeletedSecretBundle = function (deletedSecretBundle) {
            var parsedId = parseKeyvaultIdentifier("secrets", deletedSecretBundle.id);
            var resultObject;
            if (deletedSecretBundle.attributes) {
                resultObject = __assign({}, deletedSecretBundle, parsedId, deletedSecretBundle.attributes);
                delete resultObject.attributes;
            }
            else {
                resultObject = __assign({}, deletedSecretBundle, parsedId);
            }
            return resultObject;
        };
        /**
         * Creates a span using the tracer that was set by the user
         * @param methodName The name of the method for which the span is being created.
         * @param requestOptions The options for the underlying http request. This will be
         * updated to use the newly created span as the "parent" so that any new spans created
         * after this point gets the right parent.
         */
        SecretsClient.prototype.createSpan = function (methodName, requestOptions) {
            var tracer = TracerProxy.getTracer();
            var options = requestOptions || {};
            var span = tracer.startSpan(methodName, options.spanOptions);
            if (tracer.pluginType !== exports.SupportedPlugins.NOOP &&
                (options.spanOptions && options.spanOptions.parent)) {
                options.spanOptions = __assign({}, options.spanOptions, { parent: span });
            }
            return span;
        };
        return SecretsClient;
    }());

    exports.SecretsClient = SecretsClient;
    exports.TracerProxy = TracerProxy;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=azure-keyvault-secrets.js.map
