// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import * as msal from "msal";
import { IdentityClient } from "../client/identityClient";
/**
 * Enables authentication to Azure Active Directory inside of the web browser
 * using the interactive login flow, either via browser redirects or a popup
 * window.
 */
export class InteractiveBrowserCredential {
    /**
     * Creates an instance of the InteractiveBrowserCredential with the
     * details needed to authenticate against Azure Active Directory with
     * a user identity.
     *
     * @param tenantId The Azure Active Directory tenant (directory) ID.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, options) {
        options = Object.assign({}, IdentityClient.getDefaultOptions(), options);
        this.loginStyle = options.loginStyle || "popup";
        if (["redirect", "popup"].indexOf(this.loginStyle) === -1) {
            throw new Error(`Invalid loginStyle: ${options.loginStyle}`);
        }
        this.msalConfig = {
            auth: Object.assign({ clientId: clientId, authority: `${options.authorityHost}/${tenantId}` }, (options.redirectUri && { redirectUri: options.redirectUri }), (options.postLogoutRedirectUri && { redirectUri: options.postLogoutRedirectUri })),
            cache: {
                cacheLocation: "localStorage",
                storeAuthStateInCookie: true
            }
        };
        this.msalObject = new msal.UserAgentApplication(this.msalConfig);
    }
    login() {
        switch (this.loginStyle) {
            case "redirect": {
                const loginPromise = new Promise((resolve, reject) => {
                    this.msalObject.handleRedirectCallback(resolve, reject);
                });
                this.msalObject.loginRedirect();
                return loginPromise;
            }
            case "popup":
                return this.msalObject.loginPopup();
        }
    }
    acquireToken(authParams) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let authResponse;
            try {
                authResponse = yield this.msalObject.acquireTokenSilent(authParams);
            }
            catch (err) {
                if (err instanceof msal.AuthError) {
                    switch (err.errorCode) {
                        case "consent_required":
                        case "interaction_required":
                        case "login_required":
                            break;
                        default:
                            throw err;
                    }
                }
            }
            let authPromise;
            if (authResponse === undefined) {
                switch (this.loginStyle) {
                    case "redirect":
                        authPromise = new Promise((resolve, reject) => {
                            this.msalObject.handleRedirectCallback(resolve, reject);
                        });
                        this.msalObject.acquireTokenRedirect(authParams);
                        break;
                    case "popup":
                        authPromise = this.msalObject.acquireTokenPopup(authParams);
                        break;
                }
                authResponse = authPromise && (yield authPromise);
            }
            return authResponse;
        });
    }
    /**
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options // eslint-disable-line @typescript-eslint/no-unused-vars
    ) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.msalObject.getAccount()) {
                yield this.login();
            }
            const authResponse = yield this.acquireToken({
                scopes: Array.isArray(scopes) ? scopes : scopes.split(",")
            });
            if (authResponse) {
                return {
                    token: authResponse.accessToken,
                    expiresOnTimestamp: authResponse.expiresOn.getTime()
                };
            }
            else {
                return null;
            }
        });
    }
}
//# sourceMappingURL=interactiveBrowserCredential.browser.js.map