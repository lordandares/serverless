/*!
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Azure KeyVault Secrets SDK for JavaScript - 4.0.0-preview.5
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_1 = require('tslib');
var coreHttp = require('@azure/core-http');
require('@azure/core-paging');
var coreArm = require('@azure/core-arm');
var url = require('url');

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var CloudError = coreArm.CloudErrorMapper;
var BaseResource = coreArm.BaseResourceMapper;
var Attributes = {
    serializedName: "Attributes",
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "UnixTime"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "UnixTime"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
var JsonWebKey = {
    serializedName: "JsonWebKey",
    type: {
        name: "Composite",
        className: "JsonWebKey",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            n: {
                serializedName: "n",
                type: {
                    name: "Base64Url"
                }
            },
            e: {
                serializedName: "e",
                type: {
                    name: "Base64Url"
                }
            },
            d: {
                serializedName: "d",
                type: {
                    name: "Base64Url"
                }
            },
            dp: {
                serializedName: "dp",
                type: {
                    name: "Base64Url"
                }
            },
            dq: {
                serializedName: "dq",
                type: {
                    name: "Base64Url"
                }
            },
            qi: {
                serializedName: "qi",
                type: {
                    name: "Base64Url"
                }
            },
            p: {
                serializedName: "p",
                type: {
                    name: "Base64Url"
                }
            },
            q: {
                serializedName: "q",
                type: {
                    name: "Base64Url"
                }
            },
            k: {
                serializedName: "k",
                type: {
                    name: "Base64Url"
                }
            },
            t: {
                serializedName: "key_hsm",
                type: {
                    name: "Base64Url"
                }
            },
            crv: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            },
            x: {
                serializedName: "x",
                type: {
                    name: "Base64Url"
                }
            },
            y: {
                serializedName: "y",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyAttributes = {
    serializedName: "KeyAttributes",
    type: {
        name: "Composite",
        className: "KeyAttributes",
        modelProperties: tslib_1.__assign({}, Attributes.type.modelProperties, { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var KeyBundle = {
    serializedName: "KeyBundle",
    type: {
        name: "Composite",
        className: "KeyBundle",
        modelProperties: {
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "JsonWebKey"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var KeyItem = {
    serializedName: "KeyItem",
    type: {
        name: "Composite",
        className: "KeyItem",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var DeletedKeyBundle = {
    serializedName: "DeletedKeyBundle",
    type: {
        name: "Composite",
        className: "DeletedKeyBundle",
        modelProperties: tslib_1.__assign({}, KeyBundle.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedKeyItem = {
    serializedName: "DeletedKeyItem",
    type: {
        name: "Composite",
        className: "DeletedKeyItem",
        modelProperties: tslib_1.__assign({}, KeyItem.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SecretAttributes = {
    serializedName: "SecretAttributes",
    type: {
        name: "Composite",
        className: "SecretAttributes",
        modelProperties: tslib_1.__assign({}, Attributes.type.modelProperties, { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var SecretBundle = {
    serializedName: "SecretBundle",
    type: {
        name: "Composite",
        className: "SecretBundle",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var SecretItem = {
    serializedName: "SecretItem",
    type: {
        name: "Composite",
        className: "SecretItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var DeletedSecretBundle = {
    serializedName: "DeletedSecretBundle",
    type: {
        name: "Composite",
        className: "DeletedSecretBundle",
        modelProperties: tslib_1.__assign({}, SecretBundle.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedSecretItem = {
    serializedName: "DeletedSecretItem",
    type: {
        name: "Composite",
        className: "DeletedSecretItem",
        modelProperties: tslib_1.__assign({}, SecretItem.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SecretRestoreParameters = {
    serializedName: "SecretRestoreParameters",
    type: {
        name: "Composite",
        className: "SecretRestoreParameters",
        modelProperties: {
            secretBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var StorageRestoreParameters = {
    serializedName: "StorageRestoreParameters",
    type: {
        name: "Composite",
        className: "StorageRestoreParameters",
        modelProperties: {
            storageBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var CertificateAttributes = {
    serializedName: "CertificateAttributes",
    type: {
        name: "Composite",
        className: "CertificateAttributes",
        modelProperties: tslib_1.__assign({}, Attributes.type.modelProperties, { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var CertificateItem = {
    serializedName: "CertificateItem",
    type: {
        name: "Composite",
        className: "CertificateItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            x509Thumbprint: {
                serializedName: "x5t",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var CertificateIssuerItem = {
    serializedName: "CertificateIssuerItem",
    type: {
        name: "Composite",
        className: "CertificateIssuerItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var KeyProperties = {
    serializedName: "KeyProperties",
    type: {
        name: "Composite",
        className: "KeyProperties",
        modelProperties: {
            exportable: {
                serializedName: "exportable",
                type: {
                    name: "Boolean"
                }
            },
            keyType: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            reuseKey: {
                serializedName: "reuse_key",
                type: {
                    name: "Boolean"
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SecretProperties = {
    serializedName: "SecretProperties",
    type: {
        name: "Composite",
        className: "SecretProperties",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SubjectAlternativeNames = {
    serializedName: "SubjectAlternativeNames",
    type: {
        name: "Composite",
        className: "SubjectAlternativeNames",
        modelProperties: {
            emails: {
                serializedName: "emails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dnsNames: {
                serializedName: "dns_names",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            upns: {
                serializedName: "upns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var X509CertificateProperties = {
    serializedName: "X509CertificateProperties",
    type: {
        name: "Composite",
        className: "X509CertificateProperties",
        modelProperties: {
            subject: {
                serializedName: "subject",
                type: {
                    name: "String"
                }
            },
            ekus: {
                serializedName: "ekus",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            subjectAlternativeNames: {
                serializedName: "sans",
                type: {
                    name: "Composite",
                    className: "SubjectAlternativeNames"
                }
            },
            keyUsage: {
                serializedName: "key_usage",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            validityInMonths: {
                serializedName: "validity_months",
                constraints: {
                    InclusiveMinimum: 0
                },
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var Trigger = {
    serializedName: "Trigger",
    type: {
        name: "Composite",
        className: "Trigger",
        modelProperties: {
            lifetimePercentage: {
                serializedName: "lifetime_percentage",
                constraints: {
                    InclusiveMaximum: 99,
                    InclusiveMinimum: 1
                },
                type: {
                    name: "Number"
                }
            },
            daysBeforeExpiry: {
                serializedName: "days_before_expiry",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var Action = {
    serializedName: "Action",
    type: {
        name: "Composite",
        className: "Action",
        modelProperties: {
            actionType: {
                serializedName: "action_type",
                type: {
                    name: "Enum",
                    allowedValues: ["EmailContacts", "AutoRenew"]
                }
            }
        }
    }
};
var LifetimeAction = {
    serializedName: "LifetimeAction",
    type: {
        name: "Composite",
        className: "LifetimeAction",
        modelProperties: {
            trigger: {
                serializedName: "trigger",
                type: {
                    name: "Composite",
                    className: "Trigger"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "Action"
                }
            }
        }
    }
};
var IssuerParameters = {
    serializedName: "IssuerParameters",
    type: {
        name: "Composite",
        className: "IssuerParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            certificateType: {
                serializedName: "cty",
                type: {
                    name: "String"
                }
            },
            certificateTransparency: {
                serializedName: "cert_transparency",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var CertificatePolicy = {
    serializedName: "CertificatePolicy",
    type: {
        name: "Composite",
        className: "CertificatePolicy",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            keyProperties: {
                serializedName: "key_props",
                type: {
                    name: "Composite",
                    className: "KeyProperties"
                }
            },
            secretProperties: {
                serializedName: "secret_props",
                type: {
                    name: "Composite",
                    className: "SecretProperties"
                }
            },
            x509CertificateProperties: {
                serializedName: "x509_props",
                type: {
                    name: "Composite",
                    className: "X509CertificateProperties"
                }
            },
            lifetimeActions: {
                serializedName: "lifetime_actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LifetimeAction"
                        }
                    }
                }
            },
            issuerParameters: {
                serializedName: "issuer",
                type: {
                    name: "Composite",
                    className: "IssuerParameters"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            }
        }
    }
};
var CertificateBundle = {
    serializedName: "CertificateBundle",
    type: {
        name: "Composite",
        className: "CertificateBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            sid: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            x509Thumbprint: {
                readOnly: true,
                serializedName: "x5t",
                type: {
                    name: "Base64Url"
                }
            },
            policy: {
                readOnly: true,
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            cer: {
                serializedName: "cer",
                type: {
                    name: "ByteArray"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedCertificateBundle = {
    serializedName: "DeletedCertificateBundle",
    type: {
        name: "Composite",
        className: "DeletedCertificateBundle",
        modelProperties: tslib_1.__assign({}, CertificateBundle.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedCertificateItem = {
    serializedName: "DeletedCertificateItem",
    type: {
        name: "Composite",
        className: "DeletedCertificateItem",
        modelProperties: tslib_1.__assign({}, CertificateItem.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var ErrorModel = {
    serializedName: "Error",
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                readOnly: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                readOnly: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            innerError: {
                readOnly: true,
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
var CertificateOperation = {
    serializedName: "CertificateOperation",
    type: {
        name: "Composite",
        className: "CertificateOperation",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            issuerParameters: {
                serializedName: "issuer",
                type: {
                    name: "Composite",
                    className: "IssuerParameters"
                }
            },
            csr: {
                serializedName: "csr",
                type: {
                    name: "ByteArray"
                }
            },
            cancellationRequested: {
                serializedName: "cancellation_requested",
                type: {
                    name: "Boolean"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            statusDetails: {
                serializedName: "status_details",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request_id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var IssuerCredentials = {
    serializedName: "IssuerCredentials",
    type: {
        name: "Composite",
        className: "IssuerCredentials",
        modelProperties: {
            accountId: {
                serializedName: "account_id",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "pwd",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var AdministratorDetails = {
    serializedName: "AdministratorDetails",
    type: {
        name: "Composite",
        className: "AdministratorDetails",
        modelProperties: {
            firstName: {
                serializedName: "first_name",
                type: {
                    name: "String"
                }
            },
            lastName: {
                serializedName: "last_name",
                type: {
                    name: "String"
                }
            },
            emailAddress: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var OrganizationDetails = {
    serializedName: "OrganizationDetails",
    type: {
        name: "Composite",
        className: "OrganizationDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            adminDetails: {
                serializedName: "admin_details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdministratorDetails"
                        }
                    }
                }
            }
        }
    }
};
var IssuerAttributes = {
    serializedName: "IssuerAttributes",
    type: {
        name: "Composite",
        className: "IssuerAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
var IssuerBundle = {
    serializedName: "IssuerBundle",
    type: {
        name: "Composite",
        className: "IssuerBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var Contact = {
    serializedName: "Contact",
    type: {
        name: "Composite",
        className: "Contact",
        modelProperties: {
            emailAddress: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var Contacts = {
    serializedName: "Contacts",
    type: {
        name: "Composite",
        className: "Contacts",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            contactList: {
                serializedName: "contacts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Contact"
                        }
                    }
                }
            }
        }
    }
};
var KeyCreateParameters = {
    serializedName: "KeyCreateParameters",
    type: {
        name: "Composite",
        className: "KeyCreateParameters",
        modelProperties: {
            kty: {
                required: true,
                serializedName: "kty",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var KeyImportParameters = {
    serializedName: "KeyImportParameters",
    type: {
        name: "Composite",
        className: "KeyImportParameters",
        modelProperties: {
            hsm: {
                serializedName: "Hsm",
                type: {
                    name: "Boolean"
                }
            },
            key: {
                required: true,
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "JsonWebKey"
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyOperationsParameters = {
    serializedName: "KeyOperationsParameters",
    type: {
        name: "Composite",
        className: "KeyOperationsParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeySignParameters = {
    serializedName: "KeySignParameters",
    type: {
        name: "Composite",
        className: "KeySignParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyVerifyParameters = {
    serializedName: "KeyVerifyParameters",
    type: {
        name: "Composite",
        className: "KeyVerifyParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            digest: {
                required: true,
                serializedName: "digest",
                type: {
                    name: "Base64Url"
                }
            },
            signature: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyUpdateParameters = {
    serializedName: "KeyUpdateParameters",
    type: {
        name: "Composite",
        className: "KeyUpdateParameters",
        modelProperties: {
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyRestoreParameters = {
    serializedName: "KeyRestoreParameters",
    type: {
        name: "Composite",
        className: "KeyRestoreParameters",
        modelProperties: {
            keyBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var SecretSetParameters = {
    serializedName: "SecretSetParameters",
    type: {
        name: "Composite",
        className: "SecretSetParameters",
        modelProperties: {
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            secretAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            }
        }
    }
};
var SecretUpdateParameters = {
    serializedName: "SecretUpdateParameters",
    type: {
        name: "Composite",
        className: "SecretUpdateParameters",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            secretAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateCreateParameters = {
    serializedName: "CertificateCreateParameters",
    type: {
        name: "Composite",
        className: "CertificateCreateParameters",
        modelProperties: {
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateImportParameters = {
    serializedName: "CertificateImportParameters",
    type: {
        name: "Composite",
        className: "CertificateImportParameters",
        modelProperties: {
            base64EncodedCertificate: {
                required: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "pwd",
                type: {
                    name: "String"
                }
            },
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateUpdateParameters = {
    serializedName: "CertificateUpdateParameters",
    type: {
        name: "Composite",
        className: "CertificateUpdateParameters",
        modelProperties: {
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateMergeParameters = {
    serializedName: "CertificateMergeParameters",
    type: {
        name: "Composite",
        className: "CertificateMergeParameters",
        modelProperties: {
            x509Certificates: {
                required: true,
                serializedName: "x5c",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "ByteArray"
                        }
                    }
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateIssuerSetParameters = {
    serializedName: "CertificateIssuerSetParameters",
    type: {
        name: "Composite",
        className: "CertificateIssuerSetParameters",
        modelProperties: {
            provider: {
                required: true,
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var CertificateIssuerUpdateParameters = {
    serializedName: "CertificateIssuerUpdateParameters",
    type: {
        name: "Composite",
        className: "CertificateIssuerUpdateParameters",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var CertificateOperationUpdateParameter = {
    serializedName: "CertificateOperationUpdateParameter",
    type: {
        name: "Composite",
        className: "CertificateOperationUpdateParameter",
        modelProperties: {
            cancellationRequested: {
                required: true,
                serializedName: "cancellation_requested",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var KeyOperationResult = {
    serializedName: "KeyOperationResult",
    type: {
        name: "Composite",
        className: "KeyOperationResult",
        modelProperties: {
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            result: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyVerifyResult = {
    serializedName: "KeyVerifyResult",
    type: {
        name: "Composite",
        className: "KeyVerifyResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var BackupKeyResult = {
    serializedName: "BackupKeyResult",
    type: {
        name: "Composite",
        className: "BackupKeyResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupSecretResult = {
    serializedName: "BackupSecretResult",
    type: {
        name: "Composite",
        className: "BackupSecretResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupStorageResult = {
    serializedName: "BackupStorageResult",
    type: {
        name: "Composite",
        className: "BackupStorageResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var PendingCertificateSigningRequestResult = {
    serializedName: "PendingCertificateSigningRequestResult",
    type: {
        name: "Composite",
        className: "PendingCertificateSigningRequestResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageAccountAttributes = {
    serializedName: "StorageAccountAttributes",
    type: {
        name: "Composite",
        className: "StorageAccountAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            },
            recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageBundle = {
    serializedName: "StorageBundle",
    type: {
        name: "Composite",
        className: "StorageBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                readOnly: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            activeKeyName: {
                readOnly: true,
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                readOnly: true,
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                readOnly: true,
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedStorageBundle = {
    serializedName: "DeletedStorageBundle",
    type: {
        name: "Composite",
        className: "DeletedStorageBundle",
        modelProperties: tslib_1.__assign({}, StorageBundle.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var StorageAccountCreateParameters = {
    serializedName: "StorageAccountCreateParameters",
    type: {
        name: "Composite",
        className: "StorageAccountCreateParameters",
        modelProperties: {
            resourceId: {
                required: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            activeKeyName: {
                required: true,
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                required: true,
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            storageAccountAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var StorageAccountUpdateParameters = {
    serializedName: "StorageAccountUpdateParameters",
    type: {
        name: "Composite",
        className: "StorageAccountUpdateParameters",
        modelProperties: {
            activeKeyName: {
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            storageAccountAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var StorageAccountRegenerteKeyParameters = {
    serializedName: "StorageAccountRegenerteKeyParameters",
    type: {
        name: "Composite",
        className: "StorageAccountRegenerteKeyParameters",
        modelProperties: {
            keyName: {
                required: true,
                serializedName: "keyName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageAccountItem = {
    serializedName: "StorageAccountItem",
    type: {
        name: "Composite",
        className: "StorageAccountItem",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                readOnly: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedStorageAccountItem = {
    serializedName: "DeletedStorageAccountItem",
    type: {
        name: "Composite",
        className: "DeletedStorageAccountItem",
        modelProperties: tslib_1.__assign({}, StorageAccountItem.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SasDefinitionAttributes = {
    serializedName: "SasDefinitionAttributes",
    type: {
        name: "Composite",
        className: "SasDefinitionAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            },
            recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SasDefinitionBundle = {
    serializedName: "SasDefinitionBundle",
    type: {
        name: "Composite",
        className: "SasDefinitionBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            secretId: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            templateUri: {
                readOnly: true,
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                readOnly: true,
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                readOnly: true,
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedSasDefinitionBundle = {
    serializedName: "DeletedSasDefinitionBundle",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionBundle",
        modelProperties: tslib_1.__assign({}, SasDefinitionBundle.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SasDefinitionItem = {
    serializedName: "SasDefinitionItem",
    type: {
        name: "Composite",
        className: "SasDefinitionItem",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            secretId: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedSasDefinitionItem = {
    serializedName: "DeletedSasDefinitionItem",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionItem",
        modelProperties: tslib_1.__assign({}, SasDefinitionItem.type.modelProperties, { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SasDefinitionCreateParameters = {
    serializedName: "SasDefinitionCreateParameters",
    type: {
        name: "Composite",
        className: "SasDefinitionCreateParameters",
        modelProperties: {
            templateUri: {
                required: true,
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                required: true,
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                required: true,
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            sasDefinitionAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var SasDefinitionUpdateParameters = {
    serializedName: "SasDefinitionUpdateParameters",
    type: {
        name: "Composite",
        className: "SasDefinitionUpdateParameters",
        modelProperties: {
            templateUri: {
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            sasDefinitionAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyVaultError = {
    serializedName: "KeyVaultError",
    type: {
        name: "Composite",
        className: "KeyVaultError",
        modelProperties: {
            error: {
                readOnly: true,
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
var CertificateRestoreParameters = {
    serializedName: "CertificateRestoreParameters",
    type: {
        name: "Composite",
        className: "CertificateRestoreParameters",
        modelProperties: {
            certificateBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupCertificateResult = {
    serializedName: "BackupCertificateResult",
    type: {
        name: "Composite",
        className: "BackupCertificateResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyListResult = {
    serializedName: "KeyListResult",
    type: {
        name: "Composite",
        className: "KeyListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedKeyListResult = {
    serializedName: "DeletedKeyListResult",
    type: {
        name: "Composite",
        className: "DeletedKeyListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedKeyItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SecretListResult = {
    serializedName: "SecretListResult",
    type: {
        name: "Composite",
        className: "SecretListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecretItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedSecretListResult = {
    serializedName: "DeletedSecretListResult",
    type: {
        name: "Composite",
        className: "DeletedSecretListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSecretItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var CertificateListResult = {
    serializedName: "CertificateListResult",
    type: {
        name: "Composite",
        className: "CertificateListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var CertificateIssuerListResult = {
    serializedName: "CertificateIssuerListResult",
    type: {
        name: "Composite",
        className: "CertificateIssuerListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateIssuerItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedCertificateListResult = {
    serializedName: "DeletedCertificateListResult",
    type: {
        name: "Composite",
        className: "DeletedCertificateListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedCertificateItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageListResult = {
    serializedName: "StorageListResult",
    type: {
        name: "Composite",
        className: "StorageListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccountItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedStorageListResult = {
    serializedName: "DeletedStorageListResult",
    type: {
        name: "Composite",
        className: "DeletedStorageListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedStorageAccountItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SasDefinitionListResult = {
    serializedName: "SasDefinitionListResult",
    type: {
        name: "Composite",
        className: "SasDefinitionListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SasDefinitionItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedSasDefinitionListResult = {
    serializedName: "DeletedSasDefinitionListResult",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSasDefinitionItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    CloudError: CloudError,
    BaseResource: BaseResource,
    Attributes: Attributes,
    JsonWebKey: JsonWebKey,
    KeyAttributes: KeyAttributes,
    KeyBundle: KeyBundle,
    KeyItem: KeyItem,
    DeletedKeyBundle: DeletedKeyBundle,
    DeletedKeyItem: DeletedKeyItem,
    SecretAttributes: SecretAttributes,
    SecretBundle: SecretBundle,
    SecretItem: SecretItem,
    DeletedSecretBundle: DeletedSecretBundle,
    DeletedSecretItem: DeletedSecretItem,
    SecretRestoreParameters: SecretRestoreParameters,
    StorageRestoreParameters: StorageRestoreParameters,
    CertificateAttributes: CertificateAttributes,
    CertificateItem: CertificateItem,
    CertificateIssuerItem: CertificateIssuerItem,
    KeyProperties: KeyProperties,
    SecretProperties: SecretProperties,
    SubjectAlternativeNames: SubjectAlternativeNames,
    X509CertificateProperties: X509CertificateProperties,
    Trigger: Trigger,
    Action: Action,
    LifetimeAction: LifetimeAction,
    IssuerParameters: IssuerParameters,
    CertificatePolicy: CertificatePolicy,
    CertificateBundle: CertificateBundle,
    DeletedCertificateBundle: DeletedCertificateBundle,
    DeletedCertificateItem: DeletedCertificateItem,
    ErrorModel: ErrorModel,
    CertificateOperation: CertificateOperation,
    IssuerCredentials: IssuerCredentials,
    AdministratorDetails: AdministratorDetails,
    OrganizationDetails: OrganizationDetails,
    IssuerAttributes: IssuerAttributes,
    IssuerBundle: IssuerBundle,
    Contact: Contact,
    Contacts: Contacts,
    KeyCreateParameters: KeyCreateParameters,
    KeyImportParameters: KeyImportParameters,
    KeyOperationsParameters: KeyOperationsParameters,
    KeySignParameters: KeySignParameters,
    KeyVerifyParameters: KeyVerifyParameters,
    KeyUpdateParameters: KeyUpdateParameters,
    KeyRestoreParameters: KeyRestoreParameters,
    SecretSetParameters: SecretSetParameters,
    SecretUpdateParameters: SecretUpdateParameters,
    CertificateCreateParameters: CertificateCreateParameters,
    CertificateImportParameters: CertificateImportParameters,
    CertificateUpdateParameters: CertificateUpdateParameters,
    CertificateMergeParameters: CertificateMergeParameters,
    CertificateIssuerSetParameters: CertificateIssuerSetParameters,
    CertificateIssuerUpdateParameters: CertificateIssuerUpdateParameters,
    CertificateOperationUpdateParameter: CertificateOperationUpdateParameter,
    KeyOperationResult: KeyOperationResult,
    KeyVerifyResult: KeyVerifyResult,
    BackupKeyResult: BackupKeyResult,
    BackupSecretResult: BackupSecretResult,
    BackupStorageResult: BackupStorageResult,
    PendingCertificateSigningRequestResult: PendingCertificateSigningRequestResult,
    StorageAccountAttributes: StorageAccountAttributes,
    StorageBundle: StorageBundle,
    DeletedStorageBundle: DeletedStorageBundle,
    StorageAccountCreateParameters: StorageAccountCreateParameters,
    StorageAccountUpdateParameters: StorageAccountUpdateParameters,
    StorageAccountRegenerteKeyParameters: StorageAccountRegenerteKeyParameters,
    StorageAccountItem: StorageAccountItem,
    DeletedStorageAccountItem: DeletedStorageAccountItem,
    SasDefinitionAttributes: SasDefinitionAttributes,
    SasDefinitionBundle: SasDefinitionBundle,
    DeletedSasDefinitionBundle: DeletedSasDefinitionBundle,
    SasDefinitionItem: SasDefinitionItem,
    DeletedSasDefinitionItem: DeletedSasDefinitionItem,
    SasDefinitionCreateParameters: SasDefinitionCreateParameters,
    SasDefinitionUpdateParameters: SasDefinitionUpdateParameters,
    KeyVaultError: KeyVaultError,
    CertificateRestoreParameters: CertificateRestoreParameters,
    BackupCertificateResult: BackupCertificateResult,
    KeyListResult: KeyListResult,
    DeletedKeyListResult: DeletedKeyListResult,
    SecretListResult: SecretListResult,
    DeletedSecretListResult: DeletedSecretListResult,
    CertificateListResult: CertificateListResult,
    CertificateIssuerListResult: CertificateIssuerListResult,
    DeletedCertificateListResult: DeletedCertificateListResult,
    StorageListResult: StorageListResult,
    DeletedStorageListResult: DeletedStorageListResult,
    SasDefinitionListResult: SasDefinitionListResult,
    DeletedSasDefinitionListResult: DeletedSasDefinitionListResult
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var acceptLanguage = {
    parameterPath: "acceptLanguage",
    mapper: {
        serializedName: "accept-language",
        defaultValue: "en-US",
        type: {
            name: "String"
        }
    }
};
var apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        required: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
var certificateName0 = {
    parameterPath: "certificateName",
    mapper: {
        required: true,
        serializedName: "certificate-name",
        type: {
            name: "String"
        }
    }
};
var certificateName1 = {
    parameterPath: "certificateName",
    mapper: {
        required: true,
        serializedName: "certificate-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var certificateVersion = {
    parameterPath: "certificateVersion",
    mapper: {
        required: true,
        serializedName: "certificate-version",
        type: {
            name: "String"
        }
    }
};
var includePending = {
    parameterPath: ["options", "includePending"],
    mapper: {
        serializedName: "includePending",
        type: {
            name: "Boolean"
        }
    }
};
var issuerName = {
    parameterPath: "issuerName",
    mapper: {
        required: true,
        serializedName: "issuer-name",
        type: {
            name: "String"
        }
    }
};
var keyName0 = {
    parameterPath: "keyName",
    mapper: {
        required: true,
        serializedName: "key-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var keyName1 = {
    parameterPath: "keyName",
    mapper: {
        required: true,
        serializedName: "key-name",
        type: {
            name: "String"
        }
    }
};
var keyVersion = {
    parameterPath: "keyVersion",
    mapper: {
        required: true,
        serializedName: "key-version",
        type: {
            name: "String"
        }
    }
};
var maxresults = {
    parameterPath: ["options", "maxresults"],
    mapper: {
        serializedName: "maxresults",
        constraints: {
            InclusiveMaximum: 25,
            InclusiveMinimum: 1
        },
        type: {
            name: "Number"
        }
    }
};
var nextPageLink = {
    parameterPath: "nextPageLink",
    mapper: {
        required: true,
        serializedName: "nextLink",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
var sasDefinitionName = {
    parameterPath: "sasDefinitionName",
    mapper: {
        required: true,
        serializedName: "sas-definition-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z]+$/
        },
        type: {
            name: "String"
        }
    }
};
var secretName0 = {
    parameterPath: "secretName",
    mapper: {
        required: true,
        serializedName: "secret-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var secretName1 = {
    parameterPath: "secretName",
    mapper: {
        required: true,
        serializedName: "secret-name",
        type: {
            name: "String"
        }
    }
};
var secretVersion = {
    parameterPath: "secretVersion",
    mapper: {
        required: true,
        serializedName: "secret-version",
        type: {
            name: "String"
        }
    }
};
var storageAccountName0 = {
    parameterPath: "storageAccountName",
    mapper: {
        required: true,
        serializedName: "storage-account-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z]+$/
        },
        type: {
            name: "String"
        }
    }
};
var storageAccountName1 = {
    parameterPath: "storageAccountName",
    mapper: {
        required: true,
        serializedName: "storage-account-name",
        type: {
            name: "String"
        }
    }
};
var vaultBaseUrl = {
    parameterPath: "vaultBaseUrl",
    mapper: {
        required: true,
        serializedName: "vaultBaseUrl",
        defaultValue: "",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var packageName = "@azure/keyvault-secrets";
var packageVersion = "4.0.0-preview.5";
var KeyVaultClientContext = /** @class */ (function (_super) {
    tslib_1.__extends(KeyVaultClientContext, _super);
    /**
     * Initializes a new instance of the KeyVaultClient class.
     * @param credentials Credentials needed for the client to connect to Azure.
     * @param [options] The parameter options
     */
    function KeyVaultClientContext(credentials, options) {
        var _this = this;
        if (credentials == undefined) {
            throw new Error("'credentials' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            var defaultUserAgent = coreArm.getDefaultUserAgentValue();
            options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
        }
        _this = _super.call(this, credentials, options) || this;
        _this.apiVersion = "7.0";
        _this.acceptLanguage = "en-US";
        _this.longRunningOperationRetryTimeout = 30;
        _this.baseUri = "{vaultBaseUrl}";
        _this.requestContentType = "application/json; charset=utf-8";
        _this.credentials = credentials;
        if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {
            _this.acceptLanguage = options.acceptLanguage;
        }
        if (options.longRunningOperationRetryTimeout !== null &&
            options.longRunningOperationRetryTimeout !== undefined) {
            _this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;
        }
        return _this;
    }
    return KeyVaultClientContext;
}(coreArm.AzureServiceClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var KeyVaultClient = /** @class */ (function (_super) {
    tslib_1.__extends(KeyVaultClient, _super);
    /**
     * Initializes a new instance of the KeyVaultClient class.
     * @param credentials Credentials needed for the client to connect to Azure.
     * @param [options] The parameter options
     */
    function KeyVaultClient(credentials, options) {
        return _super.call(this, credentials, options) || this;
    }
    KeyVaultClient.prototype.createKey = function (vaultBaseUrl, keyName, kty, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            kty: kty,
            options: options
        }, createKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.importKey = function (vaultBaseUrl, keyName, key, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            key: key,
            options: options
        }, importKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, deleteKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateKey = function (vaultBaseUrl, keyName, keyVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            options: options
        }, updateKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKey = function (vaultBaseUrl, keyName, keyVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            options: options
        }, getKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKeyVersions = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, getKeyVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKeys = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getKeysOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, backupKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreKey = function (vaultBaseUrl, keyBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyBundleBackup: keyBundleBackup,
            options: options
        }, restoreKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.encrypt = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, encryptOperationSpec, callback);
    };
    KeyVaultClient.prototype.decrypt = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, decryptOperationSpec, callback);
    };
    KeyVaultClient.prototype.sign = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, signOperationSpec, callback);
    };
    KeyVaultClient.prototype.verify = function (vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            digest: digest,
            signature: signature,
            options: options
        }, verifyOperationSpec, callback);
    };
    KeyVaultClient.prototype.wrapKey = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, wrapKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.unwrapKey = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, unwrapKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedKeys = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedKeysOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, getDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, purgeDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, recoverDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.setSecret = function (vaultBaseUrl, secretName, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            value: value,
            options: options
        }, setSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, deleteSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateSecret = function (vaultBaseUrl, secretName, secretVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            secretVersion: secretVersion,
            options: options
        }, updateSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecret = function (vaultBaseUrl, secretName, secretVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            secretVersion: secretVersion,
            options: options
        }, getSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecrets = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getSecretsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecretVersions = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, getSecretVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSecrets = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedSecretsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, getDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, purgeDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, recoverDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, backupSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreSecret = function (vaultBaseUrl, secretBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretBundleBackup: secretBundleBackup,
            options: options
        }, restoreSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificates = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificatesOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, deleteCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.setCertificateContacts = function (vaultBaseUrl, contacts, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            contacts: contacts,
            options: options
        }, setCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateContacts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateContacts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, deleteCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateIssuers = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificateIssuersOperationSpec, callback);
    };
    KeyVaultClient.prototype.setCertificateIssuer = function (vaultBaseUrl, issuerName, provider, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            provider: provider,
            options: options
        }, setCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, updateCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, getCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, deleteCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.createCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, createCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.importCertificate = function (vaultBaseUrl, certificateName, base64EncodedCertificate, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            base64EncodedCertificate: base64EncodedCertificate,
            options: options
        }, importCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateVersions = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificateVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificatePolicy = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificatePolicyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificatePolicy = function (vaultBaseUrl, certificateName, certificatePolicy, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificatePolicy: certificatePolicy,
            options: options
        }, updateCertificatePolicyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificate = function (vaultBaseUrl, certificateName, certificateVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificateVersion: certificateVersion,
            options: options
        }, updateCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificate = function (vaultBaseUrl, certificateName, certificateVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificateVersion: certificateVersion,
            options: options
        }, getCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificateOperation = function (vaultBaseUrl, certificateName, cancellationRequested, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            cancellationRequested: cancellationRequested,
            options: options
        }, updateCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateOperation = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateOperation = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, deleteCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.mergeCertificate = function (vaultBaseUrl, certificateName, x509Certificates, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            x509Certificates: x509Certificates,
            options: options
        }, mergeCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, backupCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreCertificate = function (vaultBaseUrl, certificateBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateBundleBackup: certificateBundleBackup,
            options: options
        }, restoreCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedCertificates = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedCertificatesOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, purgeDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, recoverDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getStorageAccounts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getStorageAccountsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedStorageAccounts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedStorageAccountsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, purgeDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, recoverDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, backupStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreStorageAccount = function (vaultBaseUrl, storageBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageBundleBackup: storageBundleBackup,
            options: options
        }, restoreStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, deleteStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.getStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.setStorageAccount = function (vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            resourceId: resourceId,
            activeKeyName: activeKeyName,
            autoRegenerateKey: autoRegenerateKey,
            options: options
        }, setStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, updateStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.regenerateStorageAccountKey = function (vaultBaseUrl, storageAccountName, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            keyName: keyName,
            options: options
        }, regenerateStorageAccountKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSasDefinitions = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getSasDefinitionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSasDefinitions = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getDeletedSasDefinitionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, getDeletedSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, recoverDeletedSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, deleteSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, getSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.setSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, templateUri, sasType, validityPeriod, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            templateUri: templateUri,
            sasType: sasType,
            validityPeriod: validityPeriod,
            options: options
        }, setSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, updateSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKeyVersionsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getKeyVersionsNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKeysNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getKeysNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedKeysNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getDeletedKeysNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecretsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getSecretsNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecretVersionsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getSecretVersionsNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSecretsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getDeletedSecretsNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificatesNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getCertificatesNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateIssuersNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getCertificateIssuersNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateVersionsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getCertificateVersionsNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedCertificatesNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getDeletedCertificatesNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getStorageAccountsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getStorageAccountsNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedStorageAccountsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getDeletedStorageAccountsNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSasDefinitionsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getSasDefinitionsNextOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSasDefinitionsNext = function (nextPageLink, options, callback) {
        return this.sendOperationRequest({
            nextPageLink: nextPageLink,
            options: options
        }, getDeletedSasDefinitionsNextOperationSpec, callback);
    };
    return KeyVaultClient;
}(KeyVaultClientContext));
// Operation Specifications
var serializer = new coreHttp.Serializer(Mappers);
var createKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/create",
    urlParameters: [vaultBaseUrl, keyName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            kty: "kty",
            keySize: ["options", "keySize"],
            keyOps: ["options", "keyOps"],
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"],
            curve: ["options", "curve"]
        },
        mapper: tslib_1.__assign({}, KeyCreateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var importKeyOperationSpec = {
    httpMethod: "PUT",
    path: "keys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            hsm: ["options", "hsm"],
            key: "key",
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, KeyImportParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteKeyOperationSpec = {
    httpMethod: "DELETE",
    path: "keys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedKeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateKeyOperationSpec = {
    httpMethod: "PATCH",
    path: "keys/{key-name}/{key-version}",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            keyOps: ["options", "keyOps"],
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, KeyUpdateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeyOperationSpec = {
    httpMethod: "GET",
    path: "keys/{key-name}/{key-version}",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeyVersionsOperationSpec = {
    httpMethod: "GET",
    path: "keys/{key-name}/versions",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeysOperationSpec = {
    httpMethod: "GET",
    path: "keys",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/backup",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: BackupKeyResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            keyBundleBackup: "keyBundleBackup"
        },
        mapper: tslib_1.__assign({}, KeyRestoreParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var encryptOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/encrypt",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib_1.__assign({}, KeyOperationsParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var decryptOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/decrypt",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib_1.__assign({}, KeyOperationsParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var signOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/sign",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib_1.__assign({}, KeySignParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var verifyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/verify",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            digest: "digest",
            signature: "signature"
        },
        mapper: tslib_1.__assign({}, KeyVerifyParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyVerifyResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var wrapKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/wrapkey",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib_1.__assign({}, KeyOperationsParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var unwrapKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/unwrapkey",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib_1.__assign({}, KeyOperationsParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedKeysOperationSpec = {
    httpMethod: "GET",
    path: "deletedkeys",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedKeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedKeyOperationSpec = {
    httpMethod: "GET",
    path: "deletedkeys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedKeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedKeyOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedkeys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedKeyOperationSpec = {
    httpMethod: "POST",
    path: "deletedkeys/{key-name}/recover",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setSecretOperationSpec = {
    httpMethod: "PUT",
    path: "secrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            value: "value",
            tags: ["options", "tags"],
            contentType: ["options", "contentType"],
            secretAttributes: ["options", "secretAttributes"]
        },
        mapper: tslib_1.__assign({}, SecretSetParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteSecretOperationSpec = {
    httpMethod: "DELETE",
    path: "secrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedSecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateSecretOperationSpec = {
    httpMethod: "PATCH",
    path: "secrets/{secret-name}/{secret-version}",
    urlParameters: [vaultBaseUrl, secretName1, secretVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            contentType: ["options", "contentType"],
            secretAttributes: ["options", "secretAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, SecretUpdateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretOperationSpec = {
    httpMethod: "GET",
    path: "secrets/{secret-name}/{secret-version}",
    urlParameters: [vaultBaseUrl, secretName1, secretVersion],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretsOperationSpec = {
    httpMethod: "GET",
    path: "secrets",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretVersionsOperationSpec = {
    httpMethod: "GET",
    path: "secrets/{secret-name}/versions",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSecretsOperationSpec = {
    httpMethod: "GET",
    path: "deletedsecrets",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedSecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSecretOperationSpec = {
    httpMethod: "GET",
    path: "deletedsecrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedSecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedSecretOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedsecrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedSecretOperationSpec = {
    httpMethod: "POST",
    path: "deletedsecrets/{secret-name}/recover",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupSecretOperationSpec = {
    httpMethod: "POST",
    path: "secrets/{secret-name}/backup",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: BackupSecretResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreSecretOperationSpec = {
    httpMethod: "POST",
    path: "secrets/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            secretBundleBackup: "secretBundleBackup"
        },
        mapper: tslib_1.__assign({}, SecretRestoreParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificatesOperationSpec = {
    httpMethod: "GET",
    path: "certificates",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, includePending, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedCertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setCertificateContactsOperationSpec = {
    httpMethod: "PUT",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: "contacts",
        mapper: tslib_1.__assign({}, Contacts, { required: true })
    },
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateContactsOperationSpec = {
    httpMethod: "GET",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateContactsOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateIssuersOperationSpec = {
    httpMethod: "GET",
    path: "certificates/issuers",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateIssuerListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setCertificateIssuerOperationSpec = {
    httpMethod: "PUT",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            provider: "provider",
            credentials: ["options", "credentials"],
            organizationDetails: ["options", "organizationDetails"],
            attributes: ["options", "attributes"]
        },
        mapper: tslib_1.__assign({}, CertificateIssuerSetParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateIssuerOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            provider: ["options", "provider"],
            credentials: ["options", "credentials"],
            organizationDetails: ["options", "organizationDetails"],
            attributes: ["options", "attributes"]
        },
        mapper: tslib_1.__assign({}, CertificateIssuerUpdateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateIssuerOperationSpec = {
    httpMethod: "GET",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateIssuerOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var createCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/create",
    urlParameters: [vaultBaseUrl, certificateName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, CertificateCreateParameters, { required: true })
    },
    responses: {
        202: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var importCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/import",
    urlParameters: [vaultBaseUrl, certificateName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            base64EncodedCertificate: "base64EncodedCertificate",
            password: ["options", "password"],
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, CertificateImportParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateVersionsOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/versions",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificatePolicyOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/policy",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificatePolicy
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificatePolicyOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/policy",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: "certificatePolicy",
        mapper: tslib_1.__assign({}, CertificatePolicy, { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificatePolicy
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/{certificate-version}",
    urlParameters: [
        vaultBaseUrl,
        certificateName0,
        certificateVersion
    ],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, CertificateUpdateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/{certificate-version}",
    urlParameters: [
        vaultBaseUrl,
        certificateName0,
        certificateVersion
    ],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateOperationOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            cancellationRequested: "cancellationRequested"
        },
        mapper: tslib_1.__assign({}, CertificateOperationUpdateParameter, { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateOperationOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateOperationOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var mergeCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/pending/merge",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            x509Certificates: "x509Certificates",
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, CertificateMergeParameters, { required: true })
    },
    responses: {
        201: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/backup",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: BackupCertificateResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            certificateBundleBackup: "certificateBundleBackup"
        },
        mapper: tslib_1.__assign({}, CertificateRestoreParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedCertificatesOperationSpec = {
    httpMethod: "GET",
    path: "deletedcertificates",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, includePending, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedCertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedCertificateOperationSpec = {
    httpMethod: "GET",
    path: "deletedcertificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedCertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedCertificateOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedcertificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedCertificateOperationSpec = {
    httpMethod: "POST",
    path: "deletedcertificates/{certificate-name}/recover",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getStorageAccountsOperationSpec = {
    httpMethod: "GET",
    path: "storage",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: StorageListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedStorageAccountsOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedStorageListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedStorageAccountOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedStorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedStorageAccountOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedstorage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "deletedstorage/{storage-account-name}/recover",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "storage/{storage-account-name}/backup",
    urlParameters: [vaultBaseUrl, storageAccountName1],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: BackupStorageResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "storage/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            storageBundleBackup: "storageBundleBackup"
        },
        mapper: tslib_1.__assign({}, StorageRestoreParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteStorageAccountOperationSpec = {
    httpMethod: "DELETE",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedStorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getStorageAccountOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setStorageAccountOperationSpec = {
    httpMethod: "PUT",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            resourceId: "resourceId",
            activeKeyName: "activeKeyName",
            autoRegenerateKey: "autoRegenerateKey",
            regenerationPeriod: ["options", "regenerationPeriod"],
            storageAccountAttributes: ["options", "storageAccountAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, StorageAccountCreateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateStorageAccountOperationSpec = {
    httpMethod: "PATCH",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            activeKeyName: ["options", "activeKeyName"],
            autoRegenerateKey: ["options", "autoRegenerateKey"],
            regenerationPeriod: ["options", "regenerationPeriod"],
            storageAccountAttributes: ["options", "storageAccountAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, StorageAccountUpdateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var regenerateStorageAccountKeyOperationSpec = {
    httpMethod: "POST",
    path: "storage/{storage-account-name}/regeneratekey",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            keyName: "keyName"
        },
        mapper: tslib_1.__assign({}, StorageAccountRegenerteKeyParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSasDefinitionsOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}/sas",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SasDefinitionListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSasDefinitionsOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}/sas",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [maxresults, apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSasDefinitionOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedSasDefinitionOperationSpec = {
    httpMethod: "POST",
    path: "deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteSasDefinitionOperationSpec = {
    httpMethod: "DELETE",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSasDefinitionOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setSasDefinitionOperationSpec = {
    httpMethod: "PUT",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            templateUri: "templateUri",
            sasType: "sasType",
            validityPeriod: "validityPeriod",
            sasDefinitionAttributes: ["options", "sasDefinitionAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, SasDefinitionCreateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateSasDefinitionOperationSpec = {
    httpMethod: "PATCH",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    headerParameters: [acceptLanguage],
    requestBody: {
        parameterPath: {
            templateUri: ["options", "templateUri"],
            sasType: ["options", "sasType"],
            validityPeriod: ["options", "validityPeriod"],
            sasDefinitionAttributes: ["options", "sasDefinitionAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib_1.__assign({}, SasDefinitionUpdateParameters, { required: true })
    },
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeyVersionsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeysNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedKeysNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedKeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretVersionsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSecretsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedSecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificatesNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateIssuersNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateIssuerListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateVersionsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedCertificatesNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedCertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getStorageAccountsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: StorageListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedStorageAccountsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedStorageListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSasDefinitionsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: SasDefinitionListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSasDefinitionsNextOperationSpec = {
    httpMethod: "GET",
    baseUrl: "{vaultBaseUrl}",
    path: "{nextLink}",
    urlParameters: [nextPageLink],
    headerParameters: [acceptLanguage],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var SDK_VERSION = "4.0.0-preview.5";
var RetryConstants = {
    MIN_RETRY_INTERVAL_MS: 3000
};

// Copyright (c) Microsoft Corporation. All rights reserved.
var TokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes
/**
 * Creates a new ChallengeBasedAuthenticationPolicy factory.
 *
 * @param credential The TokenCredential implementation that can supply the challenge token.
 */
function challengeBasedAuthenticationPolicy(credential) {
    return {
        create: function (nextPolicy, options) {
            return new ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential);
        }
    };
}
var AuthenticationChallenge = /** @class */ (function () {
    function AuthenticationChallenge(scopes) {
        this.scopes = scopes;
    }
    return AuthenticationChallenge;
}());
/**
 *
 * Provides a RequestPolicy that can request a token from a TokenCredential
 * implementation and then apply it to the Authorization header of a request
 * as a Bearer token.
 *
 */
var ChallengeBasedAuthenticationPolicy = /** @class */ (function (_super) {
    tslib_1.__extends(ChallengeBasedAuthenticationPolicy, _super);
    /**
     * Creates a new ChallengeBasedAuthenticationPolicy object.
     *
     * @param nextPolicy The next RequestPolicy in the request pipeline.
     * @param options Options for this RequestPolicy.
     * @param credential The TokenCredential implementation that can supply the bearer token.
     * @param scopes The scopes for which the bearer token applies.
     */
    function ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, refreshOn) {
        if (refreshOn === void 0) { refreshOn = Date.now(); }
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.credential = credential;
        _this.refreshOn = refreshOn;
        _this.cachedToken = undefined;
        _this.challenge = undefined;
        return _this;
    }
    ChallengeBasedAuthenticationPolicy.prototype.parseWWWAuthenticate = function (www_authenticate) {
        // Parses an authentication message like:
        // ```
        // Bearer authorization="some_authorization", resource="https://some.url"
        // ```
        var authenticateArray = www_authenticate.split(" ");
        // Remove the "Bearer" piece
        delete authenticateArray[0];
        // Split the KV comma-separated list
        var commaSep = authenticateArray.join().split(",");
        for (var _i = 0, commaSep_1 = commaSep; _i < commaSep_1.length; _i++) {
            var item = commaSep_1[_i];
            // Split the key/value pairs
            var kv = item.split("=");
            if (kv[0].trim() == "resource") {
                // Remove the quotations around the string
                var resource = kv[1].trim().replace(/['"]+/g, '');
                return resource;
            }
        }
        return "";
    };
    /**
     * Applies the Bearer token to the request through the Authorization header.
     * @param webResource
     */
    ChallengeBasedAuthenticationPolicy.prototype.sendRequest = function (webResource) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var originalBody, response, www_authenticate, resource, challenge;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!webResource.headers)
                            webResource.headers = new coreHttp.HttpHeaders();
                        originalBody = webResource.body;
                        if (!(this.challenge == undefined)) return [3 /*break*/, 1];
                        // Use a blank to start the challenge
                        webResource.body = "";
                        return [3 /*break*/, 3];
                    case 1: 
                    // or use the cached token if we have one
                    return [4 /*yield*/, this.authenticateRequest(webResource)];
                    case 2:
                        // or use the cached token if we have one
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this._nextPolicy.sendRequest(webResource)];
                    case 4:
                        response = _a.sent();
                        if (!(response.status == 401)) return [3 /*break*/, 7];
                        webResource.body = originalBody;
                        www_authenticate = response.headers.get("WWW-Authenticate");
                        if (!www_authenticate) return [3 /*break*/, 6];
                        resource = this.parseWWWAuthenticate(www_authenticate);
                        challenge = new AuthenticationChallenge(resource + "/.default");
                        if (!(this.challenge != challenge)) return [3 /*break*/, 6];
                        this.challenge = challenge;
                        this.cachedToken = undefined;
                        return [4 /*yield*/, this.authenticateRequest(webResource)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [2 /*return*/, this._nextPolicy.sendRequest(webResource)];
                    case 7: return [2 /*return*/, response];
                }
            });
        });
    };
    ChallengeBasedAuthenticationPolicy.prototype.authenticateRequest = function (webResource) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var token;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.cachedToken &&
                            (Date.now() < this.refreshOn))) return [3 /*break*/, 1];
                        webResource.headers.set(coreHttp.Constants.HeaderConstants.AUTHORIZATION, "Bearer " + this.cachedToken.token);
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.credential.getToken(this.challenge.scopes)];
                    case 2:
                        token = _a.sent();
                        if (token) {
                            this.cachedToken = token;
                            this.refreshOn = token.expiresOnTimestamp - TokenRefreshBufferMs;
                            webResource.headers.set(coreHttp.Constants.HeaderConstants.AUTHORIZATION, "Bearer " + token.token);
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return ChallengeBasedAuthenticationPolicy;
}(coreHttp.BaseRequestPolicy));

function parseKeyvaultIdentifier(collection, identifier) {
    if (typeof collection != "string" || !(collection = collection.trim())) {
        throw new Error("Invalid collection argument");
    }
    if (typeof identifier != "string" || !(identifier = identifier.trim())) {
        throw new Error("Invalid identifier argument");
    }
    var baseUri;
    try {
        baseUri = url.parse(identifier, true, true);
    }
    catch (e) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". Not a valid URI");
    }
    // Path is of the form '/collection/name[/version]'
    var segments = (baseUri.pathname || "").split("/");
    if (segments.length !== 3 && segments.length !== 4) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". Bad number of segments: " + segments.length);
    }
    if (collection !== segments[1]) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". segment [1] should be \"" + collection + "\", found \"" + segments[1] + "\"");
    }
    var vaultUrl = baseUri.protocol + "//" + baseUri.host;
    var name = segments[2];
    var version = segments.length === 4 ? segments[3] : undefined;
    return {
        vaultUrl: vaultUrl,
        name: name,
        version: version
    };
}

function isNewPipelineOptions(pipelineOrOptions) {
    // An empty object is consider options
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && obj.constructor === Object;
    }
    var options = pipelineOrOptions;
    return (isEmptyObject(pipelineOrOptions) ||
        !!(options.retryOptions || options.proxyOptions || options.logger || options.HTTPClient));
}

// Copyright (c) Microsoft Corporation.
/**
 * The client to interact with the KeyVault secrets functionality
 */
var SecretsClient = /** @class */ (function () {
    /**
     * Creates an instance of SecretsClient.
     *
     * Example usage:
     * ```ts
     * import { SecretsClient } from "@azure/keyvault-secrets";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let url = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new SecretsClient(url, credentials);
     * ```
     * @param {string} url the base url to the key vault.
     * @param {TokenCredential} The credential to use for API requests.
     * @param {(Pipeline | NewPipelineOptions)} [pipelineOrOptions={}] Optional. A Pipeline, or options to create a default Pipeline instance.
     *                                                                 Omitting this parameter to create the default Pipeline instance.
     * @memberof SecretsClient
     */
    function SecretsClient(url, credential, pipelineOrOptions) {
        if (pipelineOrOptions === void 0) { pipelineOrOptions = {}; }
        this.vaultBaseUrl = url;
        this.credential = credential;
        if (isNewPipelineOptions(pipelineOrOptions)) {
            this.pipeline = SecretsClient.getDefaultPipeline(credential, pipelineOrOptions);
        }
        else {
            this.pipeline = pipelineOrOptions;
        }
        this.client = new KeyVaultClient(credential, this.pipeline);
    }
    /**
     * A static method used to create a new Pipeline object with the provided Credential.
     * @static
     * @param {TokenCredential} The credential to use for API requests.
     * @param {NewPipelineOptions} [pipelineOptions] Optional. Options.
     * @returns {Pipeline} A new Pipeline object.
     * @memberof SecretsClient
     */
    SecretsClient.getDefaultPipeline = function (credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        // Order is important. Closer to the API at the top & closer to the network at the bottom.
        // The credential's policy factory must appear close to the wire so it can sign any
        // changes made by other factories (like UniqueRequestIDPolicyFactory)
        var retryOptions = pipelineOptions.retryOptions || {};
        var userAgentString = SecretsClient.getUserAgentString(pipelineOptions.telemetry);
        var requestPolicyFactories = [];
 {
            requestPolicyFactories.push(coreHttp.proxyPolicy(coreHttp.getDefaultProxySettings((pipelineOptions.proxyOptions || {}).proxySettings)));
        }
        requestPolicyFactories = requestPolicyFactories.concat([
            coreHttp.tracingPolicy(),
            coreHttp.userAgentPolicy({ value: userAgentString }),
            coreHttp.generateClientRequestIdPolicy(),
            coreHttp.deserializationPolicy(),
            coreHttp.throttlingRetryPolicy(),
            coreHttp.systemErrorRetryPolicy(),
            coreHttp.exponentialRetryPolicy(retryOptions.retryCount, retryOptions.retryIntervalInMS, RetryConstants.MIN_RETRY_INTERVAL_MS, // Minimum retry interval to prevent frequent retries
            retryOptions.maxRetryDelayInMs),
            coreHttp.redirectPolicy(),
            coreHttp.isTokenCredential(credential)
                ? challengeBasedAuthenticationPolicy(credential)
                : coreHttp.signingPolicy(credential)
        ]);
        return {
            httpClient: pipelineOptions.HTTPClient,
            httpPipelineLogger: pipelineOptions.logger,
            requestPolicyFactories: requestPolicyFactories
        };
    };
    SecretsClient.getUserAgentString = function (telemetry) {
        var userAgentInfo = [];
        if (telemetry) {
            if (userAgentInfo.indexOf(telemetry.value) === -1) {
                userAgentInfo.push(telemetry.value);
            }
        }
        var libInfo = "azsdk-js-keyvault-secrets/" + SDK_VERSION;
        if (userAgentInfo.indexOf(libInfo) === -1) {
            userAgentInfo.push(libInfo);
        }
        var defaultUserAgentInfo = coreHttp.getDefaultUserAgentValue();
        if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {
            userAgentInfo.push(defaultUserAgentInfo);
        }
        return userAgentInfo.join(" ");
    };
    // TODO: do we want Aborter as well?
    /**
     * The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
     * Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     * ```
     * @summary Adds a secret in a specified key vault.
     * @param secretName The name of the secret.
     * @param value The value of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.setSecret = function (secretName, value, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var unflattenedAttributes, unflattenedOptions, span_1, response, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 2];
                        unflattenedAttributes = {
                            enabled: options.enabled,
                            notBefore: options.notBefore,
                            expires: options.expires
                        };
                        unflattenedOptions = tslib_1.__assign({}, options, (options.requestOptions ? options.requestOptions : {}), { secretAttributes: unflattenedAttributes });
                        delete unflattenedOptions.enabled;
                        delete unflattenedOptions.notBefore;
                        delete unflattenedOptions.expires;
                        delete unflattenedOptions.requestOptions;
                        span_1 = this.createSpan("setSecret", unflattenedOptions);
                        span_1.start();
                        return [4 /*yield*/, this.client.setSecret(this.vaultBaseUrl, secretName, value, unflattenedOptions).catch(function (err) {
                                span_1.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span_1.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    case 2: return [4 /*yield*/, this.client.setSecret(this.vaultBaseUrl, secretName, value, options)];
                    case 3:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
     * to an individual version of a secret. This operation requires the secrets/delete permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * ```
     * @summary Deletes a secret from a specified key vault.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<DeletedSecret>
     */
    SecretsClient.prototype.deleteSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("deleteSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.deleteSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getDeletedSecretFromDeletedSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
     * are not specified in the request are left unchanged. The value of a secret itself cannot be
     * changed. This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let secretName = "MySecretName";
     * let client = new SecretsClient(url, credentials);
     * let secret = await client.getSecret(secretName);
     * await client.updateSecret(secretName, secret.version, { enabled: false });
     * ```
     * @summary Updates the attributes associated with a specified secret in a given key vault.
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.updateSecretAttributes = function (secretName, secretVersion, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var unflattenedAttributes, unflattenedOptions, span_2, response, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 2];
                        unflattenedAttributes = {
                            enabled: options.enabled,
                            notBefore: options.notBefore,
                            expires: options.expires
                        };
                        unflattenedOptions = tslib_1.__assign({}, options, (options.requestOptions ? options.requestOptions : {}), { secretAttributes: unflattenedAttributes });
                        delete unflattenedOptions.enabled;
                        delete unflattenedOptions.notBefore;
                        delete unflattenedOptions.expires;
                        delete unflattenedOptions.requestOptions;
                        span_2 = this.createSpan("updateSecretAttributes", unflattenedOptions);
                        span_2.start();
                        return [4 /*yield*/, this.client.updateSecret(this.vaultBaseUrl, secretName, secretVersion, unflattenedOptions)
                                .catch(function (err) {
                                span_2.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span_2.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    case 2: return [4 /*yield*/, this.client.updateSecret(this.vaultBaseUrl, secretName, secretVersion, options)];
                    case 3:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires
     * the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let secret = await client.getSecret("MySecretName");
     * ```
     * @summary Get a specified secret from a given key vault.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.getSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("getSecret", options && options.requestOptions);
                        span.start();
                        return [4 /*yield*/, this.client.getSecret(this.vaultBaseUrl, secretName, options && options.version ? options.version : "", options ? options.requestOptions : undefined)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The Get Deleted Secret operation returns the specified deleted secret along with its attributes.
     * This operation requires the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.getDeletedSecret("MyDeletedSecret");
     * ```
     * @summary Gets the specified deleted secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<DeletedSecret>
     */
    SecretsClient.prototype.getDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("getDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.getDeletedSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The purge deleted secret operation removes the secret permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the secrets/purge permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * await client.purgeDeletedSecret("MySecretName");
     * ```
     * @summary Permanently deletes the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<void>
     */
    SecretsClient.prototype.purgeDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("purgeDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.purgeDeletedSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        _a.sent();
                        span.end();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Recovers the deleted secret in the specified vault. This operation can only be performed on a
     * soft-delete enabled vault. This operation requires the secrets/recover permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * await client.recoverDeletedSecret("MySecretName");
     * ```
     * @summary Recovers the deleted secret to the latest version.
     * @param secretName The name of the deleted secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.recoverDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("recoverDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.recoverDeletedSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the
     * secret will be downloaded. This operation requires the secrets/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let backupResult = await client.backupSecret("MySecretName");
     * ```
     * @summary Backs up the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Uint8Array | undefined>
     */
    SecretsClient.prototype.backupSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("backupSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.backupSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, response.value];
                }
            });
        });
    };
    /**
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the
     * secrets/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let mySecretBundle = await client.backupSecret("MySecretName");
     * // ...
     * await client.restoreSecret(mySecretBundle);
     * ```
     * @summary Restores a backed up secret to a vault.
     * @param secretBundleBackup The backup blob associated with a secret bundle.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.restoreSecret = function (secretBundleBackup, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("restoreSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.restoreSecret(this.vaultBaseUrl, secretBundleBackup, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretVersionsPage = function (secretName, continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listSecretVersionsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecretVersions(this.vaultBaseUrl, secretName, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecretVersionsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretVersionsAll = function (secretName, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listSecretVersionsAll_1() {
            var f, _a, _b, page, _i, page_1, item, e_1_1;
            var e_1, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listSecretVersionsPage(secretName, f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_1 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_1.length)) return [3 /*break*/, 8];
                        item = page_1[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listSecretVersions("MySecretName")) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret version: ", secret);
     * }
     * ```
     * @param secretName Name of the secret to fetch versions for
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listSecretVersions = function (secretName, options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listSecretVersions", options && options.requestOptions);
        span.start();
        var iter = this.listSecretVersionsAll(secretName, options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSecretVersionsPage(secretName, settings, options);
            },
            _a;
    };
    SecretsClient.prototype.listSecretsPage = function (continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecrets(this.vaultBaseUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecretsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretsAll = function (options) {
        return tslib_1.__asyncGenerator(this, arguments, function listSecretsAll_1() {
            var f, _a, _b, page, _i, page_2, item, e_2_1;
            var e_2, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_2 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_2.length)) return [3 /*break*/, 8];
                        item = page_2[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listSecrets()) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret: ", secret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listSecrets = function (options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listSecrets", options && options.requestOptions);
        span.start();
        var iter = this.listSecretsAll(options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSecretsPage(settings, options);
            },
            _a;
    };
    SecretsClient.prototype.listDeletedSecretsPage = function (continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listDeletedSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, tslib_1.__await(this.client.getDeletedSecrets(this.vaultBaseUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(this.client.getDeletedSecretsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listDeletedSecretsAll = function (options) {
        return tslib_1.__asyncGenerator(this, arguments, function listDeletedSecretsAll_1() {
            var f, _a, _b, page, _i, page_3, item, e_3_1;
            var e_3, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listDeletedSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_3 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_3.length)) return [3 /*break*/, 8];
                        item = page_3[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listDeletedSecrets()) {
     *   const deletedSecret = await client.getSecret(secretAttr.name);
     *   console.log("deleted secret: ", deletedSecret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listDeletedSecrets = function (options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listDeletedSecrets", options && options.requestOptions);
        span.start();
        var iter = this.listDeletedSecretsAll(options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listDeletedSecretsPage(settings, options);
            },
            _a;
    };
    SecretsClient.prototype.getSecretFromSecretBundle = function (secretBundle) {
        var parsedId = parseKeyvaultIdentifier("secrets", secretBundle.id);
        var resultObject;
        if (secretBundle.attributes) {
            resultObject = tslib_1.__assign({}, secretBundle, parsedId, secretBundle.attributes);
            delete resultObject.attributes;
        }
        else {
            resultObject = tslib_1.__assign({}, secretBundle, parsedId);
        }
        return resultObject;
    };
    SecretsClient.prototype.getDeletedSecretFromDeletedSecretBundle = function (deletedSecretBundle) {
        var parsedId = parseKeyvaultIdentifier("secrets", deletedSecretBundle.id);
        var resultObject;
        if (deletedSecretBundle.attributes) {
            resultObject = tslib_1.__assign({}, deletedSecretBundle, parsedId, deletedSecretBundle.attributes);
            delete resultObject.attributes;
        }
        else {
            resultObject = tslib_1.__assign({}, deletedSecretBundle, parsedId);
        }
        return resultObject;
    };
    /**
     * Creates a span using the tracer that was set by the user
     * @param methodName The name of the method for which the span is being created.
     * @param requestOptions The options for the underlying http request. This will be
     * updated to use the newly created span as the "parent" so that any new spans created
     * after this point gets the right parent.
     */
    SecretsClient.prototype.createSpan = function (methodName, requestOptions) {
        var tracer = coreHttp.TracerProxy.getTracer();
        var options = requestOptions || {};
        var span = tracer.startSpan(methodName, options.spanOptions);
        if (tracer.pluginType !== coreHttp.SupportedPlugins.NOOP &&
            (options.spanOptions && options.spanOptions.parent)) {
            options.spanOptions = tslib_1.__assign({}, options.spanOptions, { parent: span });
        }
        return span;
    };
    return SecretsClient;
}());

Object.defineProperty(exports, 'SupportedPlugins', {
    enumerable: true,
    get: function () {
        return coreHttp.SupportedPlugins;
    }
});
Object.defineProperty(exports, 'TracerProxy', {
    enumerable: true,
    get: function () {
        return coreHttp.TracerProxy;
    }
});
exports.SecretsClient = SecretsClient;
//# sourceMappingURL=index.js.map
