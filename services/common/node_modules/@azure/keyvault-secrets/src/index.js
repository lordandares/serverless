"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint @typescript-eslint/member-ordering: 0 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
exports.__esModule = true;
var core_http_1 = require("@azure/core-http");
exports.TracerProxy = core_http_1.TracerProxy;
exports.SupportedPlugins = core_http_1.SupportedPlugins;
require("@azure/core-paging");
var keyVaultClient_1 = require("./core/keyVaultClient");
var constants_1 = require("./core/utils/constants");
var challengeBasedAuthenticationPolicy_1 = require("./core/challengeBasedAuthenticationPolicy");
var utils_1 = require("./core/utils");
var keyVaultBase_1 = require("./core/keyVaultBase");
/**
 * The client to interact with the KeyVault secrets functionality
 */
var SecretsClient = /** @class */ (function () {
    /**
     * Creates an instance of SecretsClient.
     *
     * Example usage:
     * ```ts
     * import { SecretsClient } from "@azure/keyvault-secrets";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let url = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new SecretsClient(url, credentials);
     * ```
     * @param {string} url the base url to the key vault.
     * @param {TokenCredential} The credential to use for API requests.
     * @param {(Pipeline | NewPipelineOptions)} [pipelineOrOptions={}] Optional. A Pipeline, or options to create a default Pipeline instance.
     *                                                                 Omitting this parameter to create the default Pipeline instance.
     * @memberof SecretsClient
     */
    function SecretsClient(url, credential, pipelineOrOptions) {
        if (pipelineOrOptions === void 0) { pipelineOrOptions = {}; }
        this.vaultBaseUrl = url;
        this.credential = credential;
        if (keyVaultBase_1.isNewPipelineOptions(pipelineOrOptions)) {
            this.pipeline = SecretsClient.getDefaultPipeline(credential, pipelineOrOptions);
        }
        else {
            this.pipeline = pipelineOrOptions;
        }
        this.client = new keyVaultClient_1.KeyVaultClient(credential, this.pipeline);
    }
    /**
     * A static method used to create a new Pipeline object with the provided Credential.
     * @static
     * @param {TokenCredential} The credential to use for API requests.
     * @param {NewPipelineOptions} [pipelineOptions] Optional. Options.
     * @returns {Pipeline} A new Pipeline object.
     * @memberof SecretsClient
     */
    SecretsClient.getDefaultPipeline = function (credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        // Order is important. Closer to the API at the top & closer to the network at the bottom.
        // The credential's policy factory must appear close to the wire so it can sign any
        // changes made by other factories (like UniqueRequestIDPolicyFactory)
        var retryOptions = pipelineOptions.retryOptions || {};
        var userAgentString = SecretsClient.getUserAgentString(pipelineOptions.telemetry);
        var requestPolicyFactories = [];
        if (core_http_1.isNode) {
            requestPolicyFactories.push(core_http_1.proxyPolicy(core_http_1.getDefaultProxySettings((pipelineOptions.proxyOptions || {}).proxySettings)));
        }
        requestPolicyFactories = requestPolicyFactories.concat([
            core_http_1.tracingPolicy(),
            core_http_1.userAgentPolicy({ value: userAgentString }),
            core_http_1.generateClientRequestIdPolicy(),
            core_http_1.deserializationPolicy(),
            core_http_1.throttlingRetryPolicy(),
            core_http_1.systemErrorRetryPolicy(),
            core_http_1.exponentialRetryPolicy(retryOptions.retryCount, retryOptions.retryIntervalInMS, constants_1.RetryConstants.MIN_RETRY_INTERVAL_MS, // Minimum retry interval to prevent frequent retries
            retryOptions.maxRetryDelayInMs),
            core_http_1.redirectPolicy(),
            core_http_1.isTokenCredential(credential)
                ? challengeBasedAuthenticationPolicy_1.challengeBasedAuthenticationPolicy(credential)
                : core_http_1.signingPolicy(credential)
        ]);
        return {
            httpClient: pipelineOptions.HTTPClient,
            httpPipelineLogger: pipelineOptions.logger,
            requestPolicyFactories: requestPolicyFactories
        };
    };
    SecretsClient.getUserAgentString = function (telemetry) {
        var userAgentInfo = [];
        if (telemetry) {
            if (userAgentInfo.indexOf(telemetry.value) === -1) {
                userAgentInfo.push(telemetry.value);
            }
        }
        var libInfo = "azsdk-js-keyvault-secrets/" + constants_1.SDK_VERSION;
        if (userAgentInfo.indexOf(libInfo) === -1) {
            userAgentInfo.push(libInfo);
        }
        var defaultUserAgentInfo = core_http_1.getDefaultUserAgentValue();
        if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {
            userAgentInfo.push(defaultUserAgentInfo);
        }
        return userAgentInfo.join(" ");
    };
    // TODO: do we want Aborter as well?
    /**
     * The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
     * Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     * ```
     * @summary Adds a secret in a specified key vault.
     * @param secretName The name of the secret.
     * @param value The value of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.setSecret = function (secretName, value, options) {
        return __awaiter(this, void 0, void 0, function () {
            var unflattenedAttributes, unflattenedOptions, span_1, response, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 2];
                        unflattenedAttributes = {
                            enabled: options.enabled,
                            notBefore: options.notBefore,
                            expires: options.expires
                        };
                        unflattenedOptions = __assign({}, options, (options.requestOptions ? options.requestOptions : {}), { secretAttributes: unflattenedAttributes });
                        delete unflattenedOptions.enabled;
                        delete unflattenedOptions.notBefore;
                        delete unflattenedOptions.expires;
                        delete unflattenedOptions.requestOptions;
                        span_1 = this.createSpan("setSecret", unflattenedOptions);
                        span_1.start();
                        return [4 /*yield*/, this.client.setSecret(this.vaultBaseUrl, secretName, value, unflattenedOptions)["catch"](function (err) {
                                span_1.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span_1.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    case 2: return [4 /*yield*/, this.client.setSecret(this.vaultBaseUrl, secretName, value, options)];
                    case 3:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
     * to an individual version of a secret. This operation requires the secrets/delete permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * ```
     * @summary Deletes a secret from a specified key vault.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<DeletedSecret>
     */
    SecretsClient.prototype.deleteSecret = function (secretName, options) {
        return __awaiter(this, void 0, void 0, function () {
            var span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("deleteSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.deleteSecret(this.vaultBaseUrl, secretName, options)["catch"](function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getDeletedSecretFromDeletedSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
     * are not specified in the request are left unchanged. The value of a secret itself cannot be
     * changed. This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let secretName = "MySecretName";
     * let client = new SecretsClient(url, credentials);
     * let secret = await client.getSecret(secretName);
     * await client.updateSecret(secretName, secret.version, { enabled: false });
     * ```
     * @summary Updates the attributes associated with a specified secret in a given key vault.
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.updateSecretAttributes = function (secretName, secretVersion, options) {
        return __awaiter(this, void 0, void 0, function () {
            var unflattenedAttributes, unflattenedOptions, span_2, response, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 2];
                        unflattenedAttributes = {
                            enabled: options.enabled,
                            notBefore: options.notBefore,
                            expires: options.expires
                        };
                        unflattenedOptions = __assign({}, options, (options.requestOptions ? options.requestOptions : {}), { secretAttributes: unflattenedAttributes });
                        delete unflattenedOptions.enabled;
                        delete unflattenedOptions.notBefore;
                        delete unflattenedOptions.expires;
                        delete unflattenedOptions.requestOptions;
                        span_2 = this.createSpan("updateSecretAttributes", unflattenedOptions);
                        span_2.start();
                        return [4 /*yield*/, this.client.updateSecret(this.vaultBaseUrl, secretName, secretVersion, unflattenedOptions)["catch"](function (err) {
                                span_2.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span_2.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    case 2: return [4 /*yield*/, this.client.updateSecret(this.vaultBaseUrl, secretName, secretVersion, options)];
                    case 3:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires
     * the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let secret = await client.getSecret("MySecretName");
     * ```
     * @summary Get a specified secret from a given key vault.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.getSecret = function (secretName, options) {
        return __awaiter(this, void 0, void 0, function () {
            var span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("getSecret", options && options.requestOptions);
                        span.start();
                        return [4 /*yield*/, this.client.getSecret(this.vaultBaseUrl, secretName, options && options.version ? options.version : "", options ? options.requestOptions : undefined)["catch"](function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The Get Deleted Secret operation returns the specified deleted secret along with its attributes.
     * This operation requires the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.getDeletedSecret("MyDeletedSecret");
     * ```
     * @summary Gets the specified deleted secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<DeletedSecret>
     */
    SecretsClient.prototype.getDeletedSecret = function (secretName, options) {
        return __awaiter(this, void 0, void 0, function () {
            var span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("getDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.getDeletedSecret(this.vaultBaseUrl, secretName, options)["catch"](function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The purge deleted secret operation removes the secret permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the secrets/purge permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * await client.purgeDeletedSecret("MySecretName");
     * ```
     * @summary Permanently deletes the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<void>
     */
    SecretsClient.prototype.purgeDeletedSecret = function (secretName, options) {
        return __awaiter(this, void 0, void 0, function () {
            var span;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("purgeDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.purgeDeletedSecret(this.vaultBaseUrl, secretName, options)["catch"](function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        _a.sent();
                        span.end();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Recovers the deleted secret in the specified vault. This operation can only be performed on a
     * soft-delete enabled vault. This operation requires the secrets/recover permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * await client.recoverDeletedSecret("MySecretName");
     * ```
     * @summary Recovers the deleted secret to the latest version.
     * @param secretName The name of the deleted secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.recoverDeletedSecret = function (secretName, options) {
        return __awaiter(this, void 0, void 0, function () {
            var span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("recoverDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.recoverDeletedSecret(this.vaultBaseUrl, secretName, options)["catch"](function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the
     * secret will be downloaded. This operation requires the secrets/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let backupResult = await client.backupSecret("MySecretName");
     * ```
     * @summary Backs up the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Uint8Array | undefined>
     */
    SecretsClient.prototype.backupSecret = function (secretName, options) {
        return __awaiter(this, void 0, void 0, function () {
            var span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("backupSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.backupSecret(this.vaultBaseUrl, secretName, options)["catch"](function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, response.value];
                }
            });
        });
    };
    /**
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the
     * secrets/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let mySecretBundle = await client.backupSecret("MySecretName");
     * // ...
     * await client.restoreSecret(mySecretBundle);
     * ```
     * @summary Restores a backed up secret to a vault.
     * @param secretBundleBackup The backup blob associated with a secret bundle.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.restoreSecret = function (secretBundleBackup, options) {
        return __awaiter(this, void 0, void 0, function () {
            var span, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("restoreSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.restoreSecret(this.vaultBaseUrl, secretBundleBackup, options)["catch"](function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretVersionsPage = function (secretName, continuationState, options) {
        return __asyncGenerator(this, arguments, function listSecretVersionsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, __await(this.client.getSecretVersions(this.vaultBaseUrl, secretName, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(this.client.getSecretVersionsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretVersionsAll = function (secretName, options) {
        return __asyncGenerator(this, arguments, function listSecretVersionsAll_1() {
            var f, _a, _b, page, _i, page_1, item, e_1_1;
            var e_1, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.listSecretVersionsPage(secretName, f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_1 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_1.length)) return [3 /*break*/, 8];
                        item = page_1[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a["return"]))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listSecretVersions("MySecretName")) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret version: ", secret);
     * }
     * ```
     * @param secretName Name of the secret to fetch versions for
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listSecretVersions = function (secretName, options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listSecretVersions", options && options.requestOptions);
        span.start();
        var iter = this.listSecretVersionsAll(secretName, options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSecretVersionsPage(secretName, settings, options);
            },
            _a;
    };
    SecretsClient.prototype.listSecretsPage = function (continuationState, options) {
        return __asyncGenerator(this, arguments, function listSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, __await(this.client.getSecrets(this.vaultBaseUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(this.client.getSecretsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretsAll = function (options) {
        return __asyncGenerator(this, arguments, function listSecretsAll_1() {
            var f, _a, _b, page, _i, page_2, item, e_2_1;
            var e_2, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.listSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_2 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_2.length)) return [3 /*break*/, 8];
                        item = page_2[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a["return"]))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listSecrets()) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret: ", secret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listSecrets = function (options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listSecrets", options && options.requestOptions);
        span.start();
        var iter = this.listSecretsAll(options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSecretsPage(settings, options);
            },
            _a;
    };
    SecretsClient.prototype.listDeletedSecretsPage = function (continuationState, options) {
        return __asyncGenerator(this, arguments, function listDeletedSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = __assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, __await(this.client.getDeletedSecrets(this.vaultBaseUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(this.client.getDeletedSecretsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, __await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listDeletedSecretsAll = function (options) {
        return __asyncGenerator(this, arguments, function listDeletedSecretsAll_1() {
            var f, _a, _b, page, _i, page_3, item, e_3_1;
            var e_3, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.listDeletedSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_3 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_3.length)) return [3 /*break*/, 8];
                        item = page_3[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a["return"]))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listDeletedSecrets()) {
     *   const deletedSecret = await client.getSecret(secretAttr.name);
     *   console.log("deleted secret: ", deletedSecret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listDeletedSecrets = function (options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listDeletedSecrets", options && options.requestOptions);
        span.start();
        var iter = this.listDeletedSecretsAll(options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listDeletedSecretsPage(settings, options);
            },
            _a;
    };
    SecretsClient.prototype.getSecretFromSecretBundle = function (secretBundle) {
        var parsedId = utils_1.parseKeyvaultIdentifier("secrets", secretBundle.id);
        var resultObject;
        if (secretBundle.attributes) {
            resultObject = __assign({}, secretBundle, parsedId, secretBundle.attributes);
            delete resultObject.attributes;
        }
        else {
            resultObject = __assign({}, secretBundle, parsedId);
        }
        return resultObject;
    };
    SecretsClient.prototype.getDeletedSecretFromDeletedSecretBundle = function (deletedSecretBundle) {
        var parsedId = utils_1.parseKeyvaultIdentifier("secrets", deletedSecretBundle.id);
        var resultObject;
        if (deletedSecretBundle.attributes) {
            resultObject = __assign({}, deletedSecretBundle, parsedId, deletedSecretBundle.attributes);
            delete resultObject.attributes;
        }
        else {
            resultObject = __assign({}, deletedSecretBundle, parsedId);
        }
        return resultObject;
    };
    /**
     * Creates a span using the tracer that was set by the user
     * @param methodName The name of the method for which the span is being created.
     * @param requestOptions The options for the underlying http request. This will be
     * updated to use the newly created span as the "parent" so that any new spans created
     * after this point gets the right parent.
     */
    SecretsClient.prototype.createSpan = function (methodName, requestOptions) {
        var tracer = core_http_1.TracerProxy.getTracer();
        var options = requestOptions || {};
        var span = tracer.startSpan(methodName, options.spanOptions);
        if (tracer.pluginType !== core_http_1.SupportedPlugins.NOOP &&
            (options.spanOptions && options.spanOptions.parent)) {
            options.spanOptions = __assign({}, options.spanOptions, { parent: span });
        }
        return span;
    };
    return SecretsClient;
}());
exports.SecretsClient = SecretsClient;
