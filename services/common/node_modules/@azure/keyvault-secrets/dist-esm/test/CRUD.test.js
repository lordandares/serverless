// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import * as assert from "assert";
import { retry } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { AbortController } from "@azure/abort-controller";
describe("Secret client - create, read, update and delete operations", function () {
    var secretValue = "SECRET_VALUE";
    var secretPrefix = "CRUD" + (env.SECRET_NAME || "SecretName");
    var secretSuffix;
    var client;
    var testClient;
    var recorder;
    before(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var authentication;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        secretSuffix = authentication.secretSuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    after(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can add a secret", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, secretName, "Unexpected secret name in result from setSecret().");
                        assert.equal(result.value, secretValue, "Unexpected secret value in result from setSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can abort adding a secret", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, controller, resultPromise, error, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        controller = new AbortController();
                        resultPromise = client.setSecret(secretName, secretValue, {
                            requestOptions: {
                                abortSignal: controller.signal
                            }
                        });
                        controller.abort();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, resultPromise];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        error = e_1;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "The request was aborted");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("cannot create a secret with an empty name", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, error, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = "";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_2 = _a.sent();
                        error = e_2;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "\"secretName\" with value \"\" should satisfy the constraint \"Pattern\": /^[0-9a-zA-Z-]+$/.", "Unexpected error while running setSecret with an empty string as the name.");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can set a secret with Empty Value", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, secretValue, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretValue = "";
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, secretName, "Unexpected secret name in result from setSecret().");
                        assert.equal(result.value, secretValue, "Unexpected secret value in result from setSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can set a secret with attributes", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, expiryDate, updated;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        expiryDate = new Date("3000-01-01");
                        expiryDate.setMilliseconds(0);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue, { expires: expiryDate })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 2:
                        updated = _a.sent();
                        assert.equal(expiryDate.getDate(), updated.expires.getDate(), "Expect attribute 'expires' to be defined.");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can update a secret", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, expiryDate, updated;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        expiryDate = new Date("3000-01-01");
                        expiryDate.setMilliseconds(0);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.updateSecretAttributes(secretName, "", {
                                expires: expiryDate
                            })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 3:
                        updated = _a.sent();
                        assert.equal(updated.expires.getDate(), expiryDate.getDate(), "Expect attribute 'expires' to be updated.");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can update a disabled Secret", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, expiryDate, updated;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        expiryDate = new Date("3000-01-01");
                        expiryDate.setMilliseconds(0);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue, {
                                enabled: false
                            })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.updateSecretAttributes(secretName, "", {
                                expires: expiryDate
                            })];
                    case 2:
                        updated = _a.sent();
                        assert.equal(updated.expires.getDate(), expiryDate.getDate(), "Expect attribute 'expires' to be updated.");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a secret", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 2:
                        result = _a.sent();
                        assert.equal(result.name, secretName, "Unexpected secret name in result from setSecret().");
                        assert.equal(result.value, secretValue, "Unexpected secret value in result from setSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can't get a disabled Secret", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, expiryDate, error, e_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        expiryDate = new Date("3000-01-01");
                        expiryDate.setMilliseconds(0);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue, {
                                enabled: false
                            })];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 3:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 4:
                        e_3 = _a.sent();
                        error = e_3;
                        return [3 /*break*/, 5];
                    case 5:
                        assert.equal(error.message, "Operation get is not allowed on a disabled secret.", "Unexpected error after trying to get a disabled secret");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can retrieve the latest version of a secret value", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 2:
                        result = _a.sent();
                        assert.equal(result.name, secretName, "Unexpected secret name in result from setSecret().");
                        assert.equal(result.value, secretValue, "Unexpected secret value in result from setSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a secret (Non Existing)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, error, e_4;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_4 = _a.sent();
                        error = e_4;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Secret not found: " + secretName, "Unexpected error after trying to get a disabled secret");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can delete a secret", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, result, e_5;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.deleteSecret(secretName)];
                    case 2:
                        result = _a.sent();
                        assert.equal(typeof result.recoveryId, "string");
                        assert.ok(result.deletedDate instanceof Date);
                        assert.ok(result.scheduledPurgeDate instanceof Date);
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 4:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 5:
                        e_5 = _a.sent();
                        if (e_5.statusCode === 404) {
                            assert.equal(e_5.message, "Secret not found: " + secretName);
                        }
                        else {
                            throw e_5;
                        }
                        return [3 /*break*/, 6];
                    case 6: return [4 /*yield*/, testClient.purgeSecret(secretName)];
                    case 7:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can delete a secret (Non Existing)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, error, e_6;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.deleteSecret(secretName)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_6 = _a.sent();
                        error = e_6;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Secret not found: " + secretName, "Unexpected error after trying to get a disabled secret");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a deleted secret", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, getResult;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.deleteSecret(secretName)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, retry(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                                return [2 /*return*/, client.getDeletedSecret(secretName)];
                            }); }); })];
                    case 3:
                        getResult = _a.sent();
                        assert.equal(getResult.name, secretName, "Unexpected secret name in result from getSecret().");
                        return [4 /*yield*/, testClient.purgeSecret(secretName)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a deleted secret (Non Existing)", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, error, e_7;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.deleteSecret(secretName)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_7 = _a.sent();
                        error = e_7;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Secret not found: " + secretName, "Unexpected secret name in result from getKey().");
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=CRUD.test.js.map