import * as tslib_1 from "tslib";
import { delay as coreDelay } from "@azure/core-http";
/**
 * A simple abstraction to retry, and exponentially de-escalate retrying, a
 * given async function until it is fulfileld.
 * @param {() => Promise<T>} target The async function you want to retry
 * @param {number} delay The delay between each retry, defaults to 1000
 * @param {number} timeout Maximum time we'll let this lapse before we quit retrying, defaults to Infinity
 * @param {number} increaseFactor Increase factor of each retry, defaults to 1
 * @returns {Promise<any>} Resolved promise
 */
export function retry(target, delay, timeout, increaseFactor) {
    if (delay === void 0) { delay = 1000; }
    if (timeout === void 0) { timeout = Infinity; }
    if (increaseFactor === void 0) { increaseFactor = 1; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var start, updatedDelay, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    start = new Date().getTime();
                    updatedDelay = delay;
                    _b.label = 1;
                case 1:
                    if (!(new Date().getTime() - start < timeout)) return [3 /*break*/, 7];
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 6]);
                    return [4 /*yield*/, target()];
                case 3: return [2 /*return*/, _b.sent()];
                case 4:
                    _a = _b.sent();
                    return [4 /*yield*/, coreDelay(updatedDelay)];
                case 5:
                    _b.sent();
                    updatedDelay *= increaseFactor;
                    return [3 /*break*/, 6];
                case 6: return [3 /*break*/, 1];
                case 7: return [2 /*return*/, null];
            }
        });
    });
}
//# sourceMappingURL=retry.js.map