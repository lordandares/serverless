// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import * as assert from "assert";
import chai from "chai";
import { retry } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
var expect = chai.expect;
describe("Secret client - list secrets in various ways", function () {
    var secretValue = "SECRET_VALUE";
    var secretPrefix = "CRUD" + (env.SECRET_NAME || "SecretName");
    var secretSuffix;
    var client;
    var testClient;
    var recorder;
    before(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var authentication;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        secretSuffix = authentication.secretSuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    after(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can purge all secrets", function () {
        var e_1, _a, e_2, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _c, _d, secret, e_3, e_1_1, _e, _f, secret, e_4, e_2_1;
            return tslib_1.__generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _g.trys.push([0, 8, 9, 14]);
                        _c = tslib_1.__asyncValues(client.listSecrets());
                        _g.label = 1;
                    case 1: return [4 /*yield*/, _c.next()];
                    case 2:
                        if (!(_d = _g.sent(), !_d.done)) return [3 /*break*/, 7];
                        secret = _d.value;
                        _g.label = 3;
                    case 3:
                        _g.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, testClient.flushSecret(secret.name)];
                    case 4:
                        _g.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _g.sent();
                        return [3 /*break*/, 6];
                    case 6: return [3 /*break*/, 1];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_1_1 = _g.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _g.trys.push([9, , 12, 13]);
                        if (!(_d && !_d.done && (_a = _c.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, _a.call(_c)];
                    case 10:
                        _g.sent();
                        _g.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14:
                        _g.trys.push([14, 22, 23, 28]);
                        _e = tslib_1.__asyncValues(client.listDeletedSecrets());
                        _g.label = 15;
                    case 15: return [4 /*yield*/, _e.next()];
                    case 16:
                        if (!(_f = _g.sent(), !_f.done)) return [3 /*break*/, 21];
                        secret = _f.value;
                        _g.label = 17;
                    case 17:
                        _g.trys.push([17, 19, , 20]);
                        return [4 /*yield*/, testClient.purgeSecret(secret.name)];
                    case 18:
                        _g.sent();
                        return [3 /*break*/, 20];
                    case 19:
                        e_4 = _g.sent();
                        return [3 /*break*/, 20];
                    case 20: return [3 /*break*/, 15];
                    case 21: return [3 /*break*/, 28];
                    case 22:
                        e_2_1 = _g.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 28];
                    case 23:
                        _g.trys.push([23, , 26, 27]);
                        if (!(_f && !_f.done && (_b = _e.return))) return [3 /*break*/, 25];
                        return [4 /*yield*/, _b.call(_e)];
                    case 24:
                        _g.sent();
                        _g.label = 25;
                    case 25: return [3 /*break*/, 27];
                    case 26:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 27: return [7 /*endfinally*/];
                    case 28: return [2 /*return*/];
                }
            });
        });
    });
    it("can list secrets", function () {
        var e_5, _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, _i, secretNames_1, name_1, found, _b, _c, secret, e_5_1, _d, secretNames_2, name_2;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "0", secretName + "1"];
                        _i = 0, secretNames_1 = secretNames;
                        _e.label = 1;
                    case 1:
                        if (!(_i < secretNames_1.length)) return [3 /*break*/, 4];
                        name_1 = secretNames_1[_i];
                        return [4 /*yield*/, client.setSecret(name_1, "RSA")];
                    case 2:
                        _e.sent();
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        found = 0;
                        _e.label = 5;
                    case 5:
                        _e.trys.push([5, 10, 11, 16]);
                        _b = tslib_1.__asyncValues(client.listSecrets());
                        _e.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _e.sent(), !_c.done)) return [3 /*break*/, 9];
                        secret = _c.value;
                        // The vault might contain more secrets than the ones we inserted.
                        if (!secretNames.includes(secret.name))
                            return [3 /*break*/, 8];
                        found += 1;
                        _e.label = 8;
                    case 8: return [3 /*break*/, 6];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_5_1 = _e.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _e.trys.push([11, , 14, 15]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, _a.call(_b)];
                    case 12:
                        _e.sent();
                        _e.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_5) throw e_5.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16:
                        assert.equal(found, 2, "Unexpected number of secrets found by getSecrets.");
                        _d = 0, secretNames_2 = secretNames;
                        _e.label = 17;
                    case 17:
                        if (!(_d < secretNames_2.length)) return [3 /*break*/, 20];
                        name_2 = secretNames_2[_d];
                        return [4 /*yield*/, testClient.flushSecret(name_2)];
                    case 18:
                        _e.sent();
                        _e.label = 19;
                    case 19:
                        _d++;
                        return [3 /*break*/, 17];
                    case 20: return [2 /*return*/];
                }
            });
        });
    });
    it("can list deleted secrets", function () {
        var e_6, _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, _i, secretNames_3, name_3, _b, secretNames_4, name_4, _loop_1, _c, secretNames_5, name_5, found, _d, _e, secret, e_6_1, _f, secretNames_6, name_6;
            var _this = this;
            return tslib_1.__generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "0", secretName + "1"];
                        _i = 0, secretNames_3 = secretNames;
                        _g.label = 1;
                    case 1:
                        if (!(_i < secretNames_3.length)) return [3 /*break*/, 4];
                        name_3 = secretNames_3[_i];
                        return [4 /*yield*/, client.setSecret(name_3, "RSA")];
                    case 2:
                        _g.sent();
                        _g.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        _b = 0, secretNames_4 = secretNames;
                        _g.label = 5;
                    case 5:
                        if (!(_b < secretNames_4.length)) return [3 /*break*/, 8];
                        name_4 = secretNames_4[_b];
                        return [4 /*yield*/, client.deleteSecret(name_4)];
                    case 6:
                        _g.sent();
                        _g.label = 7;
                    case 7:
                        _b++;
                        return [3 /*break*/, 5];
                    case 8:
                        _loop_1 = function (name_5) {
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, retry(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                                            return [2 /*return*/, client.getDeletedSecret(name_5)];
                                        }); }); })];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                        _c = 0, secretNames_5 = secretNames;
                        _g.label = 9;
                    case 9:
                        if (!(_c < secretNames_5.length)) return [3 /*break*/, 12];
                        name_5 = secretNames_5[_c];
                        return [5 /*yield**/, _loop_1(name_5)];
                    case 10:
                        _g.sent();
                        _g.label = 11;
                    case 11:
                        _c++;
                        return [3 /*break*/, 9];
                    case 12:
                        found = 0;
                        _g.label = 13;
                    case 13:
                        _g.trys.push([13, 18, 19, 24]);
                        _d = tslib_1.__asyncValues(client.listDeletedSecrets());
                        _g.label = 14;
                    case 14: return [4 /*yield*/, _d.next()];
                    case 15:
                        if (!(_e = _g.sent(), !_e.done)) return [3 /*break*/, 17];
                        secret = _e.value;
                        // The vault might contain more secrets than the ones we inserted.
                        if (!secretNames.includes(secret.name))
                            return [3 /*break*/, 16];
                        found += 1;
                        _g.label = 16;
                    case 16: return [3 /*break*/, 14];
                    case 17: return [3 /*break*/, 24];
                    case 18:
                        e_6_1 = _g.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 24];
                    case 19:
                        _g.trys.push([19, , 22, 23]);
                        if (!(_e && !_e.done && (_a = _d.return))) return [3 /*break*/, 21];
                        return [4 /*yield*/, _a.call(_d)];
                    case 20:
                        _g.sent();
                        _g.label = 21;
                    case 21: return [3 /*break*/, 23];
                    case 22:
                        if (e_6) throw e_6.error;
                        return [7 /*endfinally*/];
                    case 23: return [7 /*endfinally*/];
                    case 24:
                        assert.equal(found, 2, "Unexpected number of secrets found by getDeletedSecrets.");
                        _f = 0, secretNames_6 = secretNames;
                        _g.label = 25;
                    case 25:
                        if (!(_f < secretNames_6.length)) return [3 /*break*/, 28];
                        name_6 = secretNames_6[_f];
                        return [4 /*yield*/, testClient.purgeSecret(name_6)];
                    case 26:
                        _g.sent();
                        _g.label = 27;
                    case 27:
                        _f++;
                        return [3 /*break*/, 25];
                    case 28: return [2 /*return*/];
                }
            });
        });
    });
    it("can retrieve all versions of a secret", function () {
        var e_7, _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, secretValues, versions, _i, secretValues_1, v, response, results, _b, _c, item, version, secret, e_7_1, comp;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretValues = [secretValue + "0", secretValue + "1", secretValue + "2"];
                        versions = [];
                        _i = 0, secretValues_1 = secretValues;
                        _d.label = 1;
                    case 1:
                        if (!(_i < secretValues_1.length)) return [3 /*break*/, 4];
                        v = secretValues_1[_i];
                        return [4 /*yield*/, client.setSecret(secretName, v)];
                    case 2:
                        response = _d.sent();
                        versions.push({ version: response.version, value: response.value });
                        _d.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        results = [];
                        _d.label = 5;
                    case 5:
                        _d.trys.push([5, 11, 12, 17]);
                        _b = tslib_1.__asyncValues(client.listSecretVersions(secretName));
                        _d.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 10];
                        item = _c.value;
                        version = item.version;
                        return [4 /*yield*/, client.getSecret(secretName, { version: version })];
                    case 8:
                        secret = _d.sent();
                        results.push({ version: item.version, value: secret.value });
                        _d.label = 9;
                    case 9: return [3 /*break*/, 6];
                    case 10: return [3 /*break*/, 17];
                    case 11:
                        e_7_1 = _d.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 17];
                    case 12:
                        _d.trys.push([12, , 15, 16]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 14];
                        return [4 /*yield*/, _a.call(_b)];
                    case 13:
                        _d.sent();
                        _d.label = 14;
                    case 14: return [3 /*break*/, 16];
                    case 15:
                        if (e_7) throw e_7.error;
                        return [7 /*endfinally*/];
                    case 16: return [7 /*endfinally*/];
                    case 17:
                        comp = function (a, b) {
                            return (a.version + a.value).localeCompare(b.version + b.value);
                        };
                        results.sort(comp);
                        versions.sort(comp);
                        expect(results).to.deep.equal(versions);
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 18:
                        _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can list secret versions (non existing)", function () {
        var e_8, _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, totalVersions, _b, _c, version, e_8_1;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        totalVersions = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 12]);
                        _b = tslib_1.__asyncValues(client.listSecretVersions(secretName));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 5];
                        version = _c.value;
                        assert.equal(version.name, secretName, "Unexpected key name in result from listKeyVersions().");
                        totalVersions += 1;
                        _d.label = 4;
                    case 4: return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_8_1 = _d.sent();
                        e_8 = { error: e_8_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _d.trys.push([7, , 10, 11]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _a.call(_b)];
                    case 8:
                        _d.sent();
                        _d.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_8) throw e_8.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12:
                        assert.equal(totalVersions, 0, "Unexpected total versions for secret " + secretName);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can list secrets by page", function () {
        var e_9, _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, _i, secretNames_7, name_7, found, _b, _c, page, _d, page_1, secret, e_9_1, _e, secretNames_8, name_8;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "0", secretName + "1"];
                        _i = 0, secretNames_7 = secretNames;
                        _f.label = 1;
                    case 1:
                        if (!(_i < secretNames_7.length)) return [3 /*break*/, 4];
                        name_7 = secretNames_7[_i];
                        return [4 /*yield*/, client.setSecret(name_7, "RSA")];
                    case 2:
                        _f.sent();
                        _f.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        found = 0;
                        _f.label = 5;
                    case 5:
                        _f.trys.push([5, 10, 11, 16]);
                        _b = tslib_1.__asyncValues(client.listSecrets().byPage());
                        _f.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 9];
                        page = _c.value;
                        for (_d = 0, page_1 = page; _d < page_1.length; _d++) {
                            secret = page_1[_d];
                            // The vault might contain more secrets than the ones we inserted.
                            if (!secretNames.includes(secret.name))
                                continue;
                            found += 1;
                        }
                        _f.label = 8;
                    case 8: return [3 /*break*/, 6];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_9_1 = _f.sent();
                        e_9 = { error: e_9_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _f.trys.push([11, , 14, 15]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, _a.call(_b)];
                    case 12:
                        _f.sent();
                        _f.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_9) throw e_9.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16:
                        assert.equal(found, 2, "Unexpected number of secrets found by getSecrets.");
                        _e = 0, secretNames_8 = secretNames;
                        _f.label = 17;
                    case 17:
                        if (!(_e < secretNames_8.length)) return [3 /*break*/, 20];
                        name_8 = secretNames_8[_e];
                        return [4 /*yield*/, testClient.flushSecret(name_8)];
                    case 18:
                        _f.sent();
                        _f.label = 19;
                    case 19:
                        _e++;
                        return [3 /*break*/, 17];
                    case 20: return [2 /*return*/];
                }
            });
        });
    });
    it("can list deleted secrets by page", function () {
        var e_10, _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, _i, secretNames_9, name_9, _b, secretNames_10, name_10, _loop_2, _c, secretNames_11, name_11, found, _d, _e, page, _f, page_2, secret, e_10_1, _g, secretNames_12, name_12;
            var _this = this;
            return tslib_1.__generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "0", secretName + "1"];
                        _i = 0, secretNames_9 = secretNames;
                        _h.label = 1;
                    case 1:
                        if (!(_i < secretNames_9.length)) return [3 /*break*/, 4];
                        name_9 = secretNames_9[_i];
                        return [4 /*yield*/, client.setSecret(name_9, "RSA")];
                    case 2:
                        _h.sent();
                        _h.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        _b = 0, secretNames_10 = secretNames;
                        _h.label = 5;
                    case 5:
                        if (!(_b < secretNames_10.length)) return [3 /*break*/, 8];
                        name_10 = secretNames_10[_b];
                        return [4 /*yield*/, client.deleteSecret(name_10)];
                    case 6:
                        _h.sent();
                        _h.label = 7;
                    case 7:
                        _b++;
                        return [3 /*break*/, 5];
                    case 8:
                        _loop_2 = function (name_11) {
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, retry(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                                            return [2 /*return*/, client.getDeletedSecret(name_11)];
                                        }); }); })];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                        _c = 0, secretNames_11 = secretNames;
                        _h.label = 9;
                    case 9:
                        if (!(_c < secretNames_11.length)) return [3 /*break*/, 12];
                        name_11 = secretNames_11[_c];
                        return [5 /*yield**/, _loop_2(name_11)];
                    case 10:
                        _h.sent();
                        _h.label = 11;
                    case 11:
                        _c++;
                        return [3 /*break*/, 9];
                    case 12:
                        found = 0;
                        _h.label = 13;
                    case 13:
                        _h.trys.push([13, 18, 19, 24]);
                        _d = tslib_1.__asyncValues(client.listDeletedSecrets().byPage());
                        _h.label = 14;
                    case 14: return [4 /*yield*/, _d.next()];
                    case 15:
                        if (!(_e = _h.sent(), !_e.done)) return [3 /*break*/, 17];
                        page = _e.value;
                        for (_f = 0, page_2 = page; _f < page_2.length; _f++) {
                            secret = page_2[_f];
                            // The vault might contain more secrets than the ones we inserted.
                            if (!secretNames.includes(secret.name))
                                continue;
                            found += 1;
                        }
                        _h.label = 16;
                    case 16: return [3 /*break*/, 14];
                    case 17: return [3 /*break*/, 24];
                    case 18:
                        e_10_1 = _h.sent();
                        e_10 = { error: e_10_1 };
                        return [3 /*break*/, 24];
                    case 19:
                        _h.trys.push([19, , 22, 23]);
                        if (!(_e && !_e.done && (_a = _d.return))) return [3 /*break*/, 21];
                        return [4 /*yield*/, _a.call(_d)];
                    case 20:
                        _h.sent();
                        _h.label = 21;
                    case 21: return [3 /*break*/, 23];
                    case 22:
                        if (e_10) throw e_10.error;
                        return [7 /*endfinally*/];
                    case 23: return [7 /*endfinally*/];
                    case 24:
                        assert.equal(found, 2, "Unexpected number of secrets found by getDeletedSecrets.");
                        _g = 0, secretNames_12 = secretNames;
                        _h.label = 25;
                    case 25:
                        if (!(_g < secretNames_12.length)) return [3 /*break*/, 28];
                        name_12 = secretNames_12[_g];
                        return [4 /*yield*/, testClient.purgeSecret(name_12)];
                    case 26:
                        _h.sent();
                        _h.label = 27;
                    case 27:
                        _g++;
                        return [3 /*break*/, 25];
                    case 28: return [2 /*return*/];
                }
            });
        });
    });
    it("can retrieve all versions of a secret by page", function () {
        var e_11, _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, secretValues, versions, _i, secretValues_2, v, response, results, _b, _c, page, _d, page_3, item, version, secret, e_11_1, comp;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretValues = [secretValue + "0", secretValue + "1", secretValue + "2"];
                        versions = [];
                        _i = 0, secretValues_2 = secretValues;
                        _e.label = 1;
                    case 1:
                        if (!(_i < secretValues_2.length)) return [3 /*break*/, 4];
                        v = secretValues_2[_i];
                        return [4 /*yield*/, client.setSecret(secretName, v)];
                    case 2:
                        response = _e.sent();
                        versions.push({ version: response.version, value: response.value });
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        results = [];
                        _e.label = 5;
                    case 5:
                        _e.trys.push([5, 13, 14, 19]);
                        _b = tslib_1.__asyncValues(client.listSecretVersions(secretName).byPage());
                        _e.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _e.sent(), !_c.done)) return [3 /*break*/, 12];
                        page = _c.value;
                        _d = 0, page_3 = page;
                        _e.label = 8;
                    case 8:
                        if (!(_d < page_3.length)) return [3 /*break*/, 11];
                        item = page_3[_d];
                        version = item.version;
                        return [4 /*yield*/, client.getSecret(secretName, { version: version })];
                    case 9:
                        secret = _e.sent();
                        results.push({ version: version, value: secret.value });
                        _e.label = 10;
                    case 10:
                        _d++;
                        return [3 /*break*/, 8];
                    case 11: return [3 /*break*/, 6];
                    case 12: return [3 /*break*/, 19];
                    case 13:
                        e_11_1 = _e.sent();
                        e_11 = { error: e_11_1 };
                        return [3 /*break*/, 19];
                    case 14:
                        _e.trys.push([14, , 17, 18]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 16];
                        return [4 /*yield*/, _a.call(_b)];
                    case 15:
                        _e.sent();
                        _e.label = 16;
                    case 16: return [3 /*break*/, 18];
                    case 17:
                        if (e_11) throw e_11.error;
                        return [7 /*endfinally*/];
                    case 18: return [7 /*endfinally*/];
                    case 19:
                        comp = function (a, b) {
                            return (a.version + a.value).localeCompare(b.version + b.value);
                        };
                        results.sort(comp);
                        versions.sort(comp);
                        expect(results).to.deep.equal(versions);
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 20:
                        _e.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can list secret versions by page (non existing)", function () {
        var e_12, _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secretName, totalVersions, _b, _c, page, _i, page_4, version, e_12_1;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        totalVersions = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 12]);
                        _b = tslib_1.__asyncValues(client.listSecretVersions(secretName).byPage());
                        _d.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 5];
                        page = _c.value;
                        for (_i = 0, page_4 = page; _i < page_4.length; _i++) {
                            version = page_4[_i];
                            assert.equal(version.name, secretName, "Unexpected key name in result from listKeyVersions().");
                            totalVersions += 1;
                        }
                        _d.label = 4;
                    case 4: return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_12_1 = _d.sent();
                        e_12 = { error: e_12_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _d.trys.push([7, , 10, 11]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _a.call(_b)];
                    case 8:
                        _d.sent();
                        _d.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_12) throw e_12.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12:
                        assert.equal(totalVersions, 0, "Unexpected total versions for secret " + secretName);
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=list.test.js.map