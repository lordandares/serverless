// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint @typescript-eslint/member-ordering: 0 */
import * as tslib_1 from "tslib";
import { getDefaultUserAgentValue, isTokenCredential, deserializationPolicy, signingPolicy, exponentialRetryPolicy, redirectPolicy, systemErrorRetryPolicy, generateClientRequestIdPolicy, proxyPolicy, throttlingRetryPolicy, getDefaultProxySettings, isNode, userAgentPolicy, tracingPolicy, TracerProxy, SupportedPlugins } from "@azure/core-http";
import "@azure/core-paging";
import { KeyVaultClient } from "./core/keyVaultClient";
import { RetryConstants, SDK_VERSION } from "./core/utils/constants";
import { challengeBasedAuthenticationPolicy } from "./core/challengeBasedAuthenticationPolicy";
import { parseKeyvaultIdentifier as parseKeyvaultEntityIdentifier } from "./core/utils";
import { isNewPipelineOptions } from "./core/keyVaultBase";
export { SupportedPlugins, TracerProxy };
/**
 * The client to interact with the KeyVault secrets functionality
 */
var SecretsClient = /** @class */ (function () {
    /**
     * Creates an instance of SecretsClient.
     *
     * Example usage:
     * ```ts
     * import { SecretsClient } from "@azure/keyvault-secrets";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let url = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new SecretsClient(url, credentials);
     * ```
     * @param {string} url the base url to the key vault.
     * @param {TokenCredential} The credential to use for API requests.
     * @param {(Pipeline | NewPipelineOptions)} [pipelineOrOptions={}] Optional. A Pipeline, or options to create a default Pipeline instance.
     *                                                                 Omitting this parameter to create the default Pipeline instance.
     * @memberof SecretsClient
     */
    function SecretsClient(url, credential, pipelineOrOptions) {
        if (pipelineOrOptions === void 0) { pipelineOrOptions = {}; }
        this.vaultBaseUrl = url;
        this.credential = credential;
        if (isNewPipelineOptions(pipelineOrOptions)) {
            this.pipeline = SecretsClient.getDefaultPipeline(credential, pipelineOrOptions);
        }
        else {
            this.pipeline = pipelineOrOptions;
        }
        this.client = new KeyVaultClient(credential, this.pipeline);
    }
    /**
     * A static method used to create a new Pipeline object with the provided Credential.
     * @static
     * @param {TokenCredential} The credential to use for API requests.
     * @param {NewPipelineOptions} [pipelineOptions] Optional. Options.
     * @returns {Pipeline} A new Pipeline object.
     * @memberof SecretsClient
     */
    SecretsClient.getDefaultPipeline = function (credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        // Order is important. Closer to the API at the top & closer to the network at the bottom.
        // The credential's policy factory must appear close to the wire so it can sign any
        // changes made by other factories (like UniqueRequestIDPolicyFactory)
        var retryOptions = pipelineOptions.retryOptions || {};
        var userAgentString = SecretsClient.getUserAgentString(pipelineOptions.telemetry);
        var requestPolicyFactories = [];
        if (isNode) {
            requestPolicyFactories.push(proxyPolicy(getDefaultProxySettings((pipelineOptions.proxyOptions || {}).proxySettings)));
        }
        requestPolicyFactories = requestPolicyFactories.concat([
            tracingPolicy(),
            userAgentPolicy({ value: userAgentString }),
            generateClientRequestIdPolicy(),
            deserializationPolicy(),
            throttlingRetryPolicy(),
            systemErrorRetryPolicy(),
            exponentialRetryPolicy(retryOptions.retryCount, retryOptions.retryIntervalInMS, RetryConstants.MIN_RETRY_INTERVAL_MS, // Minimum retry interval to prevent frequent retries
            retryOptions.maxRetryDelayInMs),
            redirectPolicy(),
            isTokenCredential(credential)
                ? challengeBasedAuthenticationPolicy(credential)
                : signingPolicy(credential)
        ]);
        return {
            httpClient: pipelineOptions.HTTPClient,
            httpPipelineLogger: pipelineOptions.logger,
            requestPolicyFactories: requestPolicyFactories
        };
    };
    SecretsClient.getUserAgentString = function (telemetry) {
        var userAgentInfo = [];
        if (telemetry) {
            if (userAgentInfo.indexOf(telemetry.value) === -1) {
                userAgentInfo.push(telemetry.value);
            }
        }
        var libInfo = "azsdk-js-keyvault-secrets/" + SDK_VERSION;
        if (userAgentInfo.indexOf(libInfo) === -1) {
            userAgentInfo.push(libInfo);
        }
        var defaultUserAgentInfo = getDefaultUserAgentValue();
        if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {
            userAgentInfo.push(defaultUserAgentInfo);
        }
        return userAgentInfo.join(" ");
    };
    // TODO: do we want Aborter as well?
    /**
     * The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
     * Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
     * permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     * ```
     * @summary Adds a secret in a specified key vault.
     * @param secretName The name of the secret.
     * @param value The value of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.setSecret = function (secretName, value, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var unflattenedAttributes, unflattenedOptions, span_1, response, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 2];
                        unflattenedAttributes = {
                            enabled: options.enabled,
                            notBefore: options.notBefore,
                            expires: options.expires
                        };
                        unflattenedOptions = tslib_1.__assign({}, options, (options.requestOptions ? options.requestOptions : {}), { secretAttributes: unflattenedAttributes });
                        delete unflattenedOptions.enabled;
                        delete unflattenedOptions.notBefore;
                        delete unflattenedOptions.expires;
                        delete unflattenedOptions.requestOptions;
                        span_1 = this.createSpan("setSecret", unflattenedOptions);
                        span_1.start();
                        return [4 /*yield*/, this.client.setSecret(this.vaultBaseUrl, secretName, value, unflattenedOptions).catch(function (err) {
                                span_1.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span_1.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    case 2: return [4 /*yield*/, this.client.setSecret(this.vaultBaseUrl, secretName, value, options)];
                    case 3:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
     * to an individual version of a secret. This operation requires the secrets/delete permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * ```
     * @summary Deletes a secret from a specified key vault.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<DeletedSecret>
     */
    SecretsClient.prototype.deleteSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("deleteSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.deleteSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getDeletedSecretFromDeletedSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
     * are not specified in the request are left unchanged. The value of a secret itself cannot be
     * changed. This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let secretName = "MySecretName";
     * let client = new SecretsClient(url, credentials);
     * let secret = await client.getSecret(secretName);
     * await client.updateSecret(secretName, secret.version, { enabled: false });
     * ```
     * @summary Updates the attributes associated with a specified secret in a given key vault.
     * @param secretName The name of the secret.
     * @param secretVersion The version of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.updateSecretAttributes = function (secretName, secretVersion, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var unflattenedAttributes, unflattenedOptions, span_2, response, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) return [3 /*break*/, 2];
                        unflattenedAttributes = {
                            enabled: options.enabled,
                            notBefore: options.notBefore,
                            expires: options.expires
                        };
                        unflattenedOptions = tslib_1.__assign({}, options, (options.requestOptions ? options.requestOptions : {}), { secretAttributes: unflattenedAttributes });
                        delete unflattenedOptions.enabled;
                        delete unflattenedOptions.notBefore;
                        delete unflattenedOptions.expires;
                        delete unflattenedOptions.requestOptions;
                        span_2 = this.createSpan("updateSecretAttributes", unflattenedOptions);
                        span_2.start();
                        return [4 /*yield*/, this.client.updateSecret(this.vaultBaseUrl, secretName, secretVersion, unflattenedOptions)
                                .catch(function (err) {
                                span_2.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span_2.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    case 2: return [4 /*yield*/, this.client.updateSecret(this.vaultBaseUrl, secretName, secretVersion, options)];
                    case 3:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires
     * the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let secret = await client.getSecret("MySecretName");
     * ```
     * @summary Get a specified secret from a given key vault.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.getSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("getSecret", options && options.requestOptions);
                        span.start();
                        return [4 /*yield*/, this.client.getSecret(this.vaultBaseUrl, secretName, options && options.version ? options.version : "", options ? options.requestOptions : undefined)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The Get Deleted Secret operation returns the specified deleted secret along with its attributes.
     * This operation requires the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.getDeletedSecret("MyDeletedSecret");
     * ```
     * @summary Gets the specified deleted secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<DeletedSecret>
     */
    SecretsClient.prototype.getDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("getDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.getDeletedSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The purge deleted secret operation removes the secret permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the secrets/purge permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * await client.purgeDeletedSecret("MySecretName");
     * ```
     * @summary Permanently deletes the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<void>
     */
    SecretsClient.prototype.purgeDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("purgeDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.purgeDeletedSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        _a.sent();
                        span.end();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Recovers the deleted secret in the specified vault. This operation can only be performed on a
     * soft-delete enabled vault. This operation requires the secrets/recover permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * await client.deleteSecret("MySecretName");
     * await client.recoverDeletedSecret("MySecretName");
     * ```
     * @summary Recovers the deleted secret to the latest version.
     * @param secretName The name of the deleted secret.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.recoverDeletedSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("recoverDeletedSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.recoverDeletedSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the
     * secret will be downloaded. This operation requires the secrets/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let backupResult = await client.backupSecret("MySecretName");
     * ```
     * @summary Backs up the specified secret.
     * @param secretName The name of the secret.
     * @param [options] The optional parameters
     * @returns Promise<Uint8Array | undefined>
     */
    SecretsClient.prototype.backupSecret = function (secretName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("backupSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.backupSecret(this.vaultBaseUrl, secretName, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, response.value];
                }
            });
        });
    };
    /**
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the
     * secrets/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * let mySecretBundle = await client.backupSecret("MySecretName");
     * // ...
     * await client.restoreSecret(mySecretBundle);
     * ```
     * @summary Restores a backed up secret to a vault.
     * @param secretBundleBackup The backup blob associated with a secret bundle.
     * @param [options] The optional parameters
     * @returns Promise<Secret>
     */
    SecretsClient.prototype.restoreSecret = function (secretBundleBackup, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var span, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        span = this.createSpan("restoreSecret", options);
                        span.start();
                        return [4 /*yield*/, this.client.restoreSecret(this.vaultBaseUrl, secretBundleBackup, options)
                                .catch(function (err) {
                                span.end();
                                throw err;
                            })];
                    case 1:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretVersionsPage = function (secretName, continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listSecretVersionsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecretVersions(this.vaultBaseUrl, secretName, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecretVersionsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretVersionsAll = function (secretName, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listSecretVersionsAll_1() {
            var f, _a, _b, page, _i, page_1, item, e_1_1;
            var e_1, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listSecretVersionsPage(secretName, f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_1 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_1.length)) return [3 /*break*/, 8];
                        item = page_1[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listSecretVersions("MySecretName")) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret version: ", secret);
     * }
     * ```
     * @param secretName Name of the secret to fetch versions for
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listSecretVersions = function (secretName, options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listSecretVersions", options && options.requestOptions);
        span.start();
        var iter = this.listSecretVersionsAll(secretName, options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSecretVersionsPage(secretName, settings, options);
            },
            _a;
    };
    SecretsClient.prototype.listSecretsPage = function (continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecrets(this.vaultBaseUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(this.client.getSecretsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listSecretsAll = function (options) {
        return tslib_1.__asyncGenerator(this, arguments, function listSecretsAll_1() {
            var f, _a, _b, page, _i, page_2, item, e_2_1;
            var e_2, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_2 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_2.length)) return [3 /*break*/, 8];
                        item = page_2[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listSecrets()) {
     *   const secret = await client.getSecret(secretAttr.name);
     *   console.log("secret: ", secret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listSecrets = function (options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listSecrets", options && options.requestOptions);
        span.start();
        var iter = this.listSecretsAll(options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSecretsPage(settings, options);
            },
            _a;
    };
    SecretsClient.prototype.listDeletedSecretsPage = function (continuationState, options) {
        return tslib_1.__asyncGenerator(this, arguments, function listDeletedSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib_1.__assign({ maxresults: continuationState.maxPageSize }, (options && options.requestOptions ? options.requestOptions : {}));
                        return [4 /*yield*/, tslib_1.__await(this.client.getDeletedSecrets(this.vaultBaseUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib_1.__await(this.client.getDeletedSecretsNext(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        return [4 /*yield*/, tslib_1.__await(currentSetResponse.map(this.getSecretFromSecretBundle))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SecretsClient.prototype.listDeletedSecretsAll = function (options) {
        return tslib_1.__asyncGenerator(this, arguments, function listDeletedSecretsAll_1() {
            var f, _a, _b, page, _i, page_3, item, e_3_1;
            var e_3, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib_1.__asyncValues(this.listDeletedSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib_1.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_3 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_3.length)) return [3 /*break*/, 8];
                        item = page_3[_i];
                        return [4 /*yield*/, tslib_1.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib_1.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretsClient(url, credentials);
     * for await (const secretAttr of client.listDeletedSecrets()) {
     *   const deletedSecret = await client.getSecret(secretAttr.name);
     *   console.log("deleted secret: ", deletedSecret);
     * }
     * ```
     * @summary List all secrets in the vault
     * @param [options] The optional parameters
     * @returns PagedAsyncIterableIterator<SecretAttributes, SecretAttributes[]>
     */
    SecretsClient.prototype.listDeletedSecrets = function (options) {
        var _a;
        var _this = this;
        var span = this.createSpan("listDeletedSecrets", options && options.requestOptions);
        span.start();
        var iter = this.listDeletedSecretsAll(options);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listDeletedSecretsPage(settings, options);
            },
            _a;
    };
    SecretsClient.prototype.getSecretFromSecretBundle = function (secretBundle) {
        var parsedId = parseKeyvaultEntityIdentifier("secrets", secretBundle.id);
        var resultObject;
        if (secretBundle.attributes) {
            resultObject = tslib_1.__assign({}, secretBundle, parsedId, secretBundle.attributes);
            delete resultObject.attributes;
        }
        else {
            resultObject = tslib_1.__assign({}, secretBundle, parsedId);
        }
        return resultObject;
    };
    SecretsClient.prototype.getDeletedSecretFromDeletedSecretBundle = function (deletedSecretBundle) {
        var parsedId = parseKeyvaultEntityIdentifier("secrets", deletedSecretBundle.id);
        var resultObject;
        if (deletedSecretBundle.attributes) {
            resultObject = tslib_1.__assign({}, deletedSecretBundle, parsedId, deletedSecretBundle.attributes);
            delete resultObject.attributes;
        }
        else {
            resultObject = tslib_1.__assign({}, deletedSecretBundle, parsedId);
        }
        return resultObject;
    };
    /**
     * Creates a span using the tracer that was set by the user
     * @param methodName The name of the method for which the span is being created.
     * @param requestOptions The options for the underlying http request. This will be
     * updated to use the newly created span as the "parent" so that any new spans created
     * after this point gets the right parent.
     */
    SecretsClient.prototype.createSpan = function (methodName, requestOptions) {
        var tracer = TracerProxy.getTracer();
        var options = requestOptions || {};
        var span = tracer.startSpan(methodName, options.spanOptions);
        if (tracer.pluginType !== SupportedPlugins.NOOP &&
            (options.spanOptions && options.spanOptions.parent)) {
            options.spanOptions = tslib_1.__assign({}, options.spanOptions, { parent: span });
        }
        return span;
    };
    return SecretsClient;
}());
export { SecretsClient };
//# sourceMappingURL=index.js.map