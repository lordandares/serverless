
/**
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Defines a attributes interface. */
export declare interface Attributes {
    [attributeKey: string]: unknown;
}

/**
 * An enumeration of canonical status codes.
 *
 * TODO (revision): https://github.com/open-telemetry/opentelemetry-specification/issues/59
 */
export declare enum CanonicalCode {
    /**
     * Not an error; returned on success
     */
    OK = 0,
    /**
     * The operation was cancelled (typically by the caller).
     */
    CANCELLED = 1,
    /**
     * Unknown error.  An example of where this error may be returned is
     * if a status value received from another address space belongs to
     * an error-space that is not known in this address space.  Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     */
    UNKNOWN = 2,
    /**
     * Client specified an invalid argument.  Note that this differs
     * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     */
    INVALID_ARGUMENT = 3,
    /**
     * Deadline expired before operation could complete.  For operations
     * that change the state of the system, this error may be returned
     * even if the operation has completed successfully.  For example, a
     * successful response from a server could have been delayed long
     * enough for the deadline to expire.
     */
    DEADLINE_EXCEEDED = 4,
    /**
     * Some requested entity (e.g., file or directory) was not found.
     */
    NOT_FOUND = 5,
    /**
     * Some entity that we attempted to create (e.g., file or directory)
     * already exists.
     */
    ALREADY_EXISTS = 6,
    /**
     * The caller does not have permission to execute the specified
     * operation.  PERMISSION_DENIED must not be used for rejections
     * caused by exhausting some resource (use RESOURCE_EXHAUSTED
     * instead for those errors).  PERMISSION_DENIED must not be
     * used if the caller can not be identified (use UNAUTHENTICATED
     * instead for those errors).
     */
    PERMISSION_DENIED = 7,
    /**
     * Some resource has been exhausted, perhaps a per-user quota, or
     * perhaps the entire file system is out of space.
     */
    RESOURCE_EXHAUSTED = 8,
    /**
     * Operation was rejected because the system is not in a state
     * required for the operation's execution.  For example, directory
     * to be deleted may be non-empty, an rmdir operation is applied to
     * a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
     *
     *  - Use UNAVAILABLE if the client can retry just the failing call.
     *  - Use ABORTED if the client should retry at a higher-level
     *    (e.g., restarting a read-modify-write sequence).
     *  - Use FAILED_PRECONDITION if the client should not retry until
     *    the system state has been explicitly fixed.  E.g., if an "rmdir"
     *    fails because the directory is non-empty, FAILED_PRECONDITION
     *    should be returned since the client should not retry unless
     *    they have first fixed up the directory by deleting files from it.
     *  - Use FAILED_PRECONDITION if the client performs conditional
     *    REST Get/Update/Delete on a resource and the resource on the
     *    server does not match the condition. E.g., conflicting
     *    read-modify-write on the same resource.
     */
    FAILED_PRECONDITION = 9,
    /**
     * The operation was aborted, typically due to a concurrency issue
     * like sequencer check failures, transaction aborts, etc.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */
    ABORTED = 10,
    /**
     * Operation was attempted past the valid range.  E.g., seeking or
     * reading past end of file.
     *
     * Unlike INVALID_ARGUMENT, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate INVALID_ARGUMENT if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OUT_OF_RANGE if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FAILED_PRECONDITION and
     * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OUT_OF_RANGE error to detect when
     * they are done.
     */
    OUT_OF_RANGE = 11,
    /**
     * Operation is not implemented or not supported/enabled in this service.
     */
    UNIMPLEMENTED = 12,
    /**
     * Internal errors.  Means some invariants expected by underlying
     * system has been broken.  If you see one of these errors,
     * something is very broken.
     */
    INTERNAL = 13,
    /**
     * The service is currently unavailable.  This is a most likely a
     * transient condition and may be corrected by retrying with
     * a backoff.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */
    UNAVAILABLE = 14,
    /**
     * Unrecoverable data loss or corruption.
     */
    DATA_LOSS = 15,
    /**
     * The request does not have valid authentication credentials for the
     * operation.
     */
    UNAUTHENTICATED = 16
}

/** A text annotation with a set of attributes. */
export declare interface Event {
    /** The name of the event. */
    name: string;
    /** The attributes of the event. */
    attributes?: Attributes;
}

/**
 * A pointer from the current {@link Span} to another span in the same trace or
 * in a different trace.
 */
export declare interface Link {
    /** The {@link SpanContext} of a linked span. */
    spanContext: SpanContext;
    /** A set of {@link Attributes} on the link. */
    attributes?: Attributes;
}

export declare class NoOpSpanPlugin implements Span {
    private _span;
    constructor(span: any);
    context(): SpanContext;
    end(endTime?: number): void;
    start(startTime?: number): void;
    setAttribute(key: string, value: unknown): this;
    setAttributes(attributes: Attributes): this;
    addEvent(name: string, attributes?: Attributes): this;
    addLink(spanContext: SpanContext, attributes?: Attributes): this;
    setStatus(status: Status): this;
    updateName(name: string): this;
    isRecordingEvents(): boolean;
}

export declare class NoOpTracePlugin implements Tracer {
    private _tracer;
    constructor(tracer: any);
    readonly pluginType = SupportedPlugins.NOOP;
    startSpan(name: string, options?: SpanOptions): Span;
    getCurrentSpan(): Span;
    withSpan<T extends (...args: unknown[]) => unknown>(span: Span, fn: T): ReturnType<T>;
    recordSpanData(span: Span): void;
    getBinaryFormat(): unknown;
    getHttpTextFormat(): unknown;
}

export declare class OpenCensusSpanPlugin implements Span {
    private _span;
    getSpan(): any;
    constructor(span: any);
    end(endTime?: number): void;
    start(startTime?: number): void;
    context(): SpanContext;
    setAttribute(key: string, value: unknown): this;
    setAttributes(attributes: Attributes): this;
    addEvent(name: string, attributes?: Attributes): this;
    addLink(spanContext: SpanContext, attributes?: Attributes): this;
    setStatus(status: Status): this;
    updateName(name: string): this;
    isRecordingEvents(): boolean;
}

export declare class OpenCensusTracePlugin implements Tracer {
    private _tracer;
    constructor(tracer: any);
    readonly pluginType = SupportedPlugins.OPENCENSUS;
    startSpan(name: string, options?: SpanOptions): Span;
    getCurrentSpan(): Span;
    withSpan<T extends (...args: unknown[]) => unknown>(span: Span, fn: T): ReturnType<T>;
    recordSpanData(span: Span): void;
    getBinaryFormat(): unknown;
    getHttpTextFormat(): unknown;
}

/**
 * This interface represent a sampler. Sampling is a mechanism to control the
 * noise and overhead introduced by OpenTelemetry by reducing the number of
 * samples of traces collected and sent to the backend.
 */
export declare interface Sampler {
    /**
     * Checks whether span needs to be created and tracked.
     *
     * TODO: Consider to add required arguments https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/sampling-api.md#shouldsample
     * @param [parentContext] Parent span context. Typically taken from the wire.
     *     Can be null.
     * @returns whether span should be sampled or not.
     */
    shouldSample(parentContext?: SpanContext): boolean;
    /** Returns the sampler name or short description with the configuration. */
    toString(): string;
}

/**
 * An interface that represents a span. A span represents a single operation
 * within a trace. Examples of span might include remote procedure calls or a
 * in-process function calls to sub-components. A Trace has a single, top-level
 * "root" Span that in turn may have zero or more child Spans, which in turn
 * may have children.
 */
export declare interface Span {
    /**
     * Returns the {@link SpanContext} object associated with this Span.
     *
     * @returns the SpanContext object associated with this Span.
     */
    context(): SpanContext;
    /**
     * Sets an attribute to the span.
     *
     * @param key the key for this attribute.
     * @param value the value for this attribute.
     */
    setAttribute(key: string, value: unknown): this;
    /**
     * Sets attributes to the span.
     *
     * @param attributes the attributes that will be added.
     */
    setAttributes(attributes: Attributes): this;
    /**
     * Adds an event to the Span.
     *
     * @param name the name of the event.
     * @param [attributes] the attributes that will be added; these are
     *     associated with this event.
     */
    addEvent(name: string, attributes?: Attributes): this;
    /**
     * Adds a link to the Span.
     *
     * @param spanContext the context of the linked span.
     * @param [attributes] the attributes that will be added; these are
     *     associated with this link.
     */
    addLink(spanContext: SpanContext, attributes?: Attributes): this;
    /**
     * Sets a status to the span. If used, this will override the default Span
     * status. Default is {@link CanonicalCode.OK}.
     *
     * @param status the Status to set.
     */
    setStatus(status: Status): this;
    /**
     * Updates the Span name.
     *
     * TODO (revision): https://github.com/open-telemetry/opentelemetry-specification/issues/119
     *
     * @param name the Span name.
     */
    updateName(name: string): this;
    /**
     * Marks the end of Span execution.
     *
     * Call to End of a Span MUST not have any effects on child spans. Those may
     * still be running and can be ended later.
     *
     * Do not return `this`. The Span generally should not be used after it
     * is ended so chaining is not desired in this context.
     *
     * @param [endTime] the timestamp to set as Span's end time. If not provided,
     *     use the current time as the span's end time.
     *     TODO (Add timestamp format): https://github.com/open-telemetry/opentelemetry-js/issues/19
     */
    end(endTime?: number): void;
    start(startTime?: number): void;
    /**
     * Returns the flag whether this span will be recorded.
     *
     * @returns true if this Span is active and recording information like events
     * with the AddEvent operation and attributes using setAttributes.
     */
    isRecordingEvents(): boolean;
}

/**
 * A SpanContext represents the portion of a {@link Span} which must be
 * serialized and propagated along side of a distributed context.
 */
export declare interface SpanContext {
    /**
     * The ID of the trace that this span belongs to. It is worldwide unique
     * with practically sufficient probability by being made as 16 randomly
     * generated bytes, encoded as a 32 lowercase hex characters corresponding to
     * 128 bits.
     */
    traceId: string;
    /**
     * The ID of the Span. It is globally unique with practically sufficient
     * probability by being made as 8 randomly generated bytes, encoded as a 16
     * lowercase hex characters corresponding to 64 bits.
     */
    spanId: string;
    /**
     * Trace options to propagate.
     *
     * It is represented as 1 byte (bitmap). Bit to represent whether trace is
     * sampled or not. When set, the least significant bit documents that the
     * caller may have recorded trace data. A caller who does not record trace
     * data out-of-band leaves this flag unset.
     *
     * SAMPLED = 0x1 and UNSAMPLED = 0x0;
     */
    traceOptions?: TraceOptions;
    /**
     * Tracing-system-specific info to propagate.
     *
     * The tracestate field value is a `list` as defined below. The `list` is a
     * series of `list-members` separated by commas `,`, and a list-member is a
     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
     * surrounding `list-members` are ignored. There can be a maximum of 32
     * `list-members` in a `list`.
     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field
     *
     * Examples:
     *     Single tracing system (generic format):
     *         tracestate: rojo=00f067aa0ba902b7
     *     Multiple tracing systems (with different formatting):
     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
     */
    traceState?: TraceState;
}

/**
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 */
export declare enum SpanKind {
    /** Default value. Indicates that the span is used internally. */
    INTERNAL = 0,
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SERVER = 1,
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    CLIENT = 2,
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    PRODUCER = 3,
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    CONSUMER = 4
}

export declare class SpanNoOpImpl implements Span {
    context(): SpanContext;
    setAttribute(key: string, value: unknown): this;
    setAttributes(attributes: Attributes): this;
    addEvent(name: string, attributes?: Attributes | undefined): this;
    addLink(spanContext: SpanContext, attributes?: Attributes | undefined): this;
    setStatus(status: Status): this;
    updateName(name: string): this;
    start(startTime?: number): void;
    end(endTime?: number): void;
    isRecordingEvents(): boolean;
}

/**
 * Options needed for span creation
 */
export declare interface SpanOptions {
    /** The SpanKind of a span */
    kind?: SpanKind;
    /** A spans attributes */
    attributes?: Attributes;
    /** Indicates that events are being recorded for a span */
    isRecordingEvents?: boolean;
    /**
     * A parent SpanContext (or Span, for convenience) that the newly-started
     * span will be the child of.
     */
    parent?: Span | SpanContext;
    /** A manually specified start time for the created Span object. */
    startTime?: number;
}

/**
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The status of a Span by providing a standard CanonicalCode in conjunction
 * with an optional descriptive message.
 */
export declare interface Status {
    /** The canonical code of this message. */
    code: CanonicalCode;
    /** A developer-facing error message. */
    message?: string;
}

export declare enum SupportedPlugins {
    OPENCENSUS = 0,
    NOOP = 1
}

/**
 * Represents a timed event.
 * A timed event is an event with a timestamp.
 */
export declare interface TimedEvent extends Event {
    time: number;
}

/**
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An enumeration that represents global trace options. These options are
 * propagated to all child {@link Span}. These determine features such as
 * whether a Span should be traced. It is implemented as a bitmask.
 */
export declare enum TraceOptions {
    /** Bit to represent whether trace is unsampled in trace options. */
    UNSAMPLED = 0,
    /** Bit to represent whether trace is sampled in trace options. */
    SAMPLED = 1
}

/**
 * Tracer provides an interface for creating {@link Span}s and propagating
 * context in-process.
 *
 * Users may choose to use manual or automatic Context propagation. Because of
 * that this class offers APIs to facilitate both usages.
 */
export declare interface Tracer {
    /**
     * Returns the type of the plugin being used by the tracer.
     * @returns the type of the plugin being used by the tracer.
     */
    pluginType: SupportedPlugins;
    /**
     * Returns the current Span from the current context if available.
     *
     * If there is no Span associated with the current context, a default Span
     * with invalid SpanContext is returned.
     *
     * @returns Span The currently active Span
     */
    getCurrentSpan(): Span;
    /**
     * Starts a new {@link Span}.
     * @param name The name of the span
     * @param [options] SpanOptions used for span creation
     * @returns Span The newly created span
     */
    startSpan(name: string, options?: SpanOptions): Span;
    /**
     * Executes the function given by fn within the context provided by Span
     *
     * @param span The span that provides the context
     * @param fn The function to be eexcuted inside the provided context
     */
    withSpan<T extends (...args: unknown[]) => unknown>(span: Span, fn: T): ReturnType<T>;
    /**
     * Send a pre-populated span object to the exporter.
     * Sampling and recording decisions as well as other collection optimizations
     * are the responsibility of a caller.
     *
     * @todo: Pending API discussion. Revisit if Span or SpanData should be passed
     *        in here once this is sorted out.
     * @param span Span Data to be reported to all exporters.
     */
    recordSpanData(span: Span): void;
    /**
     * Returns the {@link BinaryFormat} interface which can serialize/deserialize
     * Spans.
     *
     * If no tracer implementation is provided, this defaults to the W3C Trace
     * Context binary format ({@link BinaryFormat}). For more details see
     * <a href="https://w3c.github.io/trace-context-binary/">W3C Trace Context
     * binary protocol</a>.
     *
     * @todo: Change return type once BinaryFormat is available
     */
    getBinaryFormat(): unknown;
    /**
     * Returns the {@link HttpTextFormat} interface which can inject/extract
     * Spans.
     *
     * If no tracer implementation is provided, this defaults to the W3C Trace
     * Context HTTP text format ({@link HttpTraceContext}). For more details see
     * <a href="https://w3c.github.io/trace-context/">W3C Trace Context</a>.
     *
     * @todo: Change return type once HttpTextFormat is available
     */
    getHttpTextFormat(): unknown;
}

export declare class TracerNoOpImpl implements Tracer {
    readonly pluginType = SupportedPlugins.NOOP;
    getCurrentSpan(): Span;
    startSpan(name: string, options?: SpanOptions | undefined): Span;
    withSpan<T extends (...args: unknown[]) => unknown>(span: Span, fn: T): ReturnType<T>;
    recordSpanData(span: Span): void;
    getBinaryFormat(): unknown;
    getHttpTextFormat(): unknown;
}

export declare class TracerProxy {
    private static _tracerPlugin;
    private constructor();
    static setTracer(tracer: any, tracerPluginType: SupportedPlugins): void;
    static getTracer(): Tracer;
}

/**
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Tracestate carries system-specific configuration data, represented as a list
 * of key-value pairs. TraceState allows multiple tracing systems to
 * participate in the same trace.
 */
export declare interface TraceState {
    /**
     * Adds or updates the TraceState that has the given `key` if it is
     * present. The new State will always be added in the front of the
     * list of states.
     *
     * @param key key of the TraceState entry.
     * @param value value of the TraceState entry.
     */
    set(key: string, value: string): void;
    /**
     * Removes the TraceState Entry that has the given `key` if it is present.
     *
     * @param key the key for the TraceState Entry to be removed.
     */
    unset(key: string): void;
    /**
     * Returns the value to which the specified key is mapped, or `undefined` if
     * this map contains no mapping for the key.
     *
     * @param key with which the specified value is to be associated.
     * @returns the value to which the specified key is mapped, or `undefined` if
     *     this map contains no mapping for the key.
     */
    get(key: string): string | undefined;
    /**
     * Serializes the TraceState to a `list` as defined below. The `list` is a
     * series of `list-members` separated by commas `,`, and a list-member is a
     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
     * surrounding `list-members` are ignored. There can be a maximum of 32
     * `list-members` in a `list`.
     *
     * @returns the serialized string.
     */
    serialize(): string;
}

export { }
