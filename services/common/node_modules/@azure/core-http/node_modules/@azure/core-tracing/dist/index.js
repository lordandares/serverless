'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

(function (SupportedPlugins) {
    SupportedPlugins[SupportedPlugins["OPENCENSUS"] = 0] = "OPENCENSUS";
    SupportedPlugins[SupportedPlugins["NOOP"] = 1] = "NOOP";
})(exports.SupportedPlugins || (exports.SupportedPlugins = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * @ignore
 * @internal
 */
var OpenCensusTraceStatePlugin = /** @class */ (function () {
    function OpenCensusTraceStatePlugin(state) {
        this._state = state;
    }
    OpenCensusTraceStatePlugin.prototype.get = function (key) {
        throw new Error("Method not implemented.");
    };
    OpenCensusTraceStatePlugin.prototype.set = function (key, value) {
        throw new Error("Method not implemented.");
    };
    OpenCensusTraceStatePlugin.prototype.unset = function (key) {
        throw new Error("Method not implemented");
    };
    OpenCensusTraceStatePlugin.prototype.serialize = function () {
        return this._state || "";
    };
    return OpenCensusTraceStatePlugin;
}());

var OpenCensusSpanPlugin = /** @class */ (function () {
    function OpenCensusSpanPlugin(span) {
        this._span = span;
    }
    OpenCensusSpanPlugin.prototype.getSpan = function () {
        return this._span;
    };
    OpenCensusSpanPlugin.prototype.end = function (endTime) {
        this._span.end(endTime);
    };
    OpenCensusSpanPlugin.prototype.start = function (startTime) {
        this._span.start(startTime);
    };
    OpenCensusSpanPlugin.prototype.context = function () {
        var openCensusSpanContext = this._span.spanContext;
        return {
            spanId: openCensusSpanContext.spanId,
            traceId: openCensusSpanContext.traceId,
            traceOptions: openCensusSpanContext.options,
            traceState: new OpenCensusTraceStatePlugin(openCensusSpanContext.traceState)
        };
    };
    OpenCensusSpanPlugin.prototype.setAttribute = function (key, value) {
        this._span.addAttribute(key, value);
        return this;
    };
    OpenCensusSpanPlugin.prototype.setAttributes = function (attributes) {
        throw new Error("Method not implemented.");
    };
    OpenCensusSpanPlugin.prototype.addEvent = function (name, attributes) {
        throw new Error("Method not implemented.");
    };
    OpenCensusSpanPlugin.prototype.addLink = function (spanContext, attributes) {
        // Since there is no way to specify the link relationship
        // It is set as Unspecified = 0
        this._span.addLink(spanContext.traceId, spanContext.spanId, 0, attributes);
        return this;
    };
    OpenCensusSpanPlugin.prototype.setStatus = function (status) {
        this._span.setStatus(status.code, status.message);
        return this;
    };
    OpenCensusSpanPlugin.prototype.updateName = function (name) {
        throw new Error("Method not implemented.");
    };
    OpenCensusSpanPlugin.prototype.isRecordingEvents = function () {
        throw new Error("Method not implemented.");
    };
    return OpenCensusSpanPlugin;
}());

var OpenCensusTracePlugin = /** @class */ (function () {
    function OpenCensusTracePlugin(tracer) {
        this.pluginType = exports.SupportedPlugins.OPENCENSUS;
        this._tracer = tracer;
    }
    OpenCensusTracePlugin.prototype.startSpan = function (name, options) {
        var parent = options
            ? options.parent
                ? options.parent instanceof OpenCensusSpanPlugin
                    ? options.parent.getSpan()
                    : options.parent
                : undefined
            : undefined;
        var span = this._tracer.startChildSpan({
            name: name,
            childOf: parent
        });
        var openCensusSpanPlugin = new OpenCensusSpanPlugin(span);
        return openCensusSpanPlugin;
    };
    OpenCensusTracePlugin.prototype.getCurrentSpan = function () {
        throw new Error("Method not implemented.");
    };
    OpenCensusTracePlugin.prototype.withSpan = function (span, fn) {
        throw new Error("Method not implemented.");
    };
    OpenCensusTracePlugin.prototype.recordSpanData = function (span) {
        throw new Error("Method not implemented.");
    };
    OpenCensusTracePlugin.prototype.getBinaryFormat = function () {
        throw new Error("Method not implemented.");
    };
    OpenCensusTracePlugin.prototype.getHttpTextFormat = function () {
        throw new Error("Method not implemented.");
    };
    return OpenCensusTracePlugin;
}());

var NoOpSpanPlugin = /** @class */ (function () {
    function NoOpSpanPlugin(span) {
        this._span = span;
    }
    NoOpSpanPlugin.prototype.context = function () {
        return {
            spanId: "",
            traceId: ""
        };
    };
    NoOpSpanPlugin.prototype.end = function (endTime) {
        this._span.end(endTime);
    };
    NoOpSpanPlugin.prototype.start = function (startTime) {
        this._span.start(startTime);
    };
    NoOpSpanPlugin.prototype.setAttribute = function (key, value) {
        throw new Error("Method not implemented.");
    };
    NoOpSpanPlugin.prototype.setAttributes = function (attributes) {
        throw new Error("Method not implemented.");
    };
    NoOpSpanPlugin.prototype.addEvent = function (name, attributes) {
        throw new Error("Method not implemented.");
    };
    NoOpSpanPlugin.prototype.addLink = function (spanContext, attributes) {
        throw new Error("Method not implemented.");
    };
    NoOpSpanPlugin.prototype.setStatus = function (status) {
        throw new Error("Method not implemented.");
    };
    NoOpSpanPlugin.prototype.updateName = function (name) {
        throw new Error("Method not implemented.");
    };
    NoOpSpanPlugin.prototype.isRecordingEvents = function () {
        throw new Error("Method not implemented.");
    };
    return NoOpSpanPlugin;
}());

var SpanNoOpImpl = /** @class */ (function () {
    function SpanNoOpImpl() {
    }
    SpanNoOpImpl.prototype.context = function () {
        throw new Error("Method not implemented.");
    };
    SpanNoOpImpl.prototype.setAttribute = function (key, value) {
        throw new Error("Method not implemented.");
    };
    SpanNoOpImpl.prototype.setAttributes = function (attributes) {
        throw new Error("Method not implemented.");
    };
    SpanNoOpImpl.prototype.addEvent = function (name, attributes) {
        throw new Error("Method not implemented.");
    };
    SpanNoOpImpl.prototype.addLink = function (spanContext, attributes) {
        throw new Error("Method not implemented.");
    };
    SpanNoOpImpl.prototype.setStatus = function (status) {
        throw new Error("Method not implemented.");
    };
    SpanNoOpImpl.prototype.updateName = function (name) {
        throw new Error("Method not implemented.");
    };
    SpanNoOpImpl.prototype.start = function (startTime) { };
    SpanNoOpImpl.prototype.end = function (endTime) { };
    SpanNoOpImpl.prototype.isRecordingEvents = function () {
        throw new Error("Method not implemented.");
    };
    return SpanNoOpImpl;
}());

var NoOpTracePlugin = /** @class */ (function () {
    function NoOpTracePlugin(tracer) {
        this.pluginType = exports.SupportedPlugins.NOOP;
        this._tracer = tracer;
    }
    NoOpTracePlugin.prototype.startSpan = function (name, options) {
        var span = new SpanNoOpImpl();
        var noOpSpanPlugin = new NoOpSpanPlugin(span);
        return noOpSpanPlugin;
    };
    NoOpTracePlugin.prototype.getCurrentSpan = function () {
        throw new Error("Method not implemented.");
    };
    NoOpTracePlugin.prototype.withSpan = function (span, fn) {
        throw new Error("Method not implemented.");
    };
    NoOpTracePlugin.prototype.recordSpanData = function (span) {
        throw new Error("Method not implemented.");
    };
    NoOpTracePlugin.prototype.getBinaryFormat = function () {
        throw new Error("Method not implemented.");
    };
    NoOpTracePlugin.prototype.getHttpTextFormat = function () {
        throw new Error("Method not implemented.");
    };
    return NoOpTracePlugin;
}());

var TracerNoOpImpl = /** @class */ (function () {
    function TracerNoOpImpl() {
        this.pluginType = exports.SupportedPlugins.NOOP;
    }
    TracerNoOpImpl.prototype.getCurrentSpan = function () {
        throw new Error("Method not implemented.");
    };
    TracerNoOpImpl.prototype.startSpan = function (name, options) {
        return new SpanNoOpImpl();
    };
    TracerNoOpImpl.prototype.withSpan = function (span, fn) {
        throw new Error("Method not implemented.");
    };
    TracerNoOpImpl.prototype.recordSpanData = function (span) {
        throw new Error("Method not implemented.");
    };
    TracerNoOpImpl.prototype.getBinaryFormat = function () {
        throw new Error("Method not implemented.");
    };
    TracerNoOpImpl.prototype.getHttpTextFormat = function () {
        throw new Error("Method not implemented.");
    };
    return TracerNoOpImpl;
}());

var TracerProxy = /** @class */ (function () {
    function TracerProxy() {
    }
    TracerProxy.setTracer = function (tracer, tracerPluginType) {
        if (tracerPluginType === exports.SupportedPlugins.OPENCENSUS) {
            TracerProxy._tracerPlugin = new OpenCensusTracePlugin(tracer);
        }
        else {
            TracerProxy._tracerPlugin = new NoOpTracePlugin(tracer);
        }
    };
    TracerProxy.getTracer = function () {
        if (!TracerProxy._tracerPlugin) {
            TracerProxy._tracerPlugin = new NoOpTracePlugin(new TracerNoOpImpl());
        }
        return TracerProxy._tracerPlugin;
    };
    return TracerProxy;
}());

/**
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function (SpanKind) {
    /** Default value. Indicates that the span is used internally. */
    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(exports.SpanKind || (exports.SpanKind = {}));

/**
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function (CanonicalCode) {
    /**
     * Not an error; returned on success
     */
    CanonicalCode[CanonicalCode["OK"] = 0] = "OK";
    /**
     * The operation was cancelled (typically by the caller).
     */
    CanonicalCode[CanonicalCode["CANCELLED"] = 1] = "CANCELLED";
    /**
     * Unknown error.  An example of where this error may be returned is
     * if a status value received from another address space belongs to
     * an error-space that is not known in this address space.  Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     */
    CanonicalCode[CanonicalCode["UNKNOWN"] = 2] = "UNKNOWN";
    /**
     * Client specified an invalid argument.  Note that this differs
     * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     */
    CanonicalCode[CanonicalCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    /**
     * Deadline expired before operation could complete.  For operations
     * that change the state of the system, this error may be returned
     * even if the operation has completed successfully.  For example, a
     * successful response from a server could have been delayed long
     * enough for the deadline to expire.
     */
    CanonicalCode[CanonicalCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    /**
     * Some requested entity (e.g., file or directory) was not found.
     */
    CanonicalCode[CanonicalCode["NOT_FOUND"] = 5] = "NOT_FOUND";
    /**
     * Some entity that we attempted to create (e.g., file or directory)
     * already exists.
     */
    CanonicalCode[CanonicalCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    /**
     * The caller does not have permission to execute the specified
     * operation.  PERMISSION_DENIED must not be used for rejections
     * caused by exhausting some resource (use RESOURCE_EXHAUSTED
     * instead for those errors).  PERMISSION_DENIED must not be
     * used if the caller can not be identified (use UNAUTHENTICATED
     * instead for those errors).
     */
    CanonicalCode[CanonicalCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    /**
     * Some resource has been exhausted, perhaps a per-user quota, or
     * perhaps the entire file system is out of space.
     */
    CanonicalCode[CanonicalCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    /**
     * Operation was rejected because the system is not in a state
     * required for the operation's execution.  For example, directory
     * to be deleted may be non-empty, an rmdir operation is applied to
     * a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
     *
     *  - Use UNAVAILABLE if the client can retry just the failing call.
     *  - Use ABORTED if the client should retry at a higher-level
     *    (e.g., restarting a read-modify-write sequence).
     *  - Use FAILED_PRECONDITION if the client should not retry until
     *    the system state has been explicitly fixed.  E.g., if an "rmdir"
     *    fails because the directory is non-empty, FAILED_PRECONDITION
     *    should be returned since the client should not retry unless
     *    they have first fixed up the directory by deleting files from it.
     *  - Use FAILED_PRECONDITION if the client performs conditional
     *    REST Get/Update/Delete on a resource and the resource on the
     *    server does not match the condition. E.g., conflicting
     *    read-modify-write on the same resource.
     */
    CanonicalCode[CanonicalCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    /**
     * The operation was aborted, typically due to a concurrency issue
     * like sequencer check failures, transaction aborts, etc.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */
    CanonicalCode[CanonicalCode["ABORTED"] = 10] = "ABORTED";
    /**
     * Operation was attempted past the valid range.  E.g., seeking or
     * reading past end of file.
     *
     * Unlike INVALID_ARGUMENT, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate INVALID_ARGUMENT if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OUT_OF_RANGE if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FAILED_PRECONDITION and
     * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OUT_OF_RANGE error to detect when
     * they are done.
     */
    CanonicalCode[CanonicalCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    /**
     * Operation is not implemented or not supported/enabled in this service.
     */
    CanonicalCode[CanonicalCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    /**
     * Internal errors.  Means some invariants expected by underlying
     * system has been broken.  If you see one of these errors,
     * something is very broken.
     */
    CanonicalCode[CanonicalCode["INTERNAL"] = 13] = "INTERNAL";
    /**
     * The service is currently unavailable.  This is a most likely a
     * transient condition and may be corrected by retrying with
     * a backoff.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */
    CanonicalCode[CanonicalCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    /**
     * Unrecoverable data loss or corruption.
     */
    CanonicalCode[CanonicalCode["DATA_LOSS"] = 15] = "DATA_LOSS";
    /**
     * The request does not have valid authentication credentials for the
     * operation.
     */
    CanonicalCode[CanonicalCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(exports.CanonicalCode || (exports.CanonicalCode = {}));

/**
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function (TraceOptions) {
    /** Bit to represent whether trace is unsampled in trace options. */
    TraceOptions[TraceOptions["UNSAMPLED"] = 0] = "UNSAMPLED";
    /** Bit to represent whether trace is sampled in trace options. */
    TraceOptions[TraceOptions["SAMPLED"] = 1] = "SAMPLED";
})(exports.TraceOptions || (exports.TraceOptions = {}));

exports.NoOpSpanPlugin = NoOpSpanPlugin;
exports.NoOpTracePlugin = NoOpTracePlugin;
exports.OpenCensusSpanPlugin = OpenCensusSpanPlugin;
exports.OpenCensusTracePlugin = OpenCensusTracePlugin;
exports.SpanNoOpImpl = SpanNoOpImpl;
exports.TracerNoOpImpl = TracerNoOpImpl;
exports.TracerProxy = TracerProxy;
//# sourceMappingURL=index.js.map
