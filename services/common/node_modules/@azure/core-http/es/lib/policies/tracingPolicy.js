// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import { TracerProxy, TraceOptions } from "@azure/core-tracing";
import { BaseRequestPolicy } from "./requestPolicy";
export function tracingPolicy() {
    return {
        create: function (nextPolicy, options) {
            return new TracingPolicy(nextPolicy, options);
        }
    };
}
var TracingPolicy = /** @class */ (function (_super) {
    tslib_1.__extends(TracingPolicy, _super);
    function TracingPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    TracingPolicy.prototype.sendRequest = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tracer, span, spanContext, traceState, response, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!request.spanOptions || !request.spanOptions.parent) {
                            return [2 /*return*/, this._nextPolicy.sendRequest(request)];
                        }
                        tracer = TracerProxy.getTracer();
                        span = tracer.startSpan("core-http", request.spanOptions);
                        span.start();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        spanContext = span.context();
                        if (spanContext.spanId && spanContext.traceId) {
                            request.headers.set("traceparent", spanContext.traceId + "-" + spanContext.spanId + "-" + (spanContext.traceOptions || TraceOptions.UNSAMPLED));
                            traceState = spanContext.traceState && spanContext.traceState.serialize();
                            // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent
                            if (traceState) {
                                request.headers.set("tracestate", traceState);
                            }
                        }
                        return [4 /*yield*/, this._nextPolicy.sendRequest(request)];
                    case 2:
                        response = _a.sent();
                        span.end();
                        return [2 /*return*/, response];
                    case 3:
                        err_1 = _a.sent();
                        span.end();
                        throw err_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return TracingPolicy;
}(BaseRequestPolicy));
export { TracingPolicy };
//# sourceMappingURL=tracingPolicy.js.map