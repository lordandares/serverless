// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import qs from "qs";
import { ServiceClient, WebResource, tracingPolicy } from "@azure/core-http";
import { CanonicalCode } from "@azure/core-tracing";
import { AuthenticationError, AuthenticationErrorName } from "./errors";
import { createSpan } from "../util/tracing";
import { logger } from '../util/logging';
const DefaultAuthorityHost = "https://login.microsoftonline.com";
export class IdentityClient extends ServiceClient {
    constructor(options) {
        options = options || IdentityClient.getDefaultOptions();
        super(undefined, options);
        this.baseUri = this.authorityHost = options.authorityHost || DefaultAuthorityHost;
        if (!this.baseUri.startsWith("https:")) {
            throw new Error("The authorityHost address must use the 'https' protocol.");
        }
    }
    createWebResource(requestOptions) {
        const webResource = new WebResource();
        webResource.prepare(requestOptions);
        return webResource;
    }
    sendTokenRequest(webResource, expiresOnParser) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            logger.info(`IdentityClient: sending token request to [${webResource.url}]`);
            const response = yield this.sendRequest(webResource);
            expiresOnParser =
                expiresOnParser ||
                    ((responseBody) => {
                        return Date.now() + responseBody.expires_in * 1000;
                    });
            if (response.status === 200 || response.status === 201) {
                const token = {
                    accessToken: {
                        token: response.parsedBody.access_token,
                        expiresOnTimestamp: expiresOnParser(response.parsedBody)
                    },
                    refreshToken: response.parsedBody.refresh_token
                };
                logger.info(`IdentityClient: [${webResource.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
                return token;
            }
            else {
                const error = new AuthenticationError(response.status, response.parsedBody || response.bodyAsText);
                logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
                throw error;
            }
        });
    }
    refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (refreshToken === undefined) {
                return null;
            }
            logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
            const { span, options: newOptions } = createSpan("IdentityClient-refreshAccessToken", options);
            const refreshParams = {
                grant_type: "refresh_token",
                client_id: clientId,
                refresh_token: refreshToken,
                scope: scopes
            };
            if (clientSecret !== undefined) {
                refreshParams.client_secret = clientSecret;
            }
            try {
                const webResource = this.createWebResource({
                    url: `${this.authorityHost}/${tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify(refreshParams),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    spanOptions: newOptions.spanOptions,
                    abortSignal: options && options.abortSignal
                });
                const response = yield this.sendTokenRequest(webResource, expiresOnParser);
                logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
                return response;
            }
            catch (err) {
                if (err.name === AuthenticationErrorName &&
                    err.errorResponse.error === "interaction_required") {
                    // It's likely that the refresh token has expired, so
                    // return null so that the credential implementation will
                    // initiate the authentication flow again.
                    logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);
                    span.setStatus({
                        code: CanonicalCode.UNAUTHENTICATED,
                        message: err.message
                    });
                    return null;
                }
                else {
                    logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: err.message
                    });
                    throw err;
                }
            }
            finally {
                span.end();
            }
        });
    }
    static getDefaultOptions() {
        return {
            authorityHost: DefaultAuthorityHost,
            requestPolicyFactories: (factories) => {
                return [tracingPolicy(), ...factories];
            }
        };
    }
}
//# sourceMappingURL=identityClient.js.map