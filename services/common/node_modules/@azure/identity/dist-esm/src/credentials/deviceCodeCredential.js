// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import qs from "qs";
import { IdentityClient } from "../client/identityClient";
import { AuthenticationError, AuthenticationErrorName } from "../client/errors";
import { createSpan } from "../util/tracing";
import { delay } from "../util/delay";
import { CanonicalCode } from "@azure/core-tracing";
import { logger } from '../util/logging';
/**
 * Enables authentication to Azure Active Directory using a device code
 * that the user can enter into https://microsoft.com/devicelogin.
 */
export class DeviceCodeCredential {
    /**
     * Creates an instance of DeviceCodeCredential with the details needed
     * to initiate the device code authorization flow with Azure Active Directory.
     *
     * @param The Azure Active Directory tenant (directory) ID or name.
     * @param tenantId The Azure Active Directory tenant (directory) ID or name.
     *                 'organizations' may be used when dealing with multi-tenant scenarios.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param userPromptCallback A callback function that will be invoked to show
                                 {@link DeviceCodeInfo} to the user.
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, userPromptCallback, options) {
        this.lastTokenResponse = null;
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.userPromptCallback = userPromptCallback;
    }
    sendDeviceCodeRequest(scope, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-sendDeviceCodeRequest", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/devicecode`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        client_id: this.clientId,
                        scope
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.spanOptions
                });
                logger.info("DeviceCodeCredential: sending devicecode request");
                const response = yield this.identityClient.sendRequest(webResource);
                if (!(response.status === 200 || response.status === 201)) {
                    throw new AuthenticationError(response.status, response.bodyAsText);
                }
                return response.parsedBody;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? CanonicalCode.UNAUTHENTICATED
                    : CanonicalCode.UNKNOWN;
                if (err.name === AuthenticationErrorName) {
                    logger.warning(`DeviceCodeCredential: failed to authenticate ${err.errorResponse.errorDescription}`);
                }
                else {
                    logger.warning(`DeviceCodeCredential: failed to authenticate ${err}`);
                }
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    pollForToken(deviceCodeResponse, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let tokenResponse = null;
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-pollForToken", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        grant_type: "urn:ietf:params:oauth:grant-type:device_code",
                        client_id: this.clientId,
                        device_code: deviceCodeResponse.device_code
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.spanOptions
                });
                while (tokenResponse === null) {
                    try {
                        yield delay(deviceCodeResponse.interval * 1000);
                        // Check the abort signal before sending the request
                        if (options && options.abortSignal && options.abortSignal.aborted) {
                            return null;
                        }
                        tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                    }
                    catch (err) {
                        if (err.name === AuthenticationErrorName) {
                            switch (err.errorResponse.error) {
                                case "authorization_pending":
                                    break;
                                case "authorization_declined":
                                    return null;
                                case "expired_token":
                                    throw err;
                                case "bad_verification_code":
                                    throw err;
                                default:
                                    // Any other error should be rethrown
                                    throw err;
                            }
                        }
                        else {
                            throw err;
                        }
                    }
                }
                return tokenResponse;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? CanonicalCode.UNAUTHENTICATED
                    : CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Authenticates with Azure Active Directory and returns an {@link AccessToken} if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-getToken", options);
            try {
                let tokenResponse = null;
                let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
                if (scopeString.indexOf("offline_access") < 0) {
                    scopeString += " offline_access";
                }
                // Try to use the refresh token first
                if (this.lastTokenResponse && this.lastTokenResponse.refreshToken) {
                    tokenResponse = yield this.identityClient.refreshAccessToken(this.tenantId, this.clientId, scopeString, this.lastTokenResponse.refreshToken, undefined, // clientSecret not needed for device code auth
                    undefined, newOptions);
                }
                if (tokenResponse === null) {
                    const deviceCodeResponse = yield this.sendDeviceCodeRequest(scopeString, newOptions);
                    this.userPromptCallback({
                        userCode: deviceCodeResponse.user_code,
                        verificationUri: deviceCodeResponse.verification_uri,
                        message: deviceCodeResponse.message
                    });
                    tokenResponse = yield this.pollForToken(deviceCodeResponse, newOptions);
                }
                this.lastTokenResponse = tokenResponse;
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? CanonicalCode.UNAUTHENTICATED
                    : CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}
//# sourceMappingURL=deviceCodeCredential.js.map