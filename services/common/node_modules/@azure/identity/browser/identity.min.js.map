{"version":3,"file":"identity.min.js","sources":["../../../../common/temp/node_modules/.registry.npmjs.org/tslib/1.10.0/node_modules/tslib/tslib.es6.js","../src/client/errors.ts","../../../core/core-tracing/lib/tracers/noop/noOpSpan.ts","../../../core/core-tracing/lib/tracers/noop/noOpBinaryFormat.ts","../../../core/core-tracing/lib/tracers/noop/noOpHttpTextFormat.ts","../../../core/core-tracing/lib/tracers/noop/noOpTracer.ts","../../../core/core-tracing/lib/utils/cache.ts","../../../core/core-tracing/lib/interfaces/status.ts","../../../core/core-tracing/lib/interfaces/span_kind.ts","../../../core/core-tracing/lib/interfaces/trace_flags.ts","../../../core/core-tracing/lib/utils/global.browser.ts","../../../core/core-tracing/lib/tracerProxy.ts","../../../core/core-tracing/lib/utils/traceParentHeader.ts","../src/util/tracing.ts","../src/credentials/chainedTokenCredential.ts","../src/credentials/environmentCredential.browser.ts","../src/credentials/managedIdentityCredential.browser.ts","../src/credentials/defaultAzureCredential.ts","../../../../common/temp/node_modules/.registry.npmjs.org/qs/6.8.0/node_modules/qs/lib/utils.js","../../../../common/temp/node_modules/.registry.npmjs.org/qs/6.8.0/node_modules/qs/lib/formats.js","../../../../common/temp/node_modules/.registry.npmjs.org/qs/6.8.0/node_modules/qs/lib/stringify.js","../../../../common/temp/node_modules/.registry.npmjs.org/qs/6.8.0/node_modules/qs/lib/parse.js","../../../../common/temp/node_modules/.registry.npmjs.org/qs/6.8.0/node_modules/qs/lib/index.js","../../../core/core-http/lib/httpHeaders.ts","../../../core/core-http/lib/util/base64.browser.ts","../../../../common/temp/node_modules/.registry.npmjs.org/uuid/3.3.3/node_modules/uuid/lib/bytesToUuid.js","../../../../common/temp/node_modules/.registry.npmjs.org/uuid/3.3.3/node_modules/uuid/lib/rng-browser.js","../../../../common/temp/node_modules/.registry.npmjs.org/uuid/3.3.3/node_modules/uuid/v4.js","../../../core/core-http/lib/util/constants.ts","../../../core/core-http/lib/util/utils.ts","../../../core/core-http/lib/serializer.ts","../../../core/core-http/lib/webResource.ts","../../../../common/temp/node_modules/.registry.npmjs.org/@azure/abort-controller/1.0.0-preview.2/node_modules/@azure/abort-controller/src/AbortSignal.ts","../../../../common/temp/node_modules/.registry.npmjs.org/@azure/abort-controller/1.0.0-preview.2/node_modules/@azure/abort-controller/src/AbortController.ts","../../../core/core-http/lib/httpPipelineLogLevel.ts","../../../core/core-http/lib/restError.ts","../../../core/core-http/lib/xhrHttpClient.ts","../../../core/core-http/lib/url.ts","../../../core/core-http/lib/policies/requestPolicy.ts","../../../core/logger/src/log.browser.ts","../../../core/logger/src/debug.ts","../../../core/logger/src/logger.ts","../../../core/core-http/lib/log.ts","../../../core/core-http/lib/policies/logPolicy.ts","../../../core/core-http/lib/operationParameter.ts","../../../core/core-http/lib/operationSpec.ts","../../../core/core-http/lib/util/xml.browser.ts","../../../core/core-http/lib/policies/deserializationPolicy.ts","../../../core/core-http/lib/policies/exponentialRetryPolicy.ts","../../../core/core-http/lib/policies/generateClientRequestIdPolicy.ts","../../../core/core-http/lib/policies/msRestUserAgentPolicy.browser.ts","../../../core/core-http/lib/policies/userAgentPolicy.ts","../../../core/core-http/lib/policies/redirectPolicy.ts","../../../core/core-http/lib/policies/rpRegistrationPolicy.ts","../../../core/core-http/lib/credentials/accessTokenCache.ts","../../../core/core-http/lib/policies/bearerTokenAuthenticationPolicy.ts","../../../core/core-http/lib/policies/systemErrorRetryPolicy.ts","../../../core/core-http/lib/queryCollectionFormat.ts","../../../core/core-http/lib/policies/proxyPolicy.browser.ts","../../../core/core-http/lib/policies/throttlingRetryPolicy.ts","../../../core/core-http/lib/policies/signingPolicy.ts","../../../core/core-http/lib/policies/tracingPolicy.ts","../../../core/core-http/lib/serviceClient.ts","../../../core/core-auth/src/tokenCredential.ts","../src/util/logging.ts","../src/client/identityClient.ts","../src/credentials/clientCertificateCredential.browser.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/utils/CryptoUtils.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/utils/Constants.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/ScopeSet.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/utils/StringUtils.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/utils/UrlUtils.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/AccessTokenKey.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/AccessTokenValue.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/error/AuthError.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/error/ClientAuthError.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/error/ClientConfigurationError.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/ServerRequestParameters.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/Authority.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/AuthenticationParameters.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/ClientInfo.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/utils/TokenUtils.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/IdToken.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/AccessTokenCacheItem.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/Storage.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/Account.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/utils/TimeUtils.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/utils/ResponseUtils.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/XHRClient.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/Logger.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/AadAuthority.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/B2cAuthority.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/AuthorityFactory.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/Configuration.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/error/ServerError.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/error/InteractionRequiredAuthError.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/AuthResponse.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/telemetry/TelemetryConstants.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/telemetry/TelemetryUtils.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/telemetry/DefaultEvent.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/telemetry/TelemetryEvent.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/telemetry/TelemetryManager.ts","../../../../common/temp/node_modules/.registry.npmjs.org/msal/1.1.3/node_modules/msal/src/UserAgentApplication.ts","../src/constants.ts","../src/credentials/deviceCodeCredential.browser.ts","../src/credentials/authorizationCodeCredential.browser.ts","../src/credentials/clientSecretCredential.ts","../src/credentials/interactiveBrowserCredential.browser.ts","../src/credentials/usernamePasswordCredential.ts","../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * See the official documentation for more details:\n *\n * https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-protocols-oauth-code#error-response-1\n *\n * NOTE: This documentation is for v1 OAuth support but the same error\n * response details still apply to v2.\n */\nexport interface ErrorResponse {\n  /**\n   * The string identifier for the error.\n   */\n  error: string;\n\n  /**\n   * The error's description.\n   */\n  errorDescription: string;\n\n  /**\n   * An array of codes pertaining to the error(s) that occurred.\n   */\n  errorCodes?: number[];\n\n  /**\n   * The timestamp at which the error occurred.\n   */\n  timestamp?: string;\n\n  /**\n   * The trace identifier for this error occurrence.\n   */\n  traceId?: string;\n\n  /**\n   * The correlation ID to be used for tracking the source of the error.\n   */\n  correlationId?: string;\n}\n\n/**\n * Used for internal deserialization of OAuth responses. Public model is ErrorResponse\n * @internal\n * @ignore\n */\nexport interface OAuthErrorResponse {\n  error: string;\n  error_description: string;\n  error_codes?: number[];\n  timestamp?: string;\n  trace_id?: string;\n  correlation_id?: string;\n}\n\nfunction isErrorResponse(errorResponse: any): errorResponse is OAuthErrorResponse {\n  return (\n    errorResponse &&\n    typeof errorResponse.error === \"string\" &&\n    typeof errorResponse.error_description === \"string\"\n  );\n}\n\n/**\n * The Error.name value of an AuthenticationError\n */\nexport const AuthenticationErrorName = \"AuthenticationError\";\n\n/**\n * Provides details about a failure to authenticate with Azure Active\n * Directory.  The `errorResponse` field contains more details about\n * the specific failure.\n */\nexport class AuthenticationError extends Error {\n  /**\n   * The HTTP status code returned from the authentication request.\n   */\n  public readonly statusCode: number;\n\n  /**\n   * The error response details.\n   */\n  public readonly errorResponse: ErrorResponse;\n\n  constructor(statusCode: number, errorBody: object | string | undefined | null) {\n    let errorResponse: ErrorResponse = {\n      error: \"unknown\",\n      errorDescription: \"An unknown error occurred and no additional details are available.\"\n    };\n\n    if (isErrorResponse(errorBody)) {\n      errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);\n    } else if (typeof errorBody === \"string\") {\n      try {\n        // Most error responses will contain JSON-formatted error details\n        // in the response body        \n        const oauthErrorResponse: OAuthErrorResponse = JSON.parse(errorBody);\n        errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);\n      } catch (e) {\n        if (statusCode === 400) {\n          errorResponse = {\n            error: \"authority_not_found\",\n            errorDescription: \"The specified authority URL was not found.\"\n          };\n        } else {\n          errorResponse = {\n            error: \"unknown_error\",\n            errorDescription: `An unknown error has occurred. Response body:\\n\\n${errorBody}`\n          };\n        }\n      }\n    } else {\n      errorResponse = {\n        error: \"unknown_error\",\n        errorDescription: \"An unknown error occurred and no additional details are available.\"\n      };\n    }\n\n    super(\n      `An error was returned while authenticating to Azure Active Directory (status code ${statusCode}).\\n\\nMore details:\\n\\n${JSON.stringify(\n        errorResponse,\n        null,\n        \"  \"\n      )}`\n    );\n    this.statusCode = statusCode;\n    this.errorResponse = errorResponse;\n\n    // Ensure that this type reports the correct name\n    this.name = AuthenticationErrorName;\n  }\n}\n\n/**\n * The Error.name value of an AggregateAuthenticationError\n */\nexport const AggregateAuthenticationErrorName = \"AggregateAuthenticationError\";\n\n/**\n * Provides an `errors` array containing {@link AuthenticationError} instance\n * for authentication failures from credentials in a {@link ChainedTokenCredential}.\n */\nexport class AggregateAuthenticationError extends Error {\n  /**\n   * The array of error objects that were thrown while trying to authenticate\n   * with the credentials in a {@link ChainedTokenCredential}.\n   */\n  public errors: any[];\n\n  constructor(errors: any[]) {\n    super(\n      `Authentication failed to complete due to the following errors:\\n\\n${errors.join(\"\\n\\n\")}`\n    );\n    this.errors = errors;\n\n    // Ensure that this type reports the correct name\n    this.name = AggregateAuthenticationErrorName;\n  }\n}\n\nfunction convertOAuthErrorResponseToErrorResponse(errorBody: OAuthErrorResponse) : ErrorResponse {\n  return {\n    error: errorBody.error,\n    errorDescription: errorBody.error_description,\n    correlationId: errorBody.correlation_id,\n    errorCodes: errorBody.error_codes,\n    timestamp: errorBody.timestamp,\n    traceId: errorBody.trace_id\n  };\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { Span } from \"../../interfaces/span\";\nimport { SpanContext } from \"../../interfaces/span_context\";\nimport { Attributes } from \"../../interfaces/attributes\";\nimport { Status } from \"../../interfaces/status\";\n\n/**\n * A no-op implementation of Span that can safely be used without side-effects.\n */\nexport class NoOpSpan implements Span {\n\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  context(): SpanContext {\n    return {\n      spanId: \"\",\n      traceId: \"\"\n    };\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param _endTime The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    /* Noop */\n  }\n\n  /**\n   * Sets an attribute on the Span\n   * @param _key the attribute key\n   * @param _value the attribute value\n   */\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  /**\n   * Sets attributes on the Span\n   * @param _attributes the attributes to add\n   */\n  setAttributes(_attributes: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Adds an event to the Span\n   * @param _name The name of the event\n   * @param _attributes The associated attributes to add for this event\n   */\n  addEvent(_name: string, _attributes?: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Adds a link to the Span.\n   * @param _spanContext the context of the linked span\n   * @param _attributes attributes to be added that are associated with the link\n   */\n  addLink(_spanContext: SpanContext, _attributes?: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of CanonicalCode.OK.\n   * @param _status The status to set.\n   */\n  setStatus(_status: Status): this {\n    return this;\n  }\n\n  /**\n   * Updates the name of the Span\n   * @param _name the new Span name\n   */\n  updateName(_name: string): this {\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecordingEvents(): boolean {\n    return false;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { BinaryFormat } from \"../../interfaces/BinaryFormat\";\nimport { SpanContext } from \"../../interfaces/span_context\";\n\n/**\n * A no-op implementation of BinaryFormat to be used when tracing is disabled.\n */\nexport class NoOpBinaryFormat implements BinaryFormat {\n  /** Serialize the given SpanContext to a buffer */\n  toBytes(_spanContext: SpanContext): ArrayBuffer {\n    return new ArrayBuffer(0);\n  }\n\n  /** \n   * Deserialize a SpanContext from binary encoding. \n   * Returns null if the buffer does not contain a valid SpanContext.\n   */\n  fromBytes(_buffer: ArrayBuffer): SpanContext | null {\n    return null;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { HttpTextFormat } from \"../../interfaces/HttpTextFormat\";\nimport { SpanContext } from \"../../interfaces/span_context\";\n\n/**\n * A no-op implementation of HttpTextFormat to be used when tracing is disabled.\n */\nexport class NoOpHttpTextFormat implements HttpTextFormat {\n  /**\n   * Injects the given SpanContext for transmitting to a remote server.\n   * @param _spanContext The SpanContext to transmit\n   * @param _format The format of the carrier\n   * @param _carrier The carrier to propagate through, e.g. an HTTP request\n   */\n  inject(_spanContext: SpanContext, _format: string, _carrier: unknown): void { }\n  /**\n   * Returns a SpanContext intance extracted from the carrier.\n   * @param _format the format of the carrier\n   * @param _carrier The carrier being used for propagation, e.g. an HTTP request\n   */\n  extract(_format: string, _carrier: unknown): SpanContext | null {\n    return null;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { Tracer } from \"../../interfaces/tracer\";\nimport { Span } from \"../../interfaces/span\";\nimport { SpanOptions } from \"../../interfaces/SpanOptions\";\nimport { NoOpSpan } from \"./noOpSpan\";\nimport { BinaryFormat } from \"../../interfaces/BinaryFormat\";\nimport { HttpTextFormat } from \"../../interfaces/HttpTextFormat\";\nimport { NoOpBinaryFormat } from \"./noOpBinaryFormat\";\nimport { NoOpHttpTextFormat } from \"./noOpHttpTextFormat\";\n\n/**\n * A no-op implementation of Tracer that can be used when tracing\n * is disabled.\n */\nexport class NoOpTracer implements Tracer {\n\n  /**\n   * Starts a new Span.\n   * @param _name The name of the span.\n   * @param _options The SpanOptions used during Span creation.\n   */\n  startSpan(_name: string, _options?: SpanOptions): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Returns the current Span from the current context, if available.\n   */\n  getCurrentSpan(): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Executes the given function within the context provided by a Span.\n   * @param _span The span that provides the context.\n   * @param fn The function to be executed.\n   */\n  withSpan<T extends (...args: unknown[]) => ReturnType<T>>(\n    _span: Span,\n    fn: T\n  ): ReturnType<T> {\n    return fn();\n  }\n\n  /**\n   * Bind a Span as the target's scope\n   * @param target An object to bind the scope.\n   * @param _span A specific Span to use. Otherwise, use the current one.\n   */\n  bind<T>(target: T, _span?: Span): T {\n    return target;\n  }\n\n  /**\n   * Send a pre-populated Span object to the exporter.\n   * @param _span The span to pass along.\n   */\n  recordSpanData(_span: Span): void {\n    /* NOOP */\n  }\n\n  /**\n   * Returns the BinaryFormat interface for serializing/deserializing Spans.\n   */\n  getBinaryFormat(): BinaryFormat {\n    return new NoOpBinaryFormat();\n  }\n\n  /**\n   * Returns the HttpTextFormat interface for injecting/extracting Spans.\n   */\n  getHttpTextFormat(): HttpTextFormat {\n    return new NoOpHttpTextFormat();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tracer } from \"../interfaces/tracer\";\nimport { getGlobalObject } from \"./global\";\n\nconst GLOBAL_TRACER_VERSION = 1;\nconst GLOBAL_TRACER_SYMBOL = Symbol.for(\"@azure/core-tracing.tracerCache\");\n\nexport interface TracerCache {\n  version: number;\n  tracer?: Tracer;\n}\n\nlet cache: TracerCache;\n\nfunction loadTracerCache(): void {\n  const globalObj = getGlobalObject();\n  const existingCache: TracerCache = globalObj[GLOBAL_TRACER_SYMBOL];\n  if (existingCache) {\n    if (existingCache.version !== GLOBAL_TRACER_VERSION) {\n      throw new Error(\n        `Two incompatible versions of @azure/core-tracing have been loaded.\n         This library is ${GLOBAL_TRACER_VERSION}, existing is ${existingCache.version}.`\n      );\n    }\n    cache = existingCache;\n  } else {\n    cache = {\n      tracer: undefined,\n      version: GLOBAL_TRACER_VERSION\n    };\n    globalObj[GLOBAL_TRACER_SYMBOL] = cache;\n  }\n}\n\nexport function getCache(): TracerCache {\n  if (!cache) {\n    loadTracerCache();\n  }\n  return cache;\n}\n","/*!\n * Copyright 2019, OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The status of a Span by providing a standard CanonicalCode in conjunction\n * with an optional descriptive message.\n */\nexport interface Status {\n  /** The canonical code of this message. */\n  code: CanonicalCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of canonical status codes.\n *\n * TODO (revision): https://github.com/open-telemetry/opentelemetry-specification/issues/59\n */\nexport enum CanonicalCode {\n  /**\n   * Not an error; returned on success\n   */\n  OK = 0,\n  /**\n   * The operation was cancelled (typically by the caller).\n   */\n  CANCELLED = 1,\n  /**\n   * Unknown error.  An example of where this error may be returned is\n   * if a status value received from another address space belongs to\n   * an error-space that is not known in this address space.  Also\n   * errors raised by APIs that do not return enough error information\n   * may be converted to this error.\n   */\n  UNKNOWN = 2,\n  /**\n   * Client specified an invalid argument.  Note that this differs\n   * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments\n   * that are problematic regardless of the state of the system\n   * (e.g., a malformed file name).\n   */\n  INVALID_ARGUMENT = 3,\n  /**\n   * Deadline expired before operation could complete.  For operations\n   * that change the state of the system, this error may be returned\n   * even if the operation has completed successfully.  For example, a\n   * successful response from a server could have been delayed long\n   * enough for the deadline to expire.\n   */\n  DEADLINE_EXCEEDED = 4,\n  /**\n   * Some requested entity (e.g., file or directory) was not found.\n   */\n  NOT_FOUND = 5,\n  /**\n   * Some entity that we attempted to create (e.g., file or directory)\n   * already exists.\n   */\n  ALREADY_EXISTS = 6,\n  /**\n   * The caller does not have permission to execute the specified\n   * operation.  PERMISSION_DENIED must not be used for rejections\n   * caused by exhausting some resource (use RESOURCE_EXHAUSTED\n   * instead for those errors).  PERMISSION_DENIED must not be\n   * used if the caller can not be identified (use UNAUTHENTICATED\n   * instead for those errors).\n   */\n  PERMISSION_DENIED = 7,\n  /**\n   * Some resource has been exhausted, perhaps a per-user quota, or\n   * perhaps the entire file system is out of space.\n   */\n  RESOURCE_EXHAUSTED = 8,\n  /**\n   * Operation was rejected because the system is not in a state\n   * required for the operation's execution.  For example, directory\n   * to be deleted may be non-empty, an rmdir operation is applied to\n   * a non-directory, etc.\n   *\n   * A litmus test that may help a service implementor in deciding\n   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n   *\n   *  - Use UNAVAILABLE if the client can retry just the failing call.\n   *  - Use ABORTED if the client should retry at a higher-level\n   *    (e.g., restarting a read-modify-write sequence).\n   *  - Use FAILED_PRECONDITION if the client should not retry until\n   *    the system state has been explicitly fixed.  E.g., if an \"rmdir\"\n   *    fails because the directory is non-empty, FAILED_PRECONDITION\n   *    should be returned since the client should not retry unless\n   *    they have first fixed up the directory by deleting files from it.\n   *  - Use FAILED_PRECONDITION if the client performs conditional\n   *    REST Get/Update/Delete on a resource and the resource on the\n   *    server does not match the condition. E.g., conflicting\n   *    read-modify-write on the same resource.\n   */\n  FAILED_PRECONDITION = 9,\n  /**\n   * The operation was aborted, typically due to a concurrency issue\n   * like sequencer check failures, transaction aborts, etc.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION,\n   * ABORTED, and UNAVAILABLE.\n   */\n  ABORTED = 10,\n  /**\n   * Operation was attempted past the valid range.  E.g., seeking or\n   * reading past end of file.\n   *\n   * Unlike INVALID_ARGUMENT, this error indicates a problem that may\n   * be fixed if the system state changes. For example, a 32-bit file\n   * system will generate INVALID_ARGUMENT if asked to read at an\n   * offset that is not in the range [0,2^32-1], but it will generate\n   * OUT_OF_RANGE if asked to read from an offset past the current\n   * file size.\n   *\n   * There is a fair bit of overlap between FAILED_PRECONDITION and\n   * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific\n   * error) when it applies so that callers who are iterating through\n   * a space can easily look for an OUT_OF_RANGE error to detect when\n   * they are done.\n   */\n  OUT_OF_RANGE = 11,\n  /**\n   * Operation is not implemented or not supported/enabled in this service.\n   */\n  UNIMPLEMENTED = 12,\n  /**\n   * Internal errors.  Means some invariants expected by underlying\n   * system has been broken.  If you see one of these errors,\n   * something is very broken.\n   */\n  INTERNAL = 13,\n  /**\n   * The service is currently unavailable.  This is a most likely a\n   * transient condition and may be corrected by retrying with\n   * a backoff.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION,\n   * ABORTED, and UNAVAILABLE.\n   */\n  UNAVAILABLE = 14,\n  /**\n   * Unrecoverable data loss or corruption.\n   */\n  DATA_LOSS = 15,\n  /**\n   * The request does not have valid authentication credentials for the\n   * operation.\n   */\n  UNAUTHENTICATED = 16,\n}\n","/*!\n * Copyright 2019, OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Type of span. Can be used to specify additional relationships between spans\n * in addition to a parent/child relationship.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n","/*!\n * Copyright 2019, OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * An enumeration that represents global trace flags. These flags are\n * propagated to all child {@link Span}. These determine features such as\n * whether a Span should be traced. It is implemented as a bitmask.\n */\nexport enum TraceFlags {\n  /** Bit to represent whether trace is unsampled in trace flags. */\n  UNSAMPLED = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1,\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nexport function getGlobalObject(): any {\n  return self;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { NoOpTracer } from \"./tracers/noop/noOpTracer\";\nimport { Tracer } from \"./interfaces/tracer\";\nimport { getCache } from \"./utils/cache\";\n\n/**\n * Sets the global tracer, enabling tracing for the Azure SDK.\n * @param tracer An OpenTelemetry Tracer instance.\n */\nexport function setTracer(tracer: Tracer) {\n  const cache = getCache();\n  cache.tracer = tracer;\n}\n\n/**\n * Retrieves the active tracer, or returns a\n * no-op implementation if one is not set.\n */\nexport function getTracer() {\n  const cache = getCache();\n  if (!cache.tracer) {\n    cache.tracer = new NoOpTracer();\n  }\n  return cache.tracer;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SpanContext } from \"../interfaces/span_context\";\nimport { TraceFlags } from \"../interfaces/trace_flags\";\n\nconst VERSION = \"00\";\n\n/**\n * Generates a `SpanContext` given a `traceparent` header value.\n * @param traceParent Serialized span context data as a `traceparent` header value.\n * @returns The `SpanContext` generated from the `traceparent` value.\n */\nexport function extractSpanContextFromTraceParentHeader(\n  traceParentHeader: string\n): SpanContext | undefined {\n  const parts = traceParentHeader.split(\"-\");\n\n  if (parts.length !== 4) {\n    return;\n  }\n\n  const [version, traceId, spanId, traceOptions] = parts;\n\n  if (version !== VERSION) {\n    return;\n  }\n\n  const traceFlags = parseInt(traceOptions, 16);\n\n  const spanContext: SpanContext = {\n    spanId,\n    traceId,\n    traceFlags\n  };\n\n  return spanContext;\n}\n\n/**\n * Generates a `traceparent` value given a span context.\n * @param spanContext Contains context for a specific span.\n * @returns The `spanContext` represented as a `traceparent` value.\n */\nexport function getTraceParentHeader(spanContext: SpanContext): string | undefined {\n  const missingFields: string[] = [];\n  if (!spanContext.traceId) {\n    missingFields.push(\"traceId\");\n  }\n  if (!spanContext.spanId) {\n    missingFields.push(\"spanId\");\n  }\n\n  if (missingFields.length) {\n    return;\n  }\n\n  const flags = spanContext.traceFlags || TraceFlags.UNSAMPLED;\n  const hexFlags = flags.toString(16);\n  const traceFlags = hexFlags.length === 1 ? `0${hexFlags}` : hexFlags;\n\n  // https://www.w3.org/TR/trace-context/#traceparent-header-field-values\n  return `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-${traceFlags}`;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { GetTokenOptions } from \"@azure/core-http\";\nimport { getTracer, Span, SpanOptions, SpanKind } from \"@azure/core-tracing\";\n\n/**\n * Creates a span using the global tracer.\n * @param name The name of the operation being performed.\n * @param options The options for the underlying http request.\n */\nexport function createSpan(\n  operationName: string,\n  options: GetTokenOptions = {}\n): { span: Span; options: GetTokenOptions } {\n  const tracer = getTracer();\n  const spanOptions: SpanOptions = {\n    ...options.spanOptions,\n    kind: SpanKind.CLIENT\n  };\n\n  const span = tracer.startSpan(`Azure.Identity.${operationName}`, spanOptions);\n  span.setAttribute(\"component\", \"identity\");\n\n  let newOptions = options;\n  if (span.isRecordingEvents()) {\n    newOptions = {\n      ...options,\n      spanOptions: {\n        ...options.spanOptions,\n        parent: span\n      }\n    };\n  }\n\n  return {\n    span,\n    options: newOptions\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AccessToken, TokenCredential, GetTokenOptions } from \"@azure/core-http\";\nimport { AggregateAuthenticationError } from \"../client/errors\";\nimport { createSpan } from \"../util/tracing\";\nimport { CanonicalCode } from \"@azure/core-tracing\";\n\n/**\n * Enables multiple {@link TokenCredential} implementations to be tried in order\n * until one of the getToken methods returns an {@link AccessToken}.\n */\nexport class ChainedTokenCredential implements TokenCredential {\n  private _sources: TokenCredential[] = [];\n\n  constructor(...sources: TokenCredential[]) {\n    this._sources = sources;\n  }\n\n  /**\n   * Returns the first {@link AccessToken} returned by one of the chained\n   * {@link TokenCredential} implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an {@link AccessToken}.\n   *\n   * @param scopes The list of scopes for which the token will have access.\n   * @param options The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  async getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    let token = null;\n    const errors = [];\n\n    const { span, options: newOptions } = createSpan(\"ChainedTokenCredential-getToken\", options);\n\n    for (let i = 0; i < this._sources.length && token === null; i++) {\n      try {\n        token = await this._sources[i].getToken(scopes, newOptions);\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n\n    if (!token && errors.length > 0) {\n      const err = new AggregateAuthenticationError(errors);\n      span.setStatus({\n        code: CanonicalCode.UNAUTHENTICATED,\n        message: err.message\n      });\n      throw err;\n    }\n\n    span.end();\n\n    return token;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { AccessToken, TokenCredential, GetTokenOptions } from \"@azure/core-http\";\nimport { IdentityClientOptions } from \"../client/identityClient\";\n\nconst BrowserNotSupportedError = new Error(\n  \"EnvironmentCredential is not supported in the browser.\"\n);\n\nexport class EnvironmentCredential implements TokenCredential {\n  constructor(options?: IdentityClientOptions) {\n    throw BrowserNotSupportedError;\n  }\n\n  getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null> {\n    throw BrowserNotSupportedError;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-http\";\nimport { IdentityClientOptions } from \"../client/identityClient\";\n\nconst BrowserNotSupportedError = new Error(\n  \"ManagedIdentityCredential is not supported in the browser.\"\n);\n\nexport class ManagedIdentityCredential implements TokenCredential {\n  constructor(clientId: string, options?: IdentityClientOptions);\n  constructor(options?: IdentityClientOptions);  \n  constructor(clientIdOrOptions: string | IdentityClientOptions | undefined, options?: IdentityClientOptions) {\n    throw BrowserNotSupportedError;\n  }\n\n  public async getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    throw BrowserNotSupportedError;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { IdentityClientOptions } from \"../client/identityClient\";\nimport { ChainedTokenCredential } from \"./chainedTokenCredential\";\nimport { EnvironmentCredential } from \"./environmentCredential\";\nimport { ManagedIdentityCredential } from \"./managedIdentityCredential\";\n\n/**\n * Provides a default {@link ChainedTokenCredential} configuration for\n * applications that will be deployed to Azure.  The following credential\n * types will be tried, in order:\n *\n * - {@link EnvironmentCredential}\n * - {@link ManagedIdentityCredential}\n *\n * Consult the documentation of these credential types for more information\n * on how they attempt authentication.\n */\nexport class DefaultAzureCredential extends ChainedTokenCredential {\n  /**\n   * Creates an instance of the DefaultAzureCredential class.\n   *\n   * @param options Options for configuring the client which makes the authentication request.\n   */\n  constructor(identityClientOptions?: IdentityClientOptions) {\n    super(\n      new EnvironmentCredential(identityClientOptions),\n      new ManagedIdentityCredential(identityClientOptions)\n    );\n  }\n}\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (isArray(target)) {\n            target.push(source);\n        } else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, decoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar encode = function encode(str, defaultEncoder, charset) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    } else if (typeof str !== 'string') {\n        string = String(str);\n    }\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b) {\n    return [].concat(a, b);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    merge: merge\n};\n","'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nvar util = require('./utils');\n\nvar Format = {\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\nmodule.exports = util.assign(\n    {\n        'default': Format.RFC3986,\n        formatters: {\n            RFC1738: function (value) {\n                return replace.call(value, percentTwenties, '+');\n            },\n            RFC3986: function (value) {\n                return String(value);\n            }\n        }\n    },\n    Format\n);\n","'use strict';\n\nvar utils = require('./utils');\nvar formats = require('./formats');\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaultFormat = formats['default'];\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) { // eslint-disable-line func-name-matching\n    return typeof v === 'string'\n        || typeof v === 'number'\n        || typeof v === 'boolean'\n        || typeof v === 'symbol'\n        || typeof v === 'bigint'; // eslint-disable-line valid-typeof\n};\n\nvar stringify = function stringify( // eslint-disable-line func-name-matching\n    object,\n    prefix,\n    generateArrayPrefix,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    formatter,\n    encodeValuesOnly,\n    charset\n) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = obj.join(',');\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (isArray(obj)) {\n            pushToArray(values, stringify(\n                obj[key],\n                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        } else {\n            pushToArray(values, stringify(\n                obj[key],\n                prefix + (allowDots ? '.' + key : '[' + key + ']'),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        }\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if (opts && 'indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('✓')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n","'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\n// This is what browsers will submit when the ✓ character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the ✓ character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = {};\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);\n            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(val);\n        }\n\n        if (val && options.comma && val.indexOf(',') > -1) {\n            val = val.split(',');\n        }\n\n        if (has.call(obj, key)) {\n            obj[key] = utils.combine(obj[key], val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options) {\n    var leaf = val;\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            obj = [].concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (!options.parseArrays && cleanRoot === '') {\n                obj = { 0: leaf };\n            } else if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = options.depth > 0 && brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    return {\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    return utils.compact(obj);\n};\n","'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * A collection of HttpHeaders that can be sent with a HTTP request.\n */\nfunction getHeaderKey(headerName: string) {\n  return headerName.toLowerCase();\n}\n\n/**\n * An individual header within a HttpHeaders collection.\n */\nexport interface HttpHeader {\n  /**\n   * The name of the header.\n   */\n  name: string;\n\n  /**\n   * The value of the header.\n   */\n  value: string;\n}\n\n/**\n * A HttpHeaders collection represented as a simple JSON object.\n */\nexport type RawHttpHeaders = { [headerName: string]: string };\n\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport class HttpHeaders {\n  private readonly _headersMap: { [headerKey: string]: HttpHeader };\n\n  constructor(rawHeaders?: RawHttpHeaders) {\n    this._headersMap = {};\n    if (rawHeaders) {\n      for (const headerName in rawHeaders) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName The name of the header to set. This value is case-insensitive.\n   * @param headerValue The value of the header to set.\n   */\n  public set(headerName: string, headerValue: string | number): void {\n    this._headersMap[getHeaderKey(headerName)] = {\n      name: headerName,\n      value: headerValue.toString()\n    };\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName The name of the header.\n   */\n  public get(headerName: string): string | undefined {\n    const header: HttpHeader = this._headersMap[getHeaderKey(headerName)];\n    return !header ? undefined : header.value;\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  public contains(headerName: string): boolean {\n    return !!this._headersMap[getHeaderKey(headerName)];\n  }\n\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName The name of the header to remove.\n   */\n  public remove(headerName: string): boolean {\n    const result: boolean = this.contains(headerName);\n    delete this._headersMap[getHeaderKey(headerName)];\n    return result;\n  }\n\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  public rawHeaders(): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    for (const headerKey in this._headersMap) {\n      const header: HttpHeader = this._headersMap[headerKey];\n      result[header.name.toLowerCase()] = header.value;\n    }\n    return result;\n  }\n\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  public headersArray(): HttpHeader[] {\n    const headers: HttpHeader[] = [];\n    for (const headerKey in this._headersMap) {\n      headers.push(this._headersMap[headerKey]);\n    }\n    return headers;\n  }\n\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  public headerNames(): string[] {\n    const headerNames: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerNames.push(headers[i].name);\n    }\n    return headerNames;\n  }\n\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  public headerValues(): string[] {\n    const headerValues: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerValues.push(headers[i].value);\n    }\n    return headerValues;\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJson(): RawHttpHeaders {\n    return this.rawHeaders();\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJson());\n  }\n\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  public clone(): HttpHeaders {\n    return new HttpHeaders(this.rawHeaders());\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * Encodes a string in base64 format.\n * @param value the string to encode\n */\nexport function encodeString(value: string): string {\n  return btoa(value);\n}\n\n/**\n * Encodes a byte array in base64 format.\n * @param value the Uint8Aray to encode\n */\nexport function encodeByteArray(value: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < value.length; i++) {\n    str += String.fromCharCode(value[i]);\n  }\n  return btoa(str);\n}\n\n/**\n * Decodes a base64 string into a byte array.\n * @param value the base64 string to decode\n */\nexport function decodeString(value: string): Uint8Array {\n  const byteString = atob(value);\n  const arr = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    arr[i] = byteString.charCodeAt(i);\n  }\n  return arr;\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport const Constants = {\n  /**\n   * The core-http version\n   * @const\n   * @type {string}\n   */\n  coreHttpVersion: \"1.0.0-preview.2\",\n\n  /**\n   * Specifies HTTP.\n   *\n   * @const\n   * @type {string}\n   */\n  HTTP: \"http:\",\n\n  /**\n   * Specifies HTTPS.\n   *\n   * @const\n   * @type {string}\n   */\n  HTTPS: \"https:\",\n\n  /**\n   * Specifies HTTP Proxy.\n   *\n   * @const\n   * @type {string}\n   */\n  HTTP_PROXY: \"HTTP_PROXY\",\n\n  /**\n   * Specifies HTTPS Proxy.\n   *\n   * @const\n   * @type {string}\n   */\n  HTTPS_PROXY: \"HTTPS_PROXY\",\n\n  HttpConstants: {\n    /**\n     * Http Verbs\n     *\n     * @const\n     * @enum {string}\n     */\n    HttpVerbs: {\n      PUT: \"PUT\",\n      GET: \"GET\",\n      DELETE: \"DELETE\",\n      POST: \"POST\",\n      MERGE: \"MERGE\",\n      HEAD: \"HEAD\",\n      PATCH: \"PATCH\"\n    },\n\n    StatusCodes: {\n      TooManyRequests: 429\n    }\n  },\n\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     *\n     * @const\n     * @type {string}\n     */\n    AUTHORIZATION: \"authorization\",\n\n    AUTHORIZATION_SCHEME: \"Bearer\",\n\n    /**\n     * The Retry-After response-header field can be used with a 503 (Service\n     * Unavailable) or 349 (Too Many Requests) responses to indicate how long\n     * the service is expected to be unavailable to the requesting client.\n     *\n     * @const\n     * @type {string}\n     */\n    RETRY_AFTER: \"Retry-After\",\n\n    /**\n     * The UserAgent header.\n     *\n     * @const\n     * @type {string}\n     */\n    USER_AGENT: \"User-Agent\"\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport uuidv4 from \"uuid/v4\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { RestError } from \"../restError\";\nimport { WebResource } from \"../webResource\";\nimport { Constants } from \"./constants\";\n\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/gi;\n\n/**\n * A constant that indicates whether the environment is node.js or browser based.\n */\nexport const isNode =\n  typeof process !== \"undefined\" &&\n  !!process.version &&\n  !!process.versions &&\n  !!process.versions.node;\n\n/**\n * Checks if a parsed URL is HTTPS\n *\n * @param {object} urlToCheck The url to check\n * @return {boolean} True if the URL is HTTPS; false otherwise.\n */\nexport function urlIsHTTPS(urlToCheck: { protocol: string }): boolean {\n  return urlToCheck.protocol.toLowerCase() === Constants.HTTPS;\n}\n\n/**\n * Encodes an URI.\n *\n * @param {string} uri The URI to be encoded.\n * @return {string} The encoded URI.\n */\nexport function encodeUri(uri: string): string {\n  return encodeURIComponent(uri)\n    .replace(/!/g, \"%21\")\n    .replace(/\"/g, \"%27\")\n    .replace(/\\(/g, \"%28\")\n    .replace(/\\)/g, \"%29\")\n    .replace(/\\*/g, \"%2A\");\n}\n\n/**\n * Returns a stripped version of the Http Response which only contains body,\n * headers and the status.\n *\n * @param {HttpOperationResponse} response The Http Response\n *\n * @return {object} The stripped version of Http Response.\n */\nexport function stripResponse(response: HttpOperationResponse): any {\n  const strippedResponse: any = {};\n  strippedResponse.body = response.bodyAsText;\n  strippedResponse.headers = response.headers;\n  strippedResponse.status = response.status;\n  return strippedResponse;\n}\n\n/**\n * Returns a stripped version of the Http Request that does not contain the\n * Authorization header.\n *\n * @param {WebResource} request The Http Request object\n *\n * @return {WebResource} The stripped version of Http Request.\n */\nexport function stripRequest(request: WebResource): WebResource {\n  const strippedRequest = request.clone();\n  if (strippedRequest.headers) {\n    strippedRequest.headers.remove(\"authorization\");\n  }\n  return strippedRequest;\n}\n\n/**\n * Validates the given uuid as a string\n *\n * @param {string} uuid The uuid as a string that needs to be validated\n *\n * @return {boolean} True if the uuid is valid; false otherwise.\n */\nexport function isValidUuid(uuid: string): boolean {\n  return validUuidRegex.test(uuid);\n}\n\n/**\n * Generated UUID\n *\n * @return {string} RFC4122 v4 UUID.\n */\nexport function generateUuid(): string {\n  return uuidv4();\n}\n\n/**\n * Executes an array of promises sequentially. Inspiration of this method is here:\n * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!\n *\n * @param {Array} promiseFactories An array of promise factories(A function that return a promise)\n *\n * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.\n * If not provided then the promise chain starts with undefined.\n *\n * @return A chain of resolved or rejected promises\n */\nexport function executePromisesSequentially(promiseFactories: Array<any>, kickstart: any) {\n  let result = Promise.resolve(kickstart);\n  promiseFactories.forEach((promiseFactory) => {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @param {number} t The number of milliseconds to be delayed.\n * @param {T} value The value to be resolved with after a timeout of t milliseconds.\n * @returns {Promise<T>} Resolved promise\n */\nexport function delay<T>(t: number, value?: T): Promise<T> {\n  return new Promise((resolve) => setTimeout(() => resolve(value), t));\n}\n\n/**\n * Service callback that is returned for REST requests initiated by the service client.\n */\nexport interface ServiceCallback<TResult> {\n  /**\n   * A method that will be invoked as a callback to a service function.\n   * @param {Error | RestError | null} err The error occurred if any, while executing the request; otherwise null.\n   * @param {TResult} [result] The deserialized response body if an error did not occur.\n   * @param {WebResource} [request] The raw/actual request sent to the server if an error did not occur.\n   * @param {HttpOperationResponse} [response] The raw/actual response from the server if an error did not occur.\n   */\n  (\n    err: Error | RestError | null,\n    result?: TResult,\n    request?: WebResource,\n    response?: HttpOperationResponse\n  ): void;\n}\n\n/**\n * Converts a Promise to a callback.\n * @param {Promise<any>} promise The Promise to be converted to a callback\n * @returns {Function} A function that takes the callback (cb: Function): void\n * @deprecated generated code should instead depend on responseToBody\n */\nexport function promiseToCallback(promise: Promise<any>): Function {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n  return (cb: Function): void => {\n    promise.then(\n      (data: any) => {\n        cb(undefined, data);\n      },\n      (err: Error) => {\n        cb(err);\n      }\n    );\n  };\n}\n\n/**\n * Converts a Promise to a service callback.\n * @param {Promise<HttpOperationResponse>} promise - The Promise of HttpOperationResponse to be converted to a service callback\n * @returns {Function} A function that takes the service callback (cb: ServiceCallback<T>): void\n */\nexport function promiseToServiceCallback<T>(promise: Promise<HttpOperationResponse>): Function {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n  return (cb: ServiceCallback<T>): void => {\n    promise.then(\n      (data: HttpOperationResponse) => {\n        process.nextTick(cb, undefined, data.parsedBody as T, data.request, data);\n      },\n      (err: Error) => {\n        process.nextTick(cb, err);\n      }\n    );\n  };\n}\n\nexport function prepareXMLRootList(obj: any, elementName: string) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  return { [elementName]: obj };\n}\n\n/**\n * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor\n * @param {object} targetCtor The target object on which the properties need to be applied.\n * @param {Array<object>} sourceCtors An array of source objects from which the properties need to be taken.\n */\nexport function applyMixins(targetCtor: any, sourceCtors: any[]): void {\n  sourceCtors.forEach((sourceCtors) => {\n    Object.getOwnPropertyNames(sourceCtors.prototype).forEach((name) => {\n      targetCtor.prototype[name] = sourceCtors.prototype[name];\n    });\n  });\n}\n\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n/**\n * Indicates whether the given string is in ISO 8601 format.\n * @param {string} value The value to be validated for ISO 8601 duration format.\n * @return {boolean} `true` if valid, `false` otherwise.\n */\nexport function isDuration(value: string): boolean {\n  return validateISODuration.test(value);\n}\n\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param {string | undefined} value The value to search and replace in.\n * @param {string} searchValue The value to search for in the value argument.\n * @param {string} replaceValue The value to replace searchValue with in the value argument.\n * @returns {string | undefined} The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(\n  value: string | undefined,\n  searchValue: string,\n  replaceValue: string\n): string | undefined {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}\n\n/**\n * Determines whether the given entity is a basic/primitive type\n * (string, number, boolean, null, undefined).\n * @param {any} value Any entity\n * @return {boolean} - true is it is primitive type, false otherwise.\n */\nexport function isPrimitiveType(value: any): boolean {\n  return (typeof value !== \"object\" && typeof value !== \"function\") || value === null;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\n\nexport class Serializer {\n  constructor(\n    public readonly modelMappers: { [key: string]: any } = {},\n    public readonly isXML?: boolean\n  ) {}\n\n  validateConstraints(mapper: Mapper, value: any, objectName: string): void {\n    const failValidation = (constraintName: keyof MapperConstraints, constraintValue: any) => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`\n      );\n    };\n    if (mapper.constraints && value != undefined) {\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems\n      } = mapper.constraints;\n      if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum != undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum != undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      if (MaxItems != undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength != undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems != undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength != undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf != undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        value.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param {Mapper} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized\n   *\n   * @param {string} objectName Name of the serialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object\n   */\n  serialize(mapper: Mapper, object: any, objectName?: string): any {\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/gi) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && object == undefined) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      // Validate Constraints if any\n      this.validateConstraints(mapper, object, objectName);\n      if (mapperType.match(/^any$/gi) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/gi) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/gi) !== null) {\n        const enumMapper: EnumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/gi) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/gi) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/gi) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/gi) !== null) {\n        payload = serializeSequenceType(this, mapper as SequenceMapper, object, objectName);\n      } else if (mapperType.match(/^Dictionary$/gi) !== null) {\n        payload = serializeDictionaryType(this, mapper as DictionaryMapper, object, objectName);\n      } else if (mapperType.match(/^Composite$/gi) !== null) {\n        payload = serializeCompositeType(this, mapper as CompositeMapper, object, objectName);\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param {object} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized\n   *\n   * @param {string} objectName Name of the deserialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object\n   */\n  deserialize(mapper: Mapper, responseBody: any, objectName: string): any {\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/gi) !== null) {\n      payload = deserializeCompositeType(this, mapper as CompositeMapper, responseBody, objectName);\n    } else {\n      if (this.isXML) {\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\") and body (\"_\") properties, then just reduce the responseBody value to\n         * the body (\"_\") property.\n         */\n        if (responseBody[\"$\"] != undefined && responseBody[\"_\"] != undefined) {\n          responseBody = responseBody[\"_\"];\n        }\n      }\n\n      if (mapperType.match(/^Number$/gi) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/gi) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/gi) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/gi) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/gi) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/gi) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/gi) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/gi) !== null) {\n        payload = deserializeSequenceType(this, mapper as SequenceMapper, responseBody, objectName);\n      } else if (mapperType.match(/^Dictionary$/gi) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\nfunction trimEnd(str: string, ch: string) {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: any): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\")\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/gi) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/gi) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/gi) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`\n        );\n      }\n    } else if (typeName.match(/^Boolean$/gi) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/gi) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        objectType !== \"function\" &&\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        !(typeof Blob === \"function\" && value instanceof Blob)\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues\n      )}.`\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: any): any {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: any): any {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/gi) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`\n        );\n      }\n      value = value;\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string\n) {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  const elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    tempArray[i] = serializer.serialize(elementType, object[i], objectName);\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string\n) {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    tempDictionary[key] = serializer.serialize(valueType, object[key], objectName + \".\" + key);\n  }\n  return tempDictionary;\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer the serializer containing the entire set of mappers\n * @param mapper the composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const className = mapper.type.className;\n    if (!className) {\n      throw new Error(\n        `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n          mapper,\n          undefined,\n          2\n        )}\".`\n      );\n    }\n\n    const modelMapper = serializer.modelMappers[className];\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${className}\".`);\n    }\n    modelProps = modelMapper.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(\n            modelMapper\n          )}\" of type \"${className}\" for object \"${objectName}\".`\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string\n) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (childObject == undefined && object[key] != undefined) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          toSerialize == undefined\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName\n        );\n        if (serializedValue !== undefined && propName != undefined) {\n          if (propertyMapper.xmlIsAttribute) {\n            // $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject.$ = parentObject.$ || {};\n            parentObject.$[propName] = serializedValue;\n          } else if (propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: serializedValue };\n          } else {\n            parentObject[propName] = serializedValue;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = mapper.type.additionalProperties;\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]'\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction isSpecialXmlProperty(propertyName: string): boolean {\n  return [\"$\", \"_\"].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody.$) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody.$[xmlName!],\n          propertyObjectName\n        );\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        let unwrappedProperty = responseBody[propertyName!];\n        if (propertyMapper.xmlIsWrapped) {\n          unwrappedProperty = responseBody[xmlName!];\n          unwrappedProperty = unwrappedProperty && unwrappedProperty[xmlElementName!];\n\n          const isEmptyWrappedList = unwrappedProperty === undefined;\n          if (isEmptyWrappedList) {\n            unwrappedProperty = [];\n          }\n        }\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          unwrappedProperty,\n          propertyObjectName\n        );\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      for (const item of paths) {\n        if (!res) break;\n        res = res[item];\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        propertyInstance == undefined\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string) => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]'\n        );\n      }\n    }\n  } else if (responseBody) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  /*jshint validthis: true */\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  /*jshint validthis: true */\n  const element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`);\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\"\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      const discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        const typeName = mapper.type.uberParent || mapper.type.className;\n        const indexDiscriminator =\n          discriminatorValue === typeName\n            ? discriminatorValue\n            : typeName + \".\" + discriminatorValue;\n        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer: Serializer, typeName?: string) {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\nexport interface MapperConstraints {\n  InclusiveMaximum?: number;\n  ExclusiveMaximum?: number;\n  InclusiveMinimum?: number;\n  ExclusiveMinimum?: number;\n  MaxLength?: number;\n  MinLength?: number;\n  Pattern?: RegExp;\n  MaxItems?: number;\n  MinItems?: number;\n  UniqueItems?: true;\n  MultipleOf?: number;\n}\n\nexport type MapperType =\n  | SimpleMapperType\n  | CompositeMapperType\n  | SequenceMapperType\n  | DictionaryMapperType\n  | EnumMapperType;\n\nexport interface SimpleMapperType {\n  name:\n    | \"Base64Url\"\n    | \"Boolean\"\n    | \"ByteArray\"\n    | \"Date\"\n    | \"DateTime\"\n    | \"DateTimeRfc1123\"\n    | \"Object\"\n    | \"Stream\"\n    | \"String\"\n    | \"TimeSpan\"\n    | \"UnixTime\"\n    | \"Uuid\"\n    | \"Number\"\n    | \"any\";\n}\n\nexport interface CompositeMapperType {\n  name: \"Composite\";\n\n  // Only one of the two below properties should be present.\n  // Use className to reference another type definition,\n  // and use modelProperties/additionalProperties when the reference to the other type has been resolved.\n  className?: string;\n\n  modelProperties?: { [propertyName: string]: Mapper };\n  additionalProperties?: Mapper;\n\n  uberParent?: string;\n  polymorphicDiscriminator?: PolymorphicDiscriminator;\n}\n\nexport interface SequenceMapperType {\n  name: \"Sequence\";\n  element: Mapper;\n}\n\nexport interface DictionaryMapperType {\n  name: \"Dictionary\";\n  value: Mapper;\n}\n\nexport interface EnumMapperType {\n  name: \"Enum\";\n  allowedValues: any[];\n}\n\nexport interface BaseMapper {\n  xmlName?: string;\n  xmlIsAttribute?: boolean;\n  xmlElementName?: string;\n  xmlIsWrapped?: boolean;\n  readOnly?: boolean;\n  isConstant?: boolean;\n  required?: boolean;\n  nullable?: boolean;\n  serializedName?: string;\n  type: MapperType;\n  defaultValue?: any;\n  constraints?: MapperConstraints;\n}\n\nexport type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;\n\nexport interface PolymorphicDiscriminator {\n  serializedName: string;\n  clientName: string;\n  [key: string]: string;\n}\n\nexport interface CompositeMapper extends BaseMapper {\n  type: CompositeMapperType;\n}\n\nexport interface SequenceMapper extends BaseMapper {\n  type: SequenceMapperType;\n}\n\nexport interface DictionaryMapper extends BaseMapper {\n  type: DictionaryMapperType;\n  headerCollectionPrefix?: string;\n}\n\nexport interface EnumMapper extends BaseMapper {\n  type: EnumMapperType;\n}\n\nexport interface UrlParameterValue {\n  value: string;\n  skipUrlEncoding: boolean;\n}\n\n// TODO: why is this here?\nexport function serializeObject(toSerialize: any): any {\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    const array = [];\n    for (let i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    const dictionary: { [key: string]: any } = {};\n    for (const property in toSerialize) {\n      dictionary[property] = serializeObject(toSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum<T extends string>(o: Array<T>): { [K in T]: K } {\n  const result: any = {};\n  for (const key of o) {\n    result[key] = key;\n  }\n  return result;\n}\n\nexport const MapperType = strEnum([\n  \"Base64Url\",\n  \"Boolean\",\n  \"ByteArray\",\n  \"Composite\",\n  \"Date\",\n  \"DateTime\",\n  \"DateTimeRfc1123\",\n  \"Dictionary\",\n  \"Enum\",\n  \"Number\",\n  \"Object\",\n  \"Sequence\",\n  \"String\",\n  \"Stream\",\n  \"TimeSpan\",\n  \"UnixTime\"\n]);\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { OperationSpec } from \"./operationSpec\";\nimport { Mapper, Serializer } from \"./serializer\";\nimport { generateUuid } from \"./util/utils\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { ProxySettings } from \"./serviceClient\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { SpanOptions } from \"@azure/core-tracing\";\n\nexport type HttpMethods =\n  | \"GET\"\n  | \"PUT\"\n  | \"POST\"\n  | \"DELETE\"\n  | \"PATCH\"\n  | \"HEAD\"\n  | \"OPTIONS\"\n  | \"TRACE\";\nexport type HttpRequestBody =\n  | Blob\n  | string\n  | ArrayBuffer\n  | ArrayBufferView\n  | (() => NodeJS.ReadableStream);\n\n/**\n * Fired in response to upload or download progress.\n */\nexport type TransferProgressEvent = {\n  /**\n   * The number of bytes loaded so far.\n   */\n  loadedBytes: number;\n};\n\n/**\n * Creates a new WebResource object.\n *\n * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary\n * properties to initiate a request.\n *\n * @constructor\n */\nexport class WebResource {\n  url: string;\n  method: HttpMethods;\n  body?: any;\n  headers: HttpHeaders;\n  /**\n   * Whether or not the body of the HttpOperationResponse should be treated as a stream.\n   */\n  streamResponseBody?: boolean;\n  /**\n   * Whether or not the HttpOperationResponse should be deserialized. If this is undefined, then the\n   * HttpOperationResponse should be deserialized.\n   */\n  shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);\n  /**\n   * A function that returns the proper OperationResponse for the given OperationSpec and\n   * HttpOperationResponse combination. If this is undefined, then a simple status code lookup will\n   * be used.\n   */\n  operationResponseGetter?: (\n    operationSpec: OperationSpec,\n    response: HttpOperationResponse\n  ) => undefined | OperationResponse;\n  formData?: any;\n  query?: { [key: string]: any };\n  operationSpec?: OperationSpec;\n  withCredentials: boolean;\n  timeout: number;\n  proxySettings?: ProxySettings;\n  keepAlive?: boolean;\n\n  abortSignal?: AbortSignalLike;\n\n  /** Callback which fires upon upload progress. */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Options used to create a span when tracing is enabled.\n   */\n  spanOptions?: SpanOptions;\n\n  constructor(\n    url?: string,\n    method?: HttpMethods,\n    body?: any,\n    query?: { [key: string]: any },\n    headers?: { [key: string]: any } | HttpHeaders,\n    streamResponseBody?: boolean,\n    withCredentials?: boolean,\n    abortSignal?: AbortSignalLike,\n    timeout?: number,\n    onUploadProgress?: (progress: TransferProgressEvent) => void,\n    onDownloadProgress?: (progress: TransferProgressEvent) => void,\n    proxySettings?: ProxySettings,\n    keepAlive?: boolean\n  ) {\n    this.streamResponseBody = streamResponseBody;\n    this.url = url || \"\";\n    this.method = method || \"GET\";\n    this.headers = headers instanceof HttpHeaders ? headers : new HttpHeaders(headers);\n    this.body = body;\n    this.query = query;\n    this.formData = undefined;\n    this.withCredentials = withCredentials || false;\n    this.abortSignal = abortSignal;\n    this.timeout = timeout || 0;\n    this.onUploadProgress = onUploadProgress;\n    this.onDownloadProgress = onDownloadProgress;\n    this.proxySettings = proxySettings;\n    this.keepAlive = keepAlive;\n  }\n\n  /**\n   * Validates that the required properties such as method, url, headers[\"Content-Type\"],\n   * headers[\"accept-language\"] are defined. It will throw an error if one of the above\n   * mentioned properties are not defined.\n   */\n  validateRequestProperties(): void {\n    if (!this.method) {\n      throw new Error(\"WebResource.method is required.\");\n    }\n    if (!this.url) {\n      throw new Error(\"WebResource.url is required.\");\n    }\n  }\n\n  /**\n   * Prepares the request.\n   * @param {RequestPrepareOptions} options Options to provide for preparing the request.\n   * @returns {WebResource} Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.\n   */\n  prepare(options: RequestPrepareOptions): WebResource {\n    if (!options) {\n      throw new Error(\"options object is required\");\n    }\n\n    if (options.method == undefined || typeof options.method.valueOf() !== \"string\") {\n      throw new Error(\"options.method must be a string.\");\n    }\n\n    if (options.url && options.pathTemplate) {\n      throw new Error(\n        \"options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.\"\n      );\n    }\n\n    if (\n      (options.pathTemplate == undefined || typeof options.pathTemplate.valueOf() !== \"string\") &&\n      (options.url == undefined || typeof options.url.valueOf() !== \"string\")\n    ) {\n      throw new Error(\"Please provide exactly one of options.pathTemplate or options.url.\");\n    }\n\n    // set the url if it is provided.\n    if (options.url) {\n      if (typeof options.url !== \"string\") {\n        throw new Error('options.url must be of type \"string\".');\n      }\n      this.url = options.url;\n    }\n\n    // set the method\n    if (options.method) {\n      const validMethods = [\"GET\", \"PUT\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"POST\", \"PATCH\", \"TRACE\"];\n      if (validMethods.indexOf(options.method.toUpperCase()) === -1) {\n        throw new Error(\n          'The provided method \"' +\n            options.method +\n            '\" is invalid. Supported HTTP methods are: ' +\n            JSON.stringify(validMethods)\n        );\n      }\n    }\n    this.method = options.method.toUpperCase() as HttpMethods;\n\n    // construct the url if path template is provided\n    if (options.pathTemplate) {\n      const { pathTemplate, pathParameters } = options;\n      if (typeof pathTemplate !== \"string\") {\n        throw new Error('options.pathTemplate must be of type \"string\".');\n      }\n      if (!options.baseUrl) {\n        options.baseUrl = \"https://management.azure.com\";\n      }\n      const baseUrl = options.baseUrl;\n      let url =\n        baseUrl +\n        (baseUrl.endsWith(\"/\") ? \"\" : \"/\") +\n        (pathTemplate.startsWith(\"/\") ? pathTemplate.slice(1) : pathTemplate);\n      const segments = url.match(/({\\w*\\s*\\w*})/gi);\n      if (segments && segments.length) {\n        if (!pathParameters) {\n          throw new Error(\n            `pathTemplate: ${pathTemplate} has been provided. Hence, options.pathParameters must also be provided.`\n          );\n        }\n        segments.forEach(function(item) {\n          const pathParamName = item.slice(1, -1);\n          const pathParam = (pathParameters as { [key: string]: any })[pathParamName];\n          if (\n            pathParam === null ||\n            pathParam === undefined ||\n            !(typeof pathParam === \"string\" || typeof pathParam === \"object\")\n          ) {\n            const stringifiedPathParameters = JSON.stringify(pathParameters, undefined, 2);\n            throw new Error(\n              `pathTemplate: ${pathTemplate} contains the path parameter ${pathParamName}` +\n                ` however, it is not present in parameters: ${stringifiedPathParameters}.` +\n                `The value of the path parameter can either be a \"string\" of the form { ${pathParamName}: \"some sample value\" } or ` +\n                `it can be an \"object\" of the form { \"${pathParamName}\": { value: \"some sample value\", skipUrlEncoding: true } }.`\n            );\n          }\n\n          if (typeof pathParam.valueOf() === \"string\") {\n            url = url.replace(item, encodeURIComponent(pathParam));\n          }\n\n          if (typeof pathParam.valueOf() === \"object\") {\n            if (!pathParam.value) {\n              throw new Error(\n                `options.pathParameters[${pathParamName}] is of type \"object\" but it does not contain a \"value\" property.`\n              );\n            }\n            if (pathParam.skipUrlEncoding) {\n              url = url.replace(item, pathParam.value);\n            } else {\n              url = url.replace(item, encodeURIComponent(pathParam.value));\n            }\n          }\n        });\n      }\n      this.url = url;\n    }\n\n    // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.\n    if (options.queryParameters) {\n      const queryParameters = options.queryParameters;\n      if (typeof queryParameters !== \"object\") {\n        throw new Error(\n          `options.queryParameters must be of type object. It should be a JSON object ` +\n            `of \"query-parameter-name\" as the key and the \"query-parameter-value\" as the value. ` +\n            `The \"query-parameter-value\" may be fo type \"string\" or an \"object\" of the form { value: \"query-parameter-value\", skipUrlEncoding: true }.`\n        );\n      }\n      // append question mark if it is not present in the url\n      if (this.url && this.url.indexOf(\"?\") === -1) {\n        this.url += \"?\";\n      }\n      // construct queryString\n      const queryParams = [];\n      // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().\n      this.query = {};\n      for (const queryParamName in queryParameters) {\n        const queryParam: any = queryParameters[queryParamName];\n        if (queryParam) {\n          if (typeof queryParam === \"string\") {\n            queryParams.push(queryParamName + \"=\" + encodeURIComponent(queryParam));\n            this.query[queryParamName] = encodeURIComponent(queryParam);\n          } else if (typeof queryParam === \"object\") {\n            if (!queryParam.value) {\n              throw new Error(\n                `options.queryParameters[${queryParamName}] is of type \"object\" but it does not contain a \"value\" property.`\n              );\n            }\n            if (queryParam.skipUrlEncoding) {\n              queryParams.push(queryParamName + \"=\" + queryParam.value);\n              this.query[queryParamName] = queryParam.value;\n            } else {\n              queryParams.push(queryParamName + \"=\" + encodeURIComponent(queryParam.value));\n              this.query[queryParamName] = encodeURIComponent(queryParam.value);\n            }\n          }\n        }\n      } // end-of-for\n      // append the queryString\n      this.url += queryParams.join(\"&\");\n    }\n\n    // add headers to the request if they are provided\n    if (options.headers) {\n      const headers = options.headers;\n      for (const headerName of Object.keys(options.headers)) {\n        this.headers.set(headerName, headers[headerName]);\n      }\n    }\n    // ensure accept-language is set correctly\n    if (!this.headers.get(\"accept-language\")) {\n      this.headers.set(\"accept-language\", \"en-US\");\n    }\n    // ensure the request-id is set correctly\n    if (!this.headers.get(\"x-ms-client-request-id\") && !options.disableClientRequestId) {\n      this.headers.set(\"x-ms-client-request-id\", generateUuid());\n    }\n\n    // default\n    if (!this.headers.get(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n\n    // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicilty\n    this.body = options.body;\n    if (options.body != undefined) {\n      // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.\n      if (options.bodyIsStream) {\n        if (!this.headers.get(\"Transfer-Encoding\")) {\n          this.headers.set(\"Transfer-Encoding\", \"chunked\");\n        }\n        if (this.headers.get(\"Content-Type\") !== \"application/octet-stream\") {\n          this.headers.set(\"Content-Type\", \"application/octet-stream\");\n        }\n      } else {\n        if (options.serializationMapper) {\n          this.body = new Serializer(options.mappers).serialize(\n            options.serializationMapper,\n            options.body,\n            \"requestBody\"\n          );\n        }\n        if (!options.disableJsonStringifyOnBody) {\n          this.body = JSON.stringify(options.body);\n        }\n      }\n    }\n\n    if (options.spanOptions) {\n      this.spanOptions = options.spanOptions;\n    }\n\n    this.abortSignal = options.abortSignal;\n    this.onDownloadProgress = options.onDownloadProgress;\n    this.onUploadProgress = options.onUploadProgress;\n\n    return this;\n  }\n\n  /**\n   * Clone this WebResource HTTP request object.\n   * @returns {WebResource} The clone of this WebResource HTTP request object.\n   */\n  clone(): WebResource {\n    const result = new WebResource(\n      this.url,\n      this.method,\n      this.body,\n      this.query,\n      this.headers && this.headers.clone(),\n      this.streamResponseBody,\n      this.withCredentials,\n      this.abortSignal,\n      this.timeout,\n      this.onUploadProgress,\n      this.onDownloadProgress,\n      this.proxySettings,\n      this.keepAlive\n    );\n\n    if (this.formData) {\n      result.formData = this.formData;\n    }\n\n    if (this.operationSpec) {\n      result.operationSpec = this.operationSpec;\n    }\n\n    if (this.shouldDeserialize) {\n      result.shouldDeserialize = this.shouldDeserialize;\n    }\n\n    if (this.operationResponseGetter) {\n      result.operationResponseGetter = this.operationResponseGetter;\n    }\n\n    return result;\n  }\n}\n\nexport interface RequestPrepareOptions {\n  /**\n   * The HTTP request method. Valid values are \"GET\", \"PUT\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"POST\",\n   * or \"PATCH\".\n   */\n  method: HttpMethods;\n  /**\n   * The request url. It may or may not have query parameters in it. Either provide the \"url\" or\n   * provide the \"pathTemplate\" in the options object. Both the options are mutually exclusive.\n   */\n  url?: string;\n  /**\n   * A dictionary of query parameters to be appended to the url, where\n   * the \"key\" is the \"query-parameter-name\" and the \"value\" is the \"query-parameter-value\".\n   * The \"query-parameter-value\" can be of type \"string\" or it can be of type \"object\".\n   * The \"object\" format should be used when you want to skip url encoding. While using the object format,\n   * the object must have a property named value which provides the \"query-parameter-value\".\n   * Example:\n   *    - query-parameter-value in \"object\" format: { \"query-parameter-name\": { value: \"query-parameter-value\", skipUrlEncoding: true } }\n   *    - query-parameter-value in \"string\" format: { \"query-parameter-name\": \"query-parameter-value\"}.\n   * Note: \"If options.url already has some query parameters, then the value provided in options.queryParameters will be appended to the url.\n   */\n  queryParameters?: { [key: string]: any | ParameterValue };\n  /**\n   * The path template of the request url. Either provide the \"url\" or provide the \"pathTemplate\" in\n   * the options object. Both the options are mutually exclusive.\n   * Example: \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}\"\n   */\n  pathTemplate?: string;\n  /**\n   * The base url of the request. Default value is: \"https://management.azure.com\". This is\n   * applicable only with pathTemplate. If you are providing options.url then it is expected that\n   * you provide the complete url.\n   */\n  baseUrl?: string;\n  /**\n   * A dictionary of path parameters that need to be replaced with actual values in the pathTemplate.\n   * Here the key is the \"path-parameter-name\" and the value is the \"path-parameter-value\".\n   * The \"path-parameter-value\" can be of type \"string\"  or it can be of type \"object\".\n   * The \"object\" format should be used when you want to skip url encoding. While using the object format,\n   * the object must have a property named value which provides the \"path-parameter-value\".\n   * Example:\n   *    - path-parameter-value in \"object\" format: { \"path-parameter-name\": { value: \"path-parameter-value\", skipUrlEncoding: true } }\n   *    - path-parameter-value in \"string\" format: { \"path-parameter-name\": \"path-parameter-value\" }.\n   */\n  pathParameters?: { [key: string]: any | ParameterValue };\n  formData?: { [key: string]: any };\n  /**\n   * A dictionary of request headers that need to be applied to the request.\n   * Here the key is the \"header-name\" and the value is the \"header-value\". The header-value MUST be of type string.\n   *  - ContentType must be provided with the key name as \"Content-Type\". Default value \"application/json; charset=utf-8\".\n   *  - \"Transfer-Encoding\" is set to \"chunked\" by default if \"options.bodyIsStream\" is set to true.\n   *  - \"Content-Type\" is set to \"application/octet-stream\" by default if \"options.bodyIsStream\" is set to true.\n   *  - \"accept-language\" by default is set to \"en-US\"\n   *  - \"x-ms-client-request-id\" by default is set to a new Guid. To not generate a guid for the request, please set options.disableClientRequestId to true\n   */\n  headers?: { [key: string]: any };\n  /**\n   * When set to true, instructs the client to not set \"x-ms-client-request-id\" header to a new Guid().\n   */\n  disableClientRequestId?: boolean;\n  /**\n   * The request body. It can be of any type. This value will be serialized if it is not a stream.\n   */\n  body?: any;\n  /**\n   * Provides information on how to serialize the request body.\n   */\n  serializationMapper?: Mapper;\n  /**\n   * A dictionary of mappers that may be used while [de]serialization.\n   */\n  mappers?: { [x: string]: any };\n  /**\n   * Provides information on how to deserialize the response body.\n   */\n  deserializationMapper?: object;\n  /**\n   * Indicates whether this method should JSON.stringify() the request body. Default value: false.\n   */\n  disableJsonStringifyOnBody?: boolean;\n  /**\n   * Indicates whether the request body is a stream (useful for file upload scenarios).\n   */\n  bodyIsStream?: boolean;\n  abortSignal?: AbortSignalLike;\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n  spanOptions?: SpanOptions;\n}\n\n/**\n * The Parameter value provided for path or query parameters in RequestPrepareOptions\n */\nexport interface ParameterValue {\n  value: any;\n  skipUrlEncoding: boolean;\n  [key: string]: any;\n}\n\n/**\n * Describes the base structure of the options object that will be used in every operation.\n */\nexport interface RequestOptionsBase {\n  /**\n   * @property {object} [customHeaders] User defined custom request headers that\n   * will be applied before the request is sent.\n   */\n  customHeaders?: { [key: string]: string };\n\n  /**\n   * The signal which can be used to abort requests.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   */\n  timeout?: number;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Callback which fires upon download progress.\n   */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Options used to create a span when tracing is enabled.\n   */\n  spanOptions?: SpanOptions;\n\n  [key: string]: any;\n}\n","/// <reference path=\"./shims-public.d.ts\" />\ntype AbortEventListener = (this: AbortSignalLike, ev?: any) => any;\n\nconst listenersMap = new WeakMap<AbortSignal, AbortEventListener[]>();\nconst abortedMap = new WeakMap<AbortSignal, boolean>();\n\n/**\n * Allows the request to be aborted upon firing of the \"abort\" event.\n * Compatible with the browser built-in AbortSignal and common polyfills.\n */\nexport interface AbortSignalLike {\n  /**\n   * Indicates if the signal has already been aborted.\n   */\n  readonly aborted: boolean;\n  /**\n   * Add new \"abort\" event listener, only support \"abort\" event.\n   */\n  addEventListener(\n    type: \"abort\",\n    listener: (this: AbortSignalLike, ev: any) => any,\n    options?: any\n  ): void;\n  /**\n   * Remove \"abort\" event listener, only support \"abort\" event.\n   */\n  removeEventListener(\n    type: \"abort\",\n    listener: (this: AbortSignalLike, ev: any) => any,\n    options?: any\n  ): void;\n}\n\n/**\n * An aborter instance implements AbortSignal interface, can abort HTTP requests.\n *\n * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.\n * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation\n * cannot or will not ever be cancelled.\n *\n * @example\n * // Abort without timeout\n * await doAsyncWork(AbortSignal.none);\n *\n * @export\n * @class AbortSignal\n * @implements {AbortSignalLike}\n */\nexport class AbortSignal implements AbortSignalLike {\n  constructor() {\n    listenersMap.set(this, []);\n    abortedMap.set(this, false);\n  }\n\n  /**\n   * Status of whether aborted or not.\n   *\n   * @readonly\n   * @type {boolean}\n   * @memberof AbortSignal\n   */\n  public get aborted(): boolean {\n    if (!abortedMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n\n    return abortedMap.get(this)!;\n  }\n\n  /**\n   * Creates a new AbortSignal instance that will never be aborted.\n   *\n   * @readonly\n   * @static\n   * @type {AbortSignal}\n   * @memberof AbortSignal\n   */\n  public static get none(): AbortSignal {\n    return new AbortSignal();\n  }\n\n  /**\n   * onabort event listener.\n   *\n   * @memberof AbortSignal\n   */\n  public onabort: ((ev?: Event) => any) | null = null;\n\n  /**\n   * Added new \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof AbortSignal\n   */\n  public addEventListener(\n    // tslint:disable-next-line:variable-name\n    _type: \"abort\",\n    listener: (this: AbortSignalLike, ev: any) => any\n  ): void {\n    if (!listenersMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n\n    const listeners = listenersMap.get(this)!;\n    listeners.push(listener);\n  }\n\n  /**\n   * Remove \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof AbortSignal\n   */\n  public removeEventListener(\n    // tslint:disable-next-line:variable-name\n    _type: \"abort\",\n    listener: (this: AbortSignalLike, ev: any) => any\n  ): void {\n    if (!listenersMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n\n    const listeners = listenersMap.get(this)!;\n\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  /**\n    * Dispatches a synthetic event to the AbortSignal.\n    */\n  dispatchEvent(event: Event): boolean {\n    throw new Error(\"This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.\")\n  }\n}\n\n/**\n * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.\n * Will try to trigger abort event for all linked AbortSignal nodes.\n *\n * - If there is a timeout, the timer will be cancelled.\n * - If aborted is true, nothing will happen.\n *\n * @returns\n * @internal\n */\nexport function abortSignal(signal: AbortSignal) {\n  if (signal.aborted) {\n    return;\n  }\n\n  if (signal.onabort) {\n    signal.onabort.call(signal);\n  }\n\n  const listeners = listenersMap.get(signal)!;\n  if (listeners) {\n    listeners.forEach((listener) => {\n      listener.call(signal, { type: \"abort\" });\n    });\n  }\n\n  abortedMap.set(signal, true);\n}\n","import { AbortSignal, abortSignal, AbortSignalLike } from \"./AbortSignal\";\n\n/**\n * This error is thrown when an asynchronous operation has been aborted.\n * Check for this error by testing the `name` that the name property of the\n * error matches `\"AbortError\"`.\n *\n * @example\n * const controller = new AbortController();\n * controller.abort();\n * try {\n *   doAsyncWork(controller.signal)\n * } catch (e) {\n *   if (e.name === 'AbortError') {\n *     // handle abort error here.\n *   }\n * }\n */\nexport class AbortError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"AbortError\";\n  }\n}\n\n/**\n * An AbortController provides an AbortSignal and the associated controls to signal\n * that an asynchronous operation should be aborted.\n *\n * @example\n * // Abort an operation when another event fires\n * const controller = new AbortController();\n * const signal = controller.signal;\n * doAsyncWork(signal);\n * button.addEventListener('click', () => controller.abort());\n *\n * @example\n * // Share aborter cross multiple operations in 30s\n * // Upload the same data to 2 different data centers at the same time,\n * // abort another when any of them is finished\n * const controller = AbortController.withTimeout(30 * 1000);\n * doAsyncWork(controller.signal).then(controller.abort);\n * doAsyncWork(controller.signal).then(controller.abort);\n *\n * @example\n * // Cascaded aborting\n * // All operations can't take more than 30 seconds\n * const aborter = Aborter.timeout(30 * 1000);\n *\n * // Following 2 operations can't take more than 25 seconds\n * await doAsyncWork(aborter.withTimeout(25 * 1000));\n * await doAsyncWork(aborter.withTimeout(25 * 1000));\n *\n * @export\n * @class AbortController\n * @implements {AbortSignalLike}\n */\nexport class AbortController {\n  private _signal: AbortSignal;\n\n  /**\n   * @param {AbortSignalLike[]} [parentSignals] The AbortSignals that will signal aborted on the AbortSignal associated with this controller.\n   * @constructor\n   */\n  constructor(parentSignals?: AbortSignalLike[]);\n  /**\n   * @param {...AbortSignalLike} parentSignals The AbortSignals that will signal aborted on the AbortSignal associated with this controller.\n   * @constructor\n   */\n  constructor(...parentSignals: AbortSignalLike[]);\n  constructor(parentSignals?: any) {\n    this._signal = new AbortSignal();\n\n    if (!parentSignals) {\n      return;\n    }\n    // coerce parentSignals into an array\n    if (!Array.isArray(parentSignals)) {\n      parentSignals = arguments;\n    }\n    for (const parentSignal of parentSignals) {\n      // if the parent signal has already had abort() called,\n      // then call abort on this signal as well.\n      if (parentSignal.aborted) {\n        this.abort();\n      } else {\n        // when the parent signal aborts, this signal should as well.\n        parentSignal.addEventListener(\"abort\", () => {\n          this.abort();\n        });\n      }\n    }\n  }\n\n  /**\n   * The AbortSignal associated with this controller that will signal aborted\n   * when the abort method is called on this controller.\n   *\n   * @readonly\n   * @type {AbortSignal}\n   * @memberof AbortController\n   */\n  public get signal() {\n    return this._signal;\n  }\n\n  /**\n   * Signal that any operations passed this controller's associated abort signal\n   * to cancel any remaining work and throw an `AbortError`.\n   *\n   * @memberof AbortController\n   */\n  abort() {\n    abortSignal(this._signal);\n  }\n\n  /**\n   * Creates a new AbortSignal instance that will abort after the provided ms.\n   *\n   * @static\n   * @params {number} ms Elapsed time in milliseconds to trigger an abort.\n   * @returns {AbortSignal}\n   */\n  public static timeout(ms: number): AbortSignal {\n    const signal = new AbortSignal();\n    const timer = setTimeout(abortSignal, ms, signal);\n    // Prevent the active Timer from keeping the Node.js event loop active.\n    if (typeof timer.unref === \"function\") {\n      timer.unref();\n    }\n    return signal;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * The different levels of logs that can be used with the HttpPipelineLogger.\n */\nexport enum HttpPipelineLogLevel {\n  /**\n   * A log level that indicates that no logs will be logged.\n   */\n  OFF,\n\n  /**\n   * An error log.\n   */\n  ERROR,\n\n  /**\n   * A warning log.\n   */\n  WARNING,\n\n  /**\n   * An information log.\n   */\n  INFO\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { WebResource } from \"./webResource\";\n\nexport class RestError extends Error {\n  static readonly REQUEST_SEND_ERROR: string = \"REQUEST_SEND_ERROR\";\n  static readonly PARSE_ERROR: string = \"PARSE_ERROR\";\n\n  code?: string;\n  statusCode?: number;\n  request?: WebResource;\n  response?: HttpOperationResponse;\n  details?: unknown;\n  constructor(\n    message: string,\n    code?: string,\n    statusCode?: number,\n    request?: WebResource,\n    response?: HttpOperationResponse\n  ) {\n    super(message);\n    this.code = code;\n    this.statusCode = statusCode;\n    this.request = request;\n    this.response = response;\n\n    Object.setPrototypeOf(this, RestError.prototype);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { WebResource, TransferProgressEvent } from \"./webResource\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { RestError } from \"./restError\";\n\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nexport class XhrHttpClient implements HttpClient {\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    const xhr = new XMLHttpRequest();\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    const abortSignal = request.abortSignal;\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n\n      const listener = () => {\n        xhr.abort();\n      };\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n      const appendFormValue = (key: string, value: any) => {\n        if (value && value.hasOwnProperty(\"value\") && value.hasOwnProperty(\"options\")) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n    xhr.responseType = request.streamResponseBody ? \"blob\" : \"text\";\n\n    // tslint:disable-next-line:no-null-keyword\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (request.streamResponseBody) {\n      return new Promise((resolve, reject) => {\n        xhr.addEventListener(\"readystatechange\", () => {\n          // Resolve as soon as headers are loaded\n          if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n            const blobBody = new Promise<Blob>((resolve, reject) => {\n              xhr.addEventListener(\"load\", () => {\n                resolve(xhr.response);\n              });\n              rejectOnTerminalEvent(request, xhr, reject);\n            });\n            resolve({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr),\n              blobBody\n            });\n          }\n        });\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function(resolve, reject) {\n        xhr.addEventListener(\"load\", () =>\n          resolve({\n            request,\n            status: xhr.status,\n            headers: parseHeaders(xhr),\n            bodyAsText: xhr.responseText\n          })\n        );\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n}\n\nfunction addProgressListener(\n  xhr: XMLHttpRequestEventTarget,\n  listener?: (progress: TransferProgressEvent) => void\n) {\n  if (listener) {\n    xhr.addEventListener(\"progress\", (rawEvent) =>\n      listener({\n        loadedBytes: rawEvent.loaded\n      })\n    );\n  }\n}\n\n// exported locally for testing\nexport function parseHeaders(xhr: XMLHttpRequest) {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr\n    .getAllResponseHeaders()\n    .trim()\n    .split(/[\\r\\n]+/);\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(\n  request: WebResource,\n  xhr: XMLHttpRequest,\n  reject: (err: any) => void\n) {\n  xhr.addEventListener(\"error\", () =>\n    reject(\n      new RestError(\n        `Failed to send request to ${request.url}`,\n        RestError.REQUEST_SEND_ERROR,\n        undefined,\n        request\n      )\n    )\n  );\n  xhr.addEventListener(\"abort\", () => reject(new AbortError(\"The operation was aborted.\")));\n  xhr.addEventListener(\"timeout\", () =>\n    reject(\n      new RestError(\n        `timeout of ${xhr.timeout}ms exceeded`,\n        RestError.REQUEST_SEND_ERROR,\n        undefined,\n        request\n      )\n    )\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { replaceAll } from \"./util/utils\";\n\ntype URLQueryParseState = \"ParameterName\" | \"ParameterValue\" | \"Invalid\";\n\n/**\n * A class that handles the query portion of a URLBuilder.\n */\nexport class URLQuery {\n  private readonly _rawQuery: { [queryParameterName: string]: string | string[] } = {};\n\n  /**\n   * Get whether or not there any query parameters in this URLQuery.\n   */\n  public any(): boolean {\n    return Object.keys(this._rawQuery).length > 0;\n  }\n\n  /**\n   * Get the keys of the query string.\n   */\n  public keys(): string[] {\n    return Object.keys(this._rawQuery);\n  }\n\n  /**\n   * Set a query parameter with the provided name and value. If the parameterValue is undefined or\n   * empty, then this will attempt to remove an existing query parameter with the provided\n   * parameterName.\n   */\n  public set(parameterName: string, parameterValue: any): void {\n    if (parameterName) {\n      if (parameterValue != undefined) {\n        const newValue = Array.isArray(parameterValue) ? parameterValue : parameterValue.toString();\n        this._rawQuery[parameterName] = newValue;\n      } else {\n        delete this._rawQuery[parameterName];\n      }\n    }\n  }\n\n  /**\n   * Get the value of the query parameter with the provided name. If no parameter exists with the\n   * provided parameter name, then undefined will be returned.\n   */\n  public get(parameterName: string): string | string[] | undefined {\n    return parameterName ? this._rawQuery[parameterName] : undefined;\n  }\n\n  /**\n   * Get the string representation of this query. The return value will not start with a \"?\".\n   */\n  public toString(): string {\n    let result = \"\";\n    for (const parameterName in this._rawQuery) {\n      if (result) {\n        result += \"&\";\n      }\n      const parameterValue = this._rawQuery[parameterName];\n      if (Array.isArray(parameterValue)) {\n        const parameterStrings = [];\n        for (const parameterValueElement of parameterValue) {\n          parameterStrings.push(`${parameterName}=${parameterValueElement}`);\n        }\n        result += parameterStrings.join(\"&\");\n      } else {\n        result += `${parameterName}=${parameterValue}`;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Parse a URLQuery from the provided text.\n   */\n  public static parse(text: string): URLQuery {\n    const result = new URLQuery();\n\n    if (text) {\n      if (text.startsWith(\"?\")) {\n        text = text.substring(1);\n      }\n\n      let currentState: URLQueryParseState = \"ParameterName\";\n\n      let parameterName = \"\";\n      let parameterValue = \"\";\n      for (let i = 0; i < text.length; ++i) {\n        const currentCharacter: string = text[i];\n        switch (currentState) {\n          case \"ParameterName\":\n            switch (currentCharacter) {\n              case \"=\":\n                currentState = \"ParameterValue\";\n                break;\n\n              case \"&\":\n                parameterName = \"\";\n                parameterValue = \"\";\n                break;\n\n              default:\n                parameterName += currentCharacter;\n                break;\n            }\n            break;\n\n          case \"ParameterValue\":\n            switch (currentCharacter) {\n              case \"=\":\n                parameterName = \"\";\n                parameterValue = \"\";\n                currentState = \"Invalid\";\n                break;\n\n              case \"&\":\n                result.set(parameterName, parameterValue);\n                parameterName = \"\";\n                parameterValue = \"\";\n                currentState = \"ParameterName\";\n                break;\n\n              default:\n                parameterValue += currentCharacter;\n                break;\n            }\n            break;\n\n          case \"Invalid\":\n            if (currentCharacter === \"&\") {\n              currentState = \"ParameterName\";\n            }\n            break;\n\n          default:\n            throw new Error(\"Unrecognized URLQuery parse state: \" + currentState);\n        }\n      }\n      if (currentState === \"ParameterValue\") {\n        result.set(parameterName, parameterValue);\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * A class that handles creating, modifying, and parsing URLs.\n */\nexport class URLBuilder {\n  private _scheme: string | undefined;\n  private _host: string | undefined;\n  private _port: string | undefined;\n  private _path: string | undefined;\n  private _query: URLQuery | undefined;\n\n  /**\n   * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL\n   * (such as a host, port, path, or query), those parts will be added to this URL as well.\n   */\n  public setScheme(scheme: string | undefined): void {\n    if (!scheme) {\n      this._scheme = undefined;\n    } else {\n      this.set(scheme, \"SCHEME\");\n    }\n  }\n\n  /**\n   * Get the scheme that has been set in this URL.\n   */\n  public getScheme(): string | undefined {\n    return this._scheme;\n  }\n\n  /**\n   * Set the host for this URL. If the provided host contains other parts of a URL (such as a\n   * port, path, or query), those parts will be added to this URL as well.\n   */\n  public setHost(host: string | undefined): void {\n    if (!host) {\n      this._host = undefined;\n    } else {\n      this.set(host, \"SCHEME_OR_HOST\");\n    }\n  }\n\n  /**\n   * Get the host that has been set in this URL.\n   */\n  public getHost(): string | undefined {\n    return this._host;\n  }\n\n  /**\n   * Set the port for this URL. If the provided port contains other parts of a URL (such as a\n   * path or query), those parts will be added to this URL as well.\n   */\n  public setPort(port: number | string | undefined): void {\n    if (port == undefined || port === \"\") {\n      this._port = undefined;\n    } else {\n      this.set(port.toString(), \"PORT\");\n    }\n  }\n\n  /**\n   * Get the port that has been set in this URL.\n   */\n  public getPort(): string | undefined {\n    return this._port;\n  }\n\n  /**\n   * Set the path for this URL. If the provided path contains a query, then it will be added to\n   * this URL as well.\n   */\n  public setPath(path: string | undefined): void {\n    if (!path) {\n      this._path = undefined;\n    } else {\n      if (path.indexOf(\"://\") !== -1) {\n        this.set(path, \"SCHEME\");\n      } else {\n        this.set(path, \"PATH\");\n      }\n    }\n  }\n\n  /**\n   * Append the provided path to this URL's existing path. If the provided path contains a query,\n   * then it will be added to this URL as well.\n   */\n  public appendPath(path: string | undefined): void {\n    if (path) {\n      let currentPath: string | undefined = this.getPath();\n      if (currentPath) {\n        if (!currentPath.endsWith(\"/\")) {\n          currentPath += \"/\";\n        }\n\n        if (path.startsWith(\"/\")) {\n          path = path.substring(1);\n        }\n\n        path = currentPath + path;\n      }\n      this.set(path, \"PATH\");\n    }\n  }\n\n  /**\n   * Get the path that has been set in this URL.\n   */\n  public getPath(): string | undefined {\n    return this._path;\n  }\n\n  /**\n   * Set the query in this URL.\n   */\n  public setQuery(query: string | undefined): void {\n    if (!query) {\n      this._query = undefined;\n    } else {\n      this._query = URLQuery.parse(query);\n    }\n  }\n\n  /**\n   * Set a query parameter with the provided name and value in this URL's query. If the provided\n   * query parameter value is undefined or empty, then the query parameter will be removed if it\n   * existed.\n   */\n  public setQueryParameter(queryParameterName: string, queryParameterValue: any): void {\n    if (queryParameterName) {\n      if (!this._query) {\n        this._query = new URLQuery();\n      }\n      this._query.set(queryParameterName, queryParameterValue);\n    }\n  }\n\n  /**\n   * Get the value of the query parameter with the provided query parameter name. If no query\n   * parameter exists with the provided name, then undefined will be returned.\n   */\n  public getQueryParameterValue(queryParameterName: string): string | string[] | undefined {\n    return this._query ? this._query.get(queryParameterName) : undefined;\n  }\n\n  /**\n   * Get the query in this URL.\n   */\n  public getQuery(): string | undefined {\n    return this._query ? this._query.toString() : undefined;\n  }\n\n  /**\n   * Set the parts of this URL by parsing the provided text using the provided startState.\n   */\n  private set(text: string, startState: URLTokenizerState): void {\n    const tokenizer = new URLTokenizer(text, startState);\n\n    while (tokenizer.next()) {\n      const token: URLToken | undefined = tokenizer.current();\n      if (token) {\n        switch (token.type) {\n          case \"SCHEME\":\n            this._scheme = token.text || undefined;\n            break;\n\n          case \"HOST\":\n            this._host = token.text || undefined;\n            break;\n\n          case \"PORT\":\n            this._port = token.text || undefined;\n            break;\n\n          case \"PATH\":\n            const tokenPath: string | undefined = token.text || undefined;\n            if (!this._path || this._path === \"/\" || tokenPath !== \"/\") {\n              this._path = tokenPath;\n            }\n            break;\n\n          case \"QUERY\":\n            this._query = URLQuery.parse(token.text);\n            break;\n\n          default:\n            throw new Error(`Unrecognized URLTokenType: ${token.type}`);\n        }\n      }\n    }\n  }\n\n  public toString(): string {\n    let result = \"\";\n\n    if (this._scheme) {\n      result += `${this._scheme}://`;\n    }\n\n    if (this._host) {\n      result += this._host;\n    }\n\n    if (this._port) {\n      result += `:${this._port}`;\n    }\n\n    if (this._path) {\n      if (!this._path.startsWith(\"/\")) {\n        result += \"/\";\n      }\n      result += this._path;\n    }\n\n    if (this._query && this._query.any()) {\n      result += `?${this._query.toString()}`;\n    }\n\n    return result;\n  }\n\n  /**\n   * If the provided searchValue is found in this URLBuilder, then replace it with the provided\n   * replaceValue.\n   */\n  public replaceAll(searchValue: string, replaceValue: string): void {\n    if (searchValue) {\n      this.setScheme(replaceAll(this.getScheme(), searchValue, replaceValue));\n      this.setHost(replaceAll(this.getHost(), searchValue, replaceValue));\n      this.setPort(replaceAll(this.getPort(), searchValue, replaceValue));\n      this.setPath(replaceAll(this.getPath(), searchValue, replaceValue));\n      this.setQuery(replaceAll(this.getQuery(), searchValue, replaceValue));\n    }\n  }\n\n  public static parse(text: string): URLBuilder {\n    const result = new URLBuilder();\n    result.set(text, \"SCHEME_OR_HOST\");\n    return result;\n  }\n}\n\ntype URLTokenizerState = \"SCHEME\" | \"SCHEME_OR_HOST\" | \"HOST\" | \"PORT\" | \"PATH\" | \"QUERY\" | \"DONE\";\n\ntype URLTokenType = \"SCHEME\" | \"HOST\" | \"PORT\" | \"PATH\" | \"QUERY\";\n\nexport class URLToken {\n  public constructor(public readonly text: string, public readonly type: URLTokenType) {}\n\n  public static scheme(text: string): URLToken {\n    return new URLToken(text, \"SCHEME\");\n  }\n\n  public static host(text: string): URLToken {\n    return new URLToken(text, \"HOST\");\n  }\n\n  public static port(text: string): URLToken {\n    return new URLToken(text, \"PORT\");\n  }\n\n  public static path(text: string): URLToken {\n    return new URLToken(text, \"PATH\");\n  }\n\n  public static query(text: string): URLToken {\n    return new URLToken(text, \"QUERY\");\n  }\n}\n\n/**\n * Get whether or not the provided character (single character string) is an alphanumeric (letter or\n * digit) character.\n */\nexport function isAlphaNumericCharacter(character: string): boolean {\n  const characterCode: number = character.charCodeAt(0);\n  return (\n    (48 /* '0' */ <= characterCode && characterCode <= 57) /* '9' */ ||\n    (65 /* 'A' */ <= characterCode && characterCode <= 90) /* 'Z' */ ||\n    (97 /* 'a' */ <= characterCode && characterCode <= 122) /* 'z' */\n  );\n}\n\n/**\n * A class that tokenizes URL strings.\n */\nexport class URLTokenizer {\n  readonly _textLength: number;\n  _currentState: URLTokenizerState;\n  _currentIndex: number;\n  _currentToken: URLToken | undefined;\n\n  public constructor(readonly _text: string, state?: URLTokenizerState) {\n    this._textLength = _text ? _text.length : 0;\n    this._currentState = state != undefined ? state : \"SCHEME_OR_HOST\";\n    this._currentIndex = 0;\n  }\n\n  /**\n   * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer\n   * hasn't started or has finished tokenizing.\n   */\n  public current(): URLToken | undefined {\n    return this._currentToken;\n  }\n\n  /**\n   * Advance to the next URLToken and return whether or not a URLToken was found.\n   */\n  public next(): boolean {\n    if (!hasCurrentCharacter(this)) {\n      this._currentToken = undefined;\n    } else {\n      switch (this._currentState) {\n        case \"SCHEME\":\n          nextScheme(this);\n          break;\n\n        case \"SCHEME_OR_HOST\":\n          nextSchemeOrHost(this);\n          break;\n\n        case \"HOST\":\n          nextHost(this);\n          break;\n\n        case \"PORT\":\n          nextPort(this);\n          break;\n\n        case \"PATH\":\n          nextPath(this);\n          break;\n\n        case \"QUERY\":\n          nextQuery(this);\n          break;\n\n        default:\n          throw new Error(`Unrecognized URLTokenizerState: ${this._currentState}`);\n      }\n    }\n    return !!this._currentToken;\n  }\n}\n\n/**\n * Read the remaining characters from this Tokenizer's character stream.\n */\nfunction readRemaining(tokenizer: URLTokenizer): string {\n  let result = \"\";\n  if (tokenizer._currentIndex < tokenizer._textLength) {\n    result = tokenizer._text.substring(tokenizer._currentIndex);\n    tokenizer._currentIndex = tokenizer._textLength;\n  }\n  return result;\n}\n\n/**\n * Whether or not this URLTokenizer has a current character.\n */\nfunction hasCurrentCharacter(tokenizer: URLTokenizer): boolean {\n  return tokenizer._currentIndex < tokenizer._textLength;\n}\n\n/**\n * Get the character in the text string at the current index.\n */\nfunction getCurrentCharacter(tokenizer: URLTokenizer): string {\n  return tokenizer._text[tokenizer._currentIndex];\n}\n\n/**\n * Advance to the character in text that is \"step\" characters ahead. If no step value is provided,\n * then step will default to 1.\n */\nfunction nextCharacter(tokenizer: URLTokenizer, step?: number): void {\n  if (hasCurrentCharacter(tokenizer)) {\n    if (!step) {\n      step = 1;\n    }\n    tokenizer._currentIndex += step;\n  }\n}\n\n/**\n * Starting with the current character, peek \"charactersToPeek\" number of characters ahead in this\n * Tokenizer's stream of characters.\n */\nfunction peekCharacters(tokenizer: URLTokenizer, charactersToPeek: number): string {\n  let endIndex: number = tokenizer._currentIndex + charactersToPeek;\n  if (tokenizer._textLength < endIndex) {\n    endIndex = tokenizer._textLength;\n  }\n  return tokenizer._text.substring(tokenizer._currentIndex, endIndex);\n}\n\n/**\n * Read characters from this Tokenizer until the end of the stream or until the provided condition\n * is false when provided the current character.\n */\nfunction readWhile(tokenizer: URLTokenizer, condition: (character: string) => boolean): string {\n  let result = \"\";\n\n  while (hasCurrentCharacter(tokenizer)) {\n    const currentCharacter: string = getCurrentCharacter(tokenizer);\n    if (!condition(currentCharacter)) {\n      break;\n    } else {\n      result += currentCharacter;\n      nextCharacter(tokenizer);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Read characters from this Tokenizer until a non-alphanumeric character or the end of the\n * character stream is reached.\n */\nfunction readWhileLetterOrDigit(tokenizer: URLTokenizer): string {\n  return readWhile(tokenizer, (character: string) => isAlphaNumericCharacter(character));\n}\n\n/**\n * Read characters from this Tokenizer until one of the provided terminating characters is read or\n * the end of the character stream is reached.\n */\nfunction readUntilCharacter(tokenizer: URLTokenizer, ...terminatingCharacters: string[]): string {\n  return readWhile(\n    tokenizer,\n    (character: string) => terminatingCharacters.indexOf(character) === -1\n  );\n}\n\nfunction nextScheme(tokenizer: URLTokenizer): void {\n  const scheme: string = readWhileLetterOrDigit(tokenizer);\n  tokenizer._currentToken = URLToken.scheme(scheme);\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentState = \"DONE\";\n  } else {\n    tokenizer._currentState = \"HOST\";\n  }\n}\n\nfunction nextSchemeOrHost(tokenizer: URLTokenizer): void {\n  const schemeOrHost: string = readUntilCharacter(tokenizer, \":\", \"/\", \"?\");\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentToken = URLToken.host(schemeOrHost);\n    tokenizer._currentState = \"DONE\";\n  } else if (getCurrentCharacter(tokenizer) === \":\") {\n    if (peekCharacters(tokenizer, 3) === \"://\") {\n      tokenizer._currentToken = URLToken.scheme(schemeOrHost);\n      tokenizer._currentState = \"HOST\";\n    } else {\n      tokenizer._currentToken = URLToken.host(schemeOrHost);\n      tokenizer._currentState = \"PORT\";\n    }\n  } else {\n    tokenizer._currentToken = URLToken.host(schemeOrHost);\n    if (getCurrentCharacter(tokenizer) === \"/\") {\n      tokenizer._currentState = \"PATH\";\n    } else {\n      tokenizer._currentState = \"QUERY\";\n    }\n  }\n}\n\nfunction nextHost(tokenizer: URLTokenizer): void {\n  if (peekCharacters(tokenizer, 3) === \"://\") {\n    nextCharacter(tokenizer, 3);\n  }\n\n  const host: string = readUntilCharacter(tokenizer, \":\", \"/\", \"?\");\n  tokenizer._currentToken = URLToken.host(host);\n\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentState = \"DONE\";\n  } else if (getCurrentCharacter(tokenizer) === \":\") {\n    tokenizer._currentState = \"PORT\";\n  } else if (getCurrentCharacter(tokenizer) === \"/\") {\n    tokenizer._currentState = \"PATH\";\n  } else {\n    tokenizer._currentState = \"QUERY\";\n  }\n}\n\nfunction nextPort(tokenizer: URLTokenizer): void {\n  if (getCurrentCharacter(tokenizer) === \":\") {\n    nextCharacter(tokenizer);\n  }\n\n  const port: string = readUntilCharacter(tokenizer, \"/\", \"?\");\n  tokenizer._currentToken = URLToken.port(port);\n\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentState = \"DONE\";\n  } else if (getCurrentCharacter(tokenizer) === \"/\") {\n    tokenizer._currentState = \"PATH\";\n  } else {\n    tokenizer._currentState = \"QUERY\";\n  }\n}\n\nfunction nextPath(tokenizer: URLTokenizer): void {\n  const path: string = readUntilCharacter(tokenizer, \"?\");\n  tokenizer._currentToken = URLToken.path(path);\n\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentState = \"DONE\";\n  } else {\n    tokenizer._currentState = \"QUERY\";\n  }\n}\n\nfunction nextQuery(tokenizer: URLTokenizer): void {\n  if (getCurrentCharacter(tokenizer) === \"?\") {\n    nextCharacter(tokenizer);\n  }\n\n  const query: string = readRemaining(tokenizer);\n  tokenizer._currentToken = URLToken.query(query);\n  tokenizer._currentState = \"DONE\";\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { HttpPipelineLogger } from \"../httpPipelineLogger\";\nimport { HttpPipelineLogLevel } from \"../httpPipelineLogLevel\";\nimport { WebResource } from \"../webResource\";\n\n/**\n * Creates a new RequestPolicy per-request that uses the provided nextPolicy.\n */\nexport type RequestPolicyFactory = {\n  create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): RequestPolicy;\n};\n\nexport interface RequestPolicy {\n  sendRequest(httpRequest: WebResource): Promise<HttpOperationResponse>;\n}\n\nexport abstract class BaseRequestPolicy implements RequestPolicy {\n  protected constructor(\n    readonly _nextPolicy: RequestPolicy,\n    readonly _options: RequestPolicyOptions\n  ) {}\n\n  public abstract sendRequest(webResource: WebResource): Promise<HttpOperationResponse>;\n\n  /**\n   * Get whether or not a log with the provided log level should be logged.\n   * @param logLevel The log level of the log that will be logged.\n   * @returns Whether or not a log with the provided log level should be logged.\n   */\n  public shouldLog(logLevel: HttpPipelineLogLevel): boolean {\n    return this._options.shouldLog(logLevel);\n  }\n\n  /**\n   * Attempt to log the provided message to the provided logger. If no logger was provided or if\n   * the log level does not meat the logger's threshold, then nothing will be logged.\n   * @param logLevel The log level of this log.\n   * @param message The message of this log.\n   */\n  public log(logLevel: HttpPipelineLogLevel, message: string): void {\n    this._options.log(logLevel, message);\n  }\n}\n\n/**\n * Optional properties that can be used when creating a RequestPolicy.\n */\nexport class RequestPolicyOptions {\n  constructor(private _logger?: HttpPipelineLogger) {}\n\n  /**\n   * Get whether or not a log with the provided log level should be logged.\n   * @param logLevel The log level of the log that will be logged.\n   * @returns Whether or not a log with the provided log level should be logged.\n   */\n  public shouldLog(logLevel: HttpPipelineLogLevel): boolean {\n    return (\n      !!this._logger &&\n      logLevel !== HttpPipelineLogLevel.OFF &&\n      logLevel <= this._logger.minimumLogLevel\n    );\n  }\n\n  /**\n   * Attempt to log the provided message to the provided logger. If no logger was provided or if\n   * the log level does not meat the logger's threshold, then nothing will be logged.\n   * @param logLevel The log level of this log.\n   * @param message The message of this log.\n   */\n  public log(logLevel: HttpPipelineLogLevel, message: string): void {\n    if (this._logger && this.shouldLog(logLevel)) {\n      this._logger.log(logLevel, message);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nconst logFunction = console.debug || console.log;\nexport function log(...args: any[]) {\n  logFunction(...args);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { log } from \"./log\";\n\n/**\n * A simple mechanism for enabling logging.\n * Intended to mimic the publicly available `debug` package.\n */\nexport interface Debug {\n  /**\n   * Creates a new logger with the given namespace.\n   */\n  (namespace: string): Debugger;\n  /**\n   * The default log method (defaults to console)\n   */\n  log: (...args: any[]) => void;\n  /**\n   * Enables a particular set of namespaces.\n   * To enable multiple separate them with commas, e.g. \"info,debug\".\n   * Supports wildcards, e.g. \"azure:*\"\n   * Supports skip syntax, e.g. \"azure:*,-azure:storage:*\" will enable\n   * everything under azure except for things under azure:storage.\n   */\n  enable: (namespaces: string) => void;\n  /**\n   * Checks if a particular namespace is enabled.\n   */\n  enabled: (namespace: string) => boolean;\n  /**\n   * Disables all logging, returns what was previously enabled.\n   */\n  disable: () => string;\n}\n\n/**\n * A log function that can be dynamically enabled and redirected.\n */\nexport interface Debugger {\n  /**\n   * Logs the given arguments to the `log` method.\n   */\n  (...args: any[]): void;\n  /**\n   * True if this logger is active and logging.\n   */\n  enabled: boolean;\n  /**\n   * Used to cleanup/remove this logger.\n   */\n  destroy: () => boolean;\n  /**\n   * The current log method. Can be overridden to redirect output.\n   */\n  log: (...args: any[]) => void;\n  /**\n   * The namespace of this logger.\n   */\n  namespace: string;\n  /**\n   * Extends this logger with a child namespace.\n   * Namespaces are separated with a ':' character.\n   */\n  extend: (namespace: string) => Debugger;\n}\n\nconst debugEnvVariable =\n  (typeof process !== \"undefined\" && process.env && process.env.DEBUG) || undefined;\n\nlet enabledString: string | undefined;\nlet enabledNamespaces: RegExp[] = [];\nlet skippedNamespaces: RegExp[] = [];\nconst debuggers: Debugger[] = [];\n\nif (debugEnvVariable) {\n  enable(debugEnvVariable);\n}\n\nfunction enable(namespaces: string): void {\n  enabledString = namespaces;\n  enabledNamespaces = [];\n  skippedNamespaces = [];\n  const wildcard = /\\*/g;\n  const namespaceList = namespaces.split(\",\").map((ns) => ns.trim().replace(wildcard, \".*?\"));\n  for (const ns of namespaceList) {\n    if (ns.startsWith(\"-\")) {\n      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));\n    } else {\n      enabledNamespaces.push(new RegExp(`^${ns}$`));\n    }\n  }\n  for (const instance of debuggers) {\n    instance.enabled = enabled(instance.namespace);\n  }\n}\n\nfunction enabled(namespace: string): boolean {\n  if (namespace.endsWith(\"*\")) {\n    return true;\n  }\n\n  for (const skipped of skippedNamespaces) {\n    if (skipped.test(namespace)) {\n      return false;\n    }\n  }\n  for (const enabled of enabledNamespaces) {\n    if (enabled.test(namespace)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction disable(): string {\n  const result = enabledString || \"\";\n  enable(\"\");\n  return result;\n}\n\nfunction createDebugger(namespace: string): Debugger {\n  function debug(...args: any[]) {\n    if (!newDebugger.enabled) {\n      return;\n    }\n    if (args.length > 0) {\n      args[0] = `${namespace} ${args[0]}`;\n    }\n    newDebugger.log(...args);\n  }\n\n  const newDebugger: Debugger = Object.assign(debug, {\n    enabled: enabled(namespace),\n    destroy,\n    log: debugObj.log,\n    namespace,\n    extend\n  });\n\n  debuggers.push(newDebugger);\n\n  return newDebugger;\n}\n\nfunction destroy(this: Debugger): boolean {\n  const index = debuggers.indexOf(this);\n  if (index >= 0) {\n    debuggers.splice(index, 1);\n    return true;\n  }\n  return false;\n}\n\nfunction extend(this: Debugger, namespace: string): Debugger {\n  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);\n  newDebugger.log = this.log;\n  return newDebugger;\n}\n\nconst debugObj: Debug = Object.assign(\n  (namespace: string): Debugger => {\n    return createDebugger(namespace);\n  },\n  {\n    enable,\n    enabled,\n    disable,\n    log\n  }\n);\n\nexport default debugObj;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport debug, { Debugger } from \"./debug\";\nexport { Debugger } from \"./debug\";\n\nconst registeredLoggers = new Set<AzureDebugger>();\nconst logLevelFromEnv =\n  (typeof process !== \"undefined\" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;\n\nlet azureLogLevel: AzureLogLevel | undefined;\n\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport const AzureLogger: AzureClientLogger = debug(\"azure\");\nAzureLogger.log = (...args) => {\n  debug.log(...args);\n};\n\n/**\n * The log levels supported by the logger.\n * The log levels in order of most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport type AzureLogLevel = \"verbose\" | \"info\" | \"warning\" | \"error\";\nconst AZURE_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\n\ntype AzureDebugger = Debugger & { level: AzureLogLevel };\n\n/**\n * An AzureClientLogger is a function that can log to an appropriate severity level.\n */\nexport type AzureClientLogger = Debugger;\n\nif (logLevelFromEnv) {\n  // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n  if (isAzureLogLevel(logLevelFromEnv)) {\n    setLogLevel(logLevelFromEnv);\n  } else {\n    console.error(\n      `AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(\n        \", \"\n      )}.`\n    );\n  }\n}\n\n/**\n * Immediately enables logging at the specified log level.\n * @param level The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level?: AzureLogLevel) {\n  if (level && !isAzureLogLevel(level)) {\n    throw new Error(\n      `Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(\",\")}`\n    );\n  }\n  azureLogLevel = level;\n\n  const enabledNamespaces = [];\n  for (const logger of registeredLoggers) {\n    if (shouldEnable(logger)) {\n      enabledNamespaces.push(logger.namespace);\n    }\n  }\n\n  debug.enable(enabledNamespaces.join(\",\"));\n}\n\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n  return azureLogLevel;\n}\n\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100\n};\n\n/**\n * Defines the methods available on the SDK-facing logger.\n */\nexport interface AzureLogger {\n  /**\n   * Used for failures the program is unlikely to recover from,\n   * such as Out of Memory.\n   */\n  error: Debugger;\n  /**\n   * Used when a function fails to perform its intended task.\n   * Usually this means the function will throw an exception.\n   * Not used for self-healing events (e.g. automatic retry)\n   */\n  warning: Debugger;\n  /**\n   * Used when a function operates normally.\n   */\n  info: Debugger;\n  /**\n   * Used for detailed trbouleshooting scenarios. This is\n   * intended for use by developers / system administrators\n   * for diagnosing specific failures.\n   */\n  verbose: Debugger;\n}\n\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace The name of the SDK package.\n * @ignore\n */\nexport function createClientLogger(namespace: string): AzureLogger {\n  const clientRootLogger: AzureClientLogger = AzureLogger.extend(namespace);\n  patchLogMethod(AzureLogger, clientRootLogger);\n  return {\n    error: createLogger(clientRootLogger, \"error\"),\n    warning: createLogger(clientRootLogger, \"warning\"),\n    info: createLogger(clientRootLogger, \"info\"),\n    verbose: createLogger(clientRootLogger, \"verbose\")\n  };\n}\n\nfunction patchLogMethod(parent: AzureClientLogger, child: AzureClientLogger | AzureDebugger): void {\n  child.log = (...args) => {\n    parent.log(...args);\n  };\n}\n\nfunction createLogger(parent: AzureClientLogger, level: AzureLogLevel): AzureDebugger {\n  const logger: AzureDebugger = Object.assign(parent.extend(level), {\n    level\n  });\n\n  patchLogMethod(parent, logger);\n\n  if (shouldEnable(logger)) {\n    const enabledNamespaces = debug.disable();\n    debug.enable(enabledNamespaces + \",\" + logger.namespace);\n  }\n\n  registeredLoggers.add(logger);\n\n  return logger;\n}\n\nfunction shouldEnable(logger: AzureDebugger) {\n  if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isAzureLogLevel(logLevel: string): logLevel is AzureLogLevel {\n  return AZURE_LOG_LEVELS.includes(logLevel as any);\n}\n","import { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-http\");\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResource } from \"../webResource\";\nimport { URLBuilder, URLQuery } from \"../url\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\nimport { Debugger } from \"@azure/logger\";\nimport { logger as coreLogger, logger } from \"../log\";\n\nexport interface LogPolicyOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled. Defaults to\n   * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  allowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  allowedQueryParameters?: string[];\n}\n\n/**\n * Options to configure request/response logging.\n */\nexport interface LoggingOptions {\n  /**\n   * The Debugger (logger) instance to use for writing pipeline logs.\n   */\n  logger?: Debugger,\n\n  /**\n   * Options to pass to the logPolicy factory.\n   */\n  logPolicyOptions?: LogPolicyOptions\n}\n\nconst RedactedString = \"REDACTED\";\n\nconst defaultAllowedHeaderNames = [\n  \"x-ms-client-request-id\",\n  \"x-ms-return-client-request-id\",\n  \"traceparent\",\n\n  \"Accept\",\n  \"Cache-Control\",\n  \"Connection\",\n  \"Content-Length\",\n  \"Content-Type\",\n  \"Date\",\n  \"ETag\",\n  \"Expires\",\n  \"If-Match\",\n  \"If-Modified-Since\",\n  \"If-None-Match\",\n  \"If-Unmodified-Since\",\n  \"Last-Modified\",\n  \"Pragma\",\n  \"Request-Id\",\n  \"Retry-After\",\n  \"Server\",\n  \"Transfer-Encoding\",\n  \"User-Agent\"\n];\n\nconst defaultAllowedQueryParameters: string[] = [\n  \"api-version\"\n];\n\nexport const DefaultLoggingOptions: LoggingOptions = {\n  logger: undefined,\n  logPolicyOptions: {\n    allowedHeaderNames: [],      // These are empty lists because they are additive to\n    allowedQueryParameters: []   // the real defaultAllowed[HeaderNames|QueryParameters].\n  }\n}\n\nexport function logPolicy(\n  logger: any = coreLogger.info.bind(coreLogger),\n  logOptions: LogPolicyOptions = {}\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new LogPolicy(nextPolicy, options, logger, logOptions);\n    }\n  };\n}\n\nexport class LogPolicy extends BaseRequestPolicy {\n  logger?: any;\n\n  public allowedHeaderNames: Set<string>;\n  public allowedQueryParameters: Set<string>;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    logger: any = console.log,\n    { allowedHeaderNames = [], allowedQueryParameters = [] }: LogPolicyOptions = {}\n  ) {\n    super(nextPolicy, options);\n    this.logger = logger;\n\n    allowedHeaderNames =\n      allowedHeaderNames && allowedHeaderNames instanceof Array\n        ? defaultAllowedHeaderNames.concat(allowedHeaderNames)\n        : defaultAllowedHeaderNames;\n\n    allowedQueryParameters =\n      allowedQueryParameters && allowedQueryParameters instanceof Array\n        ? defaultAllowedQueryParameters.concat(allowedQueryParameters)\n        : defaultAllowedQueryParameters;\n\n    this.allowedHeaderNames = new Set(allowedHeaderNames);\n    this.allowedQueryParameters = new Set(allowedQueryParameters);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    if (!logger.info.enabled) return this._nextPolicy.sendRequest(request);\n\n    this.logRequest(request);\n    return this._nextPolicy.sendRequest(request).then((response) => this.logResponse(response));\n  }\n\n  private logRequest(request: WebResource) {\n    this.logger(`Request: ${JSON.stringify(request, this.sanitize.bind(this), 2)}`);\n  }\n\n  private sanitize(key: string, value: unknown) {\n    if (key === \"_headersMap\") {\n      return this.sanitizeHeaders(key, value as {});\n    } else if (key === \"url\") {\n      return this.sanitizeUrl(value as string);\n    } else if (key === \"query\") {\n      return this.sanitizeQuery(value as {});\n    } else if (key === \"body\") {\n      // Don't log the request body\n      return undefined;\n    } else if (key === \"response\") {\n      // Don't log response again\n      return undefined;\n    } else if (key === \"operationSpec\") {\n      // When using sendOperationRequest, the request carries a massive\n      // field with the autorest spec. No need to log it.\n      return undefined;\n    }\n\n    return value;\n  }\n\n  private sanitizeHeaders(_: string, value: { [s: string]: any }) {\n    return this.sanitizeObject(value, this.allowedHeaderNames, (v, k) => v[k].value);\n  }\n\n  private sanitizeQuery(value: { [s: string]: string }) {\n    return this.sanitizeObject(value, this.allowedQueryParameters, (v, k) => v[k]);\n  }\n\n  private sanitizeObject(\n    value: { [s: string]: any },\n    allowedKeys: Set<string>,\n    accessor: (value: any, key: string) => any\n  ) {\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n\n    const sanitized: { [s: string]: string } = {};\n\n    for (const k of Object.keys(value)) {\n      if (allowedKeys.has(k)) {\n        sanitized[k] = accessor(value, k);\n      } else {\n        sanitized[k] = RedactedString;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private sanitizeUrl(value: string): string {\n    if (typeof value !== \"string\" || value === null) {\n      return value;\n    }\n\n    const urlBuilder = URLBuilder.parse(value);\n    const queryString = urlBuilder.getQuery();\n\n    if (!queryString) {\n      return value;\n    }\n\n    const query = URLQuery.parse(queryString);\n    for (const k of query.keys()) {\n      if (!this.allowedQueryParameters.has(k)) {\n        query.set(k, RedactedString);\n      }\n    }\n\n    urlBuilder.setQuery(query.toString());\n    return urlBuilder.toString();\n  }\n\n  private logResponse(response: HttpOperationResponse): HttpOperationResponse {\n    this.logger(`Response status code: ${response.status}`);\n    this.logger(`Headers: ${JSON.stringify(response.headers, this.sanitize.bind(this), 2)}`);\n    return response;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { Mapper } from \"./serializer\";\n\nexport type ParameterPath = string | string[] | { [propertyName: string]: ParameterPath };\n\n/**\n * A common interface that all Operation parameter's extend.\n */\nexport interface OperationParameter {\n  /**\n   * The path to this parameter's value in OperationArguments or the object that contains paths for\n   * each property's value in OperationArguments.\n   */\n  parameterPath: ParameterPath;\n\n  /**\n   * The mapper that defines how to validate and serialize this parameter's value.\n   */\n  mapper: Mapper;\n}\n\n/**\n * A parameter for an operation that will be substituted into the operation's request URL.\n */\nexport interface OperationURLParameter extends OperationParameter {\n  /**\n   * Whether or not to skip encoding the URL parameter's value before adding it to the URL.\n   */\n  skipEncoding?: boolean;\n}\n\n/**\n * A parameter for an operation that will be added as a query parameter to the operation's HTTP\n * request.\n */\nexport interface OperationQueryParameter extends OperationParameter {\n  /**\n   * Whether or not to skip encoding the query parameter's value before adding it to the URL.\n   */\n  skipEncoding?: boolean;\n\n  /**\n   * If this query parameter's value is a collection, what type of format should the value be\n   * converted to.\n   */\n  collectionFormat?: QueryCollectionFormat;\n}\n\n/**\n * Get the path to this parameter's value as a dotted string (a.b.c).\n * @param parameter The parameter to get the path string for.\n * @returns The path to this parameter's value as a dotted string.\n */\nexport function getPathStringFromParameter(parameter: OperationParameter): string {\n  return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);\n}\n\nexport function getPathStringFromParameterPath(\n  parameterPath: ParameterPath,\n  mapper: Mapper\n): string {\n  let result: string;\n  if (typeof parameterPath === \"string\") {\n    result = parameterPath;\n  } else if (Array.isArray(parameterPath)) {\n    result = parameterPath.join(\".\");\n  } else {\n    result = mapper.serializedName!;\n  }\n  return result;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  OperationParameter,\n  OperationQueryParameter,\n  OperationURLParameter\n} from \"./operationParameter\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { MapperType, Serializer } from \"./serializer\";\nimport { HttpMethods } from \"./webResource\";\n\n/**\n * A specification that defines an operation.\n */\nexport interface OperationSpec {\n  /**\n   * The serializer to use in this operation.\n   */\n  readonly serializer: Serializer;\n\n  /**\n   * The HTTP method that should be used by requests for this operation.\n   */\n  readonly httpMethod: HttpMethods;\n\n  /**\n   * The URL that was provided in the service's specification. This will still have all of the URL\n   * template variables in it. If this is not provided when the OperationSpec is created, then it\n   * will be populated by a \"baseUri\" property on the ServiceClient.\n   */\n  readonly baseUrl?: string;\n\n  /**\n   * The fixed path for this operation's URL. This will still have all of the URL template variables\n   * in it.\n   */\n  readonly path?: string;\n\n  /**\n   * The content type of the request body. This value will be used as the \"Content-Type\" header if\n   * it is provided.\n   */\n  readonly contentType?: string;\n\n  /**\n   * The parameter that will be used to construct the HTTP request's body.\n   */\n  readonly requestBody?: OperationParameter;\n\n  /**\n   * Whether or not this operation uses XML request and response bodies.\n   */\n  readonly isXML?: boolean;\n\n  /**\n   * The parameters to the operation method that will be substituted into the constructed URL.\n   */\n  readonly urlParameters?: ReadonlyArray<OperationURLParameter>;\n\n  /**\n   * The parameters to the operation method that will be added to the constructed URL's query.\n   */\n  readonly queryParameters?: ReadonlyArray<OperationQueryParameter>;\n\n  /**\n   * The parameters to the operation method that will be converted to headers on the operation's\n   * HTTP request.\n   */\n  readonly headerParameters?: ReadonlyArray<OperationParameter>;\n\n  /**\n   * The parameters to the operation method that will be used to create a formdata body for the\n   * operation's HTTP request.\n   */\n  readonly formDataParameters?: ReadonlyArray<OperationParameter>;\n\n  /**\n   * The different types of responses that this operation can return based on what status code is\n   * returned.\n   */\n  readonly responses: { [responseCode: string]: OperationResponse };\n}\n\nexport function isStreamOperation(operationSpec: OperationSpec): boolean {\n  let result = false;\n  for (const statusCode in operationSpec.responses) {\n    const operationResponse: OperationResponse = operationSpec.responses[statusCode];\n    if (\n      operationResponse.bodyMapper &&\n      operationResponse.bodyMapper.type.name === MapperType.Stream\n    ) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n// tslint:disable-next-line:no-null-keyword\nconst doc = document.implementation.createDocument(null, null, null);\n\nconst parser = new DOMParser();\nexport function parseXML(str: string, opts?: { includeRoot?: boolean }): Promise<any> {\n  try {\n    const dom = parser.parseFromString(str, \"application/xml\");\n    throwIfError(dom);\n\n    let obj;\n    if (opts && opts.includeRoot) {\n      obj = domToObject(dom);\n    } else {\n      obj = domToObject(dom.childNodes[0]);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS = \"\";\ntry {\n  errorNS = parser.parseFromString(\"INVALID\", \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n    .namespaceURI!;\n} catch (ignored) {\n  // Most browsers will return a document containing <parsererror>, but IE will throw.\n}\n\nfunction throwIfError(dom: Document) {\n  if (errorNS) {\n    const parserErrors = dom.getElementsByTagNameNS(errorNS, \"parsererror\");\n    if (parserErrors.length) {\n      throw new Error(parserErrors.item(0)!.innerHTML);\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[\"$\"] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[\"$\"][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[\"_\"] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject: any = domToObject(child);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nconst serializer = new XMLSerializer();\n\nexport function stringifyXML(content: any, opts?: { rootName?: string }): string {\n  const rootName = (opts && opts.rootName) || \"root\";\n  const dom = buildNode(content, rootName)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom)\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string): Node[] {\n  if (\n    obj == undefined ||\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\"\n  ) {\n    const elem = doc.createElement(elementName);\n    elem.textContent = obj == undefined ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = doc.createElement(elementName);\n    for (const key of Object.keys(obj)) {\n      if (key === \"$\") {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === \"_\") {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (const child of buildNode(obj[key], key)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { OperationResponse } from \"../operationResponse\";\nimport { OperationSpec, isStreamOperation } from \"../operationSpec\";\nimport { RestError } from \"../restError\";\nimport { Mapper, MapperType } from \"../serializer\";\nimport * as utils from \"../util/utils\";\nimport { parseXML } from \"../util/xml\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\n/**\n * Options to configure API response deserialization.\n */\nexport interface DeserializationOptions {\n  /**\n   * Configures the expected content types for the deserialization of\n   * JSON and XML response bodies.\n   */\n  expectedContentTypes: DeserializationContentTypes;\n}\n\n/**\n * The content-types that will indicate that an operation response should be deserialized in a\n * particular way.\n */\nexport interface DeserializationContentTypes {\n  /**\n   * The content-types that indicate that an operation response should be deserialized as JSON.\n   * Defaults to [ \"application/json\", \"text/json\" ].\n   */\n  json?: string[];\n\n  /**\n   * The content-types that indicate that an operation response should be deserialized as XML.\n   * Defaults to [ \"application/xml\", \"application/atom+xml\" ].\n   */\n  xml?: string[];\n}\n\n/**\n * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they\n * pass through the HTTP pipeline.\n */\nexport function deserializationPolicy(\n  deserializationContentTypes?: DeserializationContentTypes\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new DeserializationPolicy(nextPolicy, deserializationContentTypes, options);\n    }\n  };\n}\n\nexport const defaultJsonContentTypes = [\"application/json\", \"text/json\", \"text/plain\"];\nexport const defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n\nexport const DefaultDeserializationOptions: DeserializationOptions = {\n  expectedContentTypes: {\n    json: defaultJsonContentTypes,\n    xml: defaultXmlContentTypes\n  }\n};\n\n/**\n * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the\n * HTTP pipeline.\n */\nexport class DeserializationPolicy extends BaseRequestPolicy {\n  public readonly jsonContentTypes: string[];\n  public readonly xmlContentTypes: string[];\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    deserializationContentTypes: DeserializationContentTypes | undefined,\n    options: RequestPolicyOptions\n  ) {\n    super(nextPolicy, options);\n\n    this.jsonContentTypes =\n      (deserializationContentTypes && deserializationContentTypes.json) || defaultJsonContentTypes;\n    this.xmlContentTypes =\n      (deserializationContentTypes && deserializationContentTypes.xml) || defaultXmlContentTypes;\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request)\n      .then((response: HttpOperationResponse) =>\n        deserializeResponseBody(this.jsonContentTypes, this.xmlContentTypes, response)\n      );\n  }\n}\n\nfunction getOperationResponse(\n  parsedResponse: HttpOperationResponse\n): undefined | OperationResponse {\n  let result: OperationResponse | undefined;\n  const request: WebResource = parsedResponse.request;\n  const operationSpec: OperationSpec | undefined = request.operationSpec;\n  if (operationSpec) {\n    const operationResponseGetter:\n      | undefined\n      | ((\n          operationSpec: OperationSpec,\n          response: HttpOperationResponse\n        ) => undefined | OperationResponse) = request.operationResponseGetter;\n    if (!operationResponseGetter) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\n\nfunction shouldDeserializeResponse(parsedResponse: HttpOperationResponse): boolean {\n  const shouldDeserialize: undefined | boolean | ((response: HttpOperationResponse) => boolean) =\n    parsedResponse.request.shouldDeserialize;\n  let result: boolean;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\n\nexport function deserializeResponseBody(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  response: HttpOperationResponse\n): Promise<HttpOperationResponse> {\n  return parse(jsonContentTypes, xmlContentTypes, response).then((parsedResponse) => {\n    const shouldDeserialize: boolean = shouldDeserializeResponse(parsedResponse);\n    if (shouldDeserialize) {\n      const operationSpec: OperationSpec | undefined = parsedResponse.request.operationSpec;\n      if (operationSpec && operationSpec.responses) {\n        const statusCode: number = parsedResponse.status;\n\n        const expectedStatusCodes: string[] = Object.keys(operationSpec.responses);\n\n        const hasNoExpectedStatusCodes: boolean =\n          expectedStatusCodes.length === 0 ||\n          (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\");\n\n        const responseSpec: OperationResponse | undefined = getOperationResponse(parsedResponse);\n\n        const isExpectedStatusCode: boolean = hasNoExpectedStatusCodes\n          ? 200 <= statusCode && statusCode < 300\n          : !!responseSpec;\n        if (!isExpectedStatusCode) {\n          const defaultResponseSpec: OperationResponse = operationSpec.responses.default;\n          if (defaultResponseSpec) {\n            const initialErrorMessage: string = isStreamOperation(operationSpec)\n              ? `Unexpected status code: ${statusCode}`\n              : (parsedResponse.bodyAsText as string);\n\n            const error = new RestError(initialErrorMessage);\n            error.statusCode = statusCode;\n            error.request = utils.stripRequest(parsedResponse.request);\n            error.response = utils.stripResponse(parsedResponse);\n\n            let parsedErrorResponse: { [key: string]: any } = parsedResponse.parsedBody;\n            try {\n              if (parsedErrorResponse) {\n                const defaultResponseBodyMapper: Mapper | undefined =\n                  defaultResponseSpec.bodyMapper;\n                if (\n                  defaultResponseBodyMapper &&\n                  defaultResponseBodyMapper.serializedName === \"CloudError\"\n                ) {\n                  if (parsedErrorResponse.error) {\n                    parsedErrorResponse = parsedErrorResponse.error;\n                  }\n                  if (parsedErrorResponse.code) {\n                    error.code = parsedErrorResponse.code;\n                  }\n                  if (parsedErrorResponse.message) {\n                    error.message = parsedErrorResponse.message;\n                  }\n                } else {\n                  let internalError: any = parsedErrorResponse;\n                  if (parsedErrorResponse.error) {\n                    internalError = parsedErrorResponse.error;\n                  }\n\n                  error.code = internalError.code;\n                  if (internalError.message) {\n                    error.message = internalError.message;\n                  }\n                }\n\n                if (defaultResponseBodyMapper) {\n                  let valueToDeserialize: any = parsedErrorResponse;\n                  if (\n                    operationSpec.isXML &&\n                    defaultResponseBodyMapper.type.name === MapperType.Sequence\n                  ) {\n                    valueToDeserialize =\n                      typeof parsedErrorResponse === \"object\"\n                        ? parsedErrorResponse[defaultResponseBodyMapper.xmlElementName!]\n                        : [];\n                  }\n                  error.response!.parsedBody = operationSpec.serializer.deserialize(\n                    defaultResponseBodyMapper,\n                    valueToDeserialize,\n                    \"error.response.parsedBody\"\n                  );\n                }\n              }\n\n              if (parsedResponse.headers && defaultResponseSpec.headersMapper) {\n                error.response!.parsedHeaders = operationSpec.serializer.deserialize(\n                  defaultResponseSpec.headersMapper,\n                  parsedResponse.headers.rawHeaders(),\n                  \"operationRes.parsedHeaders\"\n                );\n              }\n            } catch (defaultError) {\n              error.message = `Error \\\"${defaultError.message}\\\" occurred in deserializing the responseBody - \\\"${parsedResponse.bodyAsText}\\\" for the default response.`;\n            }\n            return Promise.reject(error);\n          }\n        } else if (responseSpec) {\n          if (responseSpec.bodyMapper) {\n            let valueToDeserialize: any = parsedResponse.parsedBody;\n            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {\n              valueToDeserialize =\n                typeof valueToDeserialize === \"object\"\n                  ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName!]\n                  : [];\n            }\n            try {\n              parsedResponse.parsedBody = operationSpec.serializer.deserialize(\n                responseSpec.bodyMapper,\n                valueToDeserialize,\n                \"operationRes.parsedBody\"\n              );\n            } catch (error) {\n              const restError = new RestError(\n                `Error ${error} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`\n              );\n              restError.request = utils.stripRequest(parsedResponse.request);\n              restError.response = utils.stripResponse(parsedResponse);\n              return Promise.reject(restError);\n            }\n          } else if (operationSpec.httpMethod === \"HEAD\") {\n            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n          }\n\n          if (responseSpec.headersMapper) {\n            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(\n              responseSpec.headersMapper,\n              parsedResponse.headers.rawHeaders(),\n              \"operationRes.parsedHeaders\"\n            );\n          }\n        }\n      }\n    }\n    return Promise.resolve(parsedResponse);\n  });\n}\n\nfunction parse(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  operationResponse: HttpOperationResponse\n): Promise<HttpOperationResponse> {\n  const errorHandler = (err: Error & { code: string }) => {\n    const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n    const errCode = err.code || RestError.PARSE_ERROR;\n    const e = new RestError(\n      msg,\n      errCode,\n      operationResponse.status,\n      operationResponse.request,\n      operationResponse\n    );\n    return Promise.reject(e);\n  };\n\n  if (!operationResponse.request.streamResponseBody && operationResponse.bodyAsText) {\n    const text = operationResponse.bodyAsText;\n    const contentType: string = operationResponse.headers.get(\"Content-Type\") || \"\";\n    const contentComponents: string[] = !contentType\n      ? []\n      : contentType.split(\";\").map((component) => component.toLowerCase());\n    if (\n      contentComponents.length === 0 ||\n      contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)\n    ) {\n      return new Promise<HttpOperationResponse>((resolve) => {\n        operationResponse.parsedBody = JSON.parse(text);\n        resolve(operationResponse);\n      }).catch(errorHandler);\n    } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n      return parseXML(text)\n        .then((body) => {\n          operationResponse.parsedBody = body;\n          return operationResponse;\n        })\n        .catch(errorHandler);\n    }\n  }\n\n  return Promise.resolve(operationResponse);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\nimport { RestError } from \"../restError\";\nimport { logger } from \"../log\";\n\nexport interface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\nexport interface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\nexport function exponentialRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ExponentialRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        maxRetryInterval\n      );\n    }\n  };\n}\n\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nconst DEFAULT_CLIENT_RETRY_COUNT = 3;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n * @enum RetryMode\n */\nexport enum RetryMode {\n  Exponential\n}\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface RetryOptions {\n  /**\n   * The maximum number of retry attempts.  Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 30000\n   * (30 seconds). The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 90000 (90 seconds).\n   */\n  maxRetryDelayInMs?: number;\n\n  /**\n   * Currently supporting only Exponential mode.\n   */\n  mode?: RetryMode;\n}\n\nexport const DefaultRetryOptions: RetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n}\n\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * The client retry count.\n   */\n  retryCount: number;\n  /**\n   * The client retry interval in milliseconds.\n   */\n  retryInterval: number;\n  /**\n   * The maximum retry interval in milliseconds.\n   */\n  maxRetryInterval: number;\n\n  /**\n   * @constructor\n   * @param {RequestPolicy} nextPolicy The next RequestPolicy in the pipeline chain.\n   * @param {RequestPolicyOptions} options The options for this RequestPolicy.\n   * @param {number} [retryCount]        The client retry count.\n   * @param {number} [retryInterval]     The client retry interval, in milliseconds.\n   * @param {number} [minRetryInterval]  The minimum retry interval, in milliseconds.\n   * @param {number} [maxRetryInterval]  The maximum retry interval, in milliseconds.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    function isNumber(n: any): n is number {\n      return typeof n === \"number\";\n    }\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval)\n      ? maxRetryInterval\n      : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => retry(this, request, response))\n      .catch((error) => retry(this, request, error.response, undefined, error));\n  }\n}\n\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\nfunction shouldRetry(\n  policy: ExponentialRetryPolicy,\n  statusCode: number | undefined,\n  retryData: RetryData\n): boolean {\n  if (\n    statusCode == undefined ||\n    (statusCode < 500 && statusCode !== 408) ||\n    statusCode === 501 ||\n    statusCode === 505\n  ) {\n    return false;\n  }\n\n  let currentCount: number;\n  if (!retryData) {\n    throw new Error(\"retryData for the ExponentialRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n\n  return currentCount < policy.retryCount;\n}\n\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {RetryData} retryData  The retry data.\n * @param {RetryError} [err] The operation\"s error, if any.\n */\nfunction updateRetryData(\n  policy: ExponentialRetryPolicy,\n  retryData?: RetryData,\n  err?: RetryError\n): RetryData {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  }\n\n  // Adjust retry count\n  retryData.retryCount++;\n\n  // Adjust retry interval\n  let incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  const boundedRandDelta =\n    policy.retryInterval * 0.8 +\n    Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n  incrementDelta *= boundedRandDelta;\n\n  retryData.retryInterval = Math.min(\n    incrementDelta,\n    policy.maxRetryInterval\n  );\n\n  return retryData;\n}\n\nfunction retry(\n  policy: ExponentialRetryPolicy,\n  request: WebResource,\n  response?: HttpOperationResponse,\n  retryData?: RetryData,\n  requestError?: RetryError\n): Promise<HttpOperationResponse> {\n  retryData = updateRetryData(policy, retryData, requestError);\n  const isAborted: boolean | undefined = request.abortSignal && request.abortSignal.aborted;\n  if (!isAborted && shouldRetry(policy, response && response.status, retryData)) {\n    logger.info(`Retrying request in ${retryData.retryInterval}`);\n    return utils\n      .delay(retryData.retryInterval)\n      .then(() => policy._nextPolicy.sendRequest(request.clone()))\n      .then((res) => retry(policy, request, res, retryData, undefined))\n      .catch((err) => retry(policy, request, response, retryData, err));\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    const err =\n      retryData.error ||\n      new RestError(\n        \"Failed to send the request.\",\n        RestError.REQUEST_SEND_ERROR,\n        response && response.status,\n        response && response.request,\n        response\n      );\n    return Promise.reject(err);\n  } else {\n    return Promise.resolve(response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport function generateClientRequestIdPolicy(\n  requestIdHeaderName = \"x-ms-client-request-id\"\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);\n    }\n  };\n}\n\nexport class GenerateClientRequestIdPolicy extends BaseRequestPolicy {\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private _requestIdHeaderName: string\n  ) {\n    super(nextPolicy, options);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    if (!request.headers.contains(this._requestIdHeaderName)) {\n      request.headers.set(this._requestIdHeaderName, utils.generateUuid());\n    }\n    return this._nextPolicy.sendRequest(request);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/*\n * NOTE: When moving this file, please update \"browser\" section in package.json\n * and \"plugins\" section in webpack.testconfig.ts.\n */\n\nimport { TelemetryInfo } from \"./userAgentPolicy\";\n\ninterface NavigatorEx extends Navigator {\n  // oscpu is not yet standards-compliant, but can not be undefined in TypeScript 3.6.2\n  readonly oscpu: string;\n}\n\nexport function getDefaultUserAgentKey(): string {\n  return \"x-ms-command-name\";\n}\n\nexport function getPlatformSpecificData(): TelemetryInfo[] {\n  const navigator = window.navigator as NavigatorEx;\n  const osInfo = {\n    key: \"OS\",\n    value: (navigator.oscpu || navigator.platform).replace(\" \", \"\")\n  };\n\n  return [osInfo];\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { Constants } from \"../util/constants\";\nimport { WebResource } from \"../webResource\";\nimport { getDefaultUserAgentKey, getPlatformSpecificData } from \"./msRestUserAgentPolicy\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport type TelemetryInfo = { key?: string; value?: string };\n\n/**\n * Options for adding user agent details to outgoing requests.\n */\nexport interface UserAgentOptions {\n  /*\n   * String prefix to add to the user agent for outgoing requests.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\nfunction getRuntimeInfo(): TelemetryInfo[] {\n  const msRestRuntime = {\n    key: \"core-http\",\n    value: Constants.coreHttpVersion\n  };\n\n  return [msRestRuntime];\n}\n\nfunction getUserAgentString(\n  telemetryInfo: TelemetryInfo[],\n  keySeparator = \" \",\n  valueSeparator = \"/\"\n): string {\n  return telemetryInfo\n    .map((info) => {\n      const value = info.value ? `${valueSeparator}${info.value}` : \"\";\n      return `${info.key}${value}`;\n    })\n    .join(keySeparator);\n}\n\nexport const getDefaultUserAgentHeaderName = getDefaultUserAgentKey;\n\nexport function getDefaultUserAgentValue(): string {\n  const runtimeInfo = getRuntimeInfo();\n  const platformSpecificData = getPlatformSpecificData();\n  const userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));\n  return userAgent;\n}\n\nexport function userAgentPolicy(userAgentData?: TelemetryInfo): RequestPolicyFactory {\n  const key: string =\n    !userAgentData || userAgentData.key == undefined ? getDefaultUserAgentKey() : userAgentData.key;\n  const value: string =\n    !userAgentData || userAgentData.value == undefined\n      ? getDefaultUserAgentValue()\n      : userAgentData.value;\n\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new UserAgentPolicy(nextPolicy, options, key, value);\n    }\n  };\n}\n\nexport class UserAgentPolicy extends BaseRequestPolicy {\n  constructor(\n    readonly _nextPolicy: RequestPolicy,\n    readonly _options: RequestPolicyOptions,\n    protected headerKey: string,\n    protected headerValue: string\n  ) {\n    super(_nextPolicy, _options);\n  }\n\n  sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    this.addUserAgentHeader(request);\n    return this._nextPolicy.sendRequest(request);\n  }\n\n  addUserAgentHeader(request: WebResource): void {\n    if (!request.headers) {\n      request.headers = new HttpHeaders();\n    }\n\n    if (!request.headers.get(this.headerKey) && this.headerValue) {\n      request.headers.set(this.headerKey, this.headerValue);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { URLBuilder } from \"../url\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\n/**\n * Options for how redirect responses are handled.\n */\nexport interface RedirectOptions {\n  /*\n   * When true, redirect responses are followed.  Defaults to true.\n   */\n  handleRedirects: boolean;\n\n  /*\n   * The maximum number of times the redirect URL will be tried before\n   * failing.  Defaults to 20.\n   */\n  maxRetries?: number;\n}\n\nexport const DefaultRedirectOptions: RedirectOptions = {\n  handleRedirects: true,\n  maxRetries: 20\n}\n\nexport function redirectPolicy(maximumRetries = 20): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new RedirectPolicy(nextPolicy, options, maximumRetries);\n    }\n  };\n}\n\nexport class RedirectPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, readonly maxRetries = 20) {\n    super(nextPolicy, options);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request)\n      .then((response) => handleRedirect(this, response, 0));\n  }\n}\n\nfunction handleRedirect(\n  policy: RedirectPolicy,\n  response: HttpOperationResponse,\n  currentRetries: number\n): Promise<HttpOperationResponse> {\n  const { request, status } = response;\n  const locationHeader = response.headers.get(\"location\");\n  if (\n    locationHeader &&\n    (status === 300 || status === 307 || (status === 303 && request.method === \"POST\")) &&\n    (!policy.maxRetries || currentRetries < policy.maxRetries)\n  ) {\n    const builder = URLBuilder.parse(request.url);\n    builder.setPath(locationHeader);\n    request.url = builder.toString();\n\n    // POST request with Status code 303 should be converted into a\n    // redirected GET request if the redirect url is present in the location header\n    if (status === 303) {\n      request.method = \"GET\";\n    }\n\n    return policy._nextPolicy\n      .sendRequest(request)\n      .then((res) => handleRedirect(policy, res, currentRetries + 1));\n  }\n\n  return Promise.resolve(response);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport function rpRegistrationPolicy(retryTimeout = 30): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);\n    }\n  };\n}\n\nexport class RPRegistrationPolicy extends BaseRequestPolicy {\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    readonly _retryTimeout = 30\n  ) {\n    super(nextPolicy, options);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => registerIfNeeded(this, request, response));\n  }\n}\n\nfunction registerIfNeeded(\n  policy: RPRegistrationPolicy,\n  request: WebResource,\n  response: HttpOperationResponse\n): Promise<HttpOperationResponse> {\n  if (response.status === 409) {\n    const rpName = checkRPNotRegisteredError(response.bodyAsText as string);\n    if (rpName) {\n      const urlPrefix = extractSubscriptionUrl(request.url);\n      return (\n        registerRP(policy, urlPrefix, rpName, request)\n          // Autoregistration of ${provider} failed for some reason. We will not return this error\n          // instead will return the initial response with 409 status code back to the user.\n          // do nothing here as we are returning the original response at the end of this method.\n          .catch(() => false)\n          .then((registrationStatus) => {\n            if (registrationStatus) {\n              // Retry the original request. We have to change the x-ms-client-request-id\n              // otherwise Azure endpoint will return the initial 409 (cached) response.\n              request.headers.set(\"x-ms-client-request-id\", utils.generateUuid());\n              return policy._nextPolicy.sendRequest(request.clone());\n            }\n            return response;\n          })\n      );\n    }\n  }\n\n  return Promise.resolve(response);\n}\n\n/**\n * Reuses the headers of the original request and url (if specified).\n * @param {WebResource} originalRequest The original request\n * @param {boolean} reuseUrlToo Should the url from the original request be reused as well. Default false.\n * @returns {object} A new request object with desired headers.\n */\nfunction getRequestEssentials(originalRequest: WebResource, reuseUrlToo = false): WebResource {\n  const reqOptions: WebResource = originalRequest.clone();\n  if (reuseUrlToo) {\n    reqOptions.url = originalRequest.url;\n  }\n\n  // We have to change the x-ms-client-request-id otherwise Azure endpoint\n  // will return the initial 409 (cached) response.\n  reqOptions.headers.set(\"x-ms-client-request-id\", utils.generateUuid());\n\n  // Set content-type to application/json\n  reqOptions.headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n\n  return reqOptions;\n}\n\n/**\n * Validates the error code and message associated with 409 response status code. If it matches to that of\n * RP not registered then it returns the name of the RP else returns undefined.\n * @param {string} body The response body received after making the original request.\n * @returns {string} The name of the RP if condition is satisfied else undefined.\n */\nfunction checkRPNotRegisteredError(body: string): string {\n  let result, responseBody;\n  if (body) {\n    try {\n      responseBody = JSON.parse(body);\n    } catch (err) {\n      // do nothing;\n    }\n    if (\n      responseBody &&\n      responseBody.error &&\n      responseBody.error.message &&\n      responseBody.error.code &&\n      responseBody.error.code === \"MissingSubscriptionRegistration\"\n    ) {\n      const matchRes = responseBody.error.message.match(/.*'(.*)'/i);\n      if (matchRes) {\n        result = matchRes.pop();\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Extracts the first part of the URL, just after subscription:\n * https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/\n * @param {string} url The original request url\n * @returns {string} The url prefix as explained above.\n */\nfunction extractSubscriptionUrl(url: string): string {\n  let result;\n  const matchRes = url.match(/.*\\/subscriptions\\/[a-f0-9-]+\\//gi);\n  if (matchRes && matchRes[0]) {\n    result = matchRes[0];\n  } else {\n    throw new Error(`Unable to extract subscriptionId from the given url - ${url}.`);\n  }\n  return result;\n}\n\n/**\n * Registers the given provider.\n * @param {RPRegistrationPolicy} policy The RPRegistrationPolicy this function is being called against.\n * @param {string} urlPrefix https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/\n * @param {string} provider The provider name to be registered.\n * @param {WebResource} originalRequest The original request sent by the user that returned a 409 response\n * with a message that the provider is not registered.\n * @param {registrationCallback} callback The callback that handles the RP registration\n */\nfunction registerRP(\n  policy: RPRegistrationPolicy,\n  urlPrefix: string,\n  provider: string,\n  originalRequest: WebResource\n): Promise<boolean> {\n  const postUrl = `${urlPrefix}providers/${provider}/register?api-version=2016-02-01`;\n  const getUrl = `${urlPrefix}providers/${provider}?api-version=2016-02-01`;\n  const reqOptions = getRequestEssentials(originalRequest);\n  reqOptions.method = \"POST\";\n  reqOptions.url = postUrl;\n\n  return policy._nextPolicy.sendRequest(reqOptions).then((response) => {\n    if (response.status !== 200) {\n      throw new Error(`Autoregistration of ${provider} failed. Please try registering manually.`);\n    }\n    return getRegistrationStatus(policy, getUrl, originalRequest);\n  });\n}\n\n/**\n * Polls the registration status of the provider that was registered. Polling happens at an interval of 30 seconds.\n * Polling will happen till the registrationState property of the response body is \"Registered\".\n * @param {RPRegistrationPolicy} policy The RPRegistrationPolicy this function is being called against.\n * @param {string} url The request url for polling\n * @param {WebResource} originalRequest The original request sent by the user that returned a 409 response\n * with a message that the provider is not registered.\n * @returns {Promise<boolean>} True if RP Registration is successful.\n */\nfunction getRegistrationStatus(\n  policy: RPRegistrationPolicy,\n  url: string,\n  originalRequest: WebResource\n): Promise<boolean> {\n  const reqOptions: any = getRequestEssentials(originalRequest);\n  reqOptions.url = url;\n  reqOptions.method = \"GET\";\n\n  return policy._nextPolicy.sendRequest(reqOptions).then((res) => {\n    const obj = res.parsedBody as any;\n    if (res.parsedBody && obj.registrationState && obj.registrationState === \"Registered\") {\n      return true;\n    } else {\n      return utils\n        .delay(policy._retryTimeout * 1000)\n        .then(() => getRegistrationStatus(policy, url, originalRequest));\n    }\n  });\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AccessToken } from \"@azure/core-auth\";\n\n/**\n * Defines the default token refresh buffer duration.\n */\nexport const TokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes\n\n/**\n * Provides a cache for an AccessToken that was that\n * was returned from a TokenCredential.\n */\nexport interface AccessTokenCache {\n  /**\n   * Sets the cached token.\n   *\n   * @param The {@link AccessToken} to be cached or null to\n   *        clear the cached token.\n   */\n  setCachedToken(accessToken: AccessToken | undefined): void;\n\n  /**\n   * Returns the cached {@link AccessToken} or undefined if nothing is cached.\n   */\n  getCachedToken(): AccessToken | undefined;\n}\n\n/**\n * Provides an {@link AccessTokenCache} implementation which clears\n * the cached {@link AccessToken}'s after the expiresOnTimestamp has\n * passed.\n */\nexport class ExpiringAccessTokenCache implements AccessTokenCache {\n  private tokenRefreshBufferMs: number;\n  private cachedToken?: AccessToken = undefined;\n\n  /**\n   * Constructs an instance of {@link ExpiringAccessTokenCache} with\n   * an optional expiration buffer time.\n   */\n  constructor(tokenRefreshBufferMs: number = TokenRefreshBufferMs) {\n    this.tokenRefreshBufferMs = tokenRefreshBufferMs;\n  }\n\n  setCachedToken(accessToken: AccessToken | undefined): void {\n    this.cachedToken = accessToken;\n  }\n\n  getCachedToken(): AccessToken | undefined {\n    if (\n      this.cachedToken &&\n      Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp\n    ) {\n      this.cachedToken = undefined;\n    }\n\n    return this.cachedToken;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { TokenCredential, GetTokenOptions } from \"@azure/core-auth\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"../policies/requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { WebResource } from \"../webResource\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"../credentials/accessTokenCache\";\n\n/**\n * Creates a new BearerTokenAuthenticationPolicy factory.\n *\n * @param credential The TokenCredential implementation that can supply the bearer token.\n * @param scopes The scopes for which the bearer token applies.\n */\nexport function bearerTokenAuthenticationPolicy(\n  credential: TokenCredential,\n  scopes: string | string[]\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new BearerTokenAuthenticationPolicy(\n        nextPolicy,\n        options,\n        credential,\n        scopes,\n        tokenCache\n      );\n    }\n  };\n}\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {\n  /**\n   * Creates a new BearerTokenAuthenticationPolicy object.\n   *\n   * @param nextPolicy The next RequestPolicy in the request pipeline.\n   * @param options Options for this RequestPolicy.\n   * @param credential The TokenCredential implementation that can supply the bearer token.\n   * @param scopes The scopes for which the bearer token applies.\n   * @param tokenCache The cache for the most recent AccessToken returned from the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private credential: TokenCredential,\n    private scopes: string | string[],\n    private tokenCache: AccessTokenCache\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   * @param webResource\n   */\n  public async sendRequest(webResource: WebResource): Promise<HttpOperationResponse> {\n    if (!webResource.headers) webResource.headers = new HttpHeaders();\n    const token = await this.getToken({\n      abortSignal: webResource.abortSignal,\n      spanOptions: webResource.spanOptions\n    });\n    webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  private async getToken(options: GetTokenOptions): Promise<string | undefined> {\n    let accessToken = this.tokenCache.getCachedToken();\n    if (accessToken === undefined) {\n      accessToken = (await this.credential.getToken(this.scopes, options)) || undefined;\n      this.tokenCache.setCachedToken(accessToken);\n    }\n\n    return accessToken ? accessToken.token : undefined;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport interface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\nexport interface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\nexport function systemErrorRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  minRetryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new SystemErrorRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        minRetryInterval,\n        maxRetryInterval\n      );\n    }\n  };\n}\n\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n *\n * @constructor\n * @param {number} retryCount        The client retry count.\n * @param {number} retryInterval     The client retry interval, in milliseconds.\n * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.\n * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.\n */\nexport class SystemErrorRetryPolicy extends BaseRequestPolicy {\n  retryCount: number;\n  retryInterval: number;\n  minRetryInterval: number;\n  maxRetryInterval: number;\n  DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\n  DEFAULT_CLIENT_RETRY_COUNT = 3;\n  DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n  DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    minRetryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    this.retryCount = typeof retryCount === \"number\" ? retryCount : this.DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval =\n      typeof retryInterval === \"number\" ? retryInterval : this.DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.minRetryInterval =\n      typeof minRetryInterval === \"number\"\n        ? minRetryInterval\n        : this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    this.maxRetryInterval =\n      typeof maxRetryInterval === \"number\"\n        ? maxRetryInterval\n        : this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => retry(this, request, response));\n  }\n}\n\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\nfunction shouldRetry(policy: SystemErrorRetryPolicy, retryData: RetryData): boolean {\n  let currentCount;\n  if (!retryData) {\n    throw new Error(\"retryData for the SystemErrorRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n  return currentCount < policy.retryCount;\n}\n\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {RetryData} retryData  The retry data.\n * @param {object} err        The operation\"s error, if any.\n */\nfunction updateRetryData(\n  policy: SystemErrorRetryPolicy,\n  retryData?: RetryData,\n  err?: RetryError\n): RetryData {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  }\n\n  // Adjust retry count\n  retryData.retryCount++;\n\n  // Adjust retry interval\n  let incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  const boundedRandDelta =\n    policy.retryInterval * 0.8 +\n    Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n  incrementDelta *= boundedRandDelta;\n\n  retryData.retryInterval = Math.min(\n    policy.minRetryInterval + incrementDelta,\n    policy.maxRetryInterval\n  );\n\n  return retryData;\n}\n\nfunction retry(\n  policy: SystemErrorRetryPolicy,\n  request: WebResource,\n  operationResponse: HttpOperationResponse,\n  retryData?: RetryData,\n  err?: RetryError\n): Promise<HttpOperationResponse> {\n  retryData = updateRetryData(policy, retryData, err);\n  if (\n    err &&\n    err.code &&\n    shouldRetry(policy, retryData) &&\n    (err.code === \"ETIMEDOUT\" ||\n      err.code === \"ESOCKETTIMEDOUT\" ||\n      err.code === \"ECONNREFUSED\" ||\n      err.code === \"ECONNRESET\" ||\n      err.code === \"ENOENT\")\n  ) {\n    // If previous operation ended with an error and the policy allows a retry, do that\n    return utils\n      .delay(retryData.retryInterval)\n      .then(() => policy._nextPolicy.sendRequest(request.clone()))\n      .then((res) => retry(policy, request, res, retryData, err))\n      .catch((err) => retry(policy, request, operationResponse, retryData, err));\n  } else {\n    if (err != undefined) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      err = retryData.error;\n      return Promise.reject(err);\n    }\n    return Promise.resolve(operationResponse);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * The format that will be used to join an array of values together for a query parameter value.\n */\nexport enum QueryCollectionFormat {\n  Csv = \",\",\n  Ssv = \" \",\n  Tsv = \"\\t\",\n  Pipes = \"|\",\n  Multi = \"Multi\"\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { ProxySettings } from \"../serviceClient\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResource } from \"../webResource\";\n\nconst proxyNotSupportedInBrowser = new Error(\"ProxyPolicy is not supported in browser environment\");\n\nexport function getDefaultProxySettings(_proxyUrl?: string): ProxySettings | undefined {\n  return undefined;\n}\n\nexport function proxyPolicy(_proxySettings?: ProxySettings): RequestPolicyFactory {\n  return {\n    create: (_nextPolicy: RequestPolicy, _options: RequestPolicyOptions) => {\n      throw proxyNotSupportedInBrowser;\n    }\n  };\n}\n\nexport class ProxyPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n    super(nextPolicy, options);\n    throw proxyNotSupportedInBrowser;\n  }\n\n  public sendRequest(_request: WebResource): Promise<HttpOperationResponse> {\n    throw proxyNotSupportedInBrowser;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"./requestPolicy\";\nimport { WebResource } from \"../webResource\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/utils\";\n\ntype ResponseHandler = (\n  httpRequest: WebResource,\n  response: HttpOperationResponse\n) => Promise<HttpOperationResponse>;\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n\nexport function throttlingRetryPolicy(): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\n\n/**\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  private _handleResponse: ResponseHandler;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    _handleResponse?: ResponseHandler\n  ) {\n    super(nextPolicy, options);\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n\n  public async sendRequest(httpRequest: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy.sendRequest(httpRequest.clone()).then((response) => {\n      if (response.status !== StatusCodes.TooManyRequests) {\n        return response;\n      } else {\n        return this._handleResponse(httpRequest, response);\n      }\n    });\n  }\n\n  private async _defaultResponseHandler(\n    httpRequest: WebResource,\n    httpResponse: HttpOperationResponse\n  ): Promise<HttpOperationResponse> {\n    const retryAfterHeader: string | undefined = httpResponse.headers.get(\n      Constants.HeaderConstants.RETRY_AFTER\n    );\n\n    if (retryAfterHeader) {\n      const delayInMs: number | undefined = ThrottlingRetryPolicy.parseRetryAfterHeader(\n        retryAfterHeader\n      );\n      if (delayInMs) {\n        return delay(delayInMs).then((_: any) => this._nextPolicy.sendRequest(httpRequest));\n      }\n    }\n\n    return httpResponse;\n  }\n\n  public static parseRetryAfterHeader(headerValue: string): number | undefined {\n    const retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  public static parseDateRetryAfterHeader(headerValue: string): number | undefined {\n    try {\n      const now: number = Date.now();\n      const date: number = Date.parse(headerValue);\n      const diff = date - now;\n\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { ServiceClientCredentials } from \"../credentials/serviceClientCredentials\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport function signingPolicy(\n  authenticationProvider: ServiceClientCredentials\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new SigningPolicy(nextPolicy, options, authenticationProvider);\n    }\n  };\n}\n\nexport class SigningPolicy extends BaseRequestPolicy {\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    public authenticationProvider: ServiceClientCredentials\n  ) {\n    super(nextPolicy, options);\n  }\n\n  signRequest(request: WebResource): Promise<WebResource> {\n    return this.authenticationProvider.signRequest(request);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this.signRequest(request).then((nextRequest) =>\n      this._nextPolicy.sendRequest(nextRequest)\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getTracer, getTraceParentHeader } from \"@azure/core-tracing\";\nimport {\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions,\n  BaseRequestPolicy\n} from \"./requestPolicy\";\nimport { WebResource } from \"../webResource\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\n\nexport function tracingPolicy(): RequestPolicyFactory {\n  return {\n    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n      return new TracingPolicy(nextPolicy, options);\n    }\n  };\n}\n\nexport class TracingPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n    super(nextPolicy, options);\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    if (!request.spanOptions || !request.spanOptions.parent) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    // create a new span\n    const tracer = getTracer();\n    const span = tracer.startSpan(\"core-http\", request.spanOptions);\n\n    try {\n      // set headers\n      const spanContext = span.context();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n\n      const response = await this._nextPolicy.sendRequest(request);\n      span.end();\n      return response;\n    } catch (err) {\n      span.end();\n      throw err;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { DefaultHttpClient } from \"./defaultHttpClient\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpOperationResponse, RestResponse } from \"./httpOperationResponse\";\nimport { HttpPipelineLogger } from \"./httpPipelineLogger\";\nimport { logPolicy, DefaultLoggingOptions } from \"./policies/logPolicy\";\nimport { OperationArguments } from \"./operationArguments\";\nimport {\n  getPathStringFromParameter,\n  getPathStringFromParameterPath,\n  OperationParameter,\n  ParameterPath\n} from \"./operationParameter\";\nimport { isStreamOperation, OperationSpec } from \"./operationSpec\";\nimport {\n  deserializationPolicy,\n  DeserializationContentTypes,\n  DefaultDeserializationOptions\n} from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy, DefaultRetryOptions } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport {\n  userAgentPolicy,\n  getDefaultUserAgentHeaderName,\n  getDefaultUserAgentValue,\n} from \"./policies/userAgentPolicy\";\nimport { redirectPolicy, DefaultRedirectOptions } from \"./policies/redirectPolicy\";\nimport {\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { CompositeMapper, DictionaryMapper, Mapper, MapperType, Serializer } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport { RequestOptionsBase, RequestPrepareOptions, WebResource } from \"./webResource\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { ServiceCallback, isNode } from \"./util/utils\";\nimport { proxyPolicy, getDefaultProxySettings } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { ServiceClientCredentials } from \"./credentials/serviceClientCredentials\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { logger } from \"./log\";\nimport { InternalPipelineOptions } from './pipelineOptions';\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from './policies/keepAlivePolicy';\nimport { tracingPolicy } from './policies/tracingPolicy';\n\n/**\n * Options to configure a proxy for outgoing requests (Node.js only).\n */\nexport interface ProxySettings {\n  /*\n   * The proxy's host address.\n   */\n  host: string;\n\n  /*\n   * The proxy host's port.\n   */\n  port: number;\n\n  /**\n   * The user name to authenticate with the proxy, if required.\n   */\n  username?: string;\n\n  /**\n   * The password to authenticate with the proxy, if required.\n   */\n  password?: string;\n}\n\nexport type ProxyOptions = ProxySettings; // Alias ProxySettings as ProxyOptions for future use.\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions {\n  /**\n   * An array of factories which get called to create the RequestPolicy pipeline used to send a HTTP\n   * request on the wire, or a function that takes in the defaultRequestPolicyFactories and returns\n   * the requestPolicyFactories that will be used.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * The HttpPipelineLogger that can be used to debug RequestPolicies within the HTTP pipeline.\n   */\n  httpPipelineLogger?: HttpPipelineLogger;\n  /**\n   * If set to true, turn off the default retry policy.\n   */\n  noRetryPolicy?: boolean;\n  /**\n   * Gets or sets the retry timeout in seconds for AutomaticRPRegistration. Default value is 30.\n   */\n  rpRegistrationRetryTimeout?: number;\n  /**\n   * Whether or not to generate a client request ID header for each HTTP request.\n   */\n  generateClientRequestIdHeader?: boolean;\n  /**\n   * Whether to include credentials in CORS requests in the browser.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials for more information.\n   */\n  withCredentials?: boolean;\n  /**\n   * If specified, a GenerateRequestIdPolicy will be added to the HTTP pipeline that will add a\n   * header to all outgoing requests with this header name and a random UUID as the request ID.\n   */\n  clientRequestIdHeaderName?: string;\n  /**\n   * The content-types that will be associated with JSON or XML serialization.\n   */\n  deserializationContentTypes?: DeserializationContentTypes;\n  /**\n   * The header name to use for the telemetry header while sending the request. If this is not\n   * specified, then \"User-Agent\" will be used when running on Node.js and \"x-ms-command-name\" will\n   * be used when running in a browser.\n   */\n  userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);\n  /**\n   * The string to be set to the telemetry header while sending the request, or a function that\n   * takes in the default user-agent string and returns the user-agent string that will be used.\n   */\n  userAgent?: string | ((defaultUserAgent: string) => string);\n  /**\n   * Proxy settings which will be used for every HTTP request (Node.js only).\n   */\n  proxySettings?: ProxySettings;\n}\n\n/**\n * @class\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  protected baseUri?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  protected requestContentType?: string;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n  private readonly _requestPolicyOptions: RequestPolicyOptions;\n\n  private readonly _requestPolicyFactories: RequestPolicyFactory[];\n  private readonly _withCredentials: boolean;\n\n  /**\n   * The ServiceClient constructor\n   * @constructor\n   * @param credentials The credentials used for authentication with the service.\n   * @param options The service client options that govern the behavior of the client.\n   */\n  constructor(\n    credentials?: TokenCredential | ServiceClientCredentials,\n    options?: ServiceClientOptions\n  ) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || new DefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n\n    let requestPolicyFactories: RequestPolicyFactory[];\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory: RequestPolicyFactory | undefined = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\n          \"ServiceClient: creating bearer token authentication policy from provided credentials\"\n        );\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory: () => RequestPolicyFactory = () => {\n          let bearerTokenPolicyFactory: RequestPolicyFactory | undefined = undefined;\n          let serviceClient = this;\n          return {\n            create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): RequestPolicy {\n              if (bearerTokenPolicyFactory === undefined) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(\n                  credentials,\n                  `${serviceClient.baseUri || \"\"}/.default`\n                );\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, options);\n            }\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories:\n          | void\n          | RequestPolicyFactory[] = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options: RequestPrepareOptions | WebResource): Promise<HttpOperationResponse> {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest: WebResource;\n    try {\n      if (options instanceof WebResource) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline: RequestPolicy = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(\n          httpPipeline,\n          this._requestPolicyOptions\n        );\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param {OperationArguments} operationArguments The arguments that the HTTP request's templated values will be populated from.\n   * @param {OperationSpec} operationSpec The OperationSpec to use to populate the httpRequest.\n   * @param {ServiceCallback} callback The callback to call when the response is received.\n   */\n  async sendOperationRequest(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n    callback?: ServiceCallback<any>\n  ): Promise<RestResponse> {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    const httpRequest = new WebResource();\n\n    let result: Promise<RestResponse>;\n    try {\n      const baseUri: string | undefined = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\n          \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\"\n        );\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n\n      const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue: string = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            urlParameter,\n            operationSpec.serializer\n          );\n          urlParameterValue = operationSpec.serializer.serialize(\n            urlParameter.mapper,\n            urlParameterValue,\n            getPathStringFromParameter(urlParameter)\n          );\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(\n            `{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`,\n            urlParameterValue\n          );\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            queryParameter,\n            operationSpec.serializer\n          );\n          if (queryParameterValue != undefined) {\n            queryParameterValue = operationSpec.serializer.serialize(\n              queryParameter.mapper,\n              queryParameterValue,\n              getPathStringFromParameter(queryParameter)\n            );\n            if (queryParameter.collectionFormat != undefined) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  queryParameterValue = \"\";\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] = item == undefined ? \"\" : item.toString();\n                  }\n                }\n              } else {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            requestUrl.setQueryParameter(\n              queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n              queryParameterValue\n            );\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            headerParameter,\n            operationSpec.serializer\n          );\n          if (headerValue != undefined) {\n            headerValue = operationSpec.serializer.serialize(\n              headerParameter.mapper,\n              headerValue,\n              getPathStringFromParameter(headerParameter)\n            );\n            const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n              .headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(\n                headerParameter.mapper.serializedName ||\n                  getPathStringFromParameter(headerParameter),\n                headerValue\n              );\n            }\n          }\n        }\n      }\n\n      const options: RequestOptionsBase | undefined = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n\n        if (options.spanOptions) {\n          httpRequest.spanOptions = options.spanOptions;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseBody == undefined) {\n        httpRequest.streamResponseBody = isStreamOperation(operationSpec);\n      }\n\n      let rawResponse: HttpOperationResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response){\n          sendRequestError.details = flattenResponse(\n            sendRequestError.response,\n            operationSpec.responses[sendRequestError.statusCode] ||\n              operationSpec.responses[\"default\"]\n          );\n        }\n        result = Promise.reject(\n          sendRequestError\n        );\n      } else {\n        result = Promise.resolve(\n          flattenResponse(rawResponse!, operationSpec.responses[rawResponse!.status])\n        );\n      }\n    } catch (error) {\n      result = Promise.reject(error);\n    }\n\n    const cb = callback;\n    if (cb) {\n      result\n        // tslint:disable-next-line:no-null-keyword\n        .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n        .catch((err) => cb(err));\n    }\n\n    return result;\n  }\n}\n\nexport function serializeRequestBody(\n  serviceClient: ServiceClient,\n  httpRequest: WebResource,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(\n      serviceClient,\n      operationArguments,\n      operationSpec.requestBody,\n      operationSpec.serializer\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const { required, xmlName, xmlElementName, serializedName } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n    try {\n      if (httpRequest.body != undefined || required) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        httpRequest.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          httpRequest.body,\n          requestBodyParameterPathString\n        );\n        const isStream = typeName === MapperType.Stream;\n        if (operationSpec.isXML) {\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(\n              utils.prepareXMLRootList(\n                httpRequest.body,\n                xmlElementName || xmlName || serializedName!\n              ),\n              { rootName: xmlName || serializedName }\n            );\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(httpRequest.body, {\n              rootName: xmlName || serializedName\n            });\n          }\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue: any = getOperationArgumentValueFromParameter(\n        serviceClient,\n        operationArguments,\n        formDataParameter,\n        operationSpec.serializer\n      );\n      if (formDataParameterValue != undefined) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter)\n        );\n      }\n    }\n  }\n}\n\nfunction getValueOrFunctionResult(\n  value: undefined | string | ((defaultValue: string) => string),\n  defaultValueCreator: () => string\n): string {\n  let result: string;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(\n  authPolicyFactory: RequestPolicyFactory | undefined,\n  options: ServiceClientOptions\n): RequestPolicyFactory[] {\n  const factories: RequestPolicyFactory[] = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName: string = getValueOrFunctionResult(\n    options.userAgentHeaderName,\n    getDefaultUserAgentHeaderName\n  );\n  const userAgentHeaderValue: string = getValueOrFunctionResult(\n    options.userAgent,\n    getDefaultUserAgentValue\n  );\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  const proxySettings = options.proxySettings || getDefaultProxySettings();\n  if (proxySettings) {\n    factories.push(proxyPolicy(proxySettings));\n  }\n\n  factories.push(logPolicy(logger.info, {}));\n\n  return factories;\n}\n\nexport function createPipelineFromOptions(\n  pipelineOptions: InternalPipelineOptions,\n  authPolicyFactory?: RequestPolicyFactory\n) : ServiceClientOptions {\n  let requestPolicyFactories: RequestPolicyFactory[] = [];\n\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo: string[] = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = {\n    ...DefaultKeepAliveOptions,\n    ...pipelineOptions.keepAliveOptions\n  };\n\n  const retryOptions = {\n    ...DefaultRetryOptions,\n    ...pipelineOptions.retryOptions\n  };\n\n  const redirectOptions = {\n    ...DefaultRedirectOptions,\n    ...pipelineOptions.redirectOptions\n  };\n\n  const proxySettings = pipelineOptions.proxyOptions || getDefaultProxySettings();\n  if (isNode && proxySettings) {\n    requestPolicyFactories.push(\n      proxyPolicy(proxySettings)\n    )\n  }\n\n  const deserializationOptions = {\n    ...DefaultDeserializationOptions,\n    ...pipelineOptions.deserializationOptions\n  };\n\n  const loggingOptions = {\n    ...DefaultLoggingOptions,\n    ...pipelineOptions.loggingOptions\n  };\n\n  requestPolicyFactories.push(\n    tracingPolicy(),\n    keepAlivePolicy(keepAliveOptions),\n    userAgentPolicy({ value: userAgentValue }),\n    generateClientRequestIdPolicy(),\n    deserializationPolicy(deserializationOptions.expectedContentTypes),\n    throttlingRetryPolicy(),\n    systemErrorRetryPolicy(),\n    exponentialRetryPolicy(\n      retryOptions.maxRetries,\n      retryOptions.retryDelayInMs,\n      retryOptions.maxRetryDelayInMs\n    )\n  )\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(\n      redirectPolicy(redirectOptions.maxRetries)\n    );\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(\n    logPolicy(\n      loggingOptions.logger,\n      loggingOptions.logPolicyOptions\n    )\n  );\n\n  if (pipelineOptions.updatePipelinePolicies) {\n    // If the update function throws an exception, let it bubble up.\n    requestPolicyFactories = pipelineOptions.updatePipelinePolicies(requestPolicyFactories);\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories\n  };\n}\n\n\nexport type PropertyParent = { [propertyName: string]: any };\n\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent: PropertyParent, propertyPath: string[]): PropertyParent {\n  if (parent && propertyPath) {\n    const propertyPathLength: number = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName: string = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  serializer: Serializer\n): any {\n  return getOperationArgumentValueFromParameterPath(\n    serviceClient,\n    operationArguments,\n    parameter.parameterPath,\n    parameter.mapper,\n    serializer\n  );\n}\n\nexport function getOperationArgumentValueFromParameterPath(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameterPath: ParameterPath,\n  parameterMapper: Mapper,\n  serializer: Serializer\n): any {\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult: PropertySearchResult = getPropertyFromParameterPath(\n          operationArguments,\n          parameterPath\n        );\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n\n      // Serialize just for validation purposes.\n      const parameterPathString: string = getPathStringFromParameterPath(\n        parameterPath,\n        parameterMapper\n      );\n      serializer.serialize(parameterMapper, value, parameterPathString);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameterPath(\n        serviceClient,\n        operationArguments,\n        propertyPath,\n        propertyMapper,\n        serializer\n      );\n      // Serialize just for validation purposes.\n      const propertyPathString: string = getPathStringFromParameterPath(\n        propertyPath,\n        propertyMapper\n      );\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString);\n      if (propertyValue !== undefined) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[]\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent != undefined && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\nexport function flattenResponse(\n  _response: HttpOperationResponse,\n  responseSpec: OperationResponse | undefined\n): RestResponse {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = (obj: {}) =>\n    Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      });\n    }\n\n    const modelProperties =\n      (typeName === \"Composite\" && (bodyMapper as CompositeMapper).type.modelProperties) || {};\n    const isPageableResponse = Object.keys(modelProperties).some(\n      (k) => modelProperties[k].serializedName === \"\"\n    );\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])] as RestResponse & any[];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        ..._response.parsedBody\n      });\n    }\n  }\n\n  if (\n    bodyMapper ||\n    _response.request.method === \"HEAD\" ||\n    utils.isPrimitiveType(_response.parsedBody)\n  ) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse({\n      ...parsedHeaders,\n      body: _response.parsedBody\n    });\n  }\n\n  return addOperationResponse({\n    ...parsedHeaders,\n    ..._response.parsedBody\n  });\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { SpanOptions } from \"@azure/core-tracing\";\n\n/**\n * Represents a credential capable of providing an authentication token.\n */\nexport interface TokenCredential {\n  /**\n   * Gets the token provided by this credential.\n   *\n   * @param scopes The list of scopes for which the token will have access.\n   * @param options The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;\n}\n\n/**\n * Defines options for TokenCredential.getToken.\n */\nexport interface GetTokenOptions {\n  /**\n   * An AbortSignalLike implementation that can be used to cancel\n   * the token request.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Timeout for pinging services\n   */\n  timeout?: number;\n  /**\n   * Options to create a span using the tracer if any was set.\n   */\n  spanOptions?: SpanOptions;\n}\n\n/**\n * Represents an access token with an expiration time.\n */\nexport interface AccessToken {\n  /**\n   * The access token.\n   */\n  token: string;\n\n  /**\n   * The access token's expiration timestamp.\n   */\n  expiresOnTimestamp: number;\n}\n\n/**\n * Tests an object to determine whether it implements TokenCredential.\n *\n * @param credential The assumed TokenCredential to be tested.\n */\nexport function isTokenCredential(credential: any): credential is TokenCredential {\n  // Check for an object with a 'getToken' function and possibly with\n  // a 'signRequest' function.  We do this check to make sure that\n  // a ServiceClientCredentials implementor (like TokenClientCredentials\n  // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if\n  // it doesn't actually implement TokenCredential also.\n  return (\n    credential &&\n    typeof credential.getToken === \"function\" &&\n    (credential.signRequest === undefined || credential.getToken.length > 0)\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The AzureLogger used for all clients within the identity package\n */\nexport const logger = createClientLogger(\"identity\");\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport qs from \"qs\";\nimport {\n  AccessToken,\n  ServiceClient,\n  ServiceClientOptions,\n  WebResource,\n  RequestPrepareOptions,\n  GetTokenOptions,\n  tracingPolicy,\n  RequestPolicyFactory\n} from \"@azure/core-http\";\nimport { CanonicalCode } from \"@azure/core-tracing\";\nimport { AuthenticationError, AuthenticationErrorName } from \"./errors\";\nimport { createSpan } from \"../util/tracing\";\nimport { logger } from '../util/logging';\n\n\nconst DefaultAuthorityHost = \"https://login.microsoftonline.com\";\n\n/**\n * An internal type used to communicate details of a token request's\n * response that should not be sent back as part of the AccessToken.\n */\nexport interface TokenResponse {\n  /**\n   * The AccessToken to be returned from getToken.\n   */\n  accessToken: AccessToken;\n\n  /**\n   * The refresh token if the 'offline_access' scope was used.\n   */\n  refreshToken?: string;\n}\n\nexport class IdentityClient extends ServiceClient {\n  public authorityHost: string;\n\n  constructor(options?: IdentityClientOptions) {\n    options = options || IdentityClient.getDefaultOptions();\n    super(undefined, options);\n\n    this.baseUri = this.authorityHost = options.authorityHost || DefaultAuthorityHost;\n\n    if (!this.baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n  }\n\n  createWebResource(requestOptions: RequestPrepareOptions): WebResource {\n    const webResource = new WebResource();\n    webResource.prepare(requestOptions);\n    return webResource;\n  }\n\n  async sendTokenRequest(\n    webResource: WebResource,\n    expiresOnParser?: (responseBody: any) => number\n  ): Promise<TokenResponse | null> {\n    logger.info(`IdentityClient: sending token request to [${webResource.url}]`);\n    const response = await this.sendRequest(webResource);\n\n    expiresOnParser =\n      expiresOnParser ||\n      ((responseBody: any) => {\n        return Date.now() + responseBody.expires_in * 1000;\n      });\n\n    if (response.status === 200 || response.status === 201) {\n      const token = {\n        accessToken: {\n          token: response.parsedBody.access_token,\n          expiresOnTimestamp: expiresOnParser(response.parsedBody)\n        },\n        refreshToken: response.parsedBody.refresh_token\n      };\n\n      logger.info(`IdentityClient: [${webResource.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n      return token;\n    } else {\n      const error = new AuthenticationError(response.status, response.parsedBody || response.bodyAsText);\n      logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n      throw error;\n    }\n  }\n\n  async refreshAccessToken(\n    tenantId: string,\n    clientId: string,\n    scopes: string,\n    refreshToken: string | undefined,\n    clientSecret: string | undefined,\n    expiresOnParser?: (responseBody: any) => number,\n    options?: GetTokenOptions\n  ): Promise<TokenResponse | null> {\n    if (refreshToken === undefined) {\n      return null;\n    }\n    logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n\n    const { span, options: newOptions } = createSpan(\"IdentityClient-refreshAccessToken\", options);\n\n    const refreshParams = {\n      grant_type: \"refresh_token\",\n      client_id: clientId,\n      refresh_token: refreshToken,\n      scope: scopes\n    };\n\n    if (clientSecret !== undefined) {\n      (refreshParams as any).client_secret = clientSecret;\n    }\n\n    try {\n      const webResource = this.createWebResource({\n        url: `${this.authorityHost}/${tenantId}/oauth2/v2.0/token`,\n        method: \"POST\",\n        disableJsonStringifyOnBody: true,\n        deserializationMapper: undefined,\n        body: qs.stringify(refreshParams),\n        headers: {\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        spanOptions: newOptions.spanOptions,\n        abortSignal: options && options.abortSignal\n      });\n\n      const response = await this.sendTokenRequest(webResource, expiresOnParser);\n      logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n      return response;\n    } catch (err) {\n      if (\n        err.name === AuthenticationErrorName &&\n        err.errorResponse.error === \"interaction_required\"\n      ) {\n        // It's likely that the refresh token has expired, so\n        // return null so that the credential implementation will\n        // initiate the authentication flow again.\n        logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n        span.setStatus({\n          code: CanonicalCode.UNAUTHENTICATED,\n          message: err.message\n        });\n\n        return null;\n      } else {\n        logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n      span.setStatus({\n          code: CanonicalCode.UNKNOWN,\n          message: err.message\n        });\n        throw err;\n      }\n    } finally {\n      span.end();\n    }\n  }\n\n  static getDefaultOptions(): IdentityClientOptions {\n    return {\n      authorityHost: DefaultAuthorityHost,\n      requestPolicyFactories: (factories: RequestPolicyFactory[]) => {\n        return [tracingPolicy(), ...factories];\n      }\n    };\n  }\n}\n\n/**\n * Provides options to configure how the Identity library makes authentication\n * requests to Azure Active Directory.\n */\nexport interface IdentityClientOptions extends ServiceClientOptions {\n  /**\n   * The authority host to use for authentication requests.  The default is\n   * \"https://login.microsoftonline.com\".\n   */\n  authorityHost?: string;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-http\";\nimport { IdentityClientOptions } from \"../client/identityClient\";\n\nconst BrowserNotSupportedError = new Error(\n  \"ClientCertificateCredential is not supported in the browser.\"\n);\n\nexport class ClientCertificateCredential implements TokenCredential {\n  constructor(\n    tenantId: string,\n    clientId: string,\n    certificatePath: string,\n    options?: IdentityClientOptions\n  ) {\n    throw BrowserNotSupportedError;\n  }\n\n  public getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    throw BrowserNotSupportedError;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class CryptoUtils {\r\n\r\n    /**\r\n     * Creates a new random GUID - used to populate state?\r\n     * @returns string (GUID)\r\n     */\r\n    static createNewGuid(): string {\r\n        // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or\r\n        // pseudo-random numbers.\r\n        // The algorithm is as follows:\r\n        //     Set the two most significant bits (bits 6 and 7) of the\r\n        //        clock_seq_hi_and_reserved to zero and one, respectively.\r\n        //     Set the four most significant bits (bits 12 through 15) of the\r\n        //        time_hi_and_version field to the 4-bit version number from\r\n        //        Section 4.1.3. Version4\r\n        //     Set all the other bits to randomly (or pseudo-randomly) chosen\r\n        //     values.\r\n        // UUID                   = time-low \"-\" time-mid \"-\"time-high-and-version \"-\"clock-seq-reserved and low(2hexOctet)\"-\" node\r\n        // time-low               = 4hexOctet\r\n        // time-mid               = 2hexOctet\r\n        // time-high-and-version  = 2hexOctet\r\n        // clock-seq-and-reserved = hexOctet:\r\n        // clock-seq-low          = hexOctet\r\n        // node                   = 6hexOctet\r\n        // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\r\n        // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10\r\n        // y values are 8, 9, A, B\r\n\r\n        const cryptoObj: Crypto = window.crypto; // for IE 11\r\n        if (cryptoObj && cryptoObj.getRandomValues) {\r\n        const buffer: Uint8Array = new Uint8Array(16);\r\n        cryptoObj.getRandomValues(buffer);\r\n\r\n        //buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).\r\n        buffer[6] |= 0x40; //buffer[6] | 01000000 will set the 6 bit to 1.\r\n        buffer[6] &= 0x4f; //buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = \"4\".\r\n\r\n        //buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.\r\n        buffer[8] |= 0x80; //buffer[8] | 10000000 will set the 7 bit to 1.\r\n        buffer[8] &= 0xbf; //buffer[8] & 10111111 will set the 6 bit to 0.\r\n\r\n        return CryptoUtils.decimalToHex(buffer[0]) + CryptoUtils.decimalToHex(buffer[1])\r\n            + CryptoUtils.decimalToHex(buffer[2]) + CryptoUtils.decimalToHex(buffer[3])\r\n            + \"-\" + CryptoUtils.decimalToHex(buffer[4]) + CryptoUtils.decimalToHex(buffer[5])\r\n            + \"-\" + CryptoUtils.decimalToHex(buffer[6]) + CryptoUtils.decimalToHex(buffer[7])\r\n            + \"-\" + CryptoUtils.decimalToHex(buffer[8]) + CryptoUtils.decimalToHex(buffer[9])\r\n            + \"-\" + CryptoUtils.decimalToHex(buffer[10]) + CryptoUtils.decimalToHex(buffer[11])\r\n            + CryptoUtils.decimalToHex(buffer[12]) + CryptoUtils.decimalToHex(buffer[13])\r\n            + CryptoUtils.decimalToHex(buffer[14]) + CryptoUtils.decimalToHex(buffer[15]);\r\n        }\r\n        else {\r\n        const guidHolder: string = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\";\r\n        const hex: string = \"0123456789abcdef\";\r\n        let r: number = 0;\r\n        let guidResponse: string = \"\";\r\n        for (let i: number = 0; i < 36; i++) {\r\n            if (guidHolder[i] !== \"-\" && guidHolder[i] !== \"4\") {\r\n            // each x and y needs to be random\r\n            r = Math.random()  * 16 | 0;\r\n            }\r\n            if (guidHolder[i] === \"x\") {\r\n            guidResponse += hex[r];\r\n            } else if (guidHolder[i] === \"y\") {\r\n            // clock-seq-and-reserved first hex is filtered and remaining hex values are random\r\n            r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??\r\n            r |= 0x8; // set pos 3 to 1 as 1???\r\n            guidResponse += hex[r];\r\n            } else {\r\n            guidResponse += guidHolder[i];\r\n            }\r\n        }\r\n        return guidResponse;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Decimal to Hex\r\n     *\r\n     * @param num\r\n     */\r\n    static decimalToHex(num: number): string {\r\n        var hex: string = num.toString(16);\r\n        while (hex.length < 2) {\r\n        hex = \"0\" + hex;\r\n        }\r\n        return hex;\r\n    }\r\n\r\n    \r\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Solution_4_%E2%80%93_escaping_the_string_before_encoding_it\r\n\r\n    /**\r\n     * encoding string to base64 - platform specific check\r\n     *\r\n     * @param input\r\n     */\r\n    static base64Encode(input: string): string {\r\n        return btoa(encodeURIComponent(input).replace(/%([0-9A-F]{2})/g,\r\n            function toSolidBytes(match, p1) {\r\n                return String.fromCharCode(Number(\"0x\" + p1));\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * decoding base64 token - platform specific check\r\n     *\r\n     * @param base64IdToken\r\n     */\r\n    static base64Decode(input: string): string {\r\n        return decodeURIComponent(atob(input).split(\"\").map(function(c) {\r\n            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\r\n        }).join(\"\"));\r\n    }\r\n\r\n    /**\r\n     * deserialize a string\r\n     *\r\n     * @param query\r\n     */\r\n    static deserialize(query: string): any {\r\n        let match: Array<string>; // Regex for replacing addition symbol with a space\r\n        const pl = /\\+/g;\r\n        const search = /([^&=]+)=([^&]*)/g;\r\n        const decode = (s: string) => decodeURIComponent(s.replace(pl, \" \"));\r\n        const obj: {} = {};\r\n        match = search.exec(query);\r\n        while (match) {\r\n        obj[decode(match[1])] = decode(match[2]);\r\n        match = search.exec(query);\r\n        }\r\n        return obj;\r\n    }\r\n\r\n}\r\n","import { CacheLocation } from \"../Configuration\";\r\n\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/**\r\n * @hidden\r\n * Constants\r\n */\r\nexport class Constants {\r\n  static get errorDescription(): string { return \"error_description\"; }\r\n  static get error(): string { return \"error\"; }\r\n\r\n  static get scope(): string { return \"scope\"; }\r\n  static get clientInfo(): string { return \"client_info\"; }\r\n  static get clientId(): string { return \"clientId\"; }\r\n\r\n  static get idToken(): string { return \"id_token\"; }\r\n  static get adalIdToken(): string { return \"adal.idtoken\"; }\r\n  static get accessToken(): string { return \"access_token\"; }\r\n  static get expiresIn(): string { return \"expires_in\"; }\r\n  static get sessionState(): string { return \"session_state\"; }\r\n  static get claims(): string { return \"claims\"; }\r\n\r\n  static get msalClientInfo(): string { return \"msal.client.info\"; }\r\n  static get msalError(): string { return \"msal.error\"; }\r\n  static get msalErrorDescription(): string { return \"msal.error.description\"; }\r\n\r\n  static get msalSessionState(): string { return \"msal.session.state\"; }\r\n  static get tokenKeys(): string { return \"msal.token.keys\"; }\r\n  static get accessTokenKey(): string { return \"msal.access.token.key\"; }\r\n  static get expirationKey(): string { return \"msal.expiration.key\"; }\r\n  static get stateLogin(): string { return \"msal.state.login\"; }\r\n  static get stateAcquireToken(): string { return \"msal.state.acquireToken\"; }\r\n  static get stateRenew(): string { return \"msal.state.renew\"; }\r\n  static get nonceIdToken(): string { return \"msal.nonce.idtoken\"; }\r\n  static get userName(): string { return \"msal.username\"; }\r\n  static get idTokenKey(): string { return \"msal.idtoken\"; }\r\n  static get loginRequest(): string { return \"msal.login.request\"; }\r\n  static get loginError(): string { return \"msal.login.error\"; }\r\n  static get renewStatus(): string { return \"msal.token.renew.status\"; }\r\n  static get urlHash(): string { return \"msal.urlHash\"; }\r\n  static get angularLoginRequest(): string { return \"msal.angular.login.request\"; }\r\n  static get msal(): string { return \"msal\"; }\r\n\r\n  static get no_account(): string { return \"NO_ACCOUNT\"; }\r\n  static get consumersUtid(): string { return \"9188040d-6c67-4c5b-b112-36a304b66dad\"; }\r\n  static get upn(): string { return \"upn\"; }\r\n\r\n  static get prompt_select_account(): string { return \"&prompt=select_account\"; }\r\n  static get prompt_none(): string { return \"&prompt=none\"; }\r\n  static get prompt(): string { return \"prompt\"; }\r\n\r\n  static get response_mode_fragment(): string { return \"&response_mode=fragment\"; }\r\n  static get resourceDelimiter(): string { return \"|\"; }\r\n\r\n  static get tokenRenewStatusCancelled(): string { return \"Canceled\"; }\r\n  static get tokenRenewStatusCompleted(): string { return \"Completed\"; }\r\n  static get tokenRenewStatusInProgress(): string { return \"In Progress\"; }\r\n\r\n  private static _popUpWidth: number = 483;\r\n  static get popUpWidth(): number { return this._popUpWidth; }\r\n  static set popUpWidth(width: number) {\r\n    this._popUpWidth = width;\r\n  }\r\n  private static _popUpHeight: number = 600;\r\n  static get popUpHeight(): number { return this._popUpHeight; }\r\n  static set popUpHeight(height: number) {\r\n    this._popUpHeight = height;\r\n  }\r\n\r\n  static get login(): string { return \"LOGIN\"; }\r\n  static get renewToken(): string { return \"RENEW_TOKEN\"; }\r\n  static get unknown(): string { return \"UNKNOWN\"; }\r\n\r\n  static get homeAccountIdentifier(): string { return \"homeAccountIdentifier\"; }\r\n\r\n  static get common(): string { return \"common\"; }\r\n  static get openidScope(): string { return \"openid\"; }\r\n  static get profileScope(): string { return \"profile\"; }\r\n\r\n  static get cacheLocationLocal(): CacheLocation { return \"localStorage\"; }\r\n  static get cacheLocationSession(): CacheLocation { return \"sessionStorage\"; }\r\n\r\n  static get interactionTypeRedirect(): InteractionType { return \"redirectInteraction\"; }\r\n  static get interactionTypePopup(): InteractionType { return \"popupInteraction\"; }\r\n}\r\n\r\n/**\r\n * @hidden\r\n * CacheKeys for 'authority' and 'account'\r\n */\r\nexport const CacheKeys = {\r\n    AUTHORITY: \"msal.authority\",\r\n    ACQUIRE_TOKEN_ACCOUNT: \"msal.acquireTokenAccount\"\r\n};\r\n\r\nexport const AADTrustedHostList =  {\r\n  \"login.windows.net\": \"login.windows.net\",\r\n  \"login.chinacloudapi.cn\": \"login.chinacloudapi.cn\",\r\n  \"login.cloudgovapi.us\": \"login.cloudgovapi.us\",\r\n  \"login.microsoftonline.com\": \"login.microsoftonline.com\",\r\n  \"login.microsoftonline.de\": \"login.microsoftonline.de\",\r\n  \"login.microsoftonline.us\": \"login.microsoftonline.us\"\r\n};\r\n\r\n/**\r\n * @hidden\r\n * SSO Types - generated to populate hints\r\n */\r\nexport const SSOTypes = {\r\n    ACCOUNT: \"account\",\r\n    SID: \"sid\",\r\n    LOGIN_HINT: \"login_hint\",\r\n    ID_TOKEN: \"id_token\",\r\n    DOMAIN_HINT: \"domain_hint\",\r\n    ORGANIZATIONS: \"organizations\",\r\n    CONSUMERS: \"consumers\",\r\n    ACCOUNT_ID: \"accountIdentifier\",\r\n    HOMEACCOUNT_ID: \"homeAccountIdentifier\",\r\n    LOGIN_REQ: \"login_req\",\r\n    DOMAIN_REQ: \"domain_req\"\r\n};\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport const BlacklistedEQParams = [\r\n  SSOTypes.SID,\r\n  SSOTypes.LOGIN_HINT\r\n];\r\n\r\nexport type InteractionType = \"redirectInteraction\" | \"popupInteraction\";\r\n\r\n/**\r\n * we considered making this \"enum\" in the request instead of string, however it looks like the allowed list of\r\n * prompt values kept changing over past couple of years. There are some undocumented prompt values for some\r\n * internal partners too, hence the choice of generic \"string\" type instead of the \"enum\"\r\n * @hidden\r\n */\r\nexport const PromptState = {\r\n\tLOGIN: \"login\",\r\n\tSELECT_ACCOUNT: \"select_account\",\r\n\tCONSENT: \"consent\",\r\n\tNONE: \"none\",\r\n};\r\n\r\n/**\r\n * MSAL JS Library Version\r\n */\r\nexport function libraryVersion(): string {\r\n  return \"1.1.3\";\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport class ScopeSet {\r\n\r\n    /**\r\n   * Check if there are dup scopes in a given request\r\n   *\r\n   * @param cachedScopes\r\n   * @param scopes\r\n   */\r\n  // TODO: Rename this, intersecting scopes isn't a great name for duplicate checker\r\n  static isIntersectingScopes(cachedScopes: Array<string>, scopes: Array<string>): boolean {\r\n    cachedScopes = this.convertToLowerCase(cachedScopes);\r\n    for (let i = 0; i < scopes.length; i++) {\r\n      if (cachedScopes.indexOf(scopes[i].toLowerCase()) > -1) {\r\n          return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a given scope is present in the request\r\n   *\r\n   * @param cachedScopes\r\n   * @param scopes\r\n   */\r\n  static containsScope(cachedScopes: Array<string>, scopes: Array<string>): boolean {\r\n    cachedScopes = this.convertToLowerCase(cachedScopes);\r\n    return scopes.every((value: any): boolean => cachedScopes.indexOf(value.toString().toLowerCase()) >= 0);\r\n  }\r\n\r\n  /**\r\n   * toLower\r\n   *\r\n   * @param scopes\r\n   */\r\n  // TODO: Rename this, too generic name for a function that only deals with scopes\r\n  static convertToLowerCase(scopes: Array<string>): Array<string> {\r\n    return scopes.map(scope => scope.toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * remove one element from a scope array\r\n   *\r\n   * @param scopes\r\n   * @param scope\r\n   */\r\n  // TODO: Rename this, too generic name for a function that only deals with scopes\r\n  static removeElement(scopes: Array<string>, scope: string): Array<string> {\r\n    return scopes.filter(value => value !== scope);\r\n  }\r\n\r\n  /**\r\n   * Parse the scopes into a formatted scopeList\r\n   * @param scopes\r\n   */\r\n  static parseScope(scopes: Array<string>): string {\r\n    let scopeList: string = \"\";\r\n    if (scopes) {\r\n        for (let i: number = 0; i < scopes.length; ++i) {\r\n        scopeList += (i !== scopes.length - 1) ? scopes[i] + \" \" : scopes[i];\r\n      }\r\n    }\r\n\r\n    return scopeList;\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class StringUtils {\r\n    /**\r\n     * Check if a string is empty\r\n     *\r\n     * @param str\r\n     */\r\n    static isEmpty(str: string): boolean {\r\n        return (typeof str === \"undefined\" || !str || 0 === str.length);\r\n    }\r\n}","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { IUri } from \"../IUri\";\r\nimport { Constants, SSOTypes } from \"./Constants\";\r\nimport { ServerRequestParameters } from \"../ServerRequestParameters\";\r\nimport { ScopeSet } from \"../ScopeSet\";\r\nimport { StringUtils } from './StringUtils';\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class UrlUtils {\r\n\r\n  /**\r\n   * generates the URL with QueryString Parameters\r\n   * @param scopes\r\n   */\r\n  static createNavigateUrl(serverRequestParams: ServerRequestParameters): string {\r\n    const str = this.createNavigationUrlString(serverRequestParams);\r\n    let authEndpoint: string = serverRequestParams.authorityInstance.AuthorizationEndpoint;\r\n    // if the endpoint already has queryparams, lets add to it, otherwise add the first one\r\n    if (authEndpoint.indexOf(\"?\") < 0) {\r\n      authEndpoint += \"?\";\r\n    } else {\r\n      authEndpoint += \"&\";\r\n    }\r\n\r\n    const requestUrl: string = `${authEndpoint}${str.join(\"&\")}`;\r\n    return requestUrl;\r\n  }\r\n\r\n  /**\r\n   * Generate the array of all QueryStringParams to be sent to the server\r\n   * @param scopes\r\n   */\r\n  static createNavigationUrlString(serverRequestParams: ServerRequestParameters): Array<string> {\r\n    let scopes = serverRequestParams.scopes;\r\n\r\n    if (scopes.indexOf(serverRequestParams.clientId) === -1) {\r\n      scopes.push(serverRequestParams.clientId);\r\n    }\r\n    const str: Array<string> = [];\r\n    str.push(\"response_type=\" + serverRequestParams.responseType);\r\n\r\n    this.translateclientIdUsedInScope(scopes, serverRequestParams.clientId);\r\n    str.push(\"scope=\" + encodeURIComponent(ScopeSet.parseScope(scopes)));\r\n    str.push(\"client_id=\" + encodeURIComponent(serverRequestParams.clientId));\r\n    str.push(\"redirect_uri=\" + encodeURIComponent(serverRequestParams.redirectUri));\r\n\r\n    str.push(\"state=\" + encodeURIComponent(serverRequestParams.state));\r\n    str.push(\"nonce=\" + encodeURIComponent(serverRequestParams.nonce));\r\n\r\n    str.push(\"client_info=1\");\r\n    str.push(`x-client-SKU=${serverRequestParams.xClientSku}`);\r\n    str.push(`x-client-Ver=${serverRequestParams.xClientVer}`);\r\n    if (serverRequestParams.promptValue) {\r\n      str.push(\"prompt=\" + encodeURIComponent(serverRequestParams.promptValue));\r\n    }\r\n\r\n    if (serverRequestParams.claimsValue) {\r\n      str.push(\"claims=\" + encodeURIComponent(serverRequestParams.claimsValue));\r\n    }\r\n\r\n    if (serverRequestParams.queryParameters) {\r\n      str.push(serverRequestParams.queryParameters);\r\n    }\r\n\r\n    if (serverRequestParams.extraQueryParameters) {\r\n      str.push(serverRequestParams.extraQueryParameters);\r\n    }\r\n\r\n    str.push(\"client-request-id=\" + encodeURIComponent(serverRequestParams.correlationId));\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * append the required scopes: https://openid.net/specs/openid-connect-basic-1_0.html#Scopes\r\n   * @param scopes\r\n   */\r\n  private static translateclientIdUsedInScope(scopes: Array<string>, clientId: string): void {\r\n    const clientIdIndex: number = scopes.indexOf(clientId);\r\n    if (clientIdIndex >= 0) {\r\n      scopes.splice(clientIdIndex, 1);\r\n      if (scopes.indexOf(\"openid\") === -1) {\r\n        scopes.push(\"openid\");\r\n      }\r\n      if (scopes.indexOf(\"profile\") === -1) {\r\n        scopes.push(\"profile\");\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns current window URL as redirect uri\r\n   */\r\n  static getDefaultRedirectUri(): string {\r\n    return window.location.href.split(\"?\")[0].split(\"#\")[0];\r\n  }\r\n\r\n  /**\r\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n   * @param href The url\r\n   * @param tenantId The tenant id to replace\r\n   */\r\n  static replaceTenantPath(url: string, tenantId: string): string {\r\n    url = url.toLowerCase();\r\n    var urlObject = this.GetUrlComponents(url);\r\n    var pathArray = urlObject.PathSegments;\r\n    if (tenantId && (pathArray.length !== 0 && (pathArray[0] === Constants.common || pathArray[0] === SSOTypes.ORGANIZATIONS))) {\r\n      pathArray[0] = tenantId;\r\n    }\r\n    return this.constructAuthorityUriFromObject(urlObject, pathArray);\r\n  }\r\n\r\n  static constructAuthorityUriFromObject(urlObject: IUri, pathArray: string[]) {\r\n    return this.CanonicalizeUri(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + pathArray.join(\"/\"));\r\n  }\r\n\r\n  /**\r\n   * Parses out the components from a url string.\r\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n   */\r\n  static GetUrlComponents(url: string): IUri {\r\n    if (!url) {\r\n      throw \"Url required\";\r\n    }\r\n\r\n    // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\r\n    var regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\r\n\r\n    var match = url.match(regEx);\r\n\r\n    if (!match || match.length < 6) {\r\n      throw \"Valid url required\";\r\n    }\r\n\r\n    let urlComponents = <IUri>{\r\n      Protocol: match[1],\r\n      HostNameAndPort: match[4],\r\n      AbsolutePath: match[5]\r\n    };\r\n\r\n    let pathSegments = urlComponents.AbsolutePath.split(\"/\");\r\n    pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements\r\n    urlComponents.PathSegments = pathSegments;\r\n    return urlComponents;\r\n  }\r\n\r\n  /**\r\n   * Given a url or path, append a trailing slash if one doesnt exist\r\n   *\r\n   * @param url\r\n   */\r\n  static CanonicalizeUri(url: string): string {\r\n    if (url) {\r\n      url = url.toLowerCase();\r\n    }\r\n\r\n    if (url && !UrlUtils.endsWith(url, \"/\")) {\r\n      url += \"/\";\r\n    }\r\n\r\n    return url;\r\n  }\r\n\r\n  /**\r\n   * Checks to see if the url ends with the suffix\r\n   * Required because we are compiling for es5 instead of es6\r\n   * @param url\r\n   * @param str\r\n   */\r\n  // TODO: Rename this, not clear what it is supposed to do\r\n  static endsWith(url: string, suffix: string): boolean {\r\n    if (!url || !suffix) {\r\n      return false;\r\n    }\r\n\r\n    return url.indexOf(suffix, url.length - suffix.length) !== -1;\r\n  }\r\n\r\n  /**\r\n   * Utils function to remove the login_hint and domain_hint from the i/p extraQueryParameters\r\n   * @param url\r\n   * @param name\r\n   */\r\n  static urlRemoveQueryStringParameter(url: string, name: string): string {\r\n    if (StringUtils.isEmpty(url)) {\r\n      return url;\r\n    }\r\n\r\n    var regex = new RegExp(\"(\\\\&\" + name + \"=)[^\\&]+\");\r\n    url = url.replace(regex, \"\");\r\n    // name=value&\r\n    regex = new RegExp(\"(\" + name + \"=)[^\\&]+&\");\r\n    url = url.replace(regex, \"\");\r\n    // name=value\r\n    regex = new RegExp(\"(\" + name + \"=)[^\\&]+\");\r\n    url = url.replace(regex, \"\");\r\n    return url;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Returns the anchor part(#) of the URL\r\n   */\r\n  static getHashFromUrl(urlStringOrFragment: string): string {\r\n    const hashIndex1 = urlStringOrFragment.indexOf(\"#\");\r\n    const hashIndex2 = urlStringOrFragment.indexOf(\"#/\");\r\n    if (hashIndex2 > -1) {\r\n      return urlStringOrFragment.substring(hashIndex2 + 2);\r\n    } else if (hashIndex1 > -1) {\r\n      return urlStringOrFragment.substring(hashIndex1 + 1);\r\n    }\r\n    return urlStringOrFragment;\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\r\nimport { UrlUtils } from \"./utils/UrlUtils\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class AccessTokenKey {\r\n\r\n  authority: string;\r\n  clientId: string;\r\n  scopes: string;\r\n  homeAccountIdentifier: string;\r\n\r\n  constructor(authority: string, clientId: string, scopes: string, uid: string, utid: string) {\r\n    this.authority = UrlUtils.CanonicalizeUri(authority);\r\n    this.clientId = clientId;\r\n    this.scopes = scopes;\r\n    this.homeAccountIdentifier = CryptoUtils.base64Encode(uid) + \".\" + CryptoUtils.base64Encode(utid);\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class AccessTokenValue {\r\n\r\n  accessToken: string;\r\n  idToken: string;\r\n  expiresIn: string;\r\n  homeAccountIdentifier: string;\r\n\r\n  constructor(accessToken: string, idToken: string, expiresIn: string, homeAccountIdentifier: string) {\r\n    this.accessToken = accessToken;\r\n    this.idToken = idToken;\r\n    this.expiresIn = expiresIn;\r\n    this.homeAccountIdentifier = homeAccountIdentifier;\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport const AuthErrorMessage = {\r\n    unexpectedError: {\r\n        code: \"unexpected_error\",\r\n        desc: \"Unexpected error in authentication.\"\r\n    }\r\n};\r\n\r\n/**\r\n* General error class thrown by the MSAL.js library.\r\n*/\r\nexport class AuthError extends Error {\r\n\r\n    errorCode: string;\r\n    errorMessage: string;\r\n\r\n    constructor(errorCode: string, errorMessage?: string) {\r\n        super(errorMessage);\r\n        Object.setPrototypeOf(this, AuthError.prototype);\r\n\r\n        this.errorCode = errorCode;\r\n        this.errorMessage = errorMessage;\r\n        this.name = \"AuthError\";\r\n    }\r\n\r\n    static createUnexpectedError(errDesc: string) {\r\n        return new AuthError(AuthErrorMessage.unexpectedError.code, `${AuthErrorMessage.unexpectedError.desc}: ${errDesc}`);\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { AuthError } from \"./AuthError\";\r\nimport { IdToken } from \"../IdToken\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\n\r\nexport const ClientAuthErrorMessage = {\r\n    multipleMatchingTokens: {\r\n        code: \"multiple_matching_tokens\",\r\n        desc: \"The cache contains multiple tokens satisfying the requirements. \" +\r\n            \"Call AcquireToken again providing more requirements like authority.\"\r\n    },\r\n    multipleCacheAuthorities: {\r\n        code: \"multiple_authorities\",\r\n        desc: \"Multiple authorities found in the cache. Pass authority in the API overload.\"\r\n    },\r\n    endpointResolutionError: {\r\n        code: \"endpoints_resolution_error\",\r\n        desc: \"Error: could not resolve endpoints. Please check network and try again.\"\r\n    },\r\n    popUpWindowError: {\r\n        code: \"popup_window_error\",\r\n        desc: \"Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser.\"\r\n    },\r\n    tokenRenewalError: {\r\n        code: \"token_renewal_error\",\r\n        desc: \"Token renewal operation failed due to timeout.\"\r\n    },\r\n    invalidIdToken: {\r\n        code: \"invalid_id_token\",\r\n        desc: \"Invalid ID token format.\"\r\n    },\r\n    invalidStateError: {\r\n        code: \"invalid_state_error\",\r\n        desc: \"Invalid state.\"\r\n    },\r\n    nonceMismatchError: {\r\n        code: \"nonce_mismatch_error\",\r\n        desc: \"Nonce is not matching, Nonce received: \"\r\n    },\r\n    loginProgressError: {\r\n        code: \"login_progress_error\",\r\n        desc: \"Login_In_Progress: Error during login call - login is already in progress.\"\r\n    },\r\n    acquireTokenProgressError: {\r\n        code: \"acquiretoken_progress_error\",\r\n        desc: \"AcquireToken_In_Progress: Error during login call - login is already in progress.\"\r\n    },\r\n    userCancelledError: {\r\n        code: \"user_cancelled\",\r\n        desc: \"User cancelled the flow.\"\r\n    },\r\n    callbackError: {\r\n        code: \"callback_error\",\r\n        desc: \"Error occurred in token received callback function.\"\r\n    },\r\n    userLoginRequiredError: {\r\n        code: \"user_login_error\",\r\n        desc: \"User login is required.\"\r\n    },\r\n    userDoesNotExistError: {\r\n        code: \"user_non_existent\",\r\n        desc: \"User object does not exist. Please call a login API.\"\r\n    },\r\n    clientInfoDecodingError: {\r\n        code: \"client_info_decoding_error\",\r\n        desc: \"The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause.\"\r\n    },\r\n    clientInfoNotPopulatedError: {\r\n        code: \"client_info_not_populated_error\",\r\n        desc: \"The service did not populate client_info in the response, Please verify with the service team\"\r\n    },\r\n    nullOrEmptyIdToken: {\r\n        code: \"null_or_empty_id_token\",\r\n        desc: \"The idToken is null or empty. Please review the trace to determine the root cause.\"\r\n    },\r\n    idTokenNotParsed: {\r\n        code: \"id_token_parsing_error\",\r\n        desc: \"ID token cannot be parsed. Please review stack trace to determine root cause.\"\r\n    },\r\n    tokenEncodingError: {\r\n        code: \"token_encoding_error\",\r\n        desc: \"The token to be decoded is not encoded correctly.\"\r\n    },\r\n    invalidInteractionType: {\r\n        code: \"invalid_interaction_type\",\r\n        desc: \"The interaction type passed to the handler was incorrect or unknown\"\r\n    }\r\n};\r\n\r\n/**\r\n * Error thrown when there is an error in the client code running on the browser.\r\n */\r\nexport class ClientAuthError extends AuthError {\r\n\r\n    constructor(errorCode: string, errorMessage?: string) {\r\n        super(errorCode, errorMessage);\r\n        this.name = \"ClientAuthError\";\r\n\r\n        Object.setPrototypeOf(this, ClientAuthError.prototype);\r\n    }\r\n\r\n    static createEndpointResolutionError(errDetail?: string): ClientAuthError {\r\n        let errorMessage = ClientAuthErrorMessage.endpointResolutionError.desc;\r\n        if (errDetail && !StringUtils.isEmpty(errDetail)) {\r\n            errorMessage += ` Details: ${errDetail}`;\r\n        }\r\n        return new ClientAuthError(ClientAuthErrorMessage.endpointResolutionError.code, errorMessage);\r\n    }\r\n\r\n    static createMultipleMatchingTokensInCacheError(scope: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingTokens.code,\r\n            `Cache error for scope ${scope}: ${ClientAuthErrorMessage.multipleMatchingTokens.desc}.`);\r\n    }\r\n\r\n    static createMultipleAuthoritiesInCacheError(scope: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.multipleCacheAuthorities.code,\r\n            `Cache error for scope ${scope}: ${ClientAuthErrorMessage.multipleCacheAuthorities.desc}.`);\r\n    }\r\n\r\n    static createPopupWindowError(errDetail?: string): ClientAuthError {\r\n        var errorMessage = ClientAuthErrorMessage.popUpWindowError.desc;\r\n        if (errDetail && !StringUtils.isEmpty(errDetail)) {\r\n            errorMessage += ` Details: ${errDetail}`;\r\n        }\r\n        return new ClientAuthError(ClientAuthErrorMessage.popUpWindowError.code, errorMessage);\r\n    }\r\n\r\n    static createTokenRenewalTimeoutError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.tokenRenewalError.code,\r\n            ClientAuthErrorMessage.tokenRenewalError.desc);\r\n    }\r\n\r\n    static createInvalidIdTokenError(idToken: IdToken) : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidIdToken.code,\r\n            `${ClientAuthErrorMessage.invalidIdToken.desc} Given token: ${idToken}`);\r\n    }\r\n\r\n    //TODO: Is this not a security flaw to send the user the state expected??\r\n    static createInvalidStateError(invalidState: string, actualState: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidStateError.code,\r\n            `${ClientAuthErrorMessage.invalidStateError.desc} ${invalidState}, state expected : ${actualState}.`);\r\n    }\r\n\r\n    //TODO: Is this not a security flaw to send the user the Nonce expected??\r\n    static createNonceMismatchError(invalidNonce: string, actualNonce: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.nonceMismatchError.code,\r\n            `${ClientAuthErrorMessage.nonceMismatchError.desc} ${invalidNonce}, nonce expected : ${actualNonce}.`);\r\n    }\r\n\r\n    static createLoginInProgressError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.loginProgressError.code,\r\n            ClientAuthErrorMessage.loginProgressError.desc);\r\n    }\r\n\r\n    static createAcquireTokenInProgressError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.acquireTokenProgressError.code,\r\n            ClientAuthErrorMessage.acquireTokenProgressError.desc);\r\n    }\r\n\r\n    static createUserCancelledError(): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.userCancelledError.code,\r\n            ClientAuthErrorMessage.userCancelledError.desc);\r\n    }\r\n\r\n    static createErrorInCallbackFunction(errorDesc: string): ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.callbackError.code,\r\n            `${ClientAuthErrorMessage.callbackError.desc} ${errorDesc}.`);\r\n    }\r\n\r\n    static createUserLoginRequiredError() : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.userLoginRequiredError.code,\r\n            ClientAuthErrorMessage.userLoginRequiredError.desc);\r\n    }\r\n\r\n    static createUserDoesNotExistError() : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.userDoesNotExistError.code,\r\n            ClientAuthErrorMessage.userDoesNotExistError.desc);\r\n    }\r\n\r\n    static createClientInfoDecodingError(caughtError: string) : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.clientInfoDecodingError.code,\r\n            `${ClientAuthErrorMessage.clientInfoDecodingError.desc} Failed with error: ${caughtError}`);\r\n    }\r\n\r\n    static createClientInfoNotPopulatedError(caughtError: string) : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.clientInfoNotPopulatedError.code,\r\n            `${ClientAuthErrorMessage.clientInfoNotPopulatedError.desc} Failed with error: ${caughtError}`);\r\n    }\r\n\r\n    static createIdTokenNullOrEmptyError(invalidRawTokenString: string) : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.nullOrEmptyIdToken.code,\r\n            `${ClientAuthErrorMessage.nullOrEmptyIdToken.desc} Raw ID Token Value: ${invalidRawTokenString}`);\r\n    }\r\n\r\n    static createIdTokenParsingError(caughtParsingError: string) : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.idTokenNotParsed.code,\r\n            `${ClientAuthErrorMessage.idTokenNotParsed.desc} Failed with error: ${caughtParsingError}`);\r\n    }\r\n\r\n    static createTokenEncodingError(incorrectlyEncodedToken: string) : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.tokenEncodingError.code,\r\n            `${ClientAuthErrorMessage.tokenEncodingError.desc} Attempted to decode: ${incorrectlyEncodedToken}`);\r\n    }\r\n\r\n    static createInvalidInteractionTypeError() : ClientAuthError {\r\n        return new ClientAuthError(ClientAuthErrorMessage.invalidInteractionType.code,\r\n            ClientAuthErrorMessage.invalidInteractionType.desc);\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Constants } from \"../utils/Constants\";\r\nimport { ClientAuthError } from \"./ClientAuthError\";\r\nimport { TelemetryOptions } from \"../Configuration\";\r\n\r\nexport const ClientConfigurationErrorMessage = {\r\n    configurationNotSet: {\r\n        code: \"no_config_set\",\r\n        desc: \"Configuration has not been set. Please call the UserAgentApplication constructor with a valid Configuration object.\"\r\n    },\r\n    invalidCacheLocation: {\r\n        code: \"invalid_cache_location\",\r\n        desc: \"The cache location provided is not valid.\"\r\n    },\r\n    noStorageSupported: {\r\n        code: \"browser_storage_not_supported\",\r\n        desc: \"localStorage and sessionStorage are not supported.\"\r\n    },\r\n    noRedirectCallbacksSet: {\r\n        code: \"no_redirect_callbacks\",\r\n        desc: \"No redirect callbacks have been set. Please call setRedirectCallbacks() with the appropriate function arguments before continuing. \" +\r\n            \"More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics.\"\r\n    },\r\n    invalidCallbackObject: {\r\n        code: \"invalid_callback_object\",\r\n        desc: \"The object passed for the callback was invalid. \" +\r\n          \"More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics.\"\r\n    },\r\n    scopesRequired: {\r\n        code: \"scopes_required\",\r\n        desc: \"Scopes are required to obtain an access token.\"\r\n    },\r\n    emptyScopes: {\r\n        code: \"empty_input_scopes_error\",\r\n        desc: \"Scopes cannot be passed as empty array.\"\r\n    },\r\n    nonArrayScopes: {\r\n        code: \"nonarray_input_scopes_error\",\r\n        desc: \"Scopes cannot be passed as non-array.\"\r\n    },\r\n    clientScope: {\r\n        code: \"clientid_input_scopes_error\",\r\n        desc: \"Client ID can only be provided as a single scope.\"\r\n    },\r\n    invalidPrompt: {\r\n        code: \"invalid_prompt_value\",\r\n        desc: \"Supported prompt values are 'login', 'select_account', 'consent' and 'none'\",\r\n    },\r\n    invalidAuthorityType: {\r\n        code: \"invalid_authority_type\",\r\n        desc: \"The given authority is not a valid type of authority supported by MSAL. Please see here for valid authorities: <insert URL here>.\"\r\n    },\r\n    authorityUriInsecure: {\r\n        code: \"authority_uri_insecure\",\r\n        desc: \"Authority URIs must use https.\"\r\n    },\r\n    authorityUriInvalidPath: {\r\n        code: \"authority_uri_invalid_path\",\r\n        desc: \"Given authority URI is invalid.\"\r\n    },\r\n    unsupportedAuthorityValidation: {\r\n        code: \"unsupported_authority_validation\",\r\n        desc: \"The authority validation is not supported for this authority type.\"\r\n    },\r\n    b2cAuthorityUriInvalidPath: {\r\n        code: \"b2c_authority_uri_invalid_path\",\r\n        desc: \"The given URI for the B2C authority is invalid.\"\r\n    },\r\n    claimsRequestParsingError: {\r\n        code: \"claims_request_parsing_error\",\r\n        desc: \"Could not parse the given claims request object.\"\r\n    },\r\n    emptyRequestError: {\r\n        code: \"empty_request_error\",\r\n        desc: \"Request object is required.\"\r\n    },\r\n    telemetryConfigError: {\r\n        code: \"telemetry_config_error\",\r\n        desc: \"Telemetry config is not configured with required values\"\r\n    }\r\n};\r\n\r\n/**\r\n * Error thrown when there is an error in configuration of the .js library.\r\n */\r\nexport class ClientConfigurationError extends ClientAuthError {\r\n\r\n    constructor(errorCode: string, errorMessage?: string) {\r\n        super(errorCode, errorMessage);\r\n        this.name = \"ClientConfigurationError\";\r\n        Object.setPrototypeOf(this, ClientConfigurationError.prototype);\r\n    }\r\n\r\n    static createNoSetConfigurationError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.configurationNotSet.code,\r\n            `${ClientConfigurationErrorMessage.configurationNotSet.desc}`);\r\n    }\r\n\r\n    static createInvalidCacheLocationConfigError(givenCacheLocation: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCacheLocation.code,\r\n            `${ClientConfigurationErrorMessage.invalidCacheLocation.desc} Provided value: ${givenCacheLocation}. Possible values are: ${Constants.cacheLocationLocal}, ${Constants.cacheLocationSession}.`);\r\n    }\r\n\r\n    static createNoStorageSupportedError() : ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.noStorageSupported.code,\r\n            ClientConfigurationErrorMessage.noStorageSupported.desc);\r\n    }\r\n\r\n    static createRedirectCallbacksNotSetError(): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.noRedirectCallbacksSet.code, ClientConfigurationErrorMessage.noRedirectCallbacksSet.desc);\r\n    }\r\n\r\n    static createInvalidCallbackObjectError(callbackObject: object): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCallbackObject.code,\r\n            `${ClientConfigurationErrorMessage.invalidCallbackObject.desc} Given value for callback function: ${callbackObject}`);\r\n    }\r\n\r\n    static createEmptyScopesArrayError(scopesValue: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.emptyScopes.code,\r\n            `${ClientConfigurationErrorMessage.emptyScopes.desc} Given value: ${scopesValue}.`);\r\n    }\r\n\r\n    static createScopesNonArrayError(scopesValue: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.nonArrayScopes.code,\r\n            `${ClientConfigurationErrorMessage.nonArrayScopes.desc} Given value: ${scopesValue}.`);\r\n    }\r\n\r\n    static createClientIdSingleScopeError(scopesValue: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.clientScope.code,\r\n            `${ClientConfigurationErrorMessage.clientScope.desc} Given value: ${scopesValue}.`);\r\n    }\r\n\r\n    static createScopesRequiredError(scopesValue: any): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.scopesRequired.code,\r\n            `${ClientConfigurationErrorMessage.scopesRequired.desc} Given value: ${scopesValue}`);\r\n    }\r\n\r\n    static createInvalidPromptError(promptValue: any): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidPrompt.code,\r\n            `${ClientConfigurationErrorMessage.invalidPrompt.desc} Given value: ${promptValue}`);\r\n    }\r\n\r\n    static createClaimsRequestParsingError(claimsRequestParseError: string): ClientConfigurationError {\r\n        return new ClientConfigurationError(ClientConfigurationErrorMessage.claimsRequestParsingError.code,\r\n            `${ClientConfigurationErrorMessage.claimsRequestParsingError.desc} Given value: ${claimsRequestParseError}`);\r\n    }\r\n\r\n    static createEmptyRequestError(): ClientConfigurationError {\r\n        const { code, desc } = ClientConfigurationErrorMessage.emptyRequestError;\r\n        return new ClientConfigurationError(code, desc);\r\n    }\r\n\r\n    static createTelemetryConfigError(config: TelemetryOptions): ClientConfigurationError {\r\n        const { code, desc } = ClientConfigurationErrorMessage.telemetryConfigError;\r\n        const requiredKeys = {\r\n            applicationName: \"string\",\r\n            applicationVersion: \"string\",\r\n            telemetryEmitter: \"function\"\r\n        };\r\n\r\n        const missingKeys = Object.keys(requiredKeys)\r\n            .reduce((keys, key) => {\r\n                return config[key] ? keys : keys.concat([ `${key} (${requiredKeys[key]})` ]);\r\n            }, []);\r\n\r\n        return new ClientConfigurationError(code, `${desc} mising values: ${missingKeys.join(\",\")}`);\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Authority } from \"./Authority\";\r\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\r\nimport { AuthenticationParameters, validateClaimsRequest } from \"./AuthenticationParameters\";\r\nimport { StringDict } from \"./MsalTypes\"\r\nimport { Account } from \"./Account\";\r\nimport { SSOTypes, Constants, PromptState, BlacklistedEQParams, libraryVersion } from \"./utils/Constants\";\r\nimport { ClientConfigurationError } from \"./error/ClientConfigurationError\";\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\n\r\n/**\r\n * Nonce: OIDC Nonce definition: https://openid.net/specs/openid-connect-core-1_0.html#IDToken\r\n * State: OAuth Spec: https://tools.ietf.org/html/rfc6749#section-10.12\r\n * @hidden\r\n */\r\nexport class ServerRequestParameters {\r\n\r\n  authorityInstance: Authority;\r\n  clientId: string;\r\n  scopes: Array<string>;\r\n\r\n  nonce: string;\r\n  state: string;\r\n\r\n  // telemetry information\r\n  xClientVer: string;\r\n  xClientSku: string;\r\n  correlationId: string;\r\n\r\n  responseType: string;\r\n  redirectUri: string;\r\n\r\n  promptValue: string;\r\n  claimsValue: string;\r\n\r\n  queryParameters: string;\r\n  extraQueryParameters: string;\r\n\r\n  public get authority(): string {\r\n    return this.authorityInstance ? this.authorityInstance.CanonicalAuthority : null;\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   * @param authority\r\n   * @param clientId\r\n   * @param scope\r\n   * @param responseType\r\n   * @param redirectUri\r\n   * @param state\r\n   */\r\n  constructor (authority: Authority, clientId: string, scope: Array<string>, responseType: string, redirectUri: string, state: string) {\r\n    this.authorityInstance = authority;\r\n    this.clientId = clientId;\r\n    if (!scope) {\r\n      this.scopes = [clientId];\r\n    } else {\r\n      this.scopes = [ ...scope ];\r\n    }\r\n\r\n    this.nonce = CryptoUtils.createNewGuid();\r\n    this.state = state && !StringUtils.isEmpty(state) ?  CryptoUtils.createNewGuid() + \"|\" + state   : CryptoUtils.createNewGuid();\r\n\r\n    // TODO: Change this to user passed vs generated with the new PR\r\n    this.correlationId = CryptoUtils.createNewGuid();\r\n\r\n    // telemetry information\r\n    this.xClientSku = \"MSAL.JS\";\r\n    this.xClientVer = libraryVersion();\r\n\r\n    this.responseType = responseType;\r\n    this.redirectUri = redirectUri;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Utility to populate QueryParameters and ExtraQueryParameters to ServerRequestParamerers\r\n   * @param request\r\n   * @param serverAuthenticationRequest\r\n   */\r\n  populateQueryParams(account: Account, request: AuthenticationParameters, adalIdTokenObject?: any): void {\r\n    let queryParameters: StringDict = {};\r\n\r\n    if (request) {\r\n      // add the prompt parameter to serverRequestParameters if passed\r\n      if (request.prompt) {\r\n        this.validatePromptParameter(request.prompt);\r\n        this.promptValue = request.prompt;\r\n      }\r\n\r\n      // Add claims challenge to serverRequestParameters if passed\r\n      if (request.claimsRequest) {\r\n        validateClaimsRequest(request);\r\n        this.claimsValue = request.claimsRequest;\r\n      }\r\n\r\n      // if the developer provides one of these, give preference to developer choice\r\n      if (ServerRequestParameters.isSSOParam(request)) {\r\n        queryParameters = this.constructUnifiedCacheQueryParameter(request, null);\r\n      }\r\n    }\r\n\r\n    if (adalIdTokenObject) {\r\n      queryParameters = this.constructUnifiedCacheQueryParameter(null, adalIdTokenObject);\r\n    }\r\n\r\n    // adds sid/login_hint if not populated; populates domain_req, login_req and domain_hint\r\n    // this.logger.verbose(\"Calling addHint parameters\");\r\n    queryParameters = this.addHintParameters(account, queryParameters);\r\n\r\n    // sanity check for developer passed extraQueryParameters\r\n    let eQParams: StringDict;\r\n    if (request) {\r\n      eQParams = this.sanitizeEQParams(request);\r\n    }\r\n\r\n    // Populate the extraQueryParameters to be sent to the server\r\n    this.queryParameters = ServerRequestParameters.generateQueryParametersString(queryParameters);\r\n    this.extraQueryParameters = ServerRequestParameters.generateQueryParametersString(eQParams);\r\n  }\r\n\r\n  //#region QueryParam helpers\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Utility to test if valid prompt value is passed in the request\r\n   * @param request\r\n   */\r\n  private validatePromptParameter (prompt: string) {\r\n    if (!([PromptState.LOGIN, PromptState.SELECT_ACCOUNT, PromptState.CONSENT, PromptState.NONE].indexOf(prompt) >= 0)) {\r\n        throw ClientConfigurationError.createInvalidPromptError(prompt);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Constructs extraQueryParameters to be sent to the server for the AuthenticationParameters set by the developer\r\n   * in any login() or acquireToken() calls\r\n   * @param idTokenObject\r\n   * @param extraQueryParameters\r\n   * @param sid\r\n   * @param loginHint\r\n   */\r\n  //TODO: check how this behaves when domain_hint only is sent in extraparameters and idToken has no upn.\r\n  private constructUnifiedCacheQueryParameter(request: AuthenticationParameters, idTokenObject: any): StringDict {\r\n\r\n    // preference order: account > sid > login_hint\r\n    let ssoType;\r\n    let ssoData;\r\n    let serverReqParam: StringDict = {};\r\n    // if account info is passed, account.sid > account.login_hint\r\n    if (request) {\r\n      if (request.account) {\r\n        const account: Account = request.account;\r\n        if (account.sid) {\r\n          ssoType = SSOTypes.SID;\r\n          ssoData = account.sid;\r\n        }\r\n        else if (account.userName) {\r\n          ssoType = SSOTypes.LOGIN_HINT;\r\n          ssoData = account.userName;\r\n        }\r\n      }\r\n      // sid from request\r\n      else if (request.sid) {\r\n        ssoType = SSOTypes.SID;\r\n        ssoData = request.sid;\r\n      }\r\n      // loginHint from request\r\n      else if (request.loginHint) {\r\n        ssoType = SSOTypes.LOGIN_HINT;\r\n        ssoData = request.loginHint;\r\n      }\r\n    }\r\n    // adalIdToken retrieved from cache\r\n    else if (idTokenObject) {\r\n      if (idTokenObject.hasOwnProperty(Constants.upn)) {\r\n        ssoType = SSOTypes.ID_TOKEN;\r\n        ssoData = idTokenObject.upn;\r\n      }\r\n      else {\r\n        ssoType = SSOTypes.ORGANIZATIONS;\r\n        ssoData = null;\r\n      }\r\n    }\r\n\r\n    serverReqParam = this.addSSOParameter(ssoType, ssoData);\r\n\r\n    // add the HomeAccountIdentifier info/ domain_hint\r\n    if (request && request.account && request.account.homeAccountIdentifier) {\r\n        serverReqParam = this.addSSOParameter(SSOTypes.HOMEACCOUNT_ID, request.account.homeAccountIdentifier, serverReqParam);\r\n    }\r\n\r\n    return serverReqParam;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Adds login_hint to authorization URL which is used to pre-fill the username field of sign in page for the user if known ahead of time\r\n   * domain_hint can be one of users/organizations which when added skips the email based discovery process of the user\r\n   * domain_req utid received as part of the clientInfo\r\n   * login_req uid received as part of clientInfo\r\n   * Also does a sanity check for extraQueryParameters passed by the user to ensure no repeat queryParameters\r\n   *\r\n   * @param {@link Account} account - Account for which the token is requested\r\n   * @param queryparams\r\n   * @param {@link ServerRequestParameters}\r\n   * @ignore\r\n   */\r\n  private addHintParameters(account: Account, qParams: StringDict): StringDict {\r\n    // This is a final check for all queryParams added so far; preference order: sid > login_hint\r\n    // sid cannot be passed along with login_hint or domain_hint, hence we check both are not populated yet in queryParameters\r\n    if (account && !qParams[SSOTypes.SID]) {\r\n      // sid - populate only if login_hint is not already populated and the account has sid\r\n      const populateSID = !qParams[SSOTypes.LOGIN_HINT] && account.sid && this.promptValue === PromptState.NONE;\r\n      if (populateSID) {\r\n          qParams = this.addSSOParameter(SSOTypes.SID, account.sid, qParams);\r\n      }\r\n      // login_hint - account.userName\r\n      else {\r\n        const populateLoginHint = !qParams[SSOTypes.LOGIN_HINT] && account.userName && !StringUtils.isEmpty(account.userName);\r\n        if (populateLoginHint) {\r\n          qParams = this.addSSOParameter(SSOTypes.LOGIN_HINT, account.userName, qParams);\r\n        }\r\n      }\r\n\r\n      const populateReqParams = !qParams[SSOTypes.DOMAIN_REQ] && !qParams[SSOTypes.LOGIN_REQ];\r\n      if (populateReqParams) {\r\n        qParams = this.addSSOParameter(SSOTypes.HOMEACCOUNT_ID, account.homeAccountIdentifier, qParams);\r\n      }\r\n    }\r\n\r\n    return qParams;\r\n  }\r\n\r\n  /**\r\n   * Add SID to extraQueryParameters\r\n   * @param sid\r\n   */\r\n  private addSSOParameter(ssoType: string, ssoData: string, ssoParam?: StringDict): StringDict {\r\n    if (!ssoParam) {\r\n      ssoParam = {};\r\n    }\r\n\r\n    if (!ssoData) {\r\n        return ssoParam;\r\n    }\r\n\r\n    switch (ssoType) {\r\n      case SSOTypes.SID: {\r\n        ssoParam[SSOTypes.SID] = ssoData;\r\n        break;\r\n      }\r\n      case SSOTypes.ID_TOKEN: {\r\n        ssoParam[SSOTypes.LOGIN_HINT] = ssoData;\r\n        ssoParam[SSOTypes.DOMAIN_HINT] = SSOTypes.ORGANIZATIONS;\r\n        break;\r\n      }\r\n      case SSOTypes.LOGIN_HINT: {\r\n        ssoParam[SSOTypes.LOGIN_HINT] = ssoData;\r\n        break;\r\n      }\r\n      case SSOTypes.ORGANIZATIONS: {\r\n        ssoParam[SSOTypes.DOMAIN_HINT] = SSOTypes.ORGANIZATIONS;\r\n        break;\r\n      }\r\n      case SSOTypes.CONSUMERS: {\r\n        ssoParam[SSOTypes.DOMAIN_HINT] = SSOTypes.CONSUMERS;\r\n        break;\r\n      }\r\n      case SSOTypes.HOMEACCOUNT_ID: {\r\n        let homeAccountId = ssoData.split(\".\");\r\n        const uid = CryptoUtils.base64Decode(homeAccountId[0]);\r\n        const utid = CryptoUtils.base64Decode(homeAccountId[1]);\r\n\r\n        // TODO: domain_req and login_req are not needed according to eSTS team\r\n        ssoParam[SSOTypes.LOGIN_REQ] = uid;\r\n        ssoParam[SSOTypes.DOMAIN_REQ] = utid;\r\n\r\n        if (utid === Constants.consumersUtid) {\r\n            ssoParam[SSOTypes.DOMAIN_HINT] = SSOTypes.CONSUMERS;\r\n        }\r\n        else {\r\n            ssoParam[SSOTypes.DOMAIN_HINT] = SSOTypes.ORGANIZATIONS;\r\n        }\r\n        break;\r\n      }\r\n      case SSOTypes.LOGIN_REQ: {\r\n        ssoParam[SSOTypes.LOGIN_REQ] = ssoData;\r\n        break;\r\n      }\r\n      case SSOTypes.DOMAIN_REQ: {\r\n        ssoParam[SSOTypes.DOMAIN_REQ] = ssoData;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return ssoParam;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   * Removes unnecessary or duplicate query parameters from extraQueryParameters\r\n   * @param request\r\n   */\r\n  private sanitizeEQParams(request: AuthenticationParameters) : StringDict {\r\n    let eQParams : StringDict = request.extraQueryParameters;\r\n    if (!eQParams) {\r\n      return null;\r\n    }\r\n    if (request.claimsRequest) {\r\n      // this.logger.warning(\"Removed duplicate claims from extraQueryParameters. Please use either the claimsRequest field OR pass as extraQueryParameter - not both.\");\r\n      delete eQParams[Constants.claims];\r\n    }\r\n    BlacklistedEQParams.forEach(param => {\r\n      if (eQParams[param]) {\r\n        // this.logger.warning(\"Removed duplicate \" + param + \" from extraQueryParameters. Please use the \" + param + \" field in request object.\");\r\n        delete eQParams[param];\r\n      }\r\n    });\r\n    return eQParams;\r\n  }\r\n\r\n  /**\r\n   * Utility to generate a QueryParameterString from a Key-Value mapping of extraQueryParameters passed\r\n   * @param extraQueryParameters\r\n   */\r\n  static generateQueryParametersString(queryParameters: StringDict): string {\r\n    let paramsString: string = null;\r\n\r\n    if (queryParameters) {\r\n      Object.keys(queryParameters).forEach((key: string) => {\r\n        if (paramsString == null) {\r\n          paramsString = `${key}=${encodeURIComponent(queryParameters[key])}`;\r\n        }\r\n        else {\r\n          paramsString += `&${key}=${encodeURIComponent(queryParameters[key])}`;\r\n        }\r\n     });\r\n    }\r\n\r\n    return paramsString;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  /**\r\n   * Check to see if there are SSO params set in the Request\r\n   * @param request\r\n   */\r\n  static isSSOParam(request: AuthenticationParameters) {\r\n      return request && (request.account || request.sid || request.loginHint);\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { IUri } from \"./IUri\";\r\nimport { ITenantDiscoveryResponse } from \"./ITenantDiscoveryResponse\";\r\nimport { ClientConfigurationErrorMessage } from \"./error/ClientConfigurationError\";\r\nimport { XhrClient } from \"./XHRClient\";\r\nimport { UrlUtils } from \"./utils/UrlUtils\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport enum AuthorityType {\r\n  Aad,\r\n  Adfs,\r\n  B2C\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport abstract class Authority {\r\n  constructor(authority: string, validateAuthority: boolean) {\r\n    this.IsValidationEnabled = validateAuthority;\r\n    this.CanonicalAuthority = authority;\r\n\r\n    this.validateAsUri();\r\n  }\r\n\r\n  public abstract get AuthorityType(): AuthorityType;\r\n\r\n  public IsValidationEnabled: boolean;\r\n\r\n  public get Tenant(): string {\r\n    return this.CanonicalAuthorityUrlComponents.PathSegments[0];\r\n  }\r\n\r\n  private tenantDiscoveryResponse: ITenantDiscoveryResponse;\r\n\r\n  public get AuthorizationEndpoint(): string {\r\n    this.validateResolved();\r\n    return this.tenantDiscoveryResponse.AuthorizationEndpoint.replace(\"{tenant}\", this.Tenant);\r\n  }\r\n\r\n  public get EndSessionEndpoint(): string {\r\n    this.validateResolved();\r\n    return this.tenantDiscoveryResponse.EndSessionEndpoint.replace(\"{tenant}\", this.Tenant);\r\n  }\r\n\r\n  public get SelfSignedJwtAudience(): string {\r\n    this.validateResolved();\r\n    return this.tenantDiscoveryResponse.Issuer.replace(\"{tenant}\", this.Tenant);\r\n  }\r\n\r\n  private validateResolved() {\r\n    if (!this.tenantDiscoveryResponse) {\r\n      throw \"Please call ResolveEndpointsAsync first\";\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A URL that is the authority set by the developer\r\n   */\r\n  public get CanonicalAuthority(): string {\r\n    return this.canonicalAuthority;\r\n  }\r\n\r\n  public set CanonicalAuthority(url: string) {\r\n    this.canonicalAuthority = UrlUtils.CanonicalizeUri(url);\r\n    this.canonicalAuthorityUrlComponents = null;\r\n  }\r\n\r\n  private canonicalAuthority: string;\r\n  private canonicalAuthorityUrlComponents: IUri;\r\n\r\n  public get CanonicalAuthorityUrlComponents(): IUri {\r\n    if (!this.canonicalAuthorityUrlComponents) {\r\n      this.canonicalAuthorityUrlComponents = UrlUtils.GetUrlComponents(this.CanonicalAuthority);\r\n    }\r\n\r\n    return this.canonicalAuthorityUrlComponents;\r\n  }\r\n\r\n  /**\r\n   * // http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\r\n   */\r\n  protected get DefaultOpenIdConfigurationEndpoint(): string {\r\n    return `${this.CanonicalAuthority}v2.0/.well-known/openid-configuration`;\r\n  }\r\n\r\n  /**\r\n   * Given a string, validate that it is of the form https://domain/path\r\n   */\r\n  private validateAsUri() {\r\n    let components;\r\n    try {\r\n      components = this.CanonicalAuthorityUrlComponents;\r\n    } catch (e) {\r\n      throw ClientConfigurationErrorMessage.invalidAuthorityType;\r\n    }\r\n\r\n    if (!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\r\n      throw ClientConfigurationErrorMessage.authorityUriInsecure;\r\n    }\r\n\r\n    if (!components.PathSegments || components.PathSegments.length < 1) {\r\n      throw ClientConfigurationErrorMessage.authorityUriInvalidPath;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calls the OIDC endpoint and returns the response\r\n   */\r\n  private DiscoverEndpoints(openIdConfigurationEndpoint: string): Promise<ITenantDiscoveryResponse> {\r\n    const client = new XhrClient();\r\n    return client.sendRequestAsync(openIdConfigurationEndpoint, \"GET\", /*enableCaching: */ true)\r\n        .then((response: any) => {\r\n            return <ITenantDiscoveryResponse>{\r\n                AuthorizationEndpoint: response.authorization_endpoint,\r\n                EndSessionEndpoint: response.end_session_endpoint,\r\n                Issuer: response.issuer\r\n            };\r\n        });\r\n  }\r\n\r\n  /**\r\n   * Returns a promise.\r\n   * Checks to see if the authority is in the cache\r\n   * Discover endpoints via openid-configuration\r\n   * If successful, caches the endpoint for later use in OIDC\r\n   */\r\n  public resolveEndpointsAsync(): Promise<Authority> {\r\n    let openIdConfigurationEndpoint = \"\";\r\n    return this.GetOpenIdConfigurationEndpointAsync().then(openIdConfigurationEndpointResponse => {\r\n      openIdConfigurationEndpoint = openIdConfigurationEndpointResponse;\r\n      return this.DiscoverEndpoints(openIdConfigurationEndpoint);\r\n    }).then((tenantDiscoveryResponse: ITenantDiscoveryResponse) => {\r\n      this.tenantDiscoveryResponse = tenantDiscoveryResponse;\r\n      return this;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns a promise with the TenantDiscoveryEndpoint\r\n   */\r\n  public abstract GetOpenIdConfigurationEndpointAsync(): Promise<string>;\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Account } from \"./Account\";\r\nimport { ClientConfigurationError } from \"./error/ClientConfigurationError\";\r\nimport { StringDict } from \"./MsalTypes\";\r\n\r\n/**\r\n * @link AuthenticationParameters}AuthenticationParameters\r\n */\r\nexport type AuthenticationParameters = {\r\n    scopes?: Array<string>;\r\n    extraScopesToConsent?: Array<string>;\r\n    prompt?: string;\r\n    extraQueryParameters?: StringDict;\r\n    claimsRequest?: string;\r\n    authority?: string;\r\n    state?: string;\r\n    correlationId?: string;\r\n    account?: Account;\r\n    sid?: string;\r\n    loginHint?: string;\r\n    forceRefresh?: boolean;\r\n};\r\n\r\nexport function validateClaimsRequest(request: AuthenticationParameters) {\r\n    if (!request.claimsRequest) {\r\n        return;\r\n    }\r\n    let claims;\r\n    try {\r\n        claims = JSON.parse(request.claimsRequest);\r\n    } catch (e) {\r\n        throw ClientConfigurationError.createClaimsRequestParsingError(e);\r\n    }\r\n\r\n    // TODO: More validation will be added when the server team tells us how they have actually implemented claims\r\n}\r\n","﻿// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\r\nimport { ClientAuthError } from \"./error/ClientAuthError\";\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class ClientInfo {\r\n\r\n  private _uid: string;\r\n  get uid(): string {\r\n    return this._uid ? this._uid : \"\";\r\n  }\r\n\r\n  set uid(uid: string) {\r\n    this._uid = uid;\r\n  }\r\n\r\n  private _utid: string;\r\n  get utid(): string {\r\n    return this._utid ? this._utid : \"\";\r\n  }\r\n\r\n  set utid(utid: string) {\r\n    this._utid = utid;\r\n  }\r\n\r\n  constructor(rawClientInfo: string) {\r\n    if (!rawClientInfo || StringUtils.isEmpty(rawClientInfo)) {\r\n      this.uid = \"\";\r\n      this.utid = \"\";\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const decodedClientInfo: string = CryptoUtils.base64Decode(rawClientInfo);\r\n      const clientInfo: ClientInfo = <ClientInfo>JSON.parse(decodedClientInfo);\r\n      if (clientInfo) {\r\n        if (clientInfo.hasOwnProperty(\"uid\")) {\r\n          this.uid = clientInfo.uid;\r\n        }\r\n\r\n        if (clientInfo.hasOwnProperty(\"utid\")) {\r\n          this.utid = clientInfo.utid;\r\n        }\r\n      }\r\n    } catch (e) {\r\n      throw ClientAuthError.createClientInfoDecodingError(e);\r\n    }\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { CryptoUtils } from \"./CryptoUtils\";\r\nimport { StringUtils } from './StringUtils';\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class TokenUtils {\r\n\r\n  /**\r\n   * decode a JWT\r\n   *\r\n   * @param jwtToken\r\n   */\r\n  static decodeJwt(jwtToken: string): any {\r\n    if (StringUtils.isEmpty(jwtToken)) {\r\n      return null;\r\n    }\r\n    const idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\r\n    const matches = idTokenPartsRegex.exec(jwtToken);\r\n    if (!matches || matches.length < 4) {\r\n      //this._requestContext.logger.warn(\"The returned id_token is not parseable.\");\r\n      return null;\r\n    }\r\n    const crackedToken = {\r\n      header: matches[1],\r\n      JWSPayload: matches[2],\r\n      JWSSig: matches[3]\r\n    };\r\n    return crackedToken;\r\n  }\r\n\r\n  /**\r\n   * Extract IdToken by decoding the RAWIdToken\r\n   *\r\n   * @param encodedIdToken\r\n   */\r\n  static extractIdToken(encodedIdToken: string): any {\r\n    // id token will be decoded to get the username\r\n    const decodedToken = this.decodeJwt(encodedIdToken);\r\n    if (!decodedToken) {\r\n      return null;\r\n    }\r\n    try {\r\n      const base64IdToken = decodedToken.JWSPayload;\r\n      const base64Decoded = CryptoUtils.base64Decode(base64IdToken);\r\n      if (!base64Decoded) {\r\n        //this._requestContext.logger.info(\"The returned id_token could not be base64 url safe decoded.\");\r\n        return null;\r\n      }\r\n      // ECMA script has JSON built-in support\r\n      return JSON.parse(base64Decoded);\r\n    } catch (err) {\r\n      //this._requestContext.logger.error(\"The returned id_token could not be decoded\" + err);\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { ClientAuthError } from \"./error/ClientAuthError\";\r\nimport { TokenUtils } from \"./utils/TokenUtils\";\r\nimport { StringDict } from \"./MsalTypes\";\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class IdToken {\r\n\r\n  issuer: string;\r\n  objectId: string;\r\n  subject: string;\r\n  tenantId: string;\r\n  version: string;\r\n  preferredName: string;\r\n  name: string;\r\n  homeObjectId: string;\r\n  nonce: string;\r\n  expiration: string;\r\n  rawIdToken: string;\r\n  claims: StringDict;\r\n  sid: string;\r\n  /* tslint:disable:no-string-literal */\r\n  constructor(rawIdToken: string) {\r\n    if (StringUtils.isEmpty(rawIdToken)) {\r\n      throw ClientAuthError.createIdTokenNullOrEmptyError(rawIdToken);\r\n    }\r\n    try {\r\n      this.rawIdToken = rawIdToken;\r\n      this.claims = TokenUtils.extractIdToken(rawIdToken);\r\n      if (this.claims) {\r\n        if (this.claims.hasOwnProperty(\"iss\")) {\r\n          this.issuer = this.claims[\"iss\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"oid\")) {\r\n            this.objectId = this.claims[\"oid\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"sub\")) {\r\n          this.subject = this.claims[\"sub\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"tid\")) {\r\n          this.tenantId = this.claims[\"tid\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"ver\")) {\r\n          this.version = this.claims[\"ver\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"preferred_username\")) {\r\n          this.preferredName = this.claims[\"preferred_username\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"name\")) {\r\n          this.name = this.claims[\"name\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"nonce\")) {\r\n          this.nonce = this.claims[\"nonce\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"exp\")) {\r\n          this.expiration = this.claims[\"exp\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"home_oid\")) {\r\n            this.homeObjectId = this.claims[\"home_oid\"];\r\n        }\r\n\r\n        if (this.claims.hasOwnProperty(\"sid\")) {\r\n            this.sid = this.claims[\"sid\"];\r\n        }\r\n      /* tslint:enable:no-string-literal */\r\n      }\r\n    } catch (e) {\r\n      // TODO: This error here won't really every be thrown, since extractIdToken() returns null if the decodeJwt() fails.\r\n      // Need to add better error handling here to account for being unable to decode jwts.\r\n      throw ClientAuthError.createIdTokenParsingError(e);\r\n    }\r\n  }\r\n\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { AccessTokenKey } from \"./AccessTokenKey\";\r\nimport { AccessTokenValue } from \"./AccessTokenValue\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class AccessTokenCacheItem {\r\n\r\n  key: AccessTokenKey;\r\n  value: AccessTokenValue;\r\n\r\n  constructor(key: AccessTokenKey, value: AccessTokenValue) {\r\n    this.key = key;\r\n    this.value = value;\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Constants, CacheKeys } from \"./utils/Constants\";\r\nimport { AccessTokenCacheItem } from \"./AccessTokenCacheItem\";\r\nimport { CacheLocation } from \"./Configuration\";\r\nimport { ClientConfigurationError } from \"./error/ClientConfigurationError\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class Storage {// Singleton\r\n\r\n  private static instance: Storage;\r\n  private localStorageSupported: boolean;\r\n  private sessionStorageSupported: boolean;\r\n  private cacheLocation: CacheLocation;\r\n\r\n  constructor(cacheLocation: CacheLocation) {\r\n    if (Storage.instance) {\r\n      return Storage.instance;\r\n    }\r\n\r\n    this.cacheLocation = cacheLocation;\r\n    this.localStorageSupported = typeof window[this.cacheLocation] !== \"undefined\" && window[this.cacheLocation] != null;\r\n    this.sessionStorageSupported = typeof window[cacheLocation] !== \"undefined\" && window[cacheLocation] != null;\r\n    Storage.instance = this;\r\n    if (!this.localStorageSupported && !this.sessionStorageSupported) {\r\n      throw ClientConfigurationError.createNoStorageSupportedError();\r\n    }\r\n\r\n    return Storage.instance;\r\n  }\r\n\r\n    // add value to storage\r\n    setItem(key: string, value: string, enableCookieStorage?: boolean): void {\r\n        if (window[this.cacheLocation]) {\r\n            window[this.cacheLocation].setItem(key, value);\r\n        }\r\n        if (enableCookieStorage) {\r\n            this.setItemCookie(key, value);\r\n        }\r\n    }\r\n\r\n    // get one item by key from storage\r\n    getItem(key: string, enableCookieStorage?: boolean): string {\r\n        if (enableCookieStorage && this.getItemCookie(key)) {\r\n            return this.getItemCookie(key);\r\n        }\r\n        if (window[this.cacheLocation]) {\r\n            return window[this.cacheLocation].getItem(key);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // remove value from storage\r\n    removeItem(key: string): void {\r\n        if (window[this.cacheLocation]) {\r\n            return window[this.cacheLocation].removeItem(key);\r\n        }\r\n    }\r\n\r\n    // clear storage (remove all items from it)\r\n    clear(): void {\r\n        if (window[this.cacheLocation]) {\r\n            return window[this.cacheLocation].clear();\r\n        }\r\n    }\r\n\r\n    getAllAccessTokens(clientId: string, homeAccountIdentifier: string): Array<AccessTokenCacheItem> {\r\n        const results: Array<AccessTokenCacheItem> = [];\r\n        let accessTokenCacheItem: AccessTokenCacheItem;\r\n        const storage = window[this.cacheLocation];\r\n        if (storage) {\r\n            let key: string;\r\n            for (key in storage) {\r\n                if (storage.hasOwnProperty(key)) {\r\n                    if (key.match(clientId) && key.match(homeAccountIdentifier)) {\r\n                        const value = this.getItem(key);\r\n                        if (value) {\r\n                            accessTokenCacheItem = new AccessTokenCacheItem(JSON.parse(key), JSON.parse(value));\r\n                            results.push(accessTokenCacheItem);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    removeAcquireTokenEntries(state?: string): void {\r\n        const storage = window[this.cacheLocation];\r\n        if (storage) {\r\n            let key: string;\r\n            for (key in storage) {\r\n                if (storage.hasOwnProperty(key)) {\r\n                    if ((key.indexOf(CacheKeys.AUTHORITY) !== -1 || key.indexOf(CacheKeys.ACQUIRE_TOKEN_ACCOUNT) !== 1) && (!state || key.indexOf(state) !== -1)) {\r\n                        const splitKey = key.split(Constants.resourceDelimiter);\r\n                        let state;\r\n                        if (splitKey.length > 1) {\r\n                            state = splitKey[1];\r\n                        }\r\n                        if (state && !this.tokenRenewalInProgress(state)) {\r\n                            this.removeItem(key);\r\n                            this.removeItem(Constants.renewStatus + state);\r\n                            this.removeItem(Constants.stateLogin);\r\n                            this.removeItem(Constants.stateAcquireToken);\r\n                            this.setItemCookie(key, \"\", -1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.clearCookie();\r\n    }\r\n\r\n    private tokenRenewalInProgress(stateValue: string): boolean {\r\n        const storage = window[this.cacheLocation];\r\n        const renewStatus = storage[Constants.renewStatus + stateValue];\r\n        return !(!renewStatus || renewStatus !== Constants.tokenRenewStatusInProgress);\r\n    }\r\n\r\n    resetCacheItems(): void {\r\n        const storage = window[this.cacheLocation];\r\n        if (storage) {\r\n            let key: string;\r\n            for (key in storage) {\r\n                if (storage.hasOwnProperty(key)) {\r\n                    if (key.indexOf(Constants.msal) !== -1) {\r\n                        this.removeItem(key);\r\n                    }\r\n                }\r\n            }\r\n            this.removeAcquireTokenEntries();\r\n        }\r\n    }\r\n\r\n    setItemCookie(cName: string, cValue: string, expires?: number): void {\r\n        let cookieStr = cName + \"=\" + cValue + \";\";\r\n        if (expires) {\r\n            const expireTime = this.getCookieExpirationTime(expires);\r\n            cookieStr += \"expires=\" + expireTime + \";\";\r\n        }\r\n\r\n        document.cookie = cookieStr;\r\n    }\r\n\r\n    getItemCookie(cName: string): string {\r\n        const name = cName + \"=\";\r\n        const ca = document.cookie.split(\";\");\r\n        for (let i = 0; i < ca.length; i++) {\r\n            let c = ca[i];\r\n            while (c.charAt(0) === \" \") {\r\n                c = c.substring(1);\r\n            }\r\n            if (c.indexOf(name) === 0) {\r\n                return c.substring(name.length, c.length);\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    getCookieExpirationTime(cookieLifeDays: number): string {\r\n        const today = new Date();\r\n        const expr = new Date(today.getTime() + cookieLifeDays * 24 * 60 * 60 * 1000);\r\n        return expr.toUTCString();\r\n    }\r\n\r\n    clearCookie(): void {\r\n        this.setItemCookie(Constants.nonceIdToken, \"\", -1);\r\n        this.setItemCookie(Constants.stateLogin, \"\", -1);\r\n        this.setItemCookie(Constants.loginRequest, \"\", -1);\r\n        this.setItemCookie(Constants.stateAcquireToken, \"\", -1);\r\n    }\r\n\r\n    /**\r\n     * Create acquireTokenAccountKey to cache account object\r\n     * @param accountId\r\n     * @param state\r\n     */\r\n    static generateAcquireTokenAccountKey(accountId: any, state: string): string {\r\n        return CacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.resourceDelimiter +\r\n            `${accountId}` + Constants.resourceDelimiter  + `${state}`;\r\n    }\r\n\r\n    /**\r\n     * Create authorityKey to cache authority\r\n     * @param state\r\n     */\r\n    static generateAuthorityKey(state: string): string {\r\n        return CacheKeys.AUTHORITY + Constants.resourceDelimiter + `${state}`;\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { ClientInfo } from \"./ClientInfo\";\r\nimport { IdToken } from \"./IdToken\";\r\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\nimport { StringDict } from \"./MsalTypes\";\r\n\r\n/**\r\n * accountIdentifier       combination of idToken.uid and idToken.utid\r\n * homeAccountIdentifier   combination of clientInfo.uid and clientInfo.utid\r\n * userName                idToken.preferred_username\r\n * name                    idToken.name\r\n * idToken                 idToken\r\n * sid                     idToken.sid - session identifier\r\n * environment             idtoken.issuer (the authority that issues the token)\r\n */\r\nexport class Account {\r\n\r\n    accountIdentifier: string;\r\n    homeAccountIdentifier: string;\r\n    userName: string;\r\n    name: string;\r\n    idToken: StringDict; // will be deprecated soon\r\n    idTokenClaims: StringDict;\r\n    sid: string;\r\n    environment: string;\r\n\r\n    /**\r\n     * Creates an Account Object\r\n     * @praram accountIdentifier\r\n     * @param homeAccountIdentifier\r\n     * @param userName\r\n     * @param name\r\n     * @param idToken\r\n     * @param sid\r\n     * @param environment\r\n     */\r\n    constructor(accountIdentifier: string, homeAccountIdentifier: string, userName: string, name: string, idTokenClaims: StringDict, sid: string,  environment: string) {\r\n      this.accountIdentifier = accountIdentifier;\r\n      this.homeAccountIdentifier = homeAccountIdentifier;\r\n      this.userName = userName;\r\n      this.name = name;\r\n      // will be deprecated soon\r\n      this.idToken = idTokenClaims;\r\n      this.idTokenClaims = idTokenClaims;\r\n      this.sid = sid;\r\n      this.environment = environment;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * @param idToken\r\n     * @param clientInfo\r\n     */\r\n    static createAccount(idToken: IdToken, clientInfo: ClientInfo): Account {\r\n\r\n        // create accountIdentifier\r\n        const accountIdentifier: string = idToken.objectId ||  idToken.subject;\r\n\r\n        // create homeAccountIdentifier\r\n        const uid: string = clientInfo ? clientInfo.uid : \"\";\r\n        const utid: string = clientInfo ? clientInfo.utid : \"\";\r\n\r\n        let homeAccountIdentifier: string;\r\n        if (!StringUtils.isEmpty(uid) && !StringUtils.isEmpty(utid)) {\r\n            homeAccountIdentifier = CryptoUtils.base64Encode(uid) + \".\" + CryptoUtils.base64Encode(utid);\r\n        }\r\n        return new Account(accountIdentifier, homeAccountIdentifier, idToken.preferredName, idToken.name, idToken.claims, idToken.sid, idToken.issuer);\r\n    }\r\n\r\n    /**\r\n     * Utils function to compare two Account objects - used to check if the same user account is logged in\r\n     *\r\n     * @param a1: Account object\r\n     * @param a2: Account object\r\n     */\r\n    static compareAccounts(a1: Account, a2: Account): boolean {\r\n        if (!a1 || !a2) {\r\n            return false;\r\n        }\r\n        if (a1.homeAccountIdentifier && a2.homeAccountIdentifier) {\r\n        if (a1.homeAccountIdentifier === a2.homeAccountIdentifier) {\r\n            return true;\r\n        }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class TimeUtils {\r\n    /**\r\n     * Returns time in seconds for expiration based on string value passed in.\r\n     *\r\n     * @param expiresIn\r\n     */\r\n    static parseExpiresIn(expiresIn: string): number {\r\n        // if AAD did not send \"expires_in\" property, use default expiration of 3599 seconds, for some reason AAD sends 3599 as \"expires_in\" value instead of 3600\r\n        if (!expiresIn) {\r\n        expiresIn = \"3599\";\r\n        }\r\n        return parseInt(expiresIn, 10);\r\n    }\r\n\r\n    /**\r\n     * return the current time in Unix time. Date.getTime() returns in milliseconds.\r\n     */\r\n    static now(): number {\r\n        return Math.round(new Date().getTime() / 1000.0);\r\n    }\r\n}\r\n","import { AuthResponse } from \"../AuthResponse\";\r\nimport { IdToken } from \"../IdToken\";\r\n\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class ResponseUtils {\r\n\r\n    static setResponseIdToken(originalResponse: AuthResponse, idTokenObj: IdToken) : AuthResponse {\r\n        if (!originalResponse) {\r\n            return null;\r\n        } else if (!idTokenObj) {\r\n            return originalResponse;\r\n        }\r\n\r\n        let exp = Number(idTokenObj.expiration);\r\n        if (exp && !originalResponse.expiresOn) {\r\n            originalResponse.expiresOn = new Date(exp * 1000);\r\n        }\r\n    \r\n        return {\r\n          ...originalResponse,\r\n          idToken: idTokenObj,\r\n          idTokenClaims: idTokenObj.claims,\r\n          uniqueId: idTokenObj.objectId || idTokenObj.subject,\r\n          tenantId: idTokenObj.tenantId,\r\n        };\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/**\r\n * XHR client for JSON endpoints\r\n * https://www.npmjs.com/package/async-promise\r\n * @hidden\r\n */\r\nexport class XhrClient {\r\n  public sendRequestAsync(url: string, method: string, enableCaching?: boolean): Promise<any> {\r\n    return new Promise<string>((resolve, reject) => {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open(method, url, /*async: */ true);\r\n      if (enableCaching) {\r\n        // TODO: (shivb) ensure that this can be cached\r\n        // xhr.setRequestHeader(\"Cache-Control\", \"Public\");\r\n      }\r\n\r\n      xhr.onload = (ev) => {\r\n          if (xhr.status < 200 || xhr.status >= 300) {\r\n              reject(this.handleError(xhr.responseText));\r\n          }\r\n\r\n          try {\r\n              var jsonResponse = JSON.parse(xhr.responseText);\r\n          } catch (e) {\r\n              reject(this.handleError(xhr.responseText));\r\n          }\r\n\r\n          resolve(jsonResponse);\r\n      };\r\n\r\n      xhr.onerror = (ev) => {\r\n        reject(xhr.status);\r\n      };\r\n\r\n      if (method === \"GET\") {\r\n        xhr.send();\r\n      }\r\n      else {\r\n        throw \"not implemented\";\r\n      }\r\n    });\r\n  }\r\n\r\n  protected handleError(responseText: string): any {\r\n    var jsonResponse;\r\n    try {\r\n      jsonResponse = JSON.parse(responseText);\r\n      if (jsonResponse.error) {\r\n          return jsonResponse.error;\r\n      } else {\r\n          throw responseText;\r\n      }\r\n    } catch (e) {\r\n      return responseText;\r\n    }\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\nimport { libraryVersion } from \"./utils/Constants\";\r\n\r\nexport interface ILoggerCallback {\r\n  (level: LogLevel, message: string, containsPii: boolean): void;\r\n}\r\n\r\nexport enum LogLevel {\r\n  Error,\r\n  Warning,\r\n  Info,\r\n  Verbose\r\n}\r\n\r\nexport class Logger {// Singleton Class\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  // TODO: This does not seem to be a singleton!! Change or Delete.\r\n  private static instance: Logger;\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  private correlationId: string;\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  private level: LogLevel = LogLevel.Info;\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  private piiLoggingEnabled: boolean;\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  private localCallback: ILoggerCallback;\r\n\r\n  constructor(localCallback: ILoggerCallback,\r\n      options:\r\n      {\r\n          correlationId?: string,\r\n          level?: LogLevel,\r\n          piiLoggingEnabled?: boolean,\r\n      } = {}) {\r\n      const {\r\n          correlationId = \"\",\r\n          level = LogLevel.Info,\r\n          piiLoggingEnabled = false\r\n      } = options;\r\n\r\n      this.localCallback = localCallback;\r\n      this.correlationId = correlationId;\r\n      this.level = level;\r\n      this.piiLoggingEnabled = piiLoggingEnabled;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  private logMessage(logLevel: LogLevel, logMessage: string, containsPii: boolean): void {\r\n    if ((logLevel > this.level) || (!this.piiLoggingEnabled && containsPii)) {\r\n      return;\r\n    }\r\n    const timestamp = new Date().toUTCString();\r\n    let log: string;\r\n    if (!StringUtils.isEmpty(this.correlationId)) {\r\n      log = timestamp + \":\" + this.correlationId + \"-\" + libraryVersion() + \"-\" + LogLevel[logLevel] + \" \" + logMessage;\r\n    }\r\n    else {\r\n      log = timestamp + \":\" + libraryVersion() + \"-\" + LogLevel[logLevel] + \" \" + logMessage;\r\n    }\r\n    this.executeCallback(logLevel, log, containsPii);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  executeCallback(level: LogLevel, message: string, containsPii: boolean) {\r\n    if (this.localCallback) {\r\n      this.localCallback(level, message, containsPii);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  error(message: string): void {\r\n    this.logMessage(LogLevel.Error, message, false);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  errorPii(message: string): void {\r\n    this.logMessage(LogLevel.Error, message, true);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  warning(message: string): void {\r\n    this.logMessage(LogLevel.Warning, message, false);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  warningPii(message: string): void {\r\n    this.logMessage(LogLevel.Warning, message, true);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  info(message: string): void {\r\n    this.logMessage(LogLevel.Info, message, false);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  infoPii(message: string): void {\r\n    this.logMessage(LogLevel.Info, message, true);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  verbose(message: string): void {\r\n    this.logMessage(LogLevel.Verbose, message, false);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  verbosePii(message: string): void {\r\n    this.logMessage(LogLevel.Verbose, message, true);\r\n  }\r\n\r\n  isPiiLoggingEnabled(): boolean {\r\n    return this.piiLoggingEnabled;\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Authority, AuthorityType } from \"./Authority\";\r\nimport { XhrClient } from \"./XHRClient\";\r\nimport { AADTrustedHostList } from \"./utils/Constants\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class AadAuthority extends Authority {\r\n  private static readonly AadInstanceDiscoveryEndpoint: string = \"https://login.microsoftonline.com/common/discovery/instance\";\r\n\r\n  private get AadInstanceDiscoveryEndpointUrl(): string {\r\n      return `${AadAuthority.AadInstanceDiscoveryEndpoint}?api-version=1.0&authorization_endpoint=${this.CanonicalAuthority}oauth2/v2.0/authorize`;\r\n  }\r\n\r\n  public constructor(authority: string, validateAuthority: boolean) {\r\n    super(authority, validateAuthority);\r\n  }\r\n\r\n  public get AuthorityType(): AuthorityType {\r\n    return AuthorityType.Aad;\r\n  }\r\n\r\n  /**\r\n   * Returns a promise which resolves to the OIDC endpoint\r\n   * Only responds with the endpoint\r\n   */\r\n  public GetOpenIdConfigurationEndpointAsync(): Promise<string> {\r\n      const resultPromise: Promise<string> = new Promise<string>((resolve, reject) =>\r\n      resolve(this.DefaultOpenIdConfigurationEndpoint));\r\n\r\n    if (!this.IsValidationEnabled) {\r\n      return resultPromise;\r\n    }\r\n\r\n    let host: string = this.CanonicalAuthorityUrlComponents.HostNameAndPort;\r\n    if (this.IsInTrustedHostList(host)) {\r\n      return resultPromise;\r\n    }\r\n\r\n    let client: XhrClient = new XhrClient();\r\n\r\n    return client.sendRequestAsync(this.AadInstanceDiscoveryEndpointUrl, \"GET\", true)\r\n      .then((response) => {\r\n        return response.tenant_discovery_endpoint;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Checks to see if the host is in a list of trusted hosts\r\n   * @param {string} The host to look up\r\n   */\r\n  public IsInTrustedHostList(host: string): boolean {\r\n    return AADTrustedHostList[host.toLowerCase()];\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { AadAuthority } from \"./AadAuthority\";\r\nimport { AuthorityType } from \"./Authority\";\r\nimport { ClientConfigurationErrorMessage } from \"./error/ClientConfigurationError\";\r\nimport { UrlUtils } from \"./utils/UrlUtils\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class B2cAuthority extends AadAuthority {\r\n  public static B2C_PREFIX: String = \"tfp\";\r\n  public constructor(authority: string, validateAuthority: boolean) {\r\n    super(authority, validateAuthority);\r\n    const urlComponents = UrlUtils.GetUrlComponents(authority);\r\n\r\n    const pathSegments = urlComponents.PathSegments;\r\n    if (pathSegments.length < 3) {\r\n        throw ClientConfigurationErrorMessage.b2cAuthorityUriInvalidPath;\r\n    }\r\n\r\n    this.CanonicalAuthority = `https://${urlComponents.HostNameAndPort}/${pathSegments[0]}/${pathSegments[1]}/${pathSegments[2]}/`;\r\n  }\r\n\r\n  public get AuthorityType(): AuthorityType {\r\n    return AuthorityType.B2C;\r\n  }\r\n\r\n  /**\r\n   * Returns a promise with the TenantDiscoveryEndpoint\r\n   */\r\n  public GetOpenIdConfigurationEndpointAsync(): Promise<string> {\r\n    const resultPromise = new Promise<string>((resolve, reject) =>\r\n      resolve(this.DefaultOpenIdConfigurationEndpoint));\r\n\r\n    if (!this.IsValidationEnabled) {\r\n      return resultPromise;\r\n    }\r\n\r\n    if (this.IsInTrustedHostList(this.CanonicalAuthorityUrlComponents.HostNameAndPort)) {\r\n      return resultPromise;\r\n    }\r\n\r\n    return new Promise<string>((resolve, reject) =>\r\n      reject(ClientConfigurationErrorMessage.unsupportedAuthorityValidation));\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/**\r\n * @hidden\r\n */\r\nimport { AadAuthority } from \"./AadAuthority\";\r\nimport { B2cAuthority } from \"./B2cAuthority\";\r\nimport { Authority, AuthorityType } from \"./Authority\";\r\nimport { ClientConfigurationErrorMessage } from \"./error/ClientConfigurationError\";\r\nimport { UrlUtils } from \"./utils/UrlUtils\";\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\n\r\nexport class AuthorityFactory {\r\n    /**\r\n    * Parse the url and determine the type of authority\r\n    */\r\n    private static DetectAuthorityFromUrl(authorityUrl: string): AuthorityType {\r\n        authorityUrl = UrlUtils.CanonicalizeUri(authorityUrl);\r\n        const components = UrlUtils.GetUrlComponents(authorityUrl);\r\n        const pathSegments = components.PathSegments;\r\n        switch (pathSegments[0]) {\r\n            case \"tfp\":\r\n                return AuthorityType.B2C;\r\n            case \"adfs\":\r\n                return AuthorityType.Adfs;\r\n            default:\r\n                return AuthorityType.Aad;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Create an authority object of the correct type based on the url\r\n    * Performs basic authority validation - checks to see if the authority is of a valid type (eg aad, b2c)\r\n    */\r\n    public static CreateInstance(authorityUrl: string, validateAuthority: boolean): Authority {\r\n        if (StringUtils.isEmpty(authorityUrl)) {\r\n            return null;\r\n        }\r\n        const type = AuthorityFactory.DetectAuthorityFromUrl(authorityUrl);\r\n        // Depending on above detection, create the right type.\r\n        switch (type) {\r\n            case AuthorityType.B2C:\r\n                return new B2cAuthority(authorityUrl, validateAuthority);\r\n            case AuthorityType.Aad:\r\n                return new AadAuthority(authorityUrl, validateAuthority);\r\n            default:\r\n                throw ClientConfigurationErrorMessage.invalidAuthorityType;\r\n        }\r\n    }\r\n\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Logger } from \"./Logger\";\r\nimport { UrlUtils } from \"./utils/UrlUtils\";\r\nimport { TelemetryEmitter } from \"./telemetry/TelemetryTypes\"\r\n\r\n/**\r\n * Cache location options supported by MSAL are:\r\n * - local storage: MSAL uses browsers local storage to store its cache\r\n * - session storage: MSAL uses the browsers session storage to store its cache\r\n */\r\nexport type CacheLocation = \"localStorage\" | \"sessionStorage\";\r\n\r\n/**\r\n * Defaults for the Configuration Options\r\n */\r\nconst FRAME_TIMEOUT = 6000;\r\nconst OFFSET = 300;\r\nconst NAVIGATE_FRAME_WAIT = 500;\r\n\r\n\r\n/**\r\n * @type AuthOptions: Use this to configure the auth options in the Configuration object\r\n *\r\n *  - clientId                    - Client ID of your app registered with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview in Microsoft Identity Platform\r\n *  - authority                   - You can configure a specific authority, defaults to \" \" or \"https://login.microsoftonline.com/common\"\r\n *  - validateAuthority           - Used to turn authority validation on/off. When set to true (default), MSAL will compare the application's authority against well-known URLs templates representing well-formed authorities. It is useful when the authority is obtained at run time to prevent MSAL from displaying authentication prompts from malicious pages.\r\n *  - redirectUri                 - The redirect URI of the application, this should be same as the value in the application registration portal.Defaults to `window.location.href`.\r\n *  - postLogoutRedirectUri       - Used to redirect the user to this location after logout. Defaults to `window.location.href`.\r\n *  - navigateToLoginRequestUrl   - Used to turn off default navigation to start page after login. Default is true. This is used only for redirect flows.\r\n *\r\n */\r\nexport type AuthOptions = {\r\n  clientId: string;\r\n  authority?: string;\r\n  validateAuthority?: boolean;\r\n  redirectUri?: string | (() => string);\r\n  postLogoutRedirectUri?: string | (() => string);\r\n  navigateToLoginRequestUrl?: boolean;\r\n};\r\n\r\n/**\r\n * Use this to configure the below cache configuration options:\r\n *\r\n * - cacheLocation            - Used to specify the cacheLocation user wants to set. Valid values are \"localStorage\" and \"sessionStorage\"\r\n * - storeAuthStateInCookie   - If set, MSAL store's the auth request state required for validation of the auth flows in the browser cookies. By default this flag is set to false.\r\n */\r\nexport type CacheOptions = {\r\n  cacheLocation?: CacheLocation;\r\n  storeAuthStateInCookie?: boolean;\r\n};\r\n\r\n/**\r\n * Telemetry Config Options\r\n * - applicationName              - Name of the consuming apps application\r\n * - applicationVersion           - Verison of the consuming application\r\n * - telemetryEmitter             - Function where telemetry events are flushed to\r\n */\r\nexport type TelemetryOptions = {\r\n  applicationName: string;\r\n  applicationVersion: string;\r\n  telemetryEmitter: TelemetryEmitter\r\n //TODO, add onlyAddFailureTelemetry option\r\n};\r\n\r\n/**\r\n * Library Specific Options\r\n *\r\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\r\n * - loadFrameTimeout             - maximum time the library should wait for a frame to load\r\n * - tokenRenewalOffsetSeconds    - sets the window of offset needed to renew the token before expiry\r\n * - navigateFrameWait            - sets the wait time for hidden iFrame navigation\r\n */\r\nexport type SystemOptions = {\r\n  logger?: Logger;\r\n  loadFrameTimeout?: number;\r\n  tokenRenewalOffsetSeconds?: number;\r\n  navigateFrameWait?: number;\r\n  telemetry?: TelemetryOptions\r\n};\r\n\r\n/**\r\n * App/Framework specific environment support\r\n *\r\n * - isAngular                - flag set to determine if it is Angular Framework. MSAL uses this to broadcast tokens. More to come here: detangle this dependency from core.\r\n * - unprotectedResources     - Array of URI's which are unprotected resources. MSAL will not attach a token to outgoing requests that have these URI. Defaults to 'null'.\r\n * - protectedResourceMap     - This is mapping of resources to scopes used by MSAL for automatically attaching access tokens in web API calls.A single access token is obtained for the resource. So you can map a specific resource path as follows: {\"https://graph.microsoft.com/v1.0/me\", [\"user.read\"]}, or the app URL of the resource as: {\"https://graph.microsoft.com/\", [\"user.read\", \"mail.send\"]}. This is required for CORS calls.\r\n *\r\n */\r\nexport type FrameworkOptions = {\r\n  isAngular?: boolean;\r\n  unprotectedResources?: Array<string>;\r\n  protectedResourceMap?: Map<string, Array<string>>;\r\n};\r\n\r\n/**\r\n * Use the configuration object to configure MSAL and initialize the UserAgentApplication.\r\n *\r\n * This object allows you to configure important elements of MSAL functionality:\r\n * - auth: this is where you configure auth elements like clientID,  authority used for authenticating against the Microsoft Identity Platform\r\n * - cache: this is where you configure cache location and whether to store cache in cookies\r\n * - system: this is where you can configure the logger, frame timeout etc.\r\n * - framework: this is where you can configure the running mode of angular. More to come here soon.\r\n */\r\nexport type Configuration = {\r\n  auth: AuthOptions,\r\n  cache?: CacheOptions,\r\n  system?: SystemOptions,\r\n  framework?: FrameworkOptions\r\n};\r\n\r\nconst DEFAULT_AUTH_OPTIONS: AuthOptions = {\r\n  clientId: \"\",\r\n  authority: null,\r\n  validateAuthority: true,\r\n  redirectUri: () => UrlUtils.getDefaultRedirectUri(),\r\n  postLogoutRedirectUri: () => UrlUtils.getDefaultRedirectUri(),\r\n  navigateToLoginRequestUrl: true\r\n};\r\n\r\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {\r\n  cacheLocation: \"sessionStorage\",\r\n  storeAuthStateInCookie: false\r\n};\r\n\r\nconst DEFAULT_SYSTEM_OPTIONS: SystemOptions = {\r\n  logger: new Logger(null),\r\n  loadFrameTimeout: FRAME_TIMEOUT,\r\n  tokenRenewalOffsetSeconds: OFFSET,\r\n  navigateFrameWait: NAVIGATE_FRAME_WAIT\r\n};\r\n\r\nconst DEFAULT_FRAMEWORK_OPTIONS: FrameworkOptions = {\r\n  isAngular: false,\r\n  unprotectedResources: new Array<string>(),\r\n  protectedResourceMap: new Map<string, Array<string>>()\r\n};\r\n\r\n/**\r\n * MSAL function that sets the default options when not explicitly configured from app developer\r\n *\r\n * @param TAuthOptions\r\n * @param TCacheOptions\r\n * @param TSystemOptions\r\n * @param TFrameworkOptions\r\n *\r\n * @returns TConfiguration object\r\n */\r\n\r\nexport function buildConfiguration({ auth, cache = {}, system = {}, framework = {}}: Configuration): Configuration {\r\n  const overlayedConfig: Configuration = {\r\n    auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\r\n    cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\r\n    system: { ...DEFAULT_SYSTEM_OPTIONS, ...system },\r\n    framework: { ...DEFAULT_FRAMEWORK_OPTIONS, ...framework }\r\n  };\r\n  return overlayedConfig;\r\n}\r\n\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { AuthError } from \"./AuthError\";\r\n\r\nexport const ServerErrorMessage = {\r\n    serverUnavailable: {\r\n        code: \"server_unavailable\",\r\n        desc: \"Server is temporarily unavailable.\"\r\n    },\r\n    unknownServerError: {\r\n        code: \"unknown_server_error\"\r\n    },\r\n};\r\n\r\n/**\r\n * Error thrown when there is an error with the server code, for example, unavailability.\r\n */\r\nexport class ServerError extends AuthError {\r\n\r\n    constructor(errorCode: string, errorMessage?: string) {\r\n        super(errorCode, errorMessage);\r\n        this.name = \"ServerError\";\r\n\r\n        Object.setPrototypeOf(this, ServerError.prototype);\r\n    }\r\n\r\n    static createServerUnavailableError(): ServerError {\r\n        return new ServerError(ServerErrorMessage.serverUnavailable.code,\r\n            ServerErrorMessage.serverUnavailable.desc);\r\n    }\r\n\r\n    static createUnknownServerError(errorDesc: string): ServerError {\r\n        return new ServerError(ServerErrorMessage.unknownServerError.code,\r\n            errorDesc);\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { ServerError } from \"./ServerError\";\r\n\r\nexport const InteractionRequiredAuthErrorMessage = {\r\n    interactionRequired: {\r\n        code: \"interaction_required\"\r\n    },\r\n    consentRequired: {\r\n        code: \"consent_required\"\r\n    },\r\n    loginRequired: {\r\n        code: \"login_required\"\r\n    },\r\n};\r\n\r\n/**\r\n * Error thrown when the user is required to perform an interactive token request.\r\n */\r\nexport class InteractionRequiredAuthError extends ServerError {\r\n\r\n    constructor(errorCode: string, errorMessage?: string) {\r\n        super(errorCode, errorMessage);\r\n        this.name = \"InteractionRequiredAuthError\";\r\n\r\n        Object.setPrototypeOf(this, InteractionRequiredAuthError.prototype);\r\n    }\r\n\r\n    static isInteractionRequiredError(errorString: string) : boolean {\r\n        const interactionRequiredCodes = [\r\n            InteractionRequiredAuthErrorMessage.interactionRequired.code,\r\n            InteractionRequiredAuthErrorMessage.consentRequired.code,\r\n            InteractionRequiredAuthErrorMessage.loginRequired.code\r\n        ];\r\n\r\n        return errorString && interactionRequiredCodes.indexOf(errorString) > -1;\r\n    }\r\n\r\n    static createLoginRequiredAuthError(errorDesc: string): InteractionRequiredAuthError {\r\n        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.loginRequired.code, errorDesc);\r\n    }\r\n\r\n    static createInteractionRequiredAuthError(errorDesc: string): InteractionRequiredAuthError {\r\n        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.interactionRequired.code, errorDesc);\r\n    }\r\n\r\n    static createConsentRequiredAuthError(errorDesc: string): InteractionRequiredAuthError {\r\n        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.consentRequired.code, errorDesc);\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Account } from \"./Account\";\r\nimport { IdToken } from \"./IdToken\";\r\nimport { StringDict } from \"./MsalTypes\";\r\n\r\nexport type AuthResponse = {\r\n    uniqueId: string;\r\n    tenantId: string;\r\n    tokenType: string;\r\n    idToken: IdToken;\r\n    idTokenClaims: StringDict;\r\n    accessToken: string;\r\n    scopes: Array<string>;\r\n    expiresOn: Date;\r\n    account: Account;\r\n    accountState: string;\r\n};\r\n\r\nexport function buildResponseStateOnly(state: string) : AuthResponse {\r\n    return {\r\n        uniqueId: \"\",\r\n        tenantId: \"\",\r\n        tokenType: \"\",\r\n        idToken: null,\r\n        idTokenClaims: null,\r\n        accessToken: \"\",\r\n        scopes: null,\r\n        expiresOn: null,\r\n        account: null,\r\n        accountState: state\r\n    };\r\n}\r\n","export const EVENT_NAME_PREFIX = \"msal.\";\r\nexport const EVENT_NAME_KEY = \"event_name\";\r\nexport const START_TIME_KEY = \"start_time\";\r\nexport const ELAPSED_TIME_KEY  = \"elapsed_time\";\r\n\r\nexport const TELEMETRY_BLOB_EVENT_NAMES =  {\r\n    MsalCorrelationIdConstStrKey: \"Microsoft.MSAL.correlation_id\",\r\n    ApiTelemIdConstStrKey: \"msal.api_telem_id\",\r\n    ApiIdConstStrKey: \"msal.api_id\",\r\n    BrokerAppConstStrKey: \"Microsoft_MSAL_broker_app\",\r\n    CacheEventCountConstStrKey: \"Microsoft_MSAL_cache_event_count\",\r\n    HttpEventCountTelemetryBatchKey: \"Microsoft_MSAL_http_event_count\",\r\n    IdpConstStrKey: \"Microsoft_MSAL_idp\",\r\n    IsSilentTelemetryBatchKey: \"\",\r\n    IsSuccessfulConstStrKey: \"Microsoft_MSAL_is_successful\",\r\n    ResponseTimeConstStrKey: \"Microsoft_MSAL_response_time\",\r\n    TenantIdConstStrKey: \"Microsoft_MSAL_tenant_id\",\r\n    UiEventCountTelemetryBatchKey: \"Microsoft_MSAL_ui_event_count\"\r\n};\r\n\r\n// This is used to replace the real tenant in telemetry info\r\nexport const TENANT_PLACEHOLDER = \"<tenant>\";\r\n\r\n","import { B2cAuthority } from \"../B2cAuthority\";\r\nimport { AADTrustedHostList } from \"../utils/Constants\";\r\nimport { TENANT_PLACEHOLDER, EVENT_NAME_PREFIX } from \"./TelemetryConstants\";\r\nimport { CryptoUtils } from \"../utils/CryptoUtils\";\r\nimport { UrlUtils } from \"../utils/UrlUtils\";\r\n\r\nexport const scrubTenantFromUri = (uri: string): String => {\r\n\r\n    const url = UrlUtils.GetUrlComponents(uri);\r\n\r\n    // validate trusted host\r\n    if (!AADTrustedHostList[url.HostNameAndPort.toLocaleLowerCase()]) {\r\n        // Should this return null or what was passed?\r\n        return null;\r\n    }\r\n\r\n    const pathParams = url.PathSegments;\r\n\r\n    if (pathParams && pathParams.length >= 2) {\r\n        const tenantPosition = pathParams[1] ===  B2cAuthority.B2C_PREFIX ? 2 : 1;\r\n        if (tenantPosition < pathParams.length) {\r\n            pathParams[tenantPosition] = TENANT_PLACEHOLDER;\r\n        }\r\n    }\r\n\r\n    return  `${url.Protocol}//${url.HostNameAndPort}/${pathParams.join(\"/\")}`;\r\n};\r\n\r\nexport const hashPersonalIdentifier = (valueToHash: string) => {\r\n    // TODO sha256 this\r\n    // Current test runner is being funny with node libs that are webpacked anyway\r\n    // need a different solution\r\n    return CryptoUtils.base64Encode(valueToHash);\r\n};\r\n\r\nexport const prependEventNamePrefix = (suffix: string): string => `${EVENT_NAME_PREFIX}${suffix || \"\"}`;\r\n","import { EVENT_NAME_PREFIX, TELEMETRY_BLOB_EVENT_NAMES } from \"./TelemetryConstants\";\r\nimport TelemetryEvent from \"./TelemetryEvent\";\r\nimport { EventCount, TelemetryPlatform } from \"./TelemetryTypes\";\r\nimport { prependEventNamePrefix } from \"./TelemetryUtils\";\r\n\r\nexport default class DefaultEvent extends TelemetryEvent {\r\n    // TODO Platform Type\r\n    constructor(platform: TelemetryPlatform, correlationId: string, clientId: string, eventCount: EventCount) {\r\n        super(prependEventNamePrefix(\"default_event\"), correlationId);\r\n        this.event[prependEventNamePrefix(\"client_id\")] = clientId;\r\n        this.event[prependEventNamePrefix(\"sdk_plaform\")] = platform.sdk;\r\n        this.event[prependEventNamePrefix(\"sdk_version\")] = platform.sdkVersion;\r\n        this.event[prependEventNamePrefix(\"application_name\")] = platform.applicationName;\r\n        this.event[prependEventNamePrefix(\"application_version\")] = platform.applicationVersion;\r\n        this.event[`${TELEMETRY_BLOB_EVENT_NAMES.UiEventCountTelemetryBatchKey}`] = this.getEventCount(prependEventNamePrefix(\"ui_event\"), eventCount);\r\n        this.event[`${TELEMETRY_BLOB_EVENT_NAMES.HttpEventCountTelemetryBatchKey}`] = this.getEventCount(prependEventNamePrefix(\"http_event\"), eventCount);\r\n        this.event[`${TELEMETRY_BLOB_EVENT_NAMES.CacheEventCountConstStrKey}`] = this.getEventCount(prependEventNamePrefix(\"cache_event\"), eventCount);\r\n        /// Device id?\r\n    }\r\n\r\n    private getEventCount(eventName: string, eventCount: EventCount): number {\r\n        if (!eventCount[eventName]) {\r\n            return 0;\r\n        }\r\n        return eventCount[eventName];\r\n    }\r\n}\r\n","import { TELEMETRY_BLOB_EVENT_NAMES } from \"./TelemetryConstants\";\r\nimport {\r\n    EVENT_NAME_KEY,\r\n    START_TIME_KEY,\r\n    ELAPSED_TIME_KEY\r\n} from \"./TelemetryConstants\";\r\nimport { prependEventNamePrefix } from \"./TelemetryUtils\";\r\nimport { CryptoUtils } from \"../utils/CryptoUtils\";\r\n\r\nexport default class TelemetryEvent {\r\n\r\n    private startTimestamp: number;\r\n    protected event: any; // TODO TYPE THIS\r\n    public eventId: string;\r\n\r\n    constructor(eventName: string, correlationId: string) {\r\n\r\n        this.startTimestamp = Date.now();\r\n        this.eventId = CryptoUtils.createNewGuid();\r\n        this.event = {\r\n            [prependEventNamePrefix(EVENT_NAME_KEY)]: eventName,\r\n            [prependEventNamePrefix(START_TIME_KEY)]: this.startTimestamp,\r\n            [prependEventNamePrefix(ELAPSED_TIME_KEY)]: -1,\r\n            [`${TELEMETRY_BLOB_EVENT_NAMES.MsalCorrelationIdConstStrKey}`]: correlationId\r\n        };\r\n    }\r\n\r\n    private setElapsedTime(time: Number): void {\r\n        this.event[prependEventNamePrefix(ELAPSED_TIME_KEY)] = time;\r\n    }\r\n\r\n    public stop(): void {\r\n        // Set duration of event\r\n        this.setElapsedTime(+Date.now() - +this.startTimestamp);\r\n    }\r\n\r\n    public get telemetryCorrelationId(): string {\r\n        return this.event[`${TELEMETRY_BLOB_EVENT_NAMES.MsalCorrelationIdConstStrKey}`];\r\n    }\r\n\r\n    public set telemetryCorrelationId(value: string) {\r\n        this.event[`${TELEMETRY_BLOB_EVENT_NAMES.MsalCorrelationIdConstStrKey}`] = value;\r\n    }\r\n\r\n    public get eventName(): string {\r\n        return this.event[prependEventNamePrefix(EVENT_NAME_KEY)];\r\n    }\r\n\r\n    public get(): object {\r\n        return {\r\n            ...this.event,\r\n            eventId: this.eventId\r\n        };\r\n    }\r\n}\r\n","import TelemetryEvent from \"./TelemetryEvent\";\r\nimport {\r\n    CompletedEvents,\r\n    EventCount,\r\n    EventCountByCorrelationId,\r\n    InProgressEvents,\r\n    TelemetryConfig,\r\n    TelemetryPlatform,\r\n    TelemetryEmitter\r\n} from \"./TelemetryTypes\";\r\nimport DefaultEvent from \"./DefaultEvent\";\r\n\r\n// for use in cache events\r\nconst MSAL_CACHE_EVENT_VALUE_PREFIX = \"msal.token\";\r\nconst MSAL_CACHE_EVENT_NAME = \"msal.cache_event\";\r\n\r\nconst createEventKey = (event: TelemetryEvent): string => (\r\n    `${event.telemetryCorrelationId}-${event.eventId}-${event.eventName}`\r\n);\r\n\r\nexport default class TelemetryManager {\r\n\r\n    // correlation Id to list of events\r\n    private completedEvents: CompletedEvents = {};\r\n    // event key to event\r\n    private inProgressEvents: InProgressEvents = {};\r\n    // correlation id to map of eventname to count\r\n    private eventCountByCorrelationId: EventCountByCorrelationId = {};\r\n\r\n    //Implement after API EVENT\r\n    private onlySendFailureTelemetry: boolean = false;\r\n    private telemetryPlatform: TelemetryPlatform;\r\n    private clientId: string;\r\n    private telemetryEmitter: TelemetryEmitter;\r\n\r\n    constructor(config: TelemetryConfig, telemetryEmitter: TelemetryEmitter) {\r\n        // TODO THROW if bad options\r\n        this.telemetryPlatform = config.platform;\r\n        this.clientId = config.clientId;\r\n        this.onlySendFailureTelemetry = config.onlySendFailureTelemetry;\r\n        // TODO, when i get to wiring this through, think about what it means if\r\n        // a developer does not implement telem at all, we still instrument, but telemetryEmitter can be\r\n        // optional?\r\n        this.telemetryEmitter = telemetryEmitter;\r\n    }\r\n\r\n    startEvent(event: TelemetryEvent) {\r\n        if (!this.telemetryEmitter) {\r\n            return;\r\n        }\r\n        const eventKey = createEventKey(event);\r\n        this.inProgressEvents[eventKey] = event;\r\n    }\r\n\r\n    stopEvent(event: TelemetryEvent) {\r\n        const eventKey = createEventKey(event);\r\n        if (!this.telemetryEmitter || !this.inProgressEvents[eventKey]) {\r\n            return;\r\n        }\r\n        event.stop();\r\n        this.incrementEventCount(event);\r\n\r\n        const completedEvents = this.completedEvents[event.telemetryCorrelationId];\r\n\r\n        this.completedEvents[event.telemetryCorrelationId] = [...(completedEvents || []), event];\r\n\r\n        delete this.inProgressEvents[eventKey];\r\n    }\r\n\r\n    flush(correlationId: string): void {\r\n\r\n        // If there is only unfinished events should this still return them?\r\n        if (!this.telemetryEmitter || !this.completedEvents[correlationId]) {\r\n            return;\r\n        }\r\n\r\n        const orphanedEvents = this.getOrphanedEvents(correlationId);\r\n        orphanedEvents.forEach(event => this.incrementEventCount(event));\r\n        const eventsToFlush: Array<TelemetryEvent> = [\r\n            ...this.completedEvents[correlationId],\r\n            ...orphanedEvents\r\n        ];\r\n\r\n        delete this.completedEvents[correlationId];\r\n        const eventCountsToFlush: EventCount = this.eventCountByCorrelationId[correlationId];\r\n\r\n        delete this.eventCountByCorrelationId[correlationId];\r\n        // TODO add funcitonality for onlyFlushFailures after implementing api event? ??\r\n\r\n        if (!eventsToFlush || !eventsToFlush.length) {\r\n            return;\r\n        }\r\n\r\n        const defaultEvent: DefaultEvent = new DefaultEvent(\r\n            this.telemetryPlatform,\r\n            correlationId,\r\n            this.clientId,\r\n            eventCountsToFlush\r\n        );\r\n\r\n        const eventsWithDefaultEvent = [ ...eventsToFlush, defaultEvent ];\r\n\r\n        this.telemetryEmitter(eventsWithDefaultEvent.map(e => e.get()));\r\n    }\r\n\r\n    private incrementEventCount(event: TelemetryEvent): void {\r\n        // TODO, name cache event different?\r\n        // if type is cache event, change name\r\n        const eventName = event.eventName;\r\n        const eventCount = this.eventCountByCorrelationId[event.telemetryCorrelationId];\r\n        if (!eventCount) {\r\n            this.eventCountByCorrelationId[event.telemetryCorrelationId] = {\r\n                [eventName]: 1\r\n            };\r\n        } else {\r\n            eventCount[eventName] = eventCount[eventName] ? eventCount[eventName] + 1 : 1;\r\n        }\r\n    }\r\n\r\n    private getOrphanedEvents(correlationId: string): Array<TelemetryEvent> {\r\n        return Object.keys(this.inProgressEvents)\r\n            .reduce((memo, eventKey) => {\r\n                if (eventKey.indexOf(correlationId) !== -1) {\r\n                    const event = this.inProgressEvents[eventKey];\r\n                    delete this.inProgressEvents[eventKey];\r\n                    return [...memo, event];\r\n                }\r\n                return memo;\r\n            }, []);\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { AccessTokenCacheItem } from \"./AccessTokenCacheItem\";\r\nimport { AccessTokenKey } from \"./AccessTokenKey\";\r\nimport { AccessTokenValue } from \"./AccessTokenValue\";\r\nimport { ServerRequestParameters } from \"./ServerRequestParameters\";\r\nimport { Authority } from \"./Authority\";\r\nimport { ClientInfo } from \"./ClientInfo\";\r\nimport { Constants, SSOTypes, PromptState, BlacklistedEQParams, InteractionType, libraryVersion } from \"./utils/Constants\";\r\nimport { IdToken } from \"./IdToken\";\r\nimport { Logger } from \"./Logger\";\r\nimport { Storage } from \"./Storage\";\r\nimport { Account } from \"./Account\";\r\nimport { ScopeSet } from \"./ScopeSet\";\r\nimport { StringUtils } from \"./utils/StringUtils\";\r\nimport { CryptoUtils } from \"./utils/CryptoUtils\";\r\nimport { TokenUtils } from \"./utils/TokenUtils\";\r\nimport { TimeUtils } from \"./utils/TimeUtils\";\r\nimport { UrlUtils } from \"./utils/UrlUtils\";\r\nimport { ResponseUtils } from \"./utils/ResponseUtils\";\r\nimport { AuthorityFactory } from \"./AuthorityFactory\";\r\nimport { Configuration, buildConfiguration, TelemetryOptions } from \"./Configuration\";\r\nimport { AuthenticationParameters, validateClaimsRequest } from \"./AuthenticationParameters\";\r\nimport { ClientConfigurationError } from \"./error/ClientConfigurationError\";\r\nimport { AuthError } from \"./error/AuthError\";\r\nimport { ClientAuthError, ClientAuthErrorMessage } from \"./error/ClientAuthError\";\r\nimport { ServerError } from \"./error/ServerError\";\r\nimport { InteractionRequiredAuthError } from \"./error/InteractionRequiredAuthError\";\r\nimport { AuthResponse, buildResponseStateOnly } from \"./AuthResponse\";\r\nimport TelemetryManager from \"./telemetry/TelemetryManager\";\r\nimport { TelemetryPlatform, TelemetryConfig } from './telemetry/TelemetryTypes';\r\n\r\n\r\n // default authority\r\nconst DEFAULT_AUTHORITY = \"https://login.microsoftonline.com/common\";\r\n\r\n/**\r\n * Interface to handle iFrame generation, Popup Window creation and redirect handling\r\n */\r\ndeclare global {\r\n    interface Window {\r\n        msal: Object;\r\n        CustomEvent: CustomEvent;\r\n        Event: Event;\r\n        activeRenewals: {};\r\n        renewStates: Array<string>;\r\n        callbackMappedToRenewStates : {};\r\n        promiseMappedToRenewStates: {};\r\n        openedWindows: Array<Window>;\r\n        requestType: string;\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n * @ignore\r\n * response_type from OpenIDConnect\r\n * References: https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html & https://tools.ietf.org/html/rfc6749#section-4.2.1\r\n * Since we support only implicit flow in this library, we restrict the response_type support to only 'token' and 'id_token'\r\n *\r\n */\r\nconst ResponseTypes = {\r\n  id_token: \"id_token\",\r\n  token: \"token\",\r\n  id_token_token: \"id_token token\"\r\n};\r\n\r\n/**\r\n * @hidden\r\n * @ignore\r\n */\r\nexport interface CacheResult {\r\n  errorDesc: string;\r\n  token: string;\r\n  error: string;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * @ignore\r\n * Data type to hold information about state returned from the server\r\n */\r\nexport type ResponseStateInfo = {\r\n  state: string;\r\n  stateMatch: boolean;\r\n  requestType: string;\r\n};\r\n\r\n/**\r\n * A type alias for an authResponseCallback function.\r\n * {@link (authResponseCallback:type)}\r\n * @param authErr error created for failure cases\r\n * @param response response containing token strings in success cases, or just state value in error cases\r\n */\r\nexport type authResponseCallback = (authErr: AuthError, response?: AuthResponse) => void;\r\n\r\n/**\r\n * A type alias for a tokenReceivedCallback function.\r\n * {@link (tokenReceivedCallback:type)}\r\n * @returns response of type {@link (AuthResponse:type)}\r\n * The function that will get the call back once this API is completed (either successfully or with a failure).\r\n */\r\nexport type tokenReceivedCallback = (response: AuthResponse) => void;\r\n\r\n/**\r\n * A type alias for a errorReceivedCallback function.\r\n * {@link (errorReceivedCallback:type)}\r\n * @returns response of type {@link (AuthError:class)}\r\n * @returns {string} account state\r\n */\r\nexport type errorReceivedCallback = (authErr: AuthError, accountState: string) => void;\r\n\r\n/**\r\n * @hidden\r\n * @ignore\r\n * A wrapper to handle the token response/error within the iFrame always\r\n *\r\n * @param target\r\n * @param propertyKey\r\n * @param descriptor\r\n */\r\nconst resolveTokenOnlyIfOutOfIframe = (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {\r\n  const tokenAcquisitionMethod = descriptor.value;\r\n  descriptor.value = function (...args: any[]) {\r\n      return this.isInIframe()\r\n          ? new Promise(() => {\r\n            return;\r\n          })\r\n          : tokenAcquisitionMethod.apply(this, args);\r\n  };\r\n  return descriptor;\r\n};\r\n\r\n/**\r\n * UserAgentApplication class\r\n *\r\n * Object Instance that the developer can use to make loginXX OR acquireTokenXX functions\r\n */\r\nexport class UserAgentApplication {\r\n\r\n  // input Configuration by the developer/user\r\n  private config: Configuration;\r\n\r\n  // callbacks for token/error\r\n  private authResponseCallback: authResponseCallback = null;\r\n  private tokenReceivedCallback: tokenReceivedCallback = null;\r\n  private errorReceivedCallback: errorReceivedCallback = null;\r\n\r\n  // Added for readability as these params are very frequently used\r\n  private logger: Logger;\r\n  private clientId: string;\r\n  private inCookie: boolean;\r\n  private telemetryManager: TelemetryManager;\r\n\r\n  // Cache and Account info referred across token grant flow\r\n  protected cacheStorage: Storage;\r\n  private account: Account;\r\n\r\n  // state variables\r\n  private loginInProgress: boolean;\r\n  private acquireTokenInProgress: boolean;\r\n  private silentAuthenticationState: string;\r\n  private silentLogin: boolean;\r\n  private redirectCallbacksSet: boolean;\r\n\r\n  // Authority Functionality\r\n  protected authorityInstance: Authority;\r\n\r\n  /**\r\n   * setter for the authority URL\r\n   * @param {string} authority\r\n   */\r\n  // If the developer passes an authority, create an instance\r\n  public set authority(val) {\r\n    this.authorityInstance = AuthorityFactory.CreateInstance(val, this.config.auth.validateAuthority);\r\n  }\r\n\r\n  /**\r\n   * Method to manage the authority URL.\r\n   *\r\n   * @returns {string} authority\r\n   */\r\n  public get authority(): string {\r\n    return this.authorityInstance.CanonicalAuthority;\r\n  }\r\n\r\n  /**\r\n   * Get the current authority instance from the MSAL configuration object\r\n   *\r\n   * @returns {@link Authority} authority instance\r\n   */\r\n  public getAuthorityInstance(): Authority {\r\n    return this.authorityInstance;\r\n  }\r\n\r\n  /**\r\n   * @constructor\r\n   * Constructor for the UserAgentApplication used to instantiate the UserAgentApplication object\r\n   *\r\n   * Important attributes in the Configuration object for auth are:\r\n   * - clientID: the application ID of your application.\r\n   * You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview\r\n   * - authority: the authority URL for your application.\r\n   *\r\n   * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.\r\n   * It is of the form https://login.microsoftonline.com/&lt;Enter_the_Tenant_Info_Here&gt;.\r\n   * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n   * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n   * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n   *\r\n   *\r\n   * In Azure B2C, authority is of the form https://&lt;instance&gt;/tfp/&lt;tenant&gt;/&lt;policyName&gt;/\r\n\r\n   * @param {@link (Configuration:type)} configuration object for the MSAL UserAgentApplication instance\r\n   */\r\n  constructor(configuration: Configuration) {\r\n\r\n    // Set the Configuration\r\n    this.config = buildConfiguration(configuration);\r\n\r\n    // Set the callback boolean\r\n    this.redirectCallbacksSet = false;\r\n\r\n    this.logger = this.config.system.logger;\r\n    this.clientId = this.config.auth.clientId;\r\n    this.inCookie = this.config.cache.storeAuthStateInCookie;\r\n\r\n    this.telemetryManager = this.getTelemetryManagerFromConfig(this.config.system.telemetry, this.clientId);\r\n\r\n    // if no authority is passed, set the default: \"https://login.microsoftonline.com/common\"\r\n    this.authority = this.config.auth.authority || DEFAULT_AUTHORITY;\r\n\r\n    // track login and acquireToken in progress\r\n    this.loginInProgress = false;\r\n    this.acquireTokenInProgress = false;\r\n\r\n    // cache keys msal - typescript throws an error if any value other than \"localStorage\" or \"sessionStorage\" is passed\r\n    try {\r\n      this.cacheStorage = new Storage(this.config.cache.cacheLocation);\r\n    } catch (e) {\r\n        throw ClientConfigurationError.createInvalidCacheLocationConfigError(this.config.cache.cacheLocation);\r\n    }\r\n\r\n    // Initialize window handling code\r\n    window.openedWindows = [];\r\n    window.activeRenewals = {};\r\n    window.renewStates = [];\r\n    window.callbackMappedToRenewStates = { };\r\n    window.promiseMappedToRenewStates = { };\r\n    window.msal = this;\r\n\r\n    const urlHash = window.location.hash;\r\n    const urlContainsHash = this.urlContainsHash(urlHash);\r\n\r\n    // On the server 302 - Redirect, handle this\r\n    if (!this.config.framework.isAngular) {\r\n      if (urlContainsHash) {\r\n        this.handleAuthenticationResponse(urlHash);\r\n      }\r\n    }\r\n  }\r\n\r\n  //#region Redirect Callbacks\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   * Set the callback functions for the redirect flow to send back the success or error object.\r\n   * @param {@link (tokenReceivedCallback:type)} successCallback - Callback which contains the AuthResponse object, containing data from the server.\r\n   * @param {@link (errorReceivedCallback:type)} errorCallback - Callback which contains a AuthError object, containing error data from either the server\r\n   * or the library, depending on the origin of the error.\r\n   */\r\n  handleRedirectCallback(tokenReceivedCallback: tokenReceivedCallback, errorReceivedCallback: errorReceivedCallback): void;\r\n  handleRedirectCallback(authCallback: authResponseCallback): void;\r\n  handleRedirectCallback(authOrTokenCallback: authResponseCallback | tokenReceivedCallback, errorReceivedCallback?: errorReceivedCallback): void {\r\n    if (!authOrTokenCallback) {\r\n      this.redirectCallbacksSet = false;\r\n      throw ClientConfigurationError.createInvalidCallbackObjectError(authOrTokenCallback);\r\n    }\r\n\r\n    // Set callbacks\r\n    if (errorReceivedCallback) {\r\n      this.tokenReceivedCallback = authOrTokenCallback as tokenReceivedCallback;\r\n      this.errorReceivedCallback = errorReceivedCallback;\r\n      this.logger.warning(\"This overload for callback is deprecated - please change the format of the callbacks to a single callback as shown: (err: AuthError, response: AuthResponse).\");\r\n    } else {\r\n      this.authResponseCallback = authOrTokenCallback as authResponseCallback;\r\n    }\r\n\r\n    this.redirectCallbacksSet = true;\r\n\r\n    // On the server 302 - Redirect, handle this\r\n    if (!this.config.framework.isAngular) {\r\n      const cachedHash = this.cacheStorage.getItem(Constants.urlHash);\r\n      if (cachedHash) {\r\n        this.processCallBack(cachedHash, null);\r\n      }\r\n    }\r\n  }\r\n\r\n  private authResponseHandler(interactionType: InteractionType, response: AuthResponse, resolve?: any) : void {\r\n    if (interactionType === Constants.interactionTypeRedirect) {\r\n      if (this.errorReceivedCallback) {\r\n        this.tokenReceivedCallback(response);\r\n      } else if (this.authResponseCallback) {\r\n        this.authResponseCallback(null, response);\r\n      }\r\n    } else if (interactionType === Constants.interactionTypePopup) {\r\n      resolve(response);\r\n    } else {\r\n      throw ClientAuthError.createInvalidInteractionTypeError();\r\n    }\r\n  }\r\n\r\n  private authErrorHandler(interactionType: InteractionType, authErr: AuthError, response: AuthResponse, reject?: any) : void {\r\n    if (interactionType === Constants.interactionTypeRedirect) {\r\n      if (this.errorReceivedCallback) {\r\n        this.errorReceivedCallback(authErr, response.accountState);\r\n      } else {\r\n        this.authResponseCallback(authErr, response);\r\n      }\r\n    } else if (interactionType === Constants.interactionTypePopup) {\r\n      reject(authErr);\r\n    } else {\r\n      throw ClientAuthError.createInvalidInteractionTypeError();\r\n    }\r\n  }\r\n\r\n  //#endregion\r\n  /**\r\n   * Use when initiating the login process by redirecting the user's browser to the authorization endpoint.\r\n   * @param {@link (AuthenticationParameters:type)}\r\n   */\r\n  loginRedirect(request?: AuthenticationParameters): void {\r\n    // Throw error if callbacks are not set before redirect\r\n    if (!this.redirectCallbacksSet) {\r\n      throw ClientConfigurationError.createRedirectCallbacksNotSetError();\r\n    }\r\n    this.acquireTokenInteractive(Constants.interactionTypeRedirect, true, request);\r\n  }\r\n\r\n  /**\r\n   * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint.\r\n   * @param {@link (AuthenticationParameters:type)}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   */\r\n  acquireTokenRedirect(request: AuthenticationParameters): void {\r\n    if (!request) {\r\n      throw ClientConfigurationError.createEmptyRequestError();\r\n    }\r\n\r\n    // Throw error if callbacks are not set before redirect\r\n    if (!this.redirectCallbacksSet) {\r\n      throw ClientConfigurationError.createRedirectCallbacksNotSetError();\r\n    }\r\n    this.acquireTokenInteractive(Constants.interactionTypeRedirect, false, request);\r\n  }\r\n\r\n  /**\r\n   * Use when initiating the login process via opening a popup window in the user's browser\r\n   *\r\n   * @param {@link (AuthenticationParameters:type)}\r\n   *\r\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n   */\r\n  loginPopup(request?: AuthenticationParameters): Promise<AuthResponse> {\r\n    return new Promise<AuthResponse>((resolve, reject) => {\r\n      this.acquireTokenInteractive(Constants.interactionTypePopup, true, request, resolve, reject);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser\r\n   * @param {@link AuthenticationParameters}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n   */\r\n  acquireTokenPopup(request: AuthenticationParameters): Promise<AuthResponse> {\r\n    if (!request) {\r\n      throw ClientConfigurationError.createEmptyRequestError();\r\n    }\r\n\r\n    return new Promise<AuthResponse>((resolve, reject) => {\r\n      this.acquireTokenInteractive(Constants.interactionTypePopup, false, request, resolve, reject);\r\n    });\r\n  }\r\n\r\n  //#region Acquire Token\r\n\r\n  /**\r\n   * Use when initiating the login process or when you want to obtain an access_token for your API,\r\n   * either by redirecting the user's browser window to the authorization endpoint or via opening a popup window in the user's browser.\r\n   * @param {@link (AuthenticationParameters:type)}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   */\r\n  private acquireTokenInteractive(interactionType: InteractionType, isLoginCall: boolean, request?: AuthenticationParameters, resolve?: any, reject?: any): void {\r\n\r\n    // If already in progress, do not proceed\r\n    if (this.loginInProgress || this.acquireTokenInProgress) {\r\n      const thrownError = this.loginInProgress ? ClientAuthError.createLoginInProgressError() : ClientAuthError.createAcquireTokenInProgressError();\r\n      const stateOnlyResponse = buildResponseStateOnly(this.getAccountState(request && request.state));\r\n      this.authErrorHandler(interactionType,\r\n        thrownError,\r\n        stateOnlyResponse,\r\n        reject);\r\n      return;\r\n    }\r\n\r\n    // if extraScopesToConsent is passed in loginCall, append them to the login request\r\n    const scopes: Array<string> = isLoginCall ? this.appendScopes(request) : request.scopes;\r\n\r\n    // Validate and filter scopes (the validate function will throw if validation fails)\r\n    this.validateInputScope(scopes, !isLoginCall);\r\n\r\n    // Get the account object if a session exists\r\n    const account: Account = (request && request.account && !isLoginCall) ? request.account : this.getAccount();\r\n\r\n    // If no session exists, prompt the user to login.\r\n    if (!account && !ServerRequestParameters.isSSOParam(request)) {\r\n      if (isLoginCall) {\r\n        // extract ADAL id_token if exists\r\n        let adalIdToken = this.extractADALIdToken();\r\n\r\n        // silent login if ADAL id_token is retrieved successfully - SSO\r\n        if (adalIdToken && !scopes) {\r\n          this.logger.info(\"ADAL's idToken exists. Extracting login information from ADAL's idToken \");\r\n          let tokenRequest: AuthenticationParameters = this.buildIDTokenRequest(request);\r\n\r\n          this.silentLogin = true;\r\n          this.acquireTokenSilent(tokenRequest).then(response => {\r\n            this.silentLogin = false;\r\n            this.logger.info(\"Unified cache call is successful\");\r\n\r\n            this.authResponseHandler(interactionType, response, resolve);\r\n            return;\r\n          }, (error) => {\r\n            this.silentLogin = false;\r\n            this.logger.error(\"Error occurred during unified cache ATS: \" + error);\r\n\r\n            // proceed to login since ATS failed\r\n            this.acquireTokenHelper(null, interactionType, isLoginCall, request, scopes, resolve, reject);\r\n          });\r\n        }\r\n        // No ADAL token found, proceed to login\r\n        else {\r\n          this.acquireTokenHelper(null, interactionType, isLoginCall, request, scopes, resolve, reject);\r\n        }\r\n      }\r\n      // AcquireToken call, but no account or context given, so throw error\r\n      else {\r\n        this.logger.info(\"User login is required\");\r\n        throw ClientAuthError.createUserLoginRequiredError();\r\n      }\r\n    }\r\n    // User session exists\r\n    else {\r\n      this.acquireTokenHelper(account, interactionType, isLoginCall, request, scopes, resolve, reject);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   * Helper function to acquireToken\r\n   *\r\n   */\r\n  private acquireTokenHelper(account: Account, interactionType: InteractionType, isLoginCall: boolean, request?: AuthenticationParameters, scopes?: Array<string>, resolve?: any, reject?: any): void {\r\n    // Track the acquireToken progress\r\n    if (isLoginCall) {\r\n      this.loginInProgress = true;\r\n    } else {\r\n      this.acquireTokenInProgress = true;\r\n    }\r\n\r\n    const scope = scopes ? scopes.join(\" \").toLowerCase() : this.clientId.toLowerCase();\r\n\r\n    let serverAuthenticationRequest: ServerRequestParameters;\r\n    const acquireTokenAuthority = (!isLoginCall && request && request.authority) ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority) : this.authorityInstance;\r\n\r\n    let popUpWindow: Window;\r\n    if (interactionType === Constants.interactionTypePopup) {\r\n      // Generate a popup window\r\n      popUpWindow = this.openWindow(\"about:blank\", \"_blank\", 1, this, resolve, reject);\r\n      if (!popUpWindow) {\r\n        // We pass reject in openWindow, we reject there during an error\r\n        return;\r\n      }\r\n    }\r\n\r\n    acquireTokenAuthority.resolveEndpointsAsync().then(() => {\r\n      // On Fulfillment\r\n      const responseType: string = isLoginCall ? ResponseTypes.id_token : this.getTokenType(account, scopes, false);\r\n      let loginStartPage: string;\r\n\r\n      if (isLoginCall) {\r\n        // if the user sets the login start page - angular only??\r\n        loginStartPage = this.cacheStorage.getItem(Constants.angularLoginRequest);\r\n        if (!loginStartPage || loginStartPage === \"\") {\r\n          loginStartPage = window.location.href;\r\n        } else {\r\n          this.cacheStorage.setItem(Constants.angularLoginRequest, \"\");\r\n        }\r\n      }\r\n\r\n      serverAuthenticationRequest = new ServerRequestParameters(\r\n        acquireTokenAuthority,\r\n        this.clientId,\r\n        scopes,\r\n        responseType,\r\n        this.getRedirectUri(),\r\n        request && request.state\r\n      );\r\n\r\n      this.updateCacheEntries(serverAuthenticationRequest, account, loginStartPage);\r\n\r\n      // populate QueryParameters (sid/login_hint/domain_hint) and any other extraQueryParameters set by the developer\r\n      serverAuthenticationRequest.populateQueryParams(account, request);\r\n\r\n      // Construct urlNavigate\r\n      let urlNavigate = UrlUtils.createNavigateUrl(serverAuthenticationRequest) + Constants.response_mode_fragment;\r\n\r\n      // set state in cache\r\n      if (interactionType === Constants.interactionTypeRedirect) {\r\n        if (!isLoginCall) {\r\n          this.cacheStorage.setItem(Constants.stateAcquireToken, serverAuthenticationRequest.state, this.inCookie);\r\n        }\r\n      } else if (interactionType === Constants.interactionTypePopup) {\r\n        window.renewStates.push(serverAuthenticationRequest.state);\r\n        window.requestType = isLoginCall ? Constants.login : Constants.renewToken;\r\n\r\n        // Register callback to capture results from server\r\n        this.registerCallback(serverAuthenticationRequest.state, scope, resolve, reject);\r\n      } else {\r\n        throw ClientAuthError.createInvalidInteractionTypeError();\r\n      }\r\n\r\n      // prompt user for interaction\r\n      this.navigateWindow(urlNavigate, popUpWindow);\r\n    }).catch((err) => {\r\n      this.logger.warning(\"could not resolve endpoints\");\r\n      this.authErrorHandler(interactionType, ClientAuthError.createEndpointResolutionError(err.toString), buildResponseStateOnly(request.state), reject);\r\n      if (popUpWindow) {\r\n        popUpWindow.close();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Use this function to obtain a token before every call to the API / resource provider\r\n   *\r\n   * MSAL return's a cached token when available\r\n   * Or it send's a request to the STS to obtain a new token using a hidden iframe.\r\n   *\r\n   * @param {@link AuthenticationParameters}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   * @returns {Promise.<AuthResponse>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object\r\n   *\r\n   */\r\n  @resolveTokenOnlyIfOutOfIframe\r\n  acquireTokenSilent(request: AuthenticationParameters): Promise<AuthResponse> {\r\n    if (!request) {\r\n      throw ClientConfigurationError.createEmptyRequestError();\r\n    }\r\n    return new Promise<AuthResponse>((resolve, reject) => {\r\n\r\n      // Validate and filter scopes (the validate function will throw if validation fails)\r\n      this.validateInputScope(request.scopes, true);\r\n\r\n      const scope = request.scopes.join(\" \").toLowerCase();\r\n\r\n      // if the developer passes an account, give that account the priority\r\n      const account: Account = request.account || this.getAccount();\r\n\r\n      // extract if there is an adalIdToken stashed in the cache\r\n      const adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken);\r\n\r\n      //if there is no account logged in and no login_hint/sid is passed in the request\r\n      if (!account && !(request.sid  || request.loginHint) && StringUtils.isEmpty(adalIdToken) ) {\r\n        this.logger.info(\"User login is required\");\r\n        return reject(ClientAuthError.createUserLoginRequiredError());\r\n      }\r\n\r\n      const responseType = this.getTokenType(account, request.scopes, true);\r\n\r\n      let serverAuthenticationRequest = new ServerRequestParameters(\r\n        AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority),\r\n        this.clientId,\r\n        request.scopes,\r\n        responseType,\r\n        this.getRedirectUri(),\r\n        request && request.state\r\n      );\r\n      // populate QueryParameters (sid/login_hint/domain_hint) and any other extraQueryParameters set by the developer\r\n      if (ServerRequestParameters.isSSOParam(request) || account) {\r\n        serverAuthenticationRequest.populateQueryParams(account, request);\r\n      }\r\n      //if user didn't pass login_hint/sid and adal's idtoken is present, extract the login_hint from the adalIdToken\r\n      else if (!account && !StringUtils.isEmpty(adalIdToken)) {\r\n        // if adalIdToken exists, extract the SSO info from the same\r\n        const adalIdTokenObject = TokenUtils.extractIdToken(adalIdToken);\r\n        this.logger.verbose(\"ADAL's idToken exists. Extracting login information from ADAL's idToken \");\r\n        serverAuthenticationRequest.populateQueryParams(account, null, adalIdTokenObject);\r\n      }\r\n      const userContainedClaims = request.claimsRequest || serverAuthenticationRequest.claimsValue;\r\n\r\n      let authErr: AuthError;\r\n      let cacheResultResponse;\r\n\r\n      if (!userContainedClaims && !request.forceRefresh) {\r\n        try {\r\n          cacheResultResponse = this.getCachedToken(serverAuthenticationRequest, account);\r\n        } catch (e) {\r\n          authErr = e;\r\n        }\r\n      }\r\n\r\n      // resolve/reject based on cacheResult\r\n      if (cacheResultResponse) {\r\n        this.logger.info(\"Token is already in cache for scope:\" + scope);\r\n        resolve(cacheResultResponse);\r\n        return null;\r\n      }\r\n      else if (authErr) {\r\n        this.logger.infoPii(authErr.errorCode + \":\" + authErr.errorMessage);\r\n        reject(authErr);\r\n        return null;\r\n      }\r\n      // else proceed with login\r\n      else {\r\n        let logMessage;\r\n        if (userContainedClaims) {\r\n          logMessage = \"Skipped cache lookup since claims were given.\";\r\n        } else if (request.forceRefresh) {\r\n          logMessage = \"Skipped cache lookup since request.forceRefresh option was set to true\";\r\n        } else {\r\n          logMessage = \"Token is not in cache for scope:\" + scope;\r\n        }\r\n        this.logger.verbose(logMessage);\r\n\r\n        // Cache result can return null if cache is empty. In that case, set authority to default value if no authority is passed to the api.\r\n        if (!serverAuthenticationRequest.authorityInstance) {\r\n            serverAuthenticationRequest.authorityInstance = request.authority ? AuthorityFactory.CreateInstance(request.authority, this.config.auth.validateAuthority) : this.authorityInstance;\r\n        }\r\n        // cache miss\r\n        return serverAuthenticationRequest.authorityInstance.resolveEndpointsAsync()\r\n        .then(() => {\r\n          // refresh attempt with iframe\r\n          // Already renewing for this scope, callback when we get the token.\r\n          if (window.activeRenewals[scope]) {\r\n            this.logger.verbose(\"Renew token for scope: \" + scope + \" is in progress. Registering callback\");\r\n            // Active renewals contains the state for each renewal.\r\n            this.registerCallback(window.activeRenewals[scope], scope, resolve, reject);\r\n          }\r\n          else {\r\n            if (request.scopes && request.scopes.indexOf(this.clientId) > -1 && request.scopes.length === 1) {\r\n              // App uses idToken to send to api endpoints\r\n              // Default scope is tracked as clientId to store this token\r\n              this.logger.verbose(\"renewing idToken\");\r\n              this.silentLogin = true;\r\n              this.renewIdToken(request.scopes, resolve, reject, account, serverAuthenticationRequest);\r\n            } else {\r\n              // renew access token\r\n              this.logger.verbose(\"renewing accesstoken\");\r\n              this.renewToken(request.scopes, resolve, reject, account, serverAuthenticationRequest);\r\n            }\r\n          }\r\n        }).catch((err) => {\r\n          this.logger.warning(\"could not resolve endpoints\");\r\n          reject(ClientAuthError.createEndpointResolutionError(err.toString()));\r\n          return null;\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region Popup Window Creation\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Used to send the user to the redirect_uri after authentication is complete. The user's bearer token is attached to the URI fragment as an id_token/access_token field.\r\n   * This function also closes the popup window after redirection.\r\n   *\r\n   * @param urlNavigate\r\n   * @param title\r\n   * @param interval\r\n   * @param instance\r\n   * @param resolve\r\n   * @param reject\r\n   * @ignore\r\n   */\r\n  private openWindow(urlNavigate: string, title: string, interval: number, instance: this, resolve?: Function, reject?: Function): Window {\r\n    // Generate a popup window\r\n    var popupWindow: Window;\r\n    try {\r\n      popupWindow = this.openPopup(urlNavigate, title, Constants.popUpWidth, Constants.popUpHeight);\r\n    } catch (e) {\r\n      instance.loginInProgress = false;\r\n      instance.acquireTokenInProgress = false;\r\n\r\n      this.logger.info(ClientAuthErrorMessage.popUpWindowError.code + \":\" + ClientAuthErrorMessage.popUpWindowError.desc);\r\n      this.cacheStorage.setItem(Constants.msalError, ClientAuthErrorMessage.popUpWindowError.code);\r\n      this.cacheStorage.setItem(Constants.msalErrorDescription, ClientAuthErrorMessage.popUpWindowError.desc);\r\n      if (reject) {\r\n        reject(ClientAuthError.createPopupWindowError());\r\n      }\r\n      return null;\r\n    }\r\n\r\n    // Push popup window handle onto stack for tracking\r\n    window.openedWindows.push(popupWindow);\r\n\r\n    const pollTimer = window.setInterval(() => {\r\n      // If popup closed or login in progress, cancel login\r\n      if (popupWindow && popupWindow.closed && (instance.loginInProgress || instance.acquireTokenInProgress)) {\r\n        if (reject) {\r\n          reject(ClientAuthError.createUserCancelledError());\r\n        }\r\n        window.clearInterval(pollTimer);\r\n        if (this.config.framework.isAngular) {\r\n            this.broadcast(\"msal:popUpClosed\", ClientAuthErrorMessage.userCancelledError.code + Constants.resourceDelimiter + ClientAuthErrorMessage.userCancelledError.desc);\r\n            return;\r\n        }\r\n        instance.loginInProgress = false;\r\n        instance.acquireTokenInProgress = false;\r\n      }\r\n\r\n      try {\r\n        const popUpWindowLocation = popupWindow.location;\r\n\r\n        // If the popup hash changes, close the popup window\r\n        if (popUpWindowLocation.href.indexOf(this.getRedirectUri()) !== -1) {\r\n          window.clearInterval(pollTimer);\r\n          instance.loginInProgress = false;\r\n          instance.acquireTokenInProgress = false;\r\n          this.logger.info(\"Closing popup window\");\r\n          // TODO: Check how this can be extracted for any framework specific code?\r\n          if (this.config.framework.isAngular) {\r\n              this.broadcast(\"msal:popUpHashChanged\", popUpWindowLocation.hash);\r\n              for (let i = 0; i < window.openedWindows.length; i++) {\r\n                  window.openedWindows[i].close();\r\n              }\r\n          }\r\n        }\r\n      } catch (e) {\r\n        // Cross Domain url check error.\r\n        // Will be thrown until AAD redirects the user back to the app\"s root page with the token.\r\n        // No need to log or throw this error as it will create unnecessary traffic.\r\n      }\r\n    },\r\n    interval);\r\n\r\n    return popupWindow;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Configures popup window for login.\r\n   *\r\n   * @param urlNavigate\r\n   * @param title\r\n   * @param popUpWidth\r\n   * @param popUpHeight\r\n   * @ignore\r\n   * @hidden\r\n   */\r\n  private openPopup(urlNavigate: string, title: string, popUpWidth: number, popUpHeight: number) {\r\n    try {\r\n      /**\r\n       * adding winLeft and winTop to account for dual monitor\r\n       * using screenLeft and screenTop for IE8 and earlier\r\n       */\r\n      const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\r\n      const winTop = window.screenTop ? window.screenTop : window.screenY;\r\n      /**\r\n       * window.innerWidth displays browser window\"s height and width excluding toolbars\r\n       * using document.documentElement.clientWidth for IE8 and earlier\r\n       */\r\n      const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\r\n      const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\r\n      const left = ((width / 2) - (popUpWidth / 2)) + winLeft;\r\n      const top = ((height / 2) - (popUpHeight / 2)) + winTop;\r\n\r\n      // open the window\r\n      const popupWindow = window.open(urlNavigate, title, \"width=\" + popUpWidth + \", height=\" + popUpHeight + \", top=\" + top + \", left=\" + left);\r\n      if (!popupWindow) {\r\n        throw ClientAuthError.createPopupWindowError();\r\n      }\r\n      if (popupWindow.focus) {\r\n        popupWindow.focus();\r\n      }\r\n\r\n      return popupWindow;\r\n    } catch (e) {\r\n      this.logger.error(\"error opening popup \" + e.message);\r\n      this.loginInProgress = false;\r\n      this.acquireTokenInProgress = false;\r\n      throw ClientAuthError.createPopupWindowError(e.toString());\r\n    }\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region Iframe Management\r\n\r\n  /**\r\n   * @hidden\r\n   * Returns whether current window is in ifram for token renewal\r\n   * @ignore\r\n   */\r\n  public isInIframe() {\r\n      return window.parent !== window;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Returns whether parent window exists and has msal\r\n   */\r\n  private parentIsMsal() {\r\n    return window.parent !== window && window.parent.msal;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left.\r\n   * registered when network errors occur and subsequent token requests for same resource are registered to the pending request.\r\n   * @ignore\r\n   */\r\n  private loadIframeTimeout(urlNavigate: string, frameName: string, scope: string): void {\r\n    //set iframe session to pending\r\n    const expectedState = window.activeRenewals[scope];\r\n    this.logger.verbose(\"Set loading state to pending for: \" + scope + \":\" + expectedState);\r\n    this.cacheStorage.setItem(Constants.renewStatus + expectedState, Constants.tokenRenewStatusInProgress);\r\n    this.loadFrame(urlNavigate, frameName);\r\n    setTimeout(() => {\r\n      if (this.cacheStorage.getItem(Constants.renewStatus + expectedState) === Constants.tokenRenewStatusInProgress) {\r\n        // fail the iframe session if it\"s in pending state\r\n        this.logger.verbose(\"Loading frame has timed out after: \" + (this.config.system.loadFrameTimeout / 1000) + \" seconds for scope \" + scope + \":\" + expectedState);\r\n        // Error after timeout\r\n        if (expectedState && window.callbackMappedToRenewStates[expectedState]) {\r\n          window.callbackMappedToRenewStates[expectedState](null, ClientAuthError.createTokenRenewalTimeoutError());\r\n        }\r\n\r\n        this.cacheStorage.setItem(Constants.renewStatus + expectedState, Constants.tokenRenewStatusCancelled);\r\n      }\r\n    }, this.config.system.loadFrameTimeout);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Loads iframe with authorization endpoint URL\r\n   * @ignore\r\n   */\r\n  private loadFrame(urlNavigate: string, frameName: string): void {\r\n    // This trick overcomes iframe navigation in IE\r\n    // IE does not load the page consistently in iframe\r\n    this.logger.info(\"LoadFrame: \" + frameName);\r\n    const frameCheck = frameName;\r\n\r\n    setTimeout(() => {\r\n      const frameHandle = this.addHiddenIFrame(frameCheck);\r\n      if (frameHandle.src === \"\" || frameHandle.src === \"about:blank\") {\r\n        frameHandle.src = urlNavigate;\r\n        this.logger.infoPii(\"Frame Name : \" + frameName + \" Navigated to: \" + urlNavigate);\r\n      }\r\n    },\r\n    this.config.system.navigateFrameWait);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Adds the hidden iframe for silent token renewal.\r\n   * @ignore\r\n   */\r\n  private addHiddenIFrame(iframeId: string): HTMLIFrameElement {\r\n    if (typeof iframeId === \"undefined\") {\r\n      return null;\r\n    }\r\n\r\n    this.logger.info(\"Add msal frame to document:\" + iframeId);\r\n    let adalFrame = document.getElementById(iframeId) as HTMLIFrameElement;\r\n    if (!adalFrame) {\r\n      if (document.createElement &&\r\n        document.documentElement &&\r\n        (window.navigator.userAgent.indexOf(\"MSIE 5.0\") === -1)) {\r\n        const ifr = document.createElement(\"iframe\");\r\n        ifr.setAttribute(\"id\", iframeId);\r\n        ifr.style.visibility = \"hidden\";\r\n        ifr.style.position = \"absolute\";\r\n        ifr.style.width = ifr.style.height = \"0\";\r\n        ifr.style.border = \"0\";\r\n        adalFrame = (document.getElementsByTagName(\"body\")[0].appendChild(ifr) as HTMLIFrameElement);\r\n      } else if (document.body && document.body.insertAdjacentHTML) {\r\n          document.body.insertAdjacentHTML(\"beforeend\", \"<iframe name='\" + iframeId + \"' id='\" + iframeId + \"' style='display:none'></iframe>\");\r\n      }\r\n\r\n      if (window.frames && window.frames[iframeId]) {\r\n        adalFrame = window.frames[iframeId];\r\n      }\r\n    }\r\n\r\n    return adalFrame;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region General Helpers\r\n\r\n  /**\r\n   * @hidden\r\n   * Used to redirect the browser to the STS authorization endpoint\r\n   * @param {string} urlNavigate - URL of the authorization endpoint\r\n   */\r\n  private navigateWindow(urlNavigate: string, popupWindow?: Window) {\r\n    // Navigate if valid URL\r\n    if (urlNavigate && !StringUtils.isEmpty(urlNavigate)) {\r\n      let navigateWindow: Window = popupWindow ? popupWindow : window;\r\n      let logMessage: string = popupWindow ? \"Navigated Popup window to:\" + urlNavigate : \"Navigate to:\" + urlNavigate;\r\n      this.logger.infoPii(logMessage);\r\n      navigateWindow.location.replace(urlNavigate);\r\n    }\r\n    else {\r\n      this.logger.info(\"Navigate url is empty\");\r\n      throw AuthError.createUnexpectedError(\"Navigate url is empty\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Used to add the developer requested callback to the array of callbacks for the specified scopes. The updated array is stored on the window object\r\n   * @param {string} expectedState - Unique state identifier (guid).\r\n   * @param {string} scope - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.\r\n   * @param {Function} resolve - The resolve function of the promise object.\r\n   * @param {Function} reject - The reject function of the promise object.\r\n   * @ignore\r\n   */\r\n  private registerCallback(expectedState: string, scope: string, resolve: Function, reject: Function): void {\r\n    // track active renewals\r\n    window.activeRenewals[scope] = expectedState;\r\n\r\n    // initialize callbacks mapped array\r\n    if (!window.promiseMappedToRenewStates[expectedState]) {\r\n        window.promiseMappedToRenewStates[expectedState] = [];\r\n    }\r\n    // indexing on the current state, push the callback params to callbacks mapped\r\n    window.promiseMappedToRenewStates[expectedState].push({ resolve: resolve, reject: reject });\r\n\r\n    // Store the server esponse in the current window??\r\n    if (!window.callbackMappedToRenewStates[expectedState]) {\r\n      window.callbackMappedToRenewStates[expectedState] =\r\n      (response: AuthResponse, error: AuthError) => {\r\n        // reset active renewals\r\n        window.activeRenewals[scope] = null;\r\n\r\n        // for all promiseMappedtoRenewStates for a given 'state' - call the reject/resolve with error/token respectively\r\n        for (let i = 0; i < window.promiseMappedToRenewStates[expectedState].length; ++i) {\r\n          try {\r\n            if (error) {\r\n                window.promiseMappedToRenewStates[expectedState][i].reject(error);\r\n            } else if (response) {\r\n                window.promiseMappedToRenewStates[expectedState][i].resolve(response);\r\n            } else {\r\n              throw AuthError.createUnexpectedError(\"Error and response are both null\");\r\n            }\r\n          } catch (e) {\r\n            this.logger.warning(e);\r\n          }\r\n        }\r\n\r\n        // reset\r\n        window.promiseMappedToRenewStates[expectedState] = null;\r\n        window.callbackMappedToRenewStates[expectedState] = null;\r\n      };\r\n    }\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region Logout\r\n\r\n  /**\r\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   */\r\n  logout(): void {\r\n    this.clearCache();\r\n    this.account = null;\r\n    let logout = \"\";\r\n    if (this.getPostLogoutRedirectUri()) {\r\n      logout = \"post_logout_redirect_uri=\" + encodeURIComponent(this.getPostLogoutRedirectUri());\r\n    }\r\n    this.authorityInstance.resolveEndpointsAsync().then(authority => {\r\n        const urlNavigate = authority.EndSessionEndpoint\r\n            ? `${authority.EndSessionEndpoint}?${logout}`\r\n            : `${this.authority}oauth2/v2.0/logout?${logout}`;\r\n        this.navigateWindow(urlNavigate);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Clear all access tokens in the cache.\r\n   * @ignore\r\n   */\r\n  protected clearCache(): void {\r\n    window.renewStates = [];\r\n    const accessTokenItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\r\n    for (let i = 0; i < accessTokenItems.length; i++) {\r\n      this.cacheStorage.removeItem(JSON.stringify(accessTokenItems[i].key));\r\n    }\r\n    this.cacheStorage.resetCacheItems();\r\n    this.cacheStorage.clearCookie();\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Clear a given access token from the cache.\r\n   *\r\n   * @param accessToken\r\n   */\r\n  protected clearCacheForScope(accessToken: string) {\r\n    const accessTokenItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\r\n    for (let i = 0; i < accessTokenItems.length; i++) {\r\n        let token = accessTokenItems[i];\r\n        if (token.value.accessToken === accessToken) {\r\n            this.cacheStorage.removeItem(JSON.stringify(token.key));\r\n        }\r\n    }\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region Response\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   * Checks if the redirect response is received from the STS. In case of redirect, the url fragment has either id_token, access_token or error.\r\n   * @param {string} hash - Hash passed from redirect page.\r\n   * @returns {Boolean} - true if response contains id_token, access_token or error, false otherwise.\r\n   */\r\n  isCallback(hash: string): boolean {\r\n    this.logger.info(\"isCallback will be deprecated in favor of urlContainsHash in MSAL.js v2.0.\");\r\n    return this.urlContainsHash(hash);\r\n  }\r\n\r\n  private urlContainsHash(urlString: string): boolean {\r\n    const parameters = this.deserializeHash(urlString);\r\n    return (\r\n      parameters.hasOwnProperty(Constants.errorDescription) ||\r\n      parameters.hasOwnProperty(Constants.error) ||\r\n      parameters.hasOwnProperty(Constants.accessToken) ||\r\n      parameters.hasOwnProperty(Constants.idToken)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Used to call the constructor callback with the token/error\r\n   * @param {string} [hash=window.location.hash] - Hash fragment of Url.\r\n   */\r\n  private processCallBack(hash: string, stateInfo: ResponseStateInfo, parentCallback?: Function): void {\r\n    this.logger.info(\"Processing the callback from redirect response\");\r\n    // get the state info from the hash\r\n    if (!stateInfo) {\r\n      stateInfo = this.getResponseState(hash);\r\n    }\r\n\r\n    let response : AuthResponse;\r\n    let authErr : AuthError;\r\n    // Save the token info from the hash\r\n    try {\r\n      response = this.saveTokenFromHash(hash, stateInfo);\r\n    } catch (err) {\r\n      authErr = err;\r\n    }\r\n\r\n    // remove hash from the cache\r\n    this.cacheStorage.removeItem(Constants.urlHash);\r\n\r\n    try {\r\n      // Clear the cookie in the hash\r\n      this.cacheStorage.clearCookie();\r\n      const accountState: string = this.getAccountState(stateInfo.state);\r\n      if (response) {\r\n        if ((stateInfo.requestType === Constants.renewToken) || response.accessToken) {\r\n          if (window.parent !== window) {\r\n            this.logger.verbose(\"Window is in iframe, acquiring token silently\");\r\n          } else {\r\n            this.logger.verbose(\"acquiring token interactive in progress\");\r\n          }\r\n          response.tokenType = Constants.accessToken;\r\n        }\r\n        else if (stateInfo.requestType === Constants.login) {\r\n          response.tokenType = Constants.idToken;\r\n        }\r\n        if (!parentCallback) {\r\n          this.authResponseHandler(Constants.interactionTypeRedirect, response);\r\n          return;\r\n        }\r\n      } else if (!parentCallback) {\r\n        this.authErrorHandler(Constants.interactionTypeRedirect, authErr, buildResponseStateOnly(accountState));\r\n        return;\r\n      }\r\n\r\n      parentCallback(response, authErr);\r\n    } catch (err) {\r\n      this.logger.error(\"Error occurred in token received callback function: \" + err);\r\n      throw ClientAuthError.createErrorInCallbackFunction(err.toString());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * This method must be called for processing the response received from the STS. It extracts the hash, processes the token or error information and saves it in the cache. It then\r\n   * calls the registered callbacks in case of redirect or resolves the promises with the result.\r\n   * @param {string} [hash=window.location.hash] - Hash fragment of Url.\r\n   */\r\n  private handleAuthenticationResponse(hash: string): void {\r\n    // retrieve the hash\r\n    if (hash == null) {\r\n      hash = window.location.hash;\r\n    }\r\n\r\n    let self = null;\r\n    let isPopup: boolean = false;\r\n    let isWindowOpenerMsal = false;\r\n\r\n    // Check if the current window opened the iFrame/popup\r\n    try {\r\n      isWindowOpenerMsal = window.opener && window.opener.msal && window.opener.msal !== window.msal;\r\n    } catch (err) {\r\n      // err = SecurityError: Blocked a frame with origin \"[url]\" from accessing a cross-origin frame.\r\n      isWindowOpenerMsal = false;\r\n    }\r\n\r\n    // Set the self to the window that created the popup/iframe\r\n    if (isWindowOpenerMsal) {\r\n      self = window.opener.msal;\r\n      isPopup = true;\r\n    } else if (window.parent && window.parent.msal) {\r\n      self = window.parent.msal;\r\n    }\r\n\r\n    // if (window.parent !== window), by using self, window.parent becomes equal to window in getResponseState method specifically\r\n    const stateInfo = self.getResponseState(hash);\r\n\r\n    let tokenResponseCallback: (response: AuthResponse, error: AuthError) => void = null;\r\n\r\n    self.logger.info(\"Returned from redirect url\");\r\n    // If parent window is the msal instance which opened the current window (iframe)\r\n    if (this.parentIsMsal()) {\r\n        tokenResponseCallback = window.parent.callbackMappedToRenewStates[stateInfo.state];\r\n    }\r\n    // Current window is window opener (popup)\r\n    else if (isWindowOpenerMsal) {\r\n        tokenResponseCallback = window.opener.callbackMappedToRenewStates[stateInfo.state];\r\n    }\r\n    // Redirect cases\r\n    else {\r\n      tokenResponseCallback = null;\r\n      // if set to navigate to loginRequest page post login\r\n      if (self.config.auth.navigateToLoginRequestUrl) {\r\n        self.cacheStorage.setItem(Constants.urlHash, hash);\r\n        if (window.parent === window && !isPopup) {\r\n          window.location.href = self.cacheStorage.getItem(Constants.loginRequest, self.inCookie);\r\n        }\r\n        return;\r\n      }\r\n      else {\r\n        window.location.hash = \"\";\r\n      }\r\n      if (!this.redirectCallbacksSet) {\r\n        // We reached this point too early - cache hash, return and process in handleRedirectCallbacks\r\n        self.cacheStorage.setItem(Constants.urlHash, hash);\r\n        return;\r\n      }\r\n    }\r\n\r\n    self.processCallBack(hash, stateInfo, tokenResponseCallback);\r\n\r\n    // If current window is opener, close all windows\r\n    if (isWindowOpenerMsal) {\r\n      for (let i = 0; i < window.opener.openedWindows.length; i++) {\r\n        window.opener.openedWindows[i].close();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Returns deserialized portion of URL hash\r\n   * @param hash\r\n   */\r\n  private deserializeHash(urlFragment: string) {\r\n    let hash = UrlUtils.getHashFromUrl(urlFragment);\r\n    return CryptoUtils.deserialize(hash);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Creates a stateInfo object from the URL fragment and returns it.\r\n   * @param {string} hash  -  Hash passed from redirect page\r\n   * @returns {TokenResponse} an object created from the redirect response from AAD comprising of the keys - parameters, requestType, stateMatch, stateResponse and valid.\r\n   * @ignore\r\n   */\r\n  protected getResponseState(hash: string): ResponseStateInfo {\r\n    const parameters = this.deserializeHash(hash);\r\n    let stateResponse: ResponseStateInfo;\r\n    if (!parameters) {\r\n      throw AuthError.createUnexpectedError(\"Hash was not parsed correctly.\");\r\n    }\r\n    if (parameters.hasOwnProperty(\"state\")) {\r\n      stateResponse = {\r\n        requestType: Constants.unknown,\r\n        state: parameters.state,\r\n        stateMatch: false\r\n      };\r\n    } else {\r\n      throw AuthError.createUnexpectedError(\"Hash does not contain state.\");\r\n    }\r\n    // async calls can fire iframe and login request at the same time if developer does not use the API as expected\r\n    // incoming callback needs to be looked up to find the request type\r\n\r\n    // loginRedirect\r\n    if (stateResponse.state === this.cacheStorage.getItem(Constants.stateLogin, this.inCookie) || stateResponse.state === this.silentAuthenticationState) { // loginRedirect\r\n      stateResponse.requestType = Constants.login;\r\n      stateResponse.stateMatch = true;\r\n      return stateResponse;\r\n    }\r\n    // acquireTokenRedirect\r\n    else if (stateResponse.state === this.cacheStorage.getItem(Constants.stateAcquireToken, this.inCookie)) { //acquireTokenRedirect\r\n      stateResponse.requestType = Constants.renewToken;\r\n      stateResponse.stateMatch = true;\r\n      return stateResponse;\r\n    }\r\n\r\n    // external api requests may have many renewtoken requests for different resource\r\n    if (!stateResponse.stateMatch) {\r\n      stateResponse.requestType = window.requestType;\r\n      const statesInParentContext = window.renewStates;\r\n      for (let i = 0; i < statesInParentContext.length; i++) {\r\n        if (statesInParentContext[i] === stateResponse.state) {\r\n          stateResponse.stateMatch = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return stateResponse;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region Token Processing (Extract to TokenProcessing.ts)\r\n\r\n  /**\r\n   * @hidden\r\n   * Used to get token for the specified set of scopes from the cache\r\n   * @param {@link ServerRequestParameters} - Request sent to the STS to obtain an id_token/access_token\r\n   * @param {Account} account - Account for which the scopes were requested\r\n   */\r\n  private getCachedToken(serverAuthenticationRequest: ServerRequestParameters, account: Account): AuthResponse {\r\n    let accessTokenCacheItem: AccessTokenCacheItem = null;\r\n    const scopes = serverAuthenticationRequest.scopes;\r\n\r\n    // filter by clientId and account\r\n    const tokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, account ? account.homeAccountIdentifier : null);\r\n\r\n    // No match found after initial filtering\r\n    if (tokenCacheItems.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const filteredItems: Array<AccessTokenCacheItem> = [];\r\n\r\n    // if no authority passed\r\n    if (!serverAuthenticationRequest.authority) {\r\n      // filter by scope\r\n      for (let i = 0; i < tokenCacheItems.length; i++) {\r\n        const cacheItem = tokenCacheItems[i];\r\n        const cachedScopes = cacheItem.key.scopes.split(\" \");\r\n        if (ScopeSet.containsScope(cachedScopes, scopes)) {\r\n          filteredItems.push(cacheItem);\r\n        }\r\n      }\r\n\r\n      // if only one cached token found\r\n      if (filteredItems.length === 1) {\r\n        accessTokenCacheItem = filteredItems[0];\r\n        serverAuthenticationRequest.authorityInstance = AuthorityFactory.CreateInstance(accessTokenCacheItem.key.authority, this.config.auth.validateAuthority);\r\n      }\r\n      // if more than one cached token is found\r\n      else if (filteredItems.length > 1) {\r\n        throw ClientAuthError.createMultipleMatchingTokensInCacheError(scopes.toString());\r\n      }\r\n      // if no match found, check if there was a single authority used\r\n      else {\r\n        const authorityList = this.getUniqueAuthority(tokenCacheItems, \"authority\");\r\n        if (authorityList.length > 1) {\r\n          throw ClientAuthError.createMultipleAuthoritiesInCacheError(scopes.toString());\r\n        }\r\n\r\n        serverAuthenticationRequest.authorityInstance = AuthorityFactory.CreateInstance(authorityList[0], this.config.auth.validateAuthority);\r\n      }\r\n    }\r\n    // if an authority is passed in the API\r\n    else {\r\n      // filter by authority and scope\r\n      for (let i = 0; i < tokenCacheItems.length; i++) {\r\n        const cacheItem = tokenCacheItems[i];\r\n        const cachedScopes = cacheItem.key.scopes.split(\" \");\r\n        if (ScopeSet.containsScope(cachedScopes, scopes) && UrlUtils.CanonicalizeUri(cacheItem.key.authority) === serverAuthenticationRequest.authority) {\r\n          filteredItems.push(cacheItem);\r\n        }\r\n      }\r\n      // no match\r\n      if (filteredItems.length === 0) {\r\n        return null;\r\n      }\r\n      // if only one cachedToken Found\r\n      else if (filteredItems.length === 1) {\r\n        accessTokenCacheItem = filteredItems[0];\r\n      }\r\n      else {\r\n        // if more than cached token is found\r\n        throw ClientAuthError.createMultipleMatchingTokensInCacheError(scopes.toString());\r\n      }\r\n    }\r\n\r\n    if (accessTokenCacheItem != null) {\r\n      let expired = Number(accessTokenCacheItem.value.expiresIn);\r\n      // If expiration is within offset, it will force renew\r\n      const offset = this.config.system.tokenRenewalOffsetSeconds || 300;\r\n      if (expired && (expired > TimeUtils.now() + offset)) {\r\n        let idTokenObj = new IdToken(accessTokenCacheItem.value.idToken);\r\n        if (!account) {\r\n          account = this.getAccount();\r\n          if (!account) {\r\n            throw AuthError.createUnexpectedError(\"Account should not be null here.\");\r\n          }\r\n        }\r\n        const aState = this.getAccountState(serverAuthenticationRequest.state);\r\n        let response : AuthResponse = {\r\n          uniqueId: \"\",\r\n          tenantId: \"\",\r\n          tokenType: (accessTokenCacheItem.value.idToken === accessTokenCacheItem.value.accessToken) ? Constants.idToken : Constants.accessToken,\r\n          idToken: idTokenObj,\r\n          idTokenClaims: idTokenObj.claims,\r\n          accessToken: accessTokenCacheItem.value.accessToken,\r\n          scopes: accessTokenCacheItem.key.scopes.split(\" \"),\r\n          expiresOn: new Date(expired * 1000),\r\n          account: account,\r\n          accountState: aState,\r\n        };\r\n        ResponseUtils.setResponseIdToken(response, idTokenObj);\r\n        return response;\r\n      } else {\r\n        this.cacheStorage.removeItem(JSON.stringify(filteredItems[0].key));\r\n        return null;\r\n      }\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Used to get a unique list of authoritues from the cache\r\n   * @param {Array<AccessTokenCacheItem>}  accessTokenCacheItems - accessTokenCacheItems saved in the cache\r\n   * @ignore\r\n   */\r\n  private getUniqueAuthority(accessTokenCacheItems: Array<AccessTokenCacheItem>, property: string): Array<string> {\r\n    const authorityList: Array<string> = [];\r\n    const flags: Array<string> = [];\r\n    accessTokenCacheItems.forEach(element => {\r\n      if (element.key.hasOwnProperty(property) && (flags.indexOf(element.key[property]) === -1)) {\r\n        flags.push(element.key[property]);\r\n        authorityList.push(element.key[property]);\r\n      }\r\n    });\r\n    return authorityList;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Check if ADAL id_token exists and return if exists.\r\n   *\r\n   */\r\n  private extractADALIdToken(): any {\r\n    const adalIdToken = this.cacheStorage.getItem(Constants.adalIdToken);\r\n    if (!StringUtils.isEmpty(adalIdToken)) {\r\n      return TokenUtils.extractIdToken(adalIdToken);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Acquires access token using a hidden iframe.\r\n   * @ignore\r\n   */\r\n  private renewToken(scopes: Array<string>, resolve: Function, reject: Function, account: Account, serverAuthenticationRequest: ServerRequestParameters): void {\r\n    const scope = scopes.join(\" \").toLowerCase();\r\n    this.logger.verbose(\"renewToken is called for scope:\" + scope);\r\n    const frameHandle = this.addHiddenIFrame(\"msalRenewFrame\" + scope);\r\n\r\n    this.updateCacheEntries(serverAuthenticationRequest, account);\r\n    this.logger.verbose(\"Renew token Expected state: \" + serverAuthenticationRequest.state);\r\n\r\n    // Build urlNavigate with \"prompt=none\" and navigate to URL in hidden iFrame\r\n    let urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none;\r\n\r\n    window.renewStates.push(serverAuthenticationRequest.state);\r\n    window.requestType = Constants.renewToken;\r\n    this.registerCallback(serverAuthenticationRequest.state, scope, resolve, reject);\r\n    this.logger.infoPii(\"Navigate to:\" + urlNavigate);\r\n    frameHandle.src = \"about:blank\";\r\n    this.loadIframeTimeout(urlNavigate, \"msalRenewFrame\" + scope, scope);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Renews idtoken for app\"s own backend when clientId is passed as a single scope in the scopes array.\r\n   * @ignore\r\n   */\r\n  private renewIdToken(scopes: Array<string>, resolve: Function, reject: Function, account: Account, serverAuthenticationRequest: ServerRequestParameters): void {\r\n\r\n    this.logger.info(\"renewidToken is called\");\r\n    const frameHandle = this.addHiddenIFrame(\"msalIdTokenFrame\");\r\n\r\n    this.updateCacheEntries(serverAuthenticationRequest, account);\r\n\r\n    this.logger.verbose(\"Renew Idtoken Expected state: \" + serverAuthenticationRequest.state);\r\n\r\n    // Build urlNavigate with \"prompt=none\" and navigate to URL in hidden iFrame\r\n    let urlNavigate = UrlUtils.urlRemoveQueryStringParameter(UrlUtils.createNavigateUrl(serverAuthenticationRequest), Constants.prompt) + Constants.prompt_none;\r\n\r\n    if (this.silentLogin) {\r\n        window.requestType = Constants.login;\r\n        this.silentAuthenticationState = serverAuthenticationRequest.state;\r\n    } else {\r\n        window.requestType = Constants.renewToken;\r\n        window.renewStates.push(serverAuthenticationRequest.state);\r\n    }\r\n\r\n    // note: scope here is clientId\r\n    this.registerCallback(serverAuthenticationRequest.state, this.clientId, resolve, reject);\r\n    this.logger.infoPii(\"Navigate to:\" + urlNavigate);\r\n    frameHandle.src = \"about:blank\";\r\n    this.loadIframeTimeout(urlNavigate, \"msalIdTokenFrame\", this.clientId);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * This method must be called for processing the response received from AAD. It extracts the hash, processes the token or error, saves it in the cache and calls the registered callbacks with the result.\r\n   * @param {string} authority authority received in the redirect response from AAD.\r\n   * @param {TokenResponse} requestInfo an object created from the redirect response from AAD comprising of the keys - parameters, requestType, stateMatch, stateResponse and valid.\r\n   * @param {Account} account account object for which scopes are consented for. The default account is the logged in account.\r\n   * @param {ClientInfo} clientInfo clientInfo received as part of the response comprising of fields uid and utid.\r\n   * @param {IdToken} idToken idToken received as part of the response.\r\n   * @ignore\r\n   * @private\r\n   */\r\n  /* tslint:disable:no-string-literal */\r\n  private saveAccessToken(response: AuthResponse, authority: string, parameters: any, clientInfo: string, idTokenObj: IdToken): AuthResponse {\r\n    let scope: string;\r\n    let accessTokenResponse = { ...response };\r\n    const clientObj: ClientInfo = new ClientInfo(clientInfo);\r\n    let expiration: number;\r\n\r\n    // if the response contains \"scope\"\r\n    if (parameters.hasOwnProperty(\"scope\")) {\r\n      // read the scopes\r\n      scope = parameters[\"scope\"];\r\n      const consentedScopes = scope.split(\" \");\r\n\r\n      // retrieve all access tokens from the cache, remove the dup scores\r\n      const accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(this.clientId, authority);\r\n\r\n      for (let i = 0; i < accessTokenCacheItems.length; i++) {\r\n        const accessTokenCacheItem = accessTokenCacheItems[i];\r\n\r\n        if (accessTokenCacheItem.key.homeAccountIdentifier === response.account.homeAccountIdentifier) {\r\n          const cachedScopes = accessTokenCacheItem.key.scopes.split(\" \");\r\n          if (ScopeSet.isIntersectingScopes(cachedScopes, consentedScopes)) {\r\n            this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));\r\n          }\r\n        }\r\n      }\r\n\r\n      // Generate and cache accessTokenKey and accessTokenValue\r\n      const expiresIn = TimeUtils.parseExpiresIn(parameters[Constants.expiresIn]);\r\n      expiration = TimeUtils.now() + expiresIn;\r\n      const accessTokenKey = new AccessTokenKey(authority, this.clientId, scope, clientObj.uid, clientObj.utid);\r\n      const accessTokenValue = new AccessTokenValue(parameters[Constants.accessToken], idTokenObj.rawIdToken, expiration.toString(), clientInfo);\r\n\r\n      this.cacheStorage.setItem(JSON.stringify(accessTokenKey), JSON.stringify(accessTokenValue));\r\n\r\n      accessTokenResponse.accessToken  = parameters[Constants.accessToken];\r\n      accessTokenResponse.scopes = consentedScopes;\r\n    }\r\n    // if the response does not contain \"scope\" - scope is usually client_id and the token will be id_token\r\n    else {\r\n      scope = this.clientId;\r\n\r\n      // Generate and cache accessTokenKey and accessTokenValue\r\n      const accessTokenKey = new AccessTokenKey(authority, this.clientId, scope, clientObj.uid, clientObj.utid);\r\n      expiration = Number(idTokenObj.expiration);\r\n      const accessTokenValue = new AccessTokenValue(parameters[Constants.idToken], parameters[Constants.idToken], expiration.toString(), clientInfo);\r\n      this.cacheStorage.setItem(JSON.stringify(accessTokenKey), JSON.stringify(accessTokenValue));\r\n      accessTokenResponse.scopes = [scope];\r\n      accessTokenResponse.accessToken = parameters[Constants.idToken];\r\n    }\r\n\r\n    if (expiration) {\r\n        accessTokenResponse.expiresOn = new Date(expiration * 1000);\r\n    } else {\r\n        this.logger.error(\"Could not parse expiresIn parameter\");\r\n    }\r\n\r\n    return accessTokenResponse;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * Saves token or error received in the response from AAD in the cache. In case of id_token, it also creates the account object.\r\n   * @ignore\r\n   */\r\n  protected saveTokenFromHash(hash: string, stateInfo: ResponseStateInfo): AuthResponse {\r\n    this.logger.info(\"State status:\" + stateInfo.stateMatch + \"; Request type:\" + stateInfo.requestType);\r\n    this.cacheStorage.setItem(Constants.msalError, \"\");\r\n    this.cacheStorage.setItem(Constants.msalErrorDescription, \"\");\r\n\r\n    let response : AuthResponse = {\r\n      uniqueId: \"\",\r\n      tenantId: \"\",\r\n      tokenType: \"\",\r\n      idToken: null,\r\n      idTokenClaims: null,\r\n      accessToken: null,\r\n      scopes: [],\r\n      expiresOn: null,\r\n      account: null,\r\n      accountState: \"\",\r\n    };\r\n\r\n    let error: AuthError;\r\n    const hashParams = this.deserializeHash(hash);\r\n    let authorityKey: string = \"\";\r\n    let acquireTokenAccountKey: string = \"\";\r\n    let idTokenObj: IdToken = null;\r\n\r\n    // If server returns an error\r\n    if (hashParams.hasOwnProperty(Constants.errorDescription) || hashParams.hasOwnProperty(Constants.error)) {\r\n      this.logger.infoPii(\"Error :\" + hashParams[Constants.error] + \"; Error description:\" + hashParams[Constants.errorDescription]);\r\n      this.cacheStorage.setItem(Constants.msalError, hashParams[Constants.error]);\r\n      this.cacheStorage.setItem(Constants.msalErrorDescription, hashParams[Constants.errorDescription]);\r\n\r\n      // login\r\n      if (stateInfo.requestType === Constants.login) {\r\n        this.loginInProgress = false;\r\n        this.cacheStorage.setItem(Constants.loginError, hashParams[Constants.errorDescription] + \":\" + hashParams[Constants.error]);\r\n        authorityKey = Storage.generateAuthorityKey(stateInfo.state);\r\n      }\r\n\r\n      // acquireToken\r\n      if (stateInfo.requestType === Constants.renewToken) {\r\n        this.acquireTokenInProgress = false;\r\n        authorityKey = Storage.generateAuthorityKey(stateInfo.state);\r\n\r\n        const account: Account = this.getAccount();\r\n        let accountId;\r\n\r\n        if (account && !StringUtils.isEmpty(account.homeAccountIdentifier)) {\r\n            accountId = account.homeAccountIdentifier;\r\n        }\r\n        else {\r\n            accountId = Constants.no_account;\r\n        }\r\n\r\n        acquireTokenAccountKey = Storage.generateAcquireTokenAccountKey(accountId, stateInfo.state);\r\n      }\r\n\r\n      const {\r\n        [Constants.error]: hashErr,\r\n        [Constants.errorDescription]: hashErrDesc\r\n      } = hashParams;\r\n      if (InteractionRequiredAuthError.isInteractionRequiredError(hashErr) ||\r\n        InteractionRequiredAuthError.isInteractionRequiredError(hashErrDesc)) {\r\n        error = new InteractionRequiredAuthError(hashParams[Constants.error], hashParams[Constants.errorDescription]);\r\n      } else {\r\n        error = new ServerError(hashParams[Constants.error], hashParams[Constants.errorDescription]);\r\n      }\r\n    }\r\n    // If the server returns \"Success\"\r\n    else {\r\n      // Verify the state from redirect and record tokens to storage if exists\r\n      if (stateInfo.stateMatch) {\r\n        this.logger.info(\"State is right\");\r\n        if (hashParams.hasOwnProperty(Constants.sessionState)) {\r\n            this.cacheStorage.setItem(Constants.msalSessionState, hashParams[Constants.sessionState]);\r\n        }\r\n        response.accountState = this.getAccountState(stateInfo.state);\r\n\r\n        let clientInfo: string = \"\";\r\n\r\n        // Process access_token\r\n        if (hashParams.hasOwnProperty(Constants.accessToken)) {\r\n          this.logger.info(\"Fragment has access token\");\r\n          this.acquireTokenInProgress = false;\r\n\r\n          // retrieve the id_token from response if present\r\n          if (hashParams.hasOwnProperty(Constants.idToken)) {\r\n            idTokenObj = new IdToken(hashParams[Constants.idToken]);\r\n            response.idToken = idTokenObj;\r\n            response.idTokenClaims = idTokenObj.claims;\r\n          } else {\r\n            idTokenObj = new IdToken(this.cacheStorage.getItem(Constants.idTokenKey));\r\n            response = ResponseUtils.setResponseIdToken(response, idTokenObj);\r\n          }\r\n\r\n          // retrieve the authority from cache and replace with tenantID\r\n          const authorityKey = Storage.generateAuthorityKey(stateInfo.state);\r\n          let authority: string = this.cacheStorage.getItem(authorityKey, this.inCookie);\r\n\r\n          if (!StringUtils.isEmpty(authority)) {\r\n            authority = UrlUtils.replaceTenantPath(authority, response.tenantId);\r\n          }\r\n\r\n          // retrieve client_info - if it is not found, generate the uid and utid from idToken\r\n          if (hashParams.hasOwnProperty(Constants.clientInfo)) {\r\n            clientInfo = hashParams[Constants.clientInfo];\r\n          } else {\r\n            this.logger.warning(\"ClientInfo not received in the response from AAD\");\r\n            throw ClientAuthError.createClientInfoNotPopulatedError(\"ClientInfo not received in the response from the server\");\r\n          }\r\n\r\n          response.account = Account.createAccount(idTokenObj, new ClientInfo(clientInfo));\r\n\r\n          let accountKey: string;\r\n          if (response.account && !StringUtils.isEmpty(response.account.homeAccountIdentifier)) {\r\n            accountKey = response.account.homeAccountIdentifier;\r\n          }\r\n          else {\r\n            accountKey = Constants.no_account;\r\n          }\r\n\r\n          acquireTokenAccountKey = Storage.generateAcquireTokenAccountKey(accountKey, stateInfo.state);\r\n          const acquireTokenAccountKey_noaccount = Storage.generateAcquireTokenAccountKey(Constants.no_account, stateInfo.state);\r\n\r\n          let cachedAccount: string = this.cacheStorage.getItem(acquireTokenAccountKey);\r\n          let acquireTokenAccount: Account;\r\n\r\n          // Check with the account in the Cache\r\n          if (!StringUtils.isEmpty(cachedAccount)) {\r\n            acquireTokenAccount = JSON.parse(cachedAccount);\r\n            if (response.account && acquireTokenAccount && Account.compareAccounts(response.account, acquireTokenAccount)) {\r\n              response = this.saveAccessToken(response, authority, hashParams, clientInfo, idTokenObj);\r\n              this.logger.info(\"The user object received in the response is the same as the one passed in the acquireToken request\");\r\n            }\r\n            else {\r\n              this.logger.warning(\r\n                \"The account object created from the response is not the same as the one passed in the acquireToken request\");\r\n            }\r\n          }\r\n          else if (!StringUtils.isEmpty(this.cacheStorage.getItem(acquireTokenAccountKey_noaccount))) {\r\n            response = this.saveAccessToken(response, authority, hashParams, clientInfo, idTokenObj);\r\n          }\r\n        }\r\n\r\n        // Process id_token\r\n        if (hashParams.hasOwnProperty(Constants.idToken)) {\r\n            this.logger.info(\"Fragment has id token\");\r\n\r\n            // login no longer in progress\r\n            this.loginInProgress = false;\r\n\r\n            // set the idToken\r\n            idTokenObj = new IdToken(hashParams[Constants.idToken]);\r\n\r\n            response = ResponseUtils.setResponseIdToken(response, idTokenObj);\r\n            if (hashParams.hasOwnProperty(Constants.clientInfo)) {\r\n              clientInfo = hashParams[Constants.clientInfo];\r\n            } else {\r\n              this.logger.warning(\"ClientInfo not received in the response from AAD\");\r\n            }\r\n\r\n            authorityKey = Storage.generateAuthorityKey(stateInfo.state);\r\n            let authority: string = this.cacheStorage.getItem(authorityKey, this.inCookie);\r\n\r\n            if (!StringUtils.isEmpty(authority)) {\r\n              authority = UrlUtils.replaceTenantPath(authority, idTokenObj.tenantId);\r\n            }\r\n\r\n            this.account = Account.createAccount(idTokenObj, new ClientInfo(clientInfo));\r\n            response.account = this.account;\r\n\r\n            if (idTokenObj && idTokenObj.nonce) {\r\n              // check nonce integrity if idToken has nonce - throw an error if not matched\r\n              if (idTokenObj.nonce !== this.cacheStorage.getItem(Constants.nonceIdToken, this.inCookie)) {\r\n                this.account = null;\r\n                this.cacheStorage.setItem(Constants.loginError, \"Nonce Mismatch. Expected Nonce: \" + this.cacheStorage.getItem(Constants.nonceIdToken, this.inCookie) + \",\" + \"Actual Nonce: \" + idTokenObj.nonce);\r\n                this.logger.error(\"Nonce Mismatch.Expected Nonce: \" + this.cacheStorage.getItem(Constants.nonceIdToken, this.inCookie) + \",\" + \"Actual Nonce: \" + idTokenObj.nonce);\r\n                error = ClientAuthError.createNonceMismatchError(this.cacheStorage.getItem(Constants.nonceIdToken, this.inCookie), idTokenObj.nonce);\r\n              }\r\n              // Save the token\r\n              else {\r\n                this.cacheStorage.setItem(Constants.idTokenKey, hashParams[Constants.idToken]);\r\n                this.cacheStorage.setItem(Constants.msalClientInfo, clientInfo);\r\n\r\n                // Save idToken as access token for app itself\r\n                this.saveAccessToken(response, authority, hashParams, clientInfo, idTokenObj);\r\n              }\r\n            } else {\r\n              authorityKey = stateInfo.state;\r\n              acquireTokenAccountKey = stateInfo.state;\r\n\r\n              this.logger.error(\"Invalid id_token received in the response\");\r\n              error = ClientAuthError.createInvalidIdTokenError(idTokenObj);\r\n              this.cacheStorage.setItem(Constants.msalError, error.errorCode);\r\n              this.cacheStorage.setItem(Constants.msalErrorDescription, error.errorMessage);\r\n            }\r\n        }\r\n      }\r\n      // State mismatch - unexpected/invalid state\r\n      else {\r\n        authorityKey = stateInfo.state;\r\n        acquireTokenAccountKey = stateInfo.state;\r\n\r\n        const expectedState = this.cacheStorage.getItem(Constants.stateLogin, this.inCookie);\r\n        this.logger.error(\"State Mismatch.Expected State: \" + expectedState + \",\" + \"Actual State: \" + stateInfo.state);\r\n        error = ClientAuthError.createInvalidStateError(stateInfo.state, expectedState);\r\n        this.cacheStorage.setItem(Constants.msalError, error.errorCode);\r\n        this.cacheStorage.setItem(Constants.msalErrorDescription, error.errorMessage);\r\n      }\r\n    }\r\n\r\n    this.cacheStorage.setItem(Constants.renewStatus + stateInfo.state, Constants.tokenRenewStatusCompleted);\r\n    this.cacheStorage.removeAcquireTokenEntries(stateInfo.state);\r\n    // this is required if navigateToLoginRequestUrl=false\r\n    if (this.inCookie) {\r\n      this.cacheStorage.setItemCookie(authorityKey, \"\", -1);\r\n      this.cacheStorage.clearCookie();\r\n    }\r\n    if (error) {\r\n      throw error;\r\n    }\r\n\r\n    if (!response) {\r\n        throw AuthError.createUnexpectedError(\"Response is null\");\r\n    }\r\n    return response;\r\n  }\r\n  /* tslint:enable:no-string-literal */\r\n\r\n  //#endregion\r\n\r\n  //#region Account\r\n\r\n  /**\r\n   * Returns the signed in account\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no state is found\r\n   * @returns {@link Account} - the account object stored in MSAL\r\n   */\r\n  getAccount(): Account {\r\n    // if a session already exists, get the account from the session\r\n    if (this.account) {\r\n      return this.account;\r\n    }\r\n\r\n    // frame is used to get idToken and populate the account for the given session\r\n    const rawIdToken = this.cacheStorage.getItem(Constants.idTokenKey);\r\n    const rawClientInfo = this.cacheStorage.getItem(Constants.msalClientInfo);\r\n\r\n    if (!StringUtils.isEmpty(rawIdToken) && !StringUtils.isEmpty(rawClientInfo)) {\r\n      const idToken = new IdToken(rawIdToken);\r\n      const clientInfo = new ClientInfo(rawClientInfo);\r\n      this.account = Account.createAccount(idToken, clientInfo);\r\n      return this.account;\r\n    }\r\n    // if login not yet done, return null\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Extracts state value from the accountState sent with the authentication request.\r\n   * @returns {string} scope.\r\n   * @ignore\r\n   */\r\n  getAccountState (state: string) {\r\n    if (state) {\r\n      const splitIndex = state.indexOf(\"|\");\r\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\r\n        return state.substring(splitIndex + 1);\r\n      }\r\n    }\r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * Use to get a list of unique accounts in MSAL cache based on homeAccountIdentifier.\r\n   *\r\n   * @param {@link Array<Account>} Account - all unique accounts in MSAL cache.\r\n   */\r\n  getAllAccounts(): Array<Account> {\r\n    const accounts: Array<Account> = [];\r\n    const accessTokenCacheItems = this.cacheStorage.getAllAccessTokens(Constants.clientId, Constants.homeAccountIdentifier);\r\n\r\n    for (let i = 0; i < accessTokenCacheItems.length; i++) {\r\n      const idToken = new IdToken(accessTokenCacheItems[i].value.idToken);\r\n      const clientInfo = new ClientInfo(accessTokenCacheItems[i].value.homeAccountIdentifier);\r\n      const account: Account = Account.createAccount(idToken, clientInfo);\r\n      accounts.push(account);\r\n    }\r\n\r\n    return this.getUniqueAccounts(accounts);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Used to filter accounts based on homeAccountIdentifier\r\n   * @param {Array<Account>}  Accounts - accounts saved in the cache\r\n   * @ignore\r\n   */\r\n  private getUniqueAccounts(accounts: Array<Account>): Array<Account> {\r\n    if (!accounts || accounts.length <= 1) {\r\n      return accounts;\r\n    }\r\n\r\n    const flags: Array<string> = [];\r\n    const uniqueAccounts: Array<Account> = [];\r\n    for (let index = 0; index < accounts.length; ++index) {\r\n      if (accounts[index].homeAccountIdentifier && flags.indexOf(accounts[index].homeAccountIdentifier) === -1) {\r\n        flags.push(accounts[index].homeAccountIdentifier);\r\n        uniqueAccounts.push(accounts[index]);\r\n      }\r\n    }\r\n\r\n    return uniqueAccounts;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region Scopes (Extract to Scopes.ts)\r\n\r\n  // Note: \"this\" dependency in this section is minimal.\r\n  // If pCacheStorage is separated from the class object, or passed as a fn param, scopesUtils.ts can be created\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Used to validate the scopes input parameter requested  by the developer.\r\n   * @param {Array<string>} scopes - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.\r\n   * @param {boolean} scopesRequired - Boolean indicating whether the scopes array is required or not\r\n   * @ignore\r\n   */\r\n  private validateInputScope(scopes: Array<string>, scopesRequired: boolean): void {\r\n    if (!scopes) {\r\n      if (scopesRequired) {\r\n        throw ClientConfigurationError.createScopesRequiredError(scopes);\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Check that scopes is an array object (also throws error if scopes == null)\r\n    if (!Array.isArray(scopes)) {\r\n      throw ClientConfigurationError.createScopesNonArrayError(scopes);\r\n    }\r\n\r\n    // Check that scopes is not an empty array\r\n    if (scopes.length < 1) {\r\n      throw ClientConfigurationError.createEmptyScopesArrayError(scopes.toString());\r\n    }\r\n\r\n    // Check that clientId is passed as single scope\r\n    if (scopes.indexOf(this.clientId) > -1) {\r\n      if (scopes.length > 1) {\r\n        throw ClientConfigurationError.createClientIdSingleScopeError(scopes.toString());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Extracts scope value from the state sent with the authentication request.\r\n   * @param {string} state\r\n   * @returns {string} scope.\r\n   * @ignore\r\n   */\r\n  private getScopeFromState(state: string): string {\r\n    if (state) {\r\n      const splitIndex = state.indexOf(\"|\");\r\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\r\n        return state.substring(splitIndex + 1);\r\n      }\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * Appends extraScopesToConsent if passed\r\n   * @param {@link AuthenticationParameters}\r\n   */\r\n  private appendScopes(request: AuthenticationParameters): Array<string> {\r\n\r\n    let scopes: Array<string>;\r\n\r\n    if (request && request.scopes) {\r\n        if (request.extraScopesToConsent) {\r\n            scopes = [...request.scopes, ...request.extraScopesToConsent];\r\n        }\r\n        else {\r\n        scopes = request.scopes;\r\n        }\r\n    }\r\n\r\n    return scopes;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region Angular\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Broadcast messages - Used only for Angular?  *\r\n   * @param eventName\r\n   * @param data\r\n   */\r\n  private broadcast(eventName: string, data: string) {\r\n    const evt = new CustomEvent(eventName, { detail: data });\r\n    window.dispatchEvent(evt);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Helper function to retrieve the cached token\r\n   *\r\n   * @param scopes\r\n   * @param {@link Account} account\r\n   * @param state\r\n   * @return {@link AuthResponse} AuthResponse\r\n   */\r\n  protected getCachedTokenInternal(scopes : Array<string> , account: Account, state: string): AuthResponse {\r\n    // Get the current session's account object\r\n    const accountObject: Account = account || this.getAccount();\r\n    if (!accountObject) {\r\n        return null;\r\n    }\r\n\r\n    // Construct AuthenticationRequest based on response type\r\n    const newAuthority = this.authorityInstance ? this.authorityInstance : AuthorityFactory.CreateInstance(this.authority, this.config.auth.validateAuthority);\r\n    const responseType = this.getTokenType(accountObject, scopes, true);\r\n    const serverAuthenticationRequest = new ServerRequestParameters(\r\n      newAuthority,\r\n      this.clientId,\r\n      scopes,\r\n      responseType,\r\n      this.getRedirectUri(),\r\n      state\r\n    );\r\n\r\n    // get cached token\r\n    return this.getCachedToken(serverAuthenticationRequest, account);\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   *\r\n   * Get scopes for the Endpoint - Used in Angular to track protected and unprotected resources without interaction from the developer app\r\n   *\r\n   * @param endpoint\r\n   */\r\n  protected getScopesForEndpoint(endpoint: string) : Array<string> {\r\n    // if user specified list of unprotectedResources, no need to send token to these endpoints, return null.\r\n    if (this.config.framework.unprotectedResources.length > 0) {\r\n        for (let i = 0; i < this.config.framework.unprotectedResources.length; i++) {\r\n            if (endpoint.indexOf(this.config.framework.unprotectedResources[i]) > -1) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    // process all protected resources and send the matched one\r\n    if (this.config.framework.protectedResourceMap.size > 0) {\r\n        for (let key of Array.from(this.config.framework.protectedResourceMap.keys())) {\r\n            // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\r\n            if (endpoint.indexOf(key) > -1) {\r\n                return this.config.framework.protectedResourceMap.get(key);\r\n            }\r\n        }\r\n    }\r\n\r\n    // default resource will be clientid if nothing specified\r\n    // App will use idtoken for calls to itself\r\n    // check if it's staring from http or https, needs to match with app host\r\n    if (endpoint.indexOf(\"http://\") > -1 || endpoint.indexOf(\"https://\") > -1) {\r\n        if (this.getHostFromUri(endpoint) === this.getHostFromUri(this.getRedirectUri())) {\r\n            return new Array<string>(this.clientId);\r\n        }\r\n    } else {\r\n    // in angular level, the url for $http interceptor call could be relative url,\r\n    // if it's relative call, we'll treat it as app backend call.\r\n        return new Array<string>(this.clientId);\r\n    }\r\n\r\n    // if not the app's own backend or not a domain listed in the endpoints structure\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Return boolean flag to developer to help inform if login is in progress\r\n   * @returns {boolean} true/false\r\n   */\r\n  public getLoginInProgress(): boolean {\r\n    const pendingCallback = this.cacheStorage.getItem(Constants.urlHash);\r\n    if (pendingCallback) {\r\n        return true;\r\n    }\r\n    return this.loginInProgress;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * @param loginInProgress\r\n   */\r\n  protected setloginInProgress(loginInProgress : boolean) {\r\n    this.loginInProgress = loginInProgress;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * returns the status of acquireTokenInProgress\r\n   */\r\n  protected getAcquireTokenInProgress(): boolean {\r\n      return this.acquireTokenInProgress;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * @param acquireTokenInProgress\r\n   */\r\n  protected setAcquireTokenInProgress(acquireTokenInProgress : boolean) {\r\n      this.acquireTokenInProgress = acquireTokenInProgress;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * returns the logger handle\r\n   */\r\n  protected getLogger() {\r\n      return this.config.system.logger;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region Getters and Setters\r\n\r\n  /**\r\n   *\r\n   * Use to get the redirect uri configured in MSAL or null.\r\n   * Evaluates redirectUri if its a function, otherwise simply returns its value.\r\n   * @returns {string} redirect URL\r\n   *\r\n   */\r\n  public getRedirectUri(): string {\r\n    if (typeof this.config.auth.redirectUri === \"function\") {\r\n      return this.config.auth.redirectUri();\r\n    }\r\n    return this.config.auth.redirectUri;\r\n  }\r\n\r\n  /**\r\n   * Use to get the post logout redirect uri configured in MSAL or null.\r\n   * Evaluates postLogoutredirectUri if its a function, otherwise simply returns its value.\r\n   *\r\n   * @returns {string} post logout redirect URL\r\n   */\r\n  public getPostLogoutRedirectUri(): string {\r\n    if (typeof this.config.auth.postLogoutRedirectUri === \"function\") {\r\n      return this.config.auth.postLogoutRedirectUri();\r\n    }\r\n    return this.config.auth.postLogoutRedirectUri;\r\n  }\r\n\r\n  /**\r\n   * Use to get the current {@link Configuration} object in MSAL\r\n   *\r\n   * @returns {@link Configuration}\r\n   */\r\n  public getCurrentConfiguration(): Configuration {\r\n    if (!this.config) {\r\n      throw ClientConfigurationError.createNoSetConfigurationError();\r\n    }\r\n    return this.config;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region String Util (Should be extracted to Utils.ts)\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * extract URI from the host\r\n   *\r\n   * @param {string} URI\r\n   * @returns {string} host from the URI\r\n   */\r\n  private getHostFromUri(uri: string): string {\r\n    // remove http:// or https:// from uri\r\n    let extractedUri = String(uri).replace(/^(https?:)\\/\\//, \"\");\r\n    extractedUri = extractedUri.split(\"/\")[0];\r\n    return extractedUri;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Utils function to create the Authentication\r\n   * @param {@link account} account object\r\n   * @param scopes\r\n   * @param silentCall\r\n   *\r\n   * @returns {string} token type: id_token or access_token\r\n   *\r\n   */\r\n  private getTokenType(accountObject: Account, scopes: string[], silentCall: boolean): string {\r\n\r\n    // if account is passed and matches the account object/or set to getAccount() from cache\r\n    // if client-id is passed as scope, get id_token else token/id_token_token (in case no session exists)\r\n    let tokenType: string;\r\n\r\n    // acquireTokenSilent\r\n    if (silentCall) {\r\n      if (Account.compareAccounts(accountObject, this.getAccount())) {\r\n        tokenType = (scopes.indexOf(this.config.auth.clientId) > -1) ? ResponseTypes.id_token : ResponseTypes.token;\r\n      }\r\n      else {\r\n        tokenType  = (scopes.indexOf(this.config.auth.clientId) > -1) ? ResponseTypes.id_token : ResponseTypes.id_token_token;\r\n      }\r\n\r\n      return tokenType;\r\n    }\r\n    // all other cases\r\n    else {\r\n      if (!Account.compareAccounts(accountObject, this.getAccount())) {\r\n        tokenType = ResponseTypes.id_token_token;\r\n      }\r\n      else {\r\n        tokenType = (scopes.indexOf(this.clientId) > -1) ? ResponseTypes.id_token : ResponseTypes.token;\r\n      }\r\n\r\n      return tokenType;\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Sets the cachekeys for and stores the account information in cache\r\n   * @param account\r\n   * @param state\r\n   * @hidden\r\n   */\r\n  private setAccountCache(account: Account, state: string) {\r\n\r\n    // Cache acquireTokenAccountKey\r\n    let accountId = account ? this.getAccountId(account) : Constants.no_account;\r\n\r\n    const acquireTokenAccountKey = Storage.generateAcquireTokenAccountKey(accountId, state);\r\n    this.cacheStorage.setItem(acquireTokenAccountKey, JSON.stringify(account));\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Sets the cacheKey for and stores the authority information in cache\r\n   * @param state\r\n   * @param authority\r\n   * @hidden\r\n   */\r\n  private setAuthorityCache(state: string, authority: string) {\r\n    // Cache authorityKey\r\n    const authorityKey = Storage.generateAuthorityKey(state);\r\n    this.cacheStorage.setItem(authorityKey, UrlUtils.CanonicalizeUri(authority), this.inCookie);\r\n  }\r\n\r\n  /**\r\n   * Updates account, authority, and nonce in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   * @hidden\r\n   * @ignore\r\n   */\r\n  private updateCacheEntries(serverAuthenticationRequest: ServerRequestParameters, account: Account, loginStartPage?: any) {\r\n    // Cache account and authority\r\n    if (loginStartPage) {\r\n      // Cache the state, nonce, and login request data\r\n      this.cacheStorage.setItem(Constants.loginRequest, loginStartPage, this.inCookie);\r\n      this.cacheStorage.setItem(Constants.loginError, \"\");\r\n\r\n      this.cacheStorage.setItem(Constants.stateLogin, serverAuthenticationRequest.state, this.inCookie);\r\n\r\n      this.cacheStorage.setItem(Constants.msalError, \"\");\r\n      this.cacheStorage.setItem(Constants.msalErrorDescription, \"\");\r\n    } else {\r\n      this.setAccountCache(account, serverAuthenticationRequest.state);\r\n    }\r\n    // Cache authorityKey\r\n    this.setAuthorityCache(serverAuthenticationRequest.state, serverAuthenticationRequest.authority);\r\n\r\n    // Cache nonce\r\n    this.cacheStorage.setItem(Constants.nonceIdToken, serverAuthenticationRequest.nonce, this.inCookie);\r\n  }\r\n\r\n  /**\r\n   * Returns the unique identifier for the logged in account\r\n   * @param account\r\n   * @hidden\r\n   * @ignore\r\n   */\r\n  private getAccountId(account: Account): any {\r\n    //return `${account.accountIdentifier}` + Constants.resourceDelimiter + `${account.homeAccountIdentifier}`;\r\n    let accountId: string;\r\n    if (!StringUtils.isEmpty(account.homeAccountIdentifier)) {\r\n         accountId = account.homeAccountIdentifier;\r\n    }\r\n    else {\r\n        accountId = Constants.no_account;\r\n    }\r\n\r\n    return accountId;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @ignore\r\n   *\r\n   * Construct 'tokenRequest' from the available data in adalIdToken\r\n   * @param extraQueryParameters\r\n   * @hidden\r\n   */\r\n  private buildIDTokenRequest(request: AuthenticationParameters): AuthenticationParameters {\r\n\r\n    let tokenRequest: AuthenticationParameters = {\r\n      scopes: [this.clientId],\r\n      authority: this.authority,\r\n      account: this.getAccount(),\r\n      extraQueryParameters: request.extraQueryParameters\r\n    };\r\n\r\n    return tokenRequest;\r\n  }\r\n\r\n //#endregion\r\n\r\n  private getTelemetryManagerFromConfig(config: TelemetryOptions, clientId: string): TelemetryManager {\r\n    if (!config) { // if unset\r\n      return null\r\n    }\r\n    // if set then validate\r\n    const { applicationName, applicationVersion, telemetryEmitter } = config;\r\n    if (!applicationName || !applicationVersion || ! telemetryEmitter) {\r\n      throw ClientConfigurationError.createTelemetryConfigError(config);\r\n    }\r\n    // if valid then construct\r\n    const telemetryPlatform: TelemetryPlatform = {\r\n      sdk: \"msal.js\", // TODO need to be able to override this for angular, react, etc\r\n      sdkVersion: libraryVersion(),\r\n      applicationName,\r\n      applicationVersion\r\n    };\r\n    const telemetryManagerConfig: TelemetryConfig = {\r\n      platform: telemetryPlatform,\r\n      clientId: clientId\r\n    };\r\n    return new TelemetryManager(telemetryManagerConfig, telemetryEmitter);\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * The default client ID for authentication\n * @internal\n * @ignore\n */\n// TODO: temporary - this is the Azure CLI clientID - we'll replace it when\n// Developer Sign On application is available\n// https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/identity/Azure.Identity/src/Constants.cs#L9\nexport const DeveloperSignOnClientId = \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\";\n\n/**\n * The default tenant for authentication\n * @internal\n * @ignore\n */\nexport const DefaultTenantId = \"common\";\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-http\";\nimport { DeviceCodePromptCallback } from './deviceCodeCredential';\nimport { IdentityClientOptions } from '../client/identityClient';\n\nconst BrowserNotSupportedError = new Error(\"DeviceCodeCredential is not supported in the browser.\");\n\nexport class DeviceCodeCredential implements TokenCredential {\n  constructor(\n    tenantId: string | \"organizations\",\n    clientId: string,\n    userPromptCallback: DeviceCodePromptCallback,\n    options?: IdentityClientOptions\n  ) {\n    throw BrowserNotSupportedError;\n  }\n\n  public getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    throw BrowserNotSupportedError;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-http\";\nimport { IdentityClientOptions } from '../client/identityClient';\n\nconst BrowserNotSupportedError = new Error(\n  \"AuthorizationCodeCredential is not supported in the browser.  InteractiveBrowserCredential is more appropriate for this use case.\"\n);\n\nexport class AuthorizationCodeCredential implements TokenCredential {\n  constructor(\n    tenantId: string | \"common\",\n    clientId: string,\n    clientSecret: string,\n    authorizationCode: string,\n    redirectUri: string,\n    options?: IdentityClientOptions\n  );\n  constructor(\n    tenantId: string | \"common\",\n    clientId: string,\n    authorizationCode: string,\n    redirectUri: string,\n    options?: IdentityClientOptions\n  ); \n  constructor(\n    tenantId: string | \"common\",\n    clientId: string,\n    clientSecretOrAuthorizationCode: string,\n    authorizationCodeOrRedirectUri: string,\n    redirectUriOrOptions: string | IdentityClientOptions | undefined,\n    options?: IdentityClientOptions\n  ) {\n    throw BrowserNotSupportedError;\n  }\n\n  public getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    throw BrowserNotSupportedError;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport qs from \"qs\";\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-http\";\nimport { IdentityClientOptions, IdentityClient } from \"../client/identityClient\";\nimport { createSpan } from \"../util/tracing\";\nimport { AuthenticationErrorName } from \"../client/errors\";\nimport { CanonicalCode } from \"@azure/core-tracing\";\n\n/**\n * Enables authentication to Azure Active Directory using a client secret\n * that was generated for an App Registration.  More information on how\n * to configure a client secret can be found here:\n *\n * https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application\n *\n */\nexport class ClientSecretCredential implements TokenCredential {\n  private identityClient: IdentityClient;\n  private tenantId: string;\n  private clientId: string;\n  private clientSecret: string;\n\n  /**\n   * Creates an instance of the ClientSecretCredential with the details\n   * needed to authenticate against Azure Active Directory with a client\n   * secret.\n   *\n   * @param tenantId The Azure Active Directory tenant (directory) ID.\n   * @param clientId The client (application) ID of an App Registration in the tenant.\n   * @param clientSecret A client secret that was generated for the App Registration.\n   * @param options Options for configuring the client which makes the authentication request.\n   */\n  constructor(\n    tenantId: string,\n    clientId: string,\n    clientSecret: string,\n    options?: IdentityClientOptions\n  ) {\n    this.identityClient = new IdentityClient(options);\n    this.tenantId = tenantId;\n    this.clientId = clientId;\n    this.clientSecret = clientSecret;\n  }\n\n  /**\n   * Authenticates with Azure Active Directory and returns an {@link AccessToken} if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes The list of scopes for which the token will have access.\n   * @param options The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  public async getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    const { span, options: newOptions } = createSpan(\"ClientSecretCredential-getToken\", options);\n    try {\n      const webResource = this.identityClient.createWebResource({\n        url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,\n        method: \"POST\",\n        disableJsonStringifyOnBody: true,\n        deserializationMapper: undefined,\n        body: qs.stringify({\n          response_type: \"token\",\n          grant_type: \"client_credentials\",\n          client_id: this.clientId,\n          client_secret: this.clientSecret,\n          scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \")\n        }),\n        headers: {\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        abortSignal: options && options.abortSignal,\n        spanOptions: newOptions.spanOptions\n      });\n\n      const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n      return (tokenResponse && tokenResponse.accessToken) || null;\n    } catch (err) {\n      const code =\n        err.name === AuthenticationErrorName\n          ? CanonicalCode.UNAUTHENTICATED\n          : CanonicalCode.UNKNOWN;\n      span.setStatus({\n        code,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport * as msal from \"msal\";\nimport { AccessToken, TokenCredential, GetTokenOptions } from \"@azure/core-http\";\nimport { IdentityClient } from \"../client/identityClient\";\nimport {\n  BrowserLoginStyle,\n  InteractiveBrowserCredentialOptions\n} from \"./interactiveBrowserCredentialOptions\";\nimport { createSpan } from \"../util/tracing\";\nimport { CanonicalCode } from \"@azure/core-tracing\";\nimport { DefaultTenantId, DeveloperSignOnClientId } from \"../constants\";\nimport { logger } from \"../util/logging\";\n\n/**\n * Enables authentication to Azure Active Directory inside of the web browser\n * using the interactive login flow, either via browser redirects or a popup\n * window.\n */\nexport class InteractiveBrowserCredential implements TokenCredential {\n  private loginStyle: BrowserLoginStyle;\n  private msalConfig: msal.Configuration;\n  private msalObject: msal.UserAgentApplication;\n\n  /**\n   * Creates an instance of the InteractiveBrowserCredential with the\n   * details needed to authenticate against Azure Active Directory with\n   * a user identity.\n   *\n   * @param tenantId The Azure Active Directory tenant (directory) ID.\n   * @param clientId The client (application) ID of an App Registration in the tenant.\n   * @param options Options for configuring the client which makes the authentication request.\n   */\n  constructor(options?: InteractiveBrowserCredentialOptions) {\n    options = {\n      ...IdentityClient.getDefaultOptions(),\n      ...options,\n      tenantId: (options && options.tenantId) || DefaultTenantId,\n      // TODO: temporary - this is the Azure CLI clientID - we'll replace it when\n      // Developer Sign On application is available\n      // https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/identity/Azure.Identity/src/Constants.cs#L9\n      clientId: (options && options.clientId) || DeveloperSignOnClientId\n    };\n\n    this.loginStyle = options.loginStyle || \"popup\";\n    if ([\"redirect\", \"popup\"].indexOf(this.loginStyle) === -1) {\n      throw new Error(`Invalid loginStyle: ${options.loginStyle}`);\n    }\n\n    this.msalConfig = {\n      auth: {\n        clientId: options.clientId!, // we just initialized it above\n        authority: `${options.authorityHost}/${options.tenantId}`,\n        ...(options.redirectUri && { redirectUri: options.redirectUri }),\n        ...(options.postLogoutRedirectUri && { redirectUri: options.postLogoutRedirectUri })\n      },\n      cache: {\n        cacheLocation: \"localStorage\",\n        storeAuthStateInCookie: true\n      }\n    };\n\n    this.msalObject = new msal.UserAgentApplication(this.msalConfig);\n  }\n\n  private login(): Promise<msal.AuthResponse> {\n    switch (this.loginStyle) {\n      case \"redirect\": {\n        const loginPromise = new Promise<msal.AuthResponse>((resolve, reject) => {\n          this.msalObject.handleRedirectCallback(resolve, reject);\n        });\n        this.msalObject.loginRedirect();\n        return loginPromise;\n      }\n      case \"popup\":\n        return this.msalObject.loginPopup();\n    }\n  }\n\n  private async acquireToken(\n    authParams: msal.AuthenticationParameters\n  ): Promise<msal.AuthResponse | undefined> {\n    let authResponse: msal.AuthResponse | undefined;\n    try {\n      logger.info(\"InteractiveBrowserCredential: attempting to acquire token silently\");\n      authResponse = await this.msalObject.acquireTokenSilent(authParams);\n    } catch (err) {\n      if (err instanceof msal.AuthError) {\n        switch (err.errorCode) {\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"login_required\":\n            logger.warning(\n              `InteractiveBrowserCredential: authentication returned errorCode ${err.errorCode}`\n            );\n            break;\n          default:\n            logger.warning(`InteractiveBrowserCredential: failed to acquire token: ${err}`);\n            throw err;\n        }\n      }\n    }\n\n    let authPromise: Promise<msal.AuthResponse> | undefined;\n    if (authResponse === undefined) {\n      logger.warning(\n        `InteractiveBrowserCredential: silent authentication failed, falling back to interactive method ${this.loginStyle}`\n      );\n      switch (this.loginStyle) {\n        case \"redirect\":\n          authPromise = new Promise((resolve, reject) => {\n            this.msalObject.handleRedirectCallback(resolve, reject);\n          });\n          this.msalObject.acquireTokenRedirect(authParams);\n          break;\n        case \"popup\":\n          authPromise = this.msalObject.acquireTokenPopup(authParams);\n          break;\n      }\n\n      authResponse = authPromise && (await authPromise);\n    }\n\n    return authResponse;\n  }\n\n  /**\n   * Authenticates with Azure Active Directory and returns an {@link AccessToken} if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes The list of scopes for which the token will have access.\n   * @param options The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  async getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    const { span } = createSpan(\"InteractiveBrowserCredential-getToken\", options);\n    try {\n      if (!this.msalObject.getAccount()) {\n        await this.login();\n      }\n\n      const authResponse = await this.acquireToken({\n        scopes: Array.isArray(scopes) ? scopes : scopes.split(\",\")\n      });\n\n      if (authResponse) {\n        return {\n          token: authResponse.accessToken,\n          expiresOnTimestamp: authResponse.expiresOn.getTime()\n        };\n      } else {\n        return null;\n      }\n    } catch (err) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport qs from \"qs\";\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-http\";\nimport { IdentityClientOptions, IdentityClient } from \"../client/identityClient\";\nimport { createSpan } from \"../util/tracing\";\nimport { AuthenticationErrorName } from \"../client/errors\";\nimport { CanonicalCode } from \"@azure/core-tracing\";\n\n/**\n * Enables authentication to Azure Active Directory with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n */\nexport class UsernamePasswordCredential implements TokenCredential {\n  private identityClient: IdentityClient;\n  private tenantId: string;\n  private clientId: string;\n  private username: string;\n  private password: string;\n\n  /**\n   * Creates an instance of the UsernamePasswordCredential with the details\n   * needed to authenticate against Azure Active Directory with a username\n   * and password.\n   *\n   * @param tenantIdOrName The Azure Active Directory tenant (directory) ID or name.\n   * @param clientId The client (application) ID of an App Registration in the tenant.\n   * @param username The user account's e-mail address (user name).\n   * @param password The user account's account password\n   * @param options Options for configuring the client which makes the authentication request.\n   */\n  constructor(\n    tenantIdOrName: string,\n    clientId: string,\n    username: string,\n    password: string,\n    options?: IdentityClientOptions\n  ) {\n    this.identityClient = new IdentityClient(options);\n    this.tenantId = tenantIdOrName;\n    this.clientId = clientId;\n    this.username = username;\n    this.password = password;\n  }\n\n  /**\n   * Authenticates with Azure Active Directory and returns an {@link AccessToken} if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes The list of scopes for which the token will have access.\n   * @param options The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  public async getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    const { span, options: newOptions } = createSpan(\n      \"UsernamePasswordCredential-getToken\",\n      options\n    );\n    try {\n      const webResource = this.identityClient.createWebResource({\n        url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,\n        method: \"POST\",\n        disableJsonStringifyOnBody: true,\n        deserializationMapper: undefined,\n        body: qs.stringify({\n          response_type: \"token\",\n          grant_type: \"password\",\n          client_id: this.clientId,\n          username: this.username,\n          password: this.password,\n          scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \")\n        }),\n        headers: {\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        abortSignal: options && options.abortSignal,\n        spanOptions: newOptions.spanOptions\n      });\n\n      const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n      return (tokenResponse && tokenResponse.accessToken) || null;\n    } catch (err) {\n      const code =\n        err.name === AuthenticationErrorName\n          ? CanonicalCode.UNAUTHENTICATED\n          : CanonicalCode.UNKNOWN;\n      span.setStatus({\n        code,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { TokenCredential } from \"@azure/core-http\";\nimport { DefaultAzureCredential } from \"./credentials/defaultAzureCredential\";\n\nexport { ChainedTokenCredential } from \"./credentials/chainedTokenCredential\";\nexport { IdentityClientOptions } from \"./client/identityClient\";\nexport { EnvironmentCredential } from \"./credentials/environmentCredential\";\nexport { ClientSecretCredential } from \"./credentials/clientSecretCredential\";\nexport { ClientCertificateCredential } from \"./credentials/clientCertificateCredential\";\nexport { InteractiveBrowserCredential } from \"./credentials/interactiveBrowserCredential\";\nexport {\n  InteractiveBrowserCredentialOptions,\n  BrowserLoginStyle\n} from \"./credentials/interactiveBrowserCredentialOptions\";\nexport { ManagedIdentityCredential } from \"./credentials/managedIdentityCredential\";\nexport {\n  DeviceCodeCredential,\n  DeviceCodePromptCallback,\n  DeviceCodeInfo\n} from \"./credentials/deviceCodeCredential\";\n\nexport { DefaultAzureCredential } from \"./credentials/defaultAzureCredential\";\nexport { UsernamePasswordCredential } from \"./credentials/usernamePasswordCredential\";\nexport { AuthorizationCodeCredential } from \"./credentials/authorizationCodeCredential\";\nexport {\n  AuthenticationError,\n  ErrorResponse,\n  AggregateAuthenticationError,\n  AuthenticationErrorName,\n  AggregateAuthenticationErrorName\n} from \"./client/errors\";\n\nexport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-http\";\nexport { logger } from \"./util/logging\";\n\n/**\n * Returns a new instance of the {@link DefaultAzureCredential}.\n */\nexport function getDefaultAzureCredential(): TokenCredential {\n  return new DefaultAzureCredential();\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","TypeError","pop","push","__values","o","m","__read","r","ar","error","__spread","concat","AuthenticationErrorName","AuthenticationError","Error","[object Object]","statusCode","errorBody","errorResponse","errorDescription","error_description","isErrorResponse","convertOAuthErrorResponseToErrorResponse","JSON","parse","super","stringify","name","AggregateAuthenticationErrorName","AggregateAuthenticationError","errors","join","correlationId","correlation_id","errorCodes","error_codes","timestamp","traceId","trace_id","NoOpSpan","spanId","_endTime","_key","_value","_attributes","_name","_spanContext","_status","NoOpBinaryFormat","ArrayBuffer","_buffer","NoOpHttpTextFormat","_format","_carrier","NoOpTracer","_options","_span","fn","target","cache","CanonicalCode","SpanKind","TraceFlags","GLOBAL_TRACER_VERSION","GLOBAL_TRACER_SYMBOL","for","loadTracerCache","globalObj","self","existingCache","version","tracer","undefined","getCache","getTracer","VERSION","createSpan","operationName","options","spanOptions","kind","CLIENT","span","startSpan","setAttribute","newOptions","isRecordingEvents","parent","ChainedTokenCredential","sources","_sources","scopes","token","getToken","err","setStatus","code","UNAUTHENTICATED","message","end","BrowserNotSupportedError","EnvironmentCredential","ManagedIdentityCredential","clientIdOrOptions","DefaultAzureCredential","identityClientOptions","has","isArray","hexTable","array","toString","toUpperCase","arrayToObject","source","obj","plainObjects","keys","reduce","acc","key","combine","a","compact","queue","prop","refs","item","j","val","indexOf","compacted","compactQueue","decode","str","decoder","charset","strWithoutPlus","replace","unescape","decodeURIComponent","encode","defaultEncoder","string","String","escape","$0","parseInt","slice","out","c","charCodeAt","charAt","isBuffer","isRegExp","merge","allowPrototypes","mergeTarget","forEach","targetItem","percentTwenties","Format","RFC1738","RFC3986","util","default","formatters","arrayPrefixGenerators","brackets","prefix","comma","indices","repeat","pushToArray","arr","valueOrArray","toISO","Date","toISOString","defaultFormat","formats","defaults","addQueryPrefix","allowDots","charsetSentinel","delimiter","encoder","utils","encodeValuesOnly","format","formatter","serializeDate","date","skipNulls","strictNullHandling","object","generateArrayPrefix","filter","sort","objKeys","values","arrayLimit","depth","ignoreQueryPrefix","interpretNumericEntities","parameterLimit","parseArrays","numberStr","fromCharCode","parseKeys","givenKey","child","segment","exec","index","chain","leaf","root","cleanRoot","isNaN","0","parseObject","opts","normalizeParseOptions","tempObj","cleanStr","limit","Infinity","parts","split","skipIndex","part","bracketEqualsPos","pos","parseValues","newObj","normalizeStringifyOptions","arrayFormat","joined","getHeaderKey","headerName","toLowerCase","rawHeaders","_headersMap","set","HttpHeaders","headerValue","header","contains","headerKey","headers","headerNames","headersArray","headerValues","toJson","encodeByteArray","btoa","decodeString","byteString","atob","Uint8Array","getRandomValues","crypto","bind","window","msCrypto","rnds8","module","rnds","Math","random","byteToHex","substr","buf","offset","bth","rng","ii","bytesToUuid","Constants","coreHttpVersion","HTTP","HTTPS","HTTP_PROXY","HTTPS_PROXY","HttpConstants","HttpVerbs","PUT","GET","DELETE","POST","MERGE","HEAD","PATCH","StatusCodes","TooManyRequests","HeaderConstants","AUTHORIZATION","AUTHORIZATION_SCHEME","RETRY_AFTER","USER_AGENT","validUuidRegex","process","versions","node","stripResponse","response","strippedResponse","bodyAsText","status","stripRequest","request","strippedRequest","clone","remove","generateUuid","uuidv4","delay","setTimeout","validateISODuration","replaceAll","searchValue","replaceValue","modelMappers","isXML","Serializer","mapper","objectName","failValidation","constraintName","constraintValue","constraints","_a","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","pattern","RegExp","match","some","payload","mapperType","type","serializedName","isConstant","defaultValue","required","nullable","validateConstraints","typeName","valueOf","uuid","test","objectType","isView","Blob","serializeBasicTypes","allowedValues","serializeEnumType","substring","toUTCString","floor","getTime","dateToUnixTime","utils.isDuration","serializeDateTypes","base64.encodeByteArray","serializeByteArrayType","buffer","ch","len","trimEnd","bufferToBase64Url","serializeBase64UrlType","serializer","elementType","element","tempArray","serialize","serializeSequenceType","valueType","tempDictionary","_i","serializeDictionaryType","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","modelProps","resolveModelProperties","_b","propertyMapper","readOnly","propName","parentObject","xmlIsWrapped","xmlName","xmlElementName","paths","splitSerializeName","paths_1","_c","pathName","propertyObjectName","toSerialize","polymorphicDiscriminator","clientName","serializedValue","xmlIsAttribute","$","additionalPropertiesMapper","additionalProperties","propNames","clientPropName","every","pn","serializeCompositeType","responseBody","instance","handledPropertyNames","headerCollectionPrefix","dictionary","startsWith","deserialize","unwrappedProperty","propertyInstance","res","paths_2","_d","isAdditionalProperty","responsePropName","_f","_e","includes","isSpecialXmlProperty","deserializeCompositeType","parseFloat","unixTimeToDate","base64.decodeString","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","classes","partialclass","subwords_1","modelProperties","className","modelMapper","propertyName","polymorphicPropertyName","discriminatorName","discriminatorValue","uberParent","indexDiscriminator","polymorphicMapper","discriminators","getPolymorphicDiscriminatorSafely","MapperType","o_1","strEnum","url","method","query","streamResponseBody","withCredentials","abortSignal","timeout","onUploadProgress","onDownloadProgress","proxySettings","keepAlive","formData","WebResource","pathTemplate","validMethods","pathTemplate_1","pathParameters_1","baseUrl","url_1","endsWith","segments","pathParamName","pathParam","stringifiedPathParameters","encodeURIComponent","skipUrlEncoding","queryParameters","queryParams","queryParamName","queryParam","get","disableClientRequestId","bodyIsStream","serializationMapper","mappers","disableJsonStringifyOnBody","operationSpec","shouldDeserialize","operationResponseGetter","listenersMap","WeakMap","abortedMap","AbortSignal","_type","listener","listeners","splice","event","signal","aborted","onabort","HttpPipelineLogLevel","_super","_this","tslib_1.__extends","parentSignals","_signal","parentSignals_1","parentSignal","abort","addEventListener","AbortController","ms","timer","unref","RestError","XhrHttpClient","xhr","XMLHttpRequest","AbortError","listener_1","readyState","DONE","removeEventListener","addProgressListener","upload","requestForm_1","FormData","appendFormValue","append","formKey","formValue","contentType","open","setRequestHeader","responseType","send","HEADERS_RECEIVED","blobBody","rejectOnTerminalEvent","parseHeaders","responseText","rawEvent","loadedBytes","loaded","responseHeaders","headerLines_1","getAllResponseHeaders","trim","line","REQUEST_SEND_ERROR","URLQuery","_rawQuery","parameterName","parameterValue","newValue","parameterStrings","parameterValue_1","parameterValueElement","text","currentState","currentCharacter","URLBuilder","scheme","_scheme","host","_host","port","_port","path","_path","currentPath","getPath","_query","queryParameterName","queryParameterValue","startState","tokenizer","URLTokenizer","current","tokenPath","any","setScheme","getScheme","setHost","getHost","setPort","getPort","setPath","setQuery","getQuery","URLToken","_text","state","_textLength","_currentState","_currentIndex","_currentToken","hasCurrentCharacter","readWhile","character","characterCode","isAlphaNumericCharacter","readWhileLetterOrDigit","schemeOrHost","readUntilCharacter","getCurrentCharacter","peekCharacters","nextSchemeOrHost","nextCharacter","nextHost","nextPort","nextPath","readRemaining","nextQuery","charactersToPeek","endIndex","condition","terminatingCharacters","_nextPolicy","BaseRequestPolicy","logLevel","shouldLog","log","_logger","RequestPolicyOptions","OFF","minimumLogLevel","logFunction","console","debug","enabledString","debugEnvVariable","env","DEBUG","enabledNamespaces","skippedNamespaces","debuggers","enable","namespaces","wildcard","namespaceList","map","ns","namespaceList_1","debuggers_1","enabled","namespace","skippedNamespaces_1","enabledNamespaces_1","createDebugger","newDebugger","args","destroy","debugObj","extend","azureLogLevel","disable","registeredLoggers","Set","logLevelFromEnv","AZURE_LOG_LEVEL","AzureLogger","AZURE_LOG_LEVELS","isAzureLogLevel","level","registeredLoggers_1","logger","shouldEnable","setLogLevel","levelMap","verbose","info","warning","createClientLogger","clientRootLogger","patchLogMethod","createLogger","add","defaultAllowedHeaderNames","defaultAllowedQueryParameters","nextPolicy","allowedHeaderNames","allowedQueryParameters","LogPolicy","logRequest","sendRequest","logResponse","sanitize","sanitizeHeaders","sanitizeUrl","sanitizeQuery","sanitizeObject","k","allowedKeys","accessor","sanitized","urlBuilder","queryString","getPathStringFromParameter","parameter","getPathStringFromParameterPath","parameterPath","isStreamOperation","responses","operationResponse","bodyMapper","Stream","doc","document","implementation","createDocument","parser","DOMParser","parseXML","dom","parseFromString","errorNS","parserErrors","getElementsByTagNameNS","innerHTML","throwIfError","includeRoot","domToObject","childNodes","getElementsByTagName","namespaceURI","ignored","childNodeCount","firstChildNode","onlyChildTextValue","nodeType","Node","TEXT_NODE","nodeValue","elementWithAttributes","attributes","isElement","hasAttributes","asElementWithAttributes","attr","nodeName","childObject","XMLSerializer","stringifyXML","content","buildNode","elementName","elem","createElement","textContent","obj_1","arrayElem","buildAttributes","setNamedItem","_h","_g","appendChild","rootName","serializeToString","attrs","createAttribute","defaultJsonContentTypes","defaultXmlContentTypes","deserializationContentTypes","jsonContentTypes","json","xmlContentTypes","xml","DeserializationPolicy","errorHandler","msg","errCode","PARSE_ERROR","text_1","contentComponents","component","parsedBody","catch","parsedResponse","shouldDeserializeResponse","expectedStatusCodes","hasNoExpectedStatusCodes","responseSpec","getOperationResponse","valueToDeserialize","Sequence","restError","utils.stripRequest","utils.stripResponse","httpMethod","headersMapper","parsedHeaders","defaultResponseSpec","initialErrorMessage","parsedErrorResponse","defaultResponseBodyMapper","internalError","defaultError","deserializeResponseBody","RetryMode","DEFAULT_CLIENT_RETRY_INTERVAL","DEFAULT_CLIENT_RETRY_COUNT","DEFAULT_CLIENT_MAX_RETRY_INTERVAL","retryCount","retryInterval","maxRetryInterval","isNumber","ExponentialRetryPolicy","retry","policy","retryData","requestError","innerError","incrementDelta","pow","min","updateRetryData","isAborted","shouldRetry","utils\n            .delay","_requestIdHeaderName","GenerateClientRequestIdPolicy","utils.generateUuid","getDefaultUserAgentKey","getDefaultUserAgentHeaderName","getDefaultUserAgentValue","navigator","telemetryInfo","keySeparator","valueSeparator","runtimeInfo","platformSpecificData","oscpu","platform","UserAgentPolicy","addUserAgentHeader","maxRetries","RedirectPolicy","handleRedirect","currentRetries","locationHeader","builder","_retryTimeout","RPRegistrationPolicy","rpName","matchRes","checkRPNotRegisteredError","urlPrefix","extractSubscriptionUrl","provider","originalRequest","postUrl","getUrl","reqOptions","getRequestEssentials","getRegistrationStatus","registrationState","utils\n                .delay","registerRP","registrationStatus","registerIfNeeded","reuseUrlToo","TokenRefreshBufferMs","tokenRefreshBufferMs","ExpiringAccessTokenCache","accessToken","cachedToken","now","expiresOnTimestamp","credential","tokenCache","BearerTokenAuthenticationPolicy","webResource","getCachedToken","setCachedToken","QueryCollectionFormat","minRetryInterval","DEFAULT_CLIENT_MIN_RETRY_INTERVAL","SystemErrorRetryPolicy","boundedRandDelta","currentCount","proxyNotSupportedInBrowser","ProxyPolicy","_request","_handleResponse","_defaultResponseHandler","ThrottlingRetryPolicy","httpRequest","httpResponse","retryAfterHeader","delayInMs","parseRetryAfterHeader","retryAfterInSeconds","Number","parseDateRetryAfterHeader","diff","authenticationProvider","SigningPolicy","signRequest","nextRequest","TracingPolicy","spanContext","context","traceParentHeader","missingFields","hexFlags","traceFlags","UNSAMPLED","getTraceParentHeader","traceState","err_1","credentials","requestPolicyFactories","bearerTokenPolicyFactory","serviceClient","_withCredentials","_httpClient","httpClient","DefaultHttpClient","_requestPolicyOptions","httpPipelineLogger","authPolicyFactory","bearerTokenAuthenticationPolicy","baseUri","factories","generateClientRequestIdHeader","requestIdHeaderName","clientRequestIdHeaderName","userAgentHeaderName","getValueOrFunctionResult","userAgentHeaderValue","userAgent","userAgentData","maximumRetries","redirectPolicy","retryTimeout","rpRegistrationPolicy","rpRegistrationRetryTimeout","noRetryPolicy","systemErrorRetryPolicy","deserializationPolicy","getDefaultProxySettings","logOptions","coreLogger","logPolicy","createDefaultRequestPolicyFactories","newRequestPolicyFactories","_requestPolicyFactories","ServiceClient","validateRequestProperties","prepare","httpPipeline","operationArguments","callback","requestUrl","appendPath","urlParameters","urlParameter","urlParameterValue","getOperationArgumentValueFromParameter","skipEncoding","queryParameter","collectionFormat","Multi","setQueryParameter","requestContentType","headerParameters","headerParameter","customHeaders","customHeaderName","requestBody","requestBodyParameterPathString","isStream","utils.prepareXMLRootList","formDataParameters","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializeRequestBody","rawResponse","sendRequestError","error_1","details","flattenResponse","error_2","cb","_response","defaultValueCreator","getOperationArgumentValueFromParameterPath","parameterMapper","propertySearchResult","getPropertyFromParameterPath","propertyFound","useDefaultValue","propertyValue","parameterPathString","propertyPath","propertyPathString","parameterPathPart","addOperationResponse","defineProperty","readableStreamBody","modelProperties_1","isPageableResponse","arrayResponse","DefaultAuthorityHost","IdentityClient","getDefaultOptions","authorityHost","requestOptions","expiresOnParser","expires_in","access_token","refreshToken","refresh_token","tenantId","clientId","clientSecret","refreshParams","grant_type","client_id","scope","client_secret","createWebResource","deserializationMapper","qs","Accept","Content-Type","sendTokenRequest","UNKNOWN","CryptoUtils","cryptoObj","decimalToHex","guidHolder","hex","guidResponse","num","input","p1","pl","search","_popUpWidth","width","_popUpHeight","height","CacheKeys","AADTrustedHostList","login.windows.net","login.chinacloudapi.cn","login.cloudgovapi.us","login.microsoftonline.com","login.microsoftonline.de","login.microsoftonline.us","SSOTypes","BlacklistedEQParams","PromptState","LOGIN","SELECT_ACCOUNT","CONSENT","NONE","ScopeSet","cachedScopes","convertToLowerCase","scopeList","StringUtils","UrlUtils","serverRequestParams","createNavigationUrlString","authEndpoint","authorityInstance","AuthorizationEndpoint","translateclientIdUsedInScope","parseScope","redirectUri","nonce","xClientSku","xClientVer","promptValue","claimsValue","extraQueryParameters","clientIdIndex","location","href","urlObject","GetUrlComponents","pathArray","PathSegments","common","constructAuthorityUriFromObject","CanonicalizeUri","Protocol","HostNameAndPort","regEx","urlComponents","AbsolutePath","pathSegments","suffix","isEmpty","regex","urlStringOrFragment","hashIndex1","hashIndex2","authority","uid","utid","homeAccountIdentifier","base64Encode","idToken","expiresIn","AuthErrorMessage","desc","errorCode","errorMessage","AuthError","errDesc","ClientAuthErrorMessage","ClientAuthError","errDetail","invalidState","actualState","invalidNonce","actualNonce","errorDesc","caughtError","invalidRawTokenString","caughtParsingError","incorrectlyEncodedToken","ClientConfigurationErrorMessage","configurationNotSet","invalidCacheLocation","noStorageSupported","noRedirectCallbacksSet","invalidCallbackObject","scopesRequired","emptyScopes","nonArrayScopes","clientScope","invalidPrompt","invalidAuthorityType","authorityUriInsecure","authorityUriInvalidPath","unsupportedAuthorityValidation","b2cAuthorityUriInvalidPath","claimsRequestParsingError","emptyRequestError","telemetryConfigError","ClientConfigurationError","givenCacheLocation","cacheLocationLocal","cacheLocationSession","callbackObject","scopesValue","claimsRequestParseError","config","requiredKeys","applicationName","applicationVersion","telemetryEmitter","AuthorityType","createNewGuid","ServerRequestParameters","CanonicalAuthority","account","adalIdTokenObject","eQParams","prompt","validatePromptParameter","claimsRequest","createClaimsRequestParsingError","validateClaimsRequest","isSSOParam","constructUnifiedCacheQueryParameter","addHintParameters","sanitizeEQParams","generateQueryParametersString","createInvalidPromptError","idTokenObject","ssoType","ssoData","serverReqParam","sid","userName","loginHint","upn","addSSOParameter","qParams","ssoParam","homeAccountId","base64Decode","consumersUtid","claims","param","paramsString","rawClientInfo","decodedClientInfo","clientInfo","createClientInfoDecodingError","ClientInfo","_uid","_utid","TokenUtils","jwtToken","matches","JWSPayload","JWSSig","encodedIdToken","decodedToken","decodeJwt","base64IdToken","base64Decoded","rawIdToken","createIdTokenNullOrEmptyError","extractIdToken","issuer","objectId","subject","preferredName","expiration","homeObjectId","createIdTokenParsingError","cacheLocation","Storage","localStorageSupported","sessionStorageSupported","createNoStorageSupportedError","enableCookieStorage","setItem","setItemCookie","getItemCookie","getItem","removeItem","clear","accessTokenCacheItem","results","storage","AccessTokenCacheItem","splitKey","resourceDelimiter","state_1","tokenRenewalInProgress","renewStatus","stateLogin","stateAcquireToken","clearCookie","stateValue","tokenRenewStatusInProgress","msal","removeAcquireTokenEntries","cName","cValue","expires","cookieStr","getCookieExpirationTime","cookie","ca","cookieLifeDays","today","nonceIdToken","loginRequest","accountId","accountIdentifier","idTokenClaims","environment","Account","a1","a2","TimeUtils","round","ResponseUtils","originalResponse","idTokenObj","exp","expiresOn","uniqueId","XhrClient","enableCaching","onload","ev","handleError","jsonResponse","onerror","LogLevel","validateAuthority","AadAuthority","AadInstanceDiscoveryEndpoint","Aad","resultPromise","DefaultOpenIdConfigurationEndpoint","IsValidationEnabled","CanonicalAuthorityUrlComponents","IsInTrustedHostList","sendRequestAsync","AadInstanceDiscoveryEndpointUrl","tenant_discovery_endpoint","validateAsUri","Authority","validateResolved","tenantDiscoveryResponse","Tenant","EndSessionEndpoint","Issuer","canonicalAuthority","canonicalAuthorityUrlComponents","components","openIdConfigurationEndpoint","authorization_endpoint","end_session_endpoint","GetOpenIdConfigurationEndpointAsync","openIdConfigurationEndpointResponse","DiscoverEndpoints","B2cAuthority","B2C","AuthorityFactory","authorityUrl","Adfs","DetectAuthorityFromUrl","localCallback","Info","piiLoggingEnabled","Logger","logMessage","containsPii","executeCallback","Warning","Verbose","DEFAULT_AUTH_OPTIONS","getDefaultRedirectUri","postLogoutRedirectUri","navigateToLoginRequestUrl","DEFAULT_CACHE_OPTIONS","storeAuthStateInCookie","DEFAULT_SYSTEM_OPTIONS","loadFrameTimeout","tokenRenewalOffsetSeconds","navigateFrameWait","DEFAULT_FRAMEWORK_OPTIONS","isAngular","unprotectedResources","protectedResourceMap","Map","ServerErrorMessage","ServerError","InteractionRequiredAuthErrorMessage","InteractionRequiredAuthError","errorString","interactionRequiredCodes","buildResponseStateOnly","tokenType","accountState","EVENT_NAME_KEY","START_TIME_KEY","ELAPSED_TIME_KEY","TELEMETRY_BLOB_EVENT_NAMES","MsalCorrelationIdConstStrKey","ApiTelemIdConstStrKey","ApiIdConstStrKey","BrokerAppConstStrKey","CacheEventCountConstStrKey","HttpEventCountTelemetryBatchKey","IdpConstStrKey","IsSilentTelemetryBatchKey","IsSuccessfulConstStrKey","ResponseTimeConstStrKey","TenantIdConstStrKey","UiEventCountTelemetryBatchKey","prependEventNamePrefix","eventCount","sdk","sdkVersion","getEventCount","DefaultEvent","eventName","startTimestamp","eventId","TelemetryEvent","time","setElapsedTime","createEventKey","telemetryCorrelationId","telemetryPlatform","onlySendFailureTelemetry","TelemetryManager","eventKey","inProgressEvents","stop","incrementEventCount","completedEvents","orphanedEvents","getOrphanedEvents","eventsToFlush","eventCountsToFlush","eventCountByCorrelationId","defaultEvent","eventsWithDefaultEvent","memo","event_1","DEFAULT_AUTHORITY","ResponseTypes","resolveTokenOnlyIfOutOfIframe","propertyKey","descriptor","tokenAcquisitionMethod","isInIframe","configuration","auth","system","framework","buildConfiguration","redirectCallbacksSet","inCookie","telemetryManager","getTelemetryManagerFromConfig","telemetry","loginInProgress","acquireTokenInProgress","cacheStorage","createInvalidCacheLocationConfigError","openedWindows","activeRenewals","renewStates","callbackMappedToRenewStates","promiseMappedToRenewStates","urlHash","hash","urlContainsHash","handleAuthenticationResponse","UserAgentApplication","CreateInstance","authOrTokenCallback","errorReceivedCallback","createInvalidCallbackObjectError","tokenReceivedCallback","authResponseCallback","cachedHash","processCallBack","interactionType","interactionTypeRedirect","interactionTypePopup","createInvalidInteractionTypeError","authErr","createRedirectCallbacksNotSetError","acquireTokenInteractive","createEmptyRequestError","isLoginCall","thrownError","createLoginInProgressError","createAcquireTokenInProgressError","stateOnlyResponse","getAccountState","authErrorHandler","appendScopes","validateInputScope","getAccount","acquireTokenHelper","createUserLoginRequiredError","extractADALIdToken","tokenRequest","buildIDTokenRequest","silentLogin","acquireTokenSilent","authResponseHandler","serverAuthenticationRequest","popUpWindow","acquireTokenAuthority","openWindow","resolveEndpointsAsync","loginStartPage","getTokenType","angularLoginRequest","getRedirectUri","updateCacheEntries","populateQueryParams","urlNavigate","createNavigateUrl","response_mode_fragment","requestType","login","renewToken","registerCallback","navigateWindow","createEndpointResolutionError","close","adalIdToken","cacheResultResponse","userContainedClaims","forceRefresh","infoPii","renewIdToken","title","interval","popupWindow","openPopup","popUpWidth","popUpHeight","msalError","msalErrorDescription","createPopupWindowError","pollTimer","setInterval","closed","createUserCancelledError","clearInterval","broadcast","popUpWindowLocation","winLeft","screenLeft","screenX","winTop","screenTop","screenY","innerWidth","documentElement","clientWidth","innerHeight","clientHeight","left","top_1","focus","frameName","expectedState","loadFrame","createTokenRenewalTimeoutError","tokenRenewStatusCancelled","frameCheck","frameHandle","addHiddenIFrame","src","iframeId","adalFrame","getElementById","ifr","style","visibility","position","border","insertAdjacentHTML","frames","createUnexpectedError","clearCache","logout","getPostLogoutRedirectUri","accessTokenItems","getAllAccessTokens","resetCacheItems","urlString","parameters","deserializeHash","stateInfo","parentCallback","getResponseState","saveTokenFromHash","createErrorInCallbackFunction","isPopup","isWindowOpenerMsal","opener","tokenResponseCallback","parentIsMsal","urlFragment","getHashFromUrl","stateResponse","unknown","stateMatch","silentAuthenticationState","statesInParentContext","tokenCacheItems","filteredItems","cacheItem","containsScope","createMultipleMatchingTokensInCacheError","authorityList","getUniqueAuthority","createMultipleAuthoritiesInCacheError","expired","IdToken","aState","setResponseIdToken","accessTokenCacheItems","property","flags","urlRemoveQueryStringParameter","prompt_none","loadIframeTimeout","accessTokenResponse","clientObj","consentedScopes","isIntersectingScopes","parseExpiresIn","accessTokenKey","AccessTokenKey","accessTokenValue","AccessTokenValue","hashParams","authorityKey","acquireTokenAccountKey","loginError","generateAuthorityKey","no_account","generateAcquireTokenAccountKey","hashErr","hashErrDesc","isInteractionRequiredError","sessionState","msalSessionState","idTokenKey","authorityKey_1","replaceTenantPath","createClientInfoNotPopulatedError","createAccount","accountKey","acquireTokenAccountKey_noaccount","cachedAccount","acquireTokenAccount","saveAccessToken","compareAccounts","createNonceMismatchError","msalClientInfo","createInvalidIdTokenError","createInvalidStateError","tokenRenewStatusCompleted","splitIndex","accounts","getUniqueAccounts","uniqueAccounts","createScopesNonArrayError","createEmptyScopesArrayError","createClientIdSingleScopeError","createScopesRequiredError","extraScopesToConsent","data","evt","CustomEvent","detail","dispatchEvent","accountObject","newAuthority","endpoint","size","from","getHostFromUri","createNoSetConfigurationError","uri","extractedUri","silentCall","getAccountId","setAccountCache","setAuthorityCache","createTelemetryConfigError","decorators","getOwnPropertyDescriptor","Reflect","decorate","tslib_1.__decorate","DeveloperSignOnClientId","DefaultTenantId","clientSecretOrAuthorizationCode","authorizationCodeOrRedirectUri","redirectUriOrOptions","certificatePath","identityClient","response_type","tokenResponse","userPromptCallback","loginStyle","msalConfig","msalObject","msal.UserAgentApplication","loginPromise","handleRedirectCallback","loginRedirect","loginPopup","authParams","authResponse","authPromise","msal.AuthError","acquireTokenRedirect","acquireTokenPopup","acquireToken","tenantIdOrName","username","password"],"mappings":"iOAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAGrB,SAASO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GAG5E,IAAIK,EAAW,WAQlB,OAPAA,EAAWZ,OAAOa,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAIZ,KADTW,EAAIG,UAAUF,GACOhB,OAAOU,UAAUL,eAAee,KAAKL,EAAGX,KAAIU,EAAEV,GAAKW,EAAEX,IAE9E,OAAOU,IAEKO,MAAMb,KAAMU,YA8BzB,SAASI,EAAUC,EAASC,EAAYC,EAAGC,GAC9C,OAAO,IAAKD,IAAMA,EAAIE,UAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,IAAW,MAAOG,GAAKL,EAAOK,IACpF,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,IAAW,MAAOG,GAAKL,EAAOK,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOL,OAAS,IAAIN,EAAE,SAAUG,GAAWA,EAAQQ,EAAOL,SAAWO,KAAKR,EAAWK,GACnIH,GAAMN,EAAYA,EAAUL,MAAME,EAASC,GAAc,KAAKS,UAI/D,SAASM,EAAYhB,EAASiB,GACjC,IAAsGC,EAAGC,EAAG5B,EAAG6B,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAPhC,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOiC,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAEV,KAAMgB,EAAK,GAAIC,MAASD,EAAK,GAAIE,OAAUF,EAAK,IAAwB,mBAAXG,SAA0BT,EAAES,OAAOC,UAAY,WAAa,OAAO7C,OAAUmC,EACvJ,SAASM,EAAKhC,GAAK,OAAO,SAAUqC,GAAK,OACzC,SAAcC,GACV,GAAId,EAAG,MAAM,IAAIe,UAAU,mCAC3B,KAAOZ,GAAG,IACN,GAAIH,EAAI,EAAGC,IAAM5B,EAAY,EAARyC,EAAG,GAASb,EAAU,OAAIa,EAAG,GAAKb,EAAS,SAAO5B,EAAI4B,EAAU,SAAM5B,EAAEM,KAAKsB,GAAI,GAAKA,EAAET,SAAWnB,EAAIA,EAAEM,KAAKsB,EAAGa,EAAG,KAAKlB,KAAM,OAAOvB,EAE3J,OADI4B,EAAI,EAAG5B,IAAGyC,EAAK,CAAS,EAARA,EAAG,GAAQzC,EAAEiB,QACzBwB,EAAG,IACP,KAAK,EAAG,KAAK,EAAGzC,EAAIyC,EAAI,MACxB,KAAK,EAAc,OAAXX,EAAEC,QAAgB,CAAEd,MAAOwB,EAAG,GAAIlB,MAAM,GAChD,KAAK,EAAGO,EAAEC,QAASH,EAAIa,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKX,EAAEI,IAAIS,MAAOb,EAAEG,KAAKU,MAAO,SACxC,QACI,KAAkB3C,GAAZA,EAAI8B,EAAEG,MAAY5B,OAAS,GAAKL,EAAEA,EAAEK,OAAS,MAAkB,IAAVoC,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEX,EAAI,EAAG,SACjG,GAAc,IAAVW,EAAG,MAAczC,GAAMyC,EAAG,GAAKzC,EAAE,IAAMyC,EAAG,GAAKzC,EAAE,IAAM,CAAE8B,EAAEC,MAAQU,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYX,EAAEC,MAAQ/B,EAAE,GAAI,CAAE8B,EAAEC,MAAQ/B,EAAE,GAAIA,EAAIyC,EAAI,MAC7D,GAAIzC,GAAK8B,EAAEC,MAAQ/B,EAAE,GAAI,CAAE8B,EAAEC,MAAQ/B,EAAE,GAAI8B,EAAEI,IAAIU,KAAKH,GAAK,MACvDzC,EAAE,IAAI8B,EAAEI,IAAIS,MAChBb,EAAEG,KAAKU,MAAO,SAEtBF,EAAKf,EAAKpB,KAAKG,EAASqB,GAC1B,MAAOV,GAAKqB,EAAK,CAAC,EAAGrB,GAAIQ,EAAI,UAAeD,EAAI3B,EAAI,EACtD,GAAY,EAARyC,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAExB,MAAOwB,EAAG,GAAKA,EAAG,QAAK,EAAQlB,MAAM,GArB9BL,CAAK,CAACf,EAAGqC,MA6BtD,SAASK,EAASC,GACrB,IAAIC,EAAsB,mBAAXT,QAAyBQ,EAAER,OAAOC,UAAWrC,EAAI,EAChE,OAAI6C,EAAUA,EAAEzC,KAAKwC,GACd,CACH3B,KAAM,WAEF,OADI2B,GAAK5C,GAAK4C,EAAEzC,SAAQyC,OAAI,GACrB,CAAE7B,MAAO6B,GAAKA,EAAE5C,KAAMqB,MAAOuB,KAKzC,SAASE,EAAOF,EAAG3C,GACtB,IAAI4C,EAAsB,mBAAXT,QAAyBQ,EAAER,OAAOC,UACjD,IAAKQ,EAAG,OAAOD,EACf,IAAmBG,EAAY7B,EAA3BlB,EAAI6C,EAAEzC,KAAKwC,GAAOI,EAAK,GAC3B,IACI,WAAc,IAAN/C,GAAgBA,KAAM,MAAQ8C,EAAI/C,EAAEiB,QAAQI,MAAM2B,EAAGN,KAAKK,EAAEhC,OAExE,MAAOkC,GAAS/B,EAAI,CAAE+B,MAAOA,WAEzB,IACQF,IAAMA,EAAE1B,OAASwB,EAAI7C,EAAU,SAAI6C,EAAEzC,KAAKJ,WAExC,GAAIkB,EAAG,MAAMA,EAAE+B,OAE7B,OAAOD,EAGJ,SAASE,IACZ,IAAK,IAAIF,EAAK,GAAIhD,EAAI,EAAGA,EAAIE,UAAUC,OAAQH,IAC3CgD,EAAKA,EAAGG,OAAOL,EAAO5C,UAAUF,KACpC,OAAOgD,QCvEEI,EAA0B,4BAO1BC,UAA4BC,MAWvCC,YAAYC,EAAoBC,GAC9B,IAAIC,EAA+B,CACjCT,MAAO,UACPU,iBAAkB,sEAGpB,GAnCJ,SAAyBD,GACvB,OACEA,GAC+B,iBAAxBA,EAAcT,OACsB,iBAApCS,EAAcE,kBA+BjBC,CAAgBJ,GAClBC,EAAgBI,EAAyCL,QACpD,GAAyB,iBAAdA,EAChB,IAIEC,EAAgBI,EAD+BC,KAAKC,MAAMP,IAE1D,MAAOvC,GAELwC,EADiB,MAAfF,EACc,CACdP,MAAO,sBACPU,iBAAkB,8CAGJ,CACdV,MAAO,gBACPU,qEAAsEF,UAK5EC,EAAgB,CACdT,MAAO,gBACPU,iBAAkB,sEAItBM,2FACuFT,2BAAoCO,KAAKG,UAC5HR,EACA,KACA,SAGJlE,KAAKgE,WAAaA,EAClBhE,KAAKkE,cAAgBA,EAGrBlE,KAAK2E,KAAOf,SAOHgB,EAAmC,qCAMnCC,UAAqCf,MAOhDC,YAAYe,GACVL,2EACuEK,EAAOC,KAAK,WAEnF/E,KAAK8E,OAASA,EAGd9E,KAAK2E,KAAOC,GAIhB,SAASN,EAAyCL,GAChD,MAAO,CACLR,MAAOQ,EAAUR,MACjBU,iBAAkBF,EAAUG,kBAC5BY,cAAef,EAAUgB,eACzBC,WAAYjB,EAAUkB,YACtBC,UAAWnB,EAAUmB,UACrBC,QAASpB,EAAUqB,UC/JvB,iBAAA,cA8EA,OAzEEC,oBAAA,WACE,MAAO,CACLC,OAAQ,GACRH,QAAS,KASbE,gBAAA,SAAIE,KASJF,yBAAA,SAAaG,EAAcC,GACzB,OAAO3F,MAOTuF,0BAAA,SAAcK,GACZ,OAAO5F,MAQTuF,qBAAA,SAASM,EAAeD,GACtB,OAAO5F,MAQTuF,oBAAA,SAAQO,EAA2BF,GACjC,OAAO5F,MAOTuF,sBAAA,SAAUQ,GACR,OAAO/F,MAOTuF,uBAAA,SAAWM,GACT,OAAO7F,MAMTuF,8BAAA,WACE,OAAO,qBC7EX,cAaA,OAXES,oBAAA,SAAQF,GACN,OAAO,IAAIG,YAAY,IAOzBD,sBAAA,SAAUE,GACR,OAAO,wBCXX,cAgBA,OATEC,mBAAA,SAAOL,EAA2BM,EAAiBC,KAMnDF,oBAAA,SAAQC,EAAiBC,GACvB,OAAO,wBCRX,cA4DA,OArDEC,sBAAA,SAAUT,EAAeU,GACvB,OAAO,IAAIhB,GAMbe,2BAAA,WACE,OAAO,IAAIf,GAQbe,qBAAA,SACEE,EACAC,GAEA,OAAOA,KAQTH,iBAAA,SAAQI,EAAWF,GACjB,OAAOE,GAOTJ,2BAAA,SAAeE,KAOfF,4BAAA,WACE,OAAO,IAAIN,GAMbM,8BAAA,WACE,OAAO,IAAIH,QCnEf,IAQIQ,ECkBQC,ECZAC,ECCAC,EHfNC,EAAwB,EACxBC,EAAuBpE,OAAOqE,IAAI,mCASxC,SAASC,IACP,IAAMC,EIbCC,KJcDC,EAA6BF,EAAUH,GAC7C,GAAIK,EAAe,CACjB,GAAIA,EAAcC,UAAYP,EAC5B,MAAM,IAAIjD,MACR,gGACmBiD,mBAAsCM,EAAcC,aAG3EX,EAAQU,OAERV,EAAQ,CACNY,YAAQC,EACRF,QAASP,GAEXI,EAAUH,GAAwBL,WAItBc,IAId,OAHKd,GACHO,IAEKP,WKpBOe,IACd,IAAMf,EAAQc,IAId,OAHKd,EAAMY,SACTZ,EAAMY,OAAS,IAAIjB,GAEdK,EAAMY,QJOf,SAAYX,GAIVA,eAIAA,6BAQAA,yBAOAA,2CAQAA,6CAIAA,6BAKAA,uCASAA,6CAKAA,+CAuBAA,iDAQAA,0BAkBAA,oCAIAA,sCAMAA,4BASAA,kCAIAA,8BAKAA,0CAnIF,CAAYA,IAAAA,OCZZ,SAAYC,GAEVA,2BAMAA,uBAMAA,uBAOAA,2BAOAA,2BA5BF,CAAYA,IAAAA,OCCZ,SAAYC,GAEVA,6BAEAA,yBAJF,CAAYA,IAAAA,OGfZ,IAAMa,EAAU,cCKAC,EACdC,EACAC,EAA2B,IAE3B,MAAMP,EAASG,IACTK,mBACDD,EAAQC,aACXC,KAAMnB,EAASoB,SAGXC,EAAOX,EAAOY,4BAA4BN,IAAiBE,GACjEG,EAAKE,aAAa,YAAa,YAE/B,IAAIC,EAAaP,EAWjB,OAVII,EAAKI,sBACPD,mBACKP,GACHC,6BACKD,EAAQC,aACXQ,OAAQL,OAKP,CACLA,KAAAA,EACAJ,QAASO,SCzBAG,EAGXzE,eAAe0E,GAFPzI,cAA8B,GAGpCA,KAAK0I,SAAWD,EAaZ1E,SACJ4E,EACAb,2CAEA,IAAIc,EAAQ,KACZ,MAAM9D,EAAS,IAEToD,KAAEA,EAAMJ,QAASO,GAAeT,EAAW,kCAAmCE,GAEpF,IAAK,IAAItH,EAAI,EAAGA,EAAIR,KAAK0I,SAAS/H,QAAoB,OAAViI,EAAgBpI,IAC1D,IACEoI,QAAc5I,KAAK0I,SAASlI,GAAGqI,SAASF,EAAQN,GAChD,MAAOS,GACPhE,EAAO5B,KAAK4F,GAIhB,IAAKF,GAAS9D,EAAOnE,OAAS,EAAG,CAC/B,MAAMmI,EAAM,IAAIjE,EAA6BC,GAK7C,MAJAoD,EAAKa,UAAU,CACbC,KAAMpC,EAAcqC,gBACpBC,QAASJ,EAAII,UAETJ,EAKR,OAFAZ,EAAKiB,MAEEP,KCjDX,MAAMQ,EAA2B,IAAItF,MACnC,gEAGWuF,EACXtF,YAAY+D,GACV,MAAMsB,EAGRrF,SAAS4E,EAA2Bb,GAClC,MAAMsB,GCVV,MAAMA,EAA2B,IAAItF,MACnC,oEAGWwF,EAGXvF,YAAYwF,EAA+DzB,GACzE,MAAMsB,EAGKrF,SACX4E,EACAb,2CAEA,MAAMsB,WCJGI,UAA+BhB,EAM1CzE,YAAY0F,GACVhF,MACE,IAAI4E,EAAsBI,GAC1B,IAAIH,EAA0BG,KC1BpC,IAAIC,EAAMlK,OAAOU,UAAUL,eACvB8J,EAAUhK,MAAMgK,QAEhBC,EAAY,WAEZ,IADA,IAAIC,EAAQ,GACHrJ,EAAI,EAAGA,EAAI,MAAOA,EACvBqJ,EAAM3G,KAAK,MAAQ1C,EAAI,GAAK,IAAM,IAAMA,EAAEsJ,SAAS,KAAKC,eAG5D,OAAOF,KAsBPG,EAAgB,SAAuBC,EAAQnC,GAE/C,IADA,IAAIoC,EAAMpC,GAAWA,EAAQqC,aAAe3K,OAAOW,OAAO,MAAQ,GACzDK,EAAI,EAAGA,EAAIyJ,EAAOtJ,SAAUH,OACR,IAAdyJ,EAAOzJ,KACd0J,EAAI1J,GAAKyJ,EAAOzJ,IAIxB,OAAO0J,KAuLM,CACbF,cAAeA,EACf3J,OA9HS,SAA4BqG,EAAQuD,GAC7C,OAAOzK,OAAO4K,KAAKH,GAAQI,OAAO,SAAUC,EAAKC,GAE7C,OADAD,EAAIC,GAAON,EAAOM,GACXD,GACR5D,IA2HH8D,QAPU,SAAiBC,EAAGlL,GAC9B,MAAO,GAAGoE,OAAO8G,EAAGlL,IAOpBmL,QA5CU,SAAiBnJ,GAI3B,IAHA,IAAIoJ,EAAQ,CAAC,CAAET,IAAK,CAAE9G,EAAG7B,GAASqJ,KAAM,MACpCC,EAAO,GAEFrK,EAAI,EAAGA,EAAImK,EAAMhK,SAAUH,EAKhC,IAJA,IAAIsK,EAAOH,EAAMnK,GACb0J,EAAMY,EAAKZ,IAAIY,EAAKF,MAEpBR,EAAO5K,OAAO4K,KAAKF,GACda,EAAI,EAAGA,EAAIX,EAAKzJ,SAAUoK,EAAG,CAClC,IAAIR,EAAMH,EAAKW,GACXC,EAAMd,EAAIK,GACK,iBAARS,GAA4B,OAARA,IAAuC,IAAvBH,EAAKI,QAAQD,KACxDL,EAAMzH,KAAK,CAAEgH,IAAKA,EAAKU,KAAML,IAC7BM,EAAK3H,KAAK8H,IAOtB,OA/Le,SAAsBL,GACrC,KAAOA,EAAMhK,OAAS,GAAG,CACrB,IAAImK,EAAOH,EAAM1H,MACbiH,EAAMY,EAAKZ,IAAIY,EAAKF,MAExB,GAAIjB,EAAQO,GAAM,CAGd,IAFA,IAAIgB,EAAY,GAEPH,EAAI,EAAGA,EAAIb,EAAIvJ,SAAUoK,OACR,IAAXb,EAAIa,IACXG,EAAUhI,KAAKgH,EAAIa,IAI3BD,EAAKZ,IAAIY,EAAKF,MAAQM,IA+K9BC,CAAaR,GAENpJ,GAwBP6J,OA1HS,SAAUC,EAAKC,EAASC,GACjC,IAAIC,EAAiBH,EAAII,QAAQ,MAAO,KACxC,GAAgB,eAAZF,EAEA,OAAOC,EAAeC,QAAQ,iBAAkBC,UAGpD,IACI,OAAOC,mBAAmBH,GAC5B,MAAO9J,GACL,OAAO8J,IAiHXI,OA7GS,SAAgBP,EAAKQ,EAAgBN,GAG9C,GAAmB,IAAfF,EAAI1K,OACJ,OAAO0K,EAGX,IAAIS,EAAST,EAOb,GANmB,iBAARA,EACPS,EAASlJ,OAAO1C,UAAU4J,SAASlJ,KAAKyK,GAClB,iBAARA,IACdS,EAASC,OAAOV,IAGJ,eAAZE,EACA,OAAOS,OAAOF,GAAQL,QAAQ,kBAAmB,SAAUQ,GACvD,MAAO,SAAWC,SAASD,EAAGE,MAAM,GAAI,IAAM,QAKtD,IADA,IAAIC,EAAM,GACD5L,EAAI,EAAGA,EAAIsL,EAAOnL,SAAUH,EAAG,CACpC,IAAI6L,EAAIP,EAAOQ,WAAW9L,GAGhB,KAAN6L,GACS,KAANA,GACM,KAANA,GACM,MAANA,GACCA,GAAK,IAAQA,GAAK,IAClBA,GAAK,IAAQA,GAAK,IAClBA,GAAK,IAAQA,GAAK,IAEtBD,GAAON,EAAOS,OAAO/L,GAIrB6L,EAAI,IACJD,GAAYxC,EAASyC,GAIrBA,EAAI,KACJD,GAAaxC,EAAS,IAAQyC,GAAK,GAAMzC,EAAS,IAAY,GAAJyC,GAI1DA,EAAI,OAAUA,GAAK,MACnBD,GAAaxC,EAAS,IAAQyC,GAAK,IAAOzC,EAAS,IAASyC,GAAK,EAAK,IAASzC,EAAS,IAAY,GAAJyC,IAIpG7L,GAAK,EACL6L,EAAI,QAAiB,KAAJA,IAAc,GAA8B,KAAvBP,EAAOQ,WAAW9L,IACxD4L,GAAOxC,EAAS,IAAQyC,GAAK,IACvBzC,EAAS,IAASyC,GAAK,GAAM,IAC7BzC,EAAS,IAASyC,GAAK,EAAK,IAC5BzC,EAAS,IAAY,GAAJyC,IAG3B,OAAOD,GAkDPI,SAnBW,SAAkBtC,GAC7B,SAAKA,GAAsB,iBAARA,OAITA,EAAIjK,aAAeiK,EAAIjK,YAAYuM,UAAYtC,EAAIjK,YAAYuM,SAAStC,KAelFuC,SAxBW,SAAkBvC,GAC7B,MAA+C,oBAAxC1K,OAAOU,UAAU4J,SAASlJ,KAAKsJ,IAwBtCwC,MA7LQ,SAASA,EAAMhG,EAAQuD,EAAQnC,GACvC,IAAKmC,EACD,OAAOvD,EAGX,GAAsB,iBAAXuD,EAAqB,CAC5B,GAAIN,EAAQjD,GACRA,EAAOxD,KAAK+G,OACT,CAAA,IAAIvD,GAA4B,iBAAXA,EAKxB,MAAO,CAACA,EAAQuD,IAJXnC,IAAYA,EAAQqC,cAAgBrC,EAAQ6E,mBAAsBjD,EAAI9I,KAAKpB,OAAOU,UAAW+J,MAC9FvD,EAAOuD,IAAU,GAMzB,OAAOvD,EAGX,IAAKA,GAA4B,iBAAXA,EAClB,MAAO,CAACA,GAAQ/C,OAAOsG,GAG3B,IAAI2C,EAAclG,EAKlB,OAJIiD,EAAQjD,KAAYiD,EAAQM,KAC5B2C,EAAc5C,EAActD,EAAQoB,IAGpC6B,EAAQjD,IAAWiD,EAAQM,IAC3BA,EAAO4C,QAAQ,SAAU/B,EAAMtK,GAC3B,GAAIkJ,EAAI9I,KAAK8F,EAAQlG,GAAI,CACrB,IAAIsM,EAAapG,EAAOlG,GACpBsM,GAAoC,iBAAfA,GAA2BhC,GAAwB,iBAATA,EAC/DpE,EAAOlG,GAAKkM,EAAMI,EAAYhC,EAAMhD,GAEpCpB,EAAOxD,KAAK4H,QAGhBpE,EAAOlG,GAAKsK,IAGbpE,GAGJlH,OAAO4K,KAAKH,GAAQI,OAAO,SAAUC,EAAKC,GAC7C,IAAIhJ,EAAQ0I,EAAOM,GAOnB,OALIb,EAAI9I,KAAK0J,EAAKC,GACdD,EAAIC,GAAOmC,EAAMpC,EAAIC,GAAMhJ,EAAOuG,GAElCwC,EAAIC,GAAOhJ,EAER+I,GACRsC,KC/FHnB,EAAUM,OAAO7L,UAAUuL,QAC3BsB,EAAkB,OAIlBC,EAAS,CACTC,QAAS,UACTC,QAAS,aAGIC,EAAK9M,OAClB,CACI+M,QAAWJ,EAAOE,QAClBG,WAAY,CACRJ,QAAS,SAAU1L,GACf,OAAOkK,EAAQ7K,KAAKW,EAAOwL,EAAiB,MAEhDG,QAAS,SAAU3L,GACf,OAAOwK,OAAOxK,MAI1ByL,GCpBAtD,EAAMlK,OAAOU,UAAUL,eAEvByN,EAAwB,CACxBC,SAAU,SAAkBC,GACxB,OAAOA,EAAS,MAEpBC,MAAO,QACPC,QAAS,SAAiBF,EAAQjD,GAC9B,OAAOiD,EAAS,IAAMjD,EAAM,KAEhCoD,OAAQ,SAAgBH,GACpB,OAAOA,IAIX7D,EAAUhK,MAAMgK,QAChBzG,EAAOvD,MAAMO,UAAUgD,KACvB0K,EAAc,SAAUC,EAAKC,GAC7B5K,EAAKrC,MAAMgN,EAAKlE,EAAQmE,GAAgBA,EAAe,CAACA,KAGxDC,EAAQC,KAAK9N,UAAU+N,YAEvBC,EAAgBC,EAAiB,QACjCC,EAAW,CACXC,gBAAgB,EAChBC,WAAW,EACX/C,QAAS,QACTgD,iBAAiB,EACjBC,UAAW,IACX5C,QAAQ,EACR6C,QAASC,EAAM9C,OACf+C,kBAAkB,EAClBC,OAAQV,EACRW,UAAWV,EAAQd,WAAWa,GAE9BR,SAAS,EACToB,cAAe,SAAuBC,GAClC,OAAOhB,EAAMnN,KAAKmO,IAEtBC,WAAW,EACXC,oBAAoB,GAWpBvK,EAAY,SAASA,EACrBwK,EACA1B,EACA2B,EACAF,EACAD,EACAP,EACAW,EACAC,EACAf,EACAQ,EACAD,EACAF,EACApD,GAEA,IAvBuDzI,EAuBnDoH,EAAMgF,EASV,GARsB,mBAAXE,EACPlF,EAAMkF,EAAO5B,EAAQtD,GACdA,aAAe8D,KACtB9D,EAAM4E,EAAc5E,GACW,UAAxBiF,GAAmCxF,EAAQO,KAClDA,EAAMA,EAAInF,KAAK,MAGP,OAARmF,EAAc,CACd,GAAI+E,EACA,OAAOR,IAAYE,EAAmBF,EAAQjB,EAAQY,EAASK,QAASlD,GAAWiC,EAGvFtD,EAAM,GAGV,GAvCoB,iBADmCpH,EAwC7BoH,IAtCN,iBAANpH,GACM,kBAANA,GACM,iBAANA,GACM,iBAANA,GAmCoB4L,EAAMlC,SAAStC,GAC7C,OAAIuE,EAEO,CAACI,EADOF,EAAmBnB,EAASiB,EAAQjB,EAAQY,EAASK,QAASlD,IAC/C,IAAMsD,EAAUJ,EAAQvE,EAAKkE,EAASK,QAASlD,KAE1E,CAACsD,EAAUrB,GAAU,IAAMqB,EAAU9C,OAAO7B,KAGvD,IAMIoF,EANAC,EAAS,GAEb,QAAmB,IAARrF,EACP,OAAOqF,EAIX,GAAI5F,EAAQyF,GACRE,EAAUF,MACP,CACH,IAAIhF,EAAO5K,OAAO4K,KAAKF,GACvBoF,EAAUD,EAAOjF,EAAKiF,KAAKA,GAAQjF,EAGvC,IAAK,IAAI5J,EAAI,EAAGA,EAAI8O,EAAQ3O,SAAUH,EAAG,CACrC,IAAI+J,EAAM+E,EAAQ9O,GAEdwO,GAA0B,OAAb9E,EAAIK,KAIjBZ,EAAQO,GACR0D,EAAY2B,EAAQ7K,EAChBwF,EAAIK,GAC2B,mBAAxB4E,EAAqCA,EAAoB3B,EAAQjD,GAAOiD,EAC/E2B,EACAF,EACAD,EACAP,EACAW,EACAC,EACAf,EACAQ,EACAD,EACAF,EACApD,IAGJqC,EAAY2B,EAAQ7K,EAChBwF,EAAIK,GACJiD,GAAUc,EAAY,IAAM/D,EAAM,IAAMA,EAAM,KAC9C4E,EACAF,EACAD,EACAP,EACAW,EACAC,EACAf,EACAQ,EACAD,EACAF,EACApD,KAKZ,OAAOgE,GCpJP7F,EAAMlK,OAAOU,UAAUL,eAEvBuO,GAAW,CACXE,WAAW,EACX3B,iBAAiB,EACjB6C,WAAY,GACZjE,QAAS,QACTgD,iBAAiB,EACjBd,OAAO,EACPnC,QAASoD,EAAMtD,OACfoD,UAAW,IACXiB,MAAO,EACPC,mBAAmB,EACnBC,0BAA0B,EAC1BC,eAAgB,IAChBC,aAAa,EACb1F,cAAc,EACd8E,oBAAoB,GAGpBU,GAA2B,SAAUtE,GACrC,OAAOA,EAAII,QAAQ,YAAa,SAAUQ,EAAI6D,GAC1C,OAAO/D,OAAOgE,aAAa7D,SAAS4D,EAAW,QA4GnDE,GAAY,SAA8BC,EAAUjF,EAAKlD,GACzD,GAAKmI,EAAL,CAKA,IAAI1F,EAAMzC,EAAQwG,UAAY2B,EAASxE,QAAQ,cAAe,QAAUwE,EAKpEC,EAAQ,gBAIRC,EAAUrI,EAAQ2H,MAAQ,GALf,eAK6BW,KAAK7F,GAC7ChC,EAAS4H,EAAU5F,EAAI4B,MAAM,EAAGgE,EAAQE,OAAS9F,EAIjDH,EAAO,GACX,GAAI7B,EAAQ,CAER,IAAKT,EAAQqC,cAAgBT,EAAI9I,KAAKpB,OAAOU,UAAWqI,KAC/CT,EAAQ6E,gBACT,OAIRvC,EAAKlH,KAAKqF,GAMd,IADA,IAAI/H,EAAI,EACDsH,EAAQ2H,MAAQ,GAAqC,QAA/BU,EAAUD,EAAME,KAAK7F,KAAkB/J,EAAIsH,EAAQ2H,OAAO,CAEnF,GADAjP,GAAK,GACAsH,EAAQqC,cAAgBT,EAAI9I,KAAKpB,OAAOU,UAAWiQ,EAAQ,GAAGhE,MAAM,GAAI,MACpErE,EAAQ6E,gBACT,OAGRvC,EAAKlH,KAAKiN,EAAQ,IAStB,OAJIA,GACA/F,EAAKlH,KAAK,IAAMqH,EAAI4B,MAAMgE,EAAQE,OAAS,KAnFjC,SAAUC,EAAOtF,EAAKlD,GAGpC,IAFA,IAAIyI,EAAOvF,EAEFxK,EAAI8P,EAAM3P,OAAS,EAAGH,GAAK,IAAKA,EAAG,CACxC,IAAI0J,EACAsG,EAAOF,EAAM9P,GAEjB,GAAa,OAATgQ,GAAiB1I,EAAQ+H,YACzB3F,EAAM,GAAGvG,OAAO4M,OACb,CACHrG,EAAMpC,EAAQqC,aAAe3K,OAAOW,OAAO,MAAQ,GACnD,IAAIsQ,EAA+B,MAAnBD,EAAKjE,OAAO,IAA+C,MAAjCiE,EAAKjE,OAAOiE,EAAK7P,OAAS,GAAa6P,EAAKrE,MAAM,GAAI,GAAKqE,EACjGH,EAAQnE,SAASuE,EAAW,IAC3B3I,EAAQ+H,aAA6B,KAAdY,GAGvBC,MAAML,IACJG,IAASC,GACT1E,OAAOsE,KAAWI,GAClBJ,GAAS,GACRvI,EAAQ+H,aAAeQ,GAASvI,EAAQ0H,YAE5CtF,EAAM,IACFmG,GAASE,EAEbrG,EAAIuG,GAAaF,EAXjBrG,EAAM,CAAEyG,EAAGJ,GAenBA,EAAOrG,EAGX,OAAOqG,EAsDAK,CAAYxG,EAAMY,EAAKlD,QCnLjB,CACbqG,QAASA,EACT3J,MDsNa,SAAU6G,EAAKwF,GAC5B,IAAI/I,EAnCoB,SAA+B+I,GACvD,IAAKA,EACD,OAAOzC,GAGX,GAAqB,OAAjByC,EAAKvF,cAAqC9D,IAAjBqJ,EAAKvF,SAAiD,mBAAjBuF,EAAKvF,QACnE,MAAM,IAAItI,UAAU,iCAGxB,QAA4B,IAAjB6N,EAAKtF,SAA4C,UAAjBsF,EAAKtF,SAAwC,eAAjBsF,EAAKtF,QACxE,MAAM,IAAIzH,MAAM,qEAEpB,IAAIyH,OAAkC,IAAjBsF,EAAKtF,QAA0B6C,GAAS7C,QAAUsF,EAAKtF,QAE5E,MAAO,CACH+C,eAAqC,IAAnBuC,EAAKvC,UAA4BF,GAASE,YAAcuC,EAAKvC,UAC/E3B,gBAAiD,kBAAzBkE,EAAKlE,gBAAgCkE,EAAKlE,gBAAkByB,GAASzB,gBAC7F6C,WAAuC,iBAApBqB,EAAKrB,WAA0BqB,EAAKrB,WAAapB,GAASoB,WAC7EjE,QAASA,EACTgD,gBAAiD,kBAAzBsC,EAAKtC,gBAAgCsC,EAAKtC,gBAAkBH,GAASG,gBAC7Fd,MAA6B,kBAAfoD,EAAKpD,MAAsBoD,EAAKpD,MAAQW,GAASX,MAC/DnC,QAAiC,mBAAjBuF,EAAKvF,QAAyBuF,EAAKvF,QAAU8C,GAAS9C,QACtEkD,UAAqC,iBAAnBqC,EAAKrC,WAA0BE,EAAMjC,SAASoE,EAAKrC,WAAaqC,EAAKrC,UAAYJ,GAASI,UAE5GiB,MAA8B,iBAAfoB,EAAKpB,QAAqC,IAAfoB,EAAKpB,OAAoBoB,EAAKpB,MAAQrB,GAASqB,MACzFC,mBAA8C,IAA3BmB,EAAKnB,kBACxBC,yBAAmE,kBAAlCkB,EAAKlB,yBAAyCkB,EAAKlB,yBAA2BvB,GAASuB,yBACxHC,eAA+C,iBAAxBiB,EAAKjB,eAA8BiB,EAAKjB,eAAiBxB,GAASwB,eACzFC,aAAkC,IAArBgB,EAAKhB,YAClB1F,aAA2C,kBAAtB0G,EAAK1G,aAA6B0G,EAAK1G,aAAeiE,GAASjE,aACpF8E,mBAAuD,kBAA5B4B,EAAK5B,mBAAmC4B,EAAK5B,mBAAqBb,GAASa,oBAK5F6B,CAAsBD,GAEpC,GAAY,KAARxF,GAAAA,MAAcA,EACd,OAAOvD,EAAQqC,aAAe3K,OAAOW,OAAO,MAAQ,GASxD,IANA,IAAI4Q,EAAyB,iBAAR1F,EA7LP,SAAgCA,EAAKvD,GACnD,IAKItH,EALA0J,EAAM,GACN8G,EAAWlJ,EAAQ4H,kBAAoBrE,EAAII,QAAQ,MAAO,IAAMJ,EAChE4F,EAAQnJ,EAAQ8H,iBAAmBsB,EAAAA,OAAW1J,EAAYM,EAAQ8H,eAClEuB,EAAQH,EAASI,MAAMtJ,EAAQ0G,UAAWyC,GAC1CI,GAAa,EAGb9F,EAAUzD,EAAQyD,QACtB,GAAIzD,EAAQyG,gBACR,IAAK/N,EAAI,EAAGA,EAAI2Q,EAAMxQ,SAAUH,EACM,IAA9B2Q,EAAM3Q,GAAGyK,QAAQ,WAbX,mBAcFkG,EAAM3Q,GACN+K,EAAU,QAlBZ,wBAmBS4F,EAAM3Q,KACb+K,EAAU,cAEd8F,EAAY7Q,EACZA,EAAI2Q,EAAMxQ,QAKtB,IAAKH,EAAI,EAAGA,EAAI2Q,EAAMxQ,SAAUH,EAC5B,GAAIA,IAAM6Q,EAAV,CAGA,IAKI9G,EAAKS,EALLsG,EAAOH,EAAM3Q,GAEb+Q,EAAmBD,EAAKrG,QAAQ,MAChCuG,GAA4B,IAAtBD,EAA0BD,EAAKrG,QAAQ,KAAOsG,EAAmB,GAG9D,IAATC,GACAjH,EAAMzC,EAAQwD,QAAQgG,EAAMlD,GAAS9C,QAASC,GAC9CP,EAAMlD,EAAQmH,mBAAqB,KAAO,KAE1C1E,EAAMzC,EAAQwD,QAAQgG,EAAKnF,MAAM,EAAGqF,GAAMpD,GAAS9C,QAASC,GAC5DP,EAAMlD,EAAQwD,QAAQgG,EAAKnF,MAAMqF,EAAM,GAAIpD,GAAS9C,QAASC,IAG7DP,GAAOlD,EAAQ6H,0BAAwC,eAAZpE,IAC3CP,EAAM2E,GAAyB3E,IAG/BA,GAAOlD,EAAQ2F,OAASzC,EAAIC,QAAQ,MAAQ,IAC5CD,EAAMA,EAAIoG,MAAM,MAGhB1H,EAAI9I,KAAKsJ,EAAKK,GACdL,EAAIK,GAAOmE,EAAMlE,QAAQN,EAAIK,GAAMS,GAEnCd,EAAIK,GAAOS,EAInB,OAAOd,EAqIiCuH,CAAYpG,EAAKvD,GAAWuD,EAChEnB,EAAMpC,EAAQqC,aAAe3K,OAAOW,OAAO,MAAQ,GAInDiK,EAAO5K,OAAO4K,KAAK2G,GACdvQ,EAAI,EAAGA,EAAI4J,EAAKzJ,SAAUH,EAAG,CAClC,IAAI+J,EAAMH,EAAK5J,GACXkR,EAAS1B,GAAUzF,EAAKwG,EAAQxG,GAAMzC,GAC1CoC,EAAMwE,EAAMhC,MAAMxC,EAAKwH,EAAQ5J,GAGnC,OAAO4G,EAAMhE,QAAQR,ICxOrBxF,UFgMa,SAAUwK,EAAQ2B,GAC/B,IAGIvB,EAHApF,EAAMgF,EACNpH,EAhDwB,SAAmC+I,GAC/D,IAAKA,EACD,OAAOzC,EAGX,GAAqB,OAAjByC,EAAKpC,cAAqCjH,IAAjBqJ,EAAKpC,SAAiD,mBAAjBoC,EAAKpC,QACnE,MAAM,IAAIzL,UAAU,iCAGxB,IAAIuI,EAAUsF,EAAKtF,SAAW6C,EAAS7C,QACvC,QAA4B,IAAjBsF,EAAKtF,SAA4C,UAAjBsF,EAAKtF,SAAwC,eAAjBsF,EAAKtF,QACxE,MAAM,IAAIvI,UAAU,qEAGxB,IAAI4L,EAAST,EAAiB,QAC9B,QAA2B,IAAhB0C,EAAKjC,OAAwB,CACpC,IAAKlF,EAAI9I,KAAKuN,EAAQd,WAAYwD,EAAKjC,QACnC,MAAM,IAAI5L,UAAU,mCAExB4L,EAASiC,EAAKjC,OAElB,IAAIC,EAAYV,EAAQd,WAAWuB,GAE/BQ,EAAShB,EAASgB,OAKtB,OAJ2B,mBAAhByB,EAAKzB,QAAyBzF,EAAQkH,EAAKzB,WAClDA,EAASyB,EAAKzB,QAGX,CACHf,eAA+C,kBAAxBwC,EAAKxC,eAA+BwC,EAAKxC,eAAiBD,EAASC,eAC1FC,eAAqC,IAAnBuC,EAAKvC,UAA4BF,EAASE,YAAcuC,EAAKvC,UAC/E/C,QAASA,EACTgD,gBAAiD,kBAAzBsC,EAAKtC,gBAAgCsC,EAAKtC,gBAAkBH,EAASG,gBAC7FC,eAAqC,IAAnBqC,EAAKrC,UAA4BJ,EAASI,UAAYqC,EAAKrC,UAC7E5C,OAA+B,kBAAhBiF,EAAKjF,OAAuBiF,EAAKjF,OAASwC,EAASxC,OAClE6C,QAAiC,mBAAjBoC,EAAKpC,QAAyBoC,EAAKpC,QAAUL,EAASK,QACtEE,iBAAmD,kBAA1BkC,EAAKlC,iBAAiCkC,EAAKlC,iBAAmBP,EAASO,iBAChGS,OAAQA,EACRP,UAAWA,EACXC,cAA6C,mBAAvB+B,EAAK/B,cAA+B+B,EAAK/B,cAAgBV,EAASU,cACxFE,UAAqC,kBAAnB6B,EAAK7B,UAA0B6B,EAAK7B,UAAYZ,EAASY,UAC3EK,KAA2B,mBAAdwB,EAAKxB,KAAsBwB,EAAKxB,KAAO,KACpDJ,mBAAuD,kBAA5B4B,EAAK5B,mBAAmC4B,EAAK5B,mBAAqBb,EAASa,oBAM5F0C,CAA0Bd,GAKV,mBAAnB/I,EAAQsH,OAEflF,GADAkF,EAAStH,EAAQsH,QACJ,GAAIlF,GACVP,EAAQ7B,EAAQsH,UAEvBE,EADSxH,EAAQsH,QAIrB,IAMIwC,EANAxH,EAAO,GAEX,GAAmB,iBAARF,GAA4B,OAARA,EAC3B,MAAO,GAKP0H,EADAf,GAAQA,EAAKe,eAAetE,EACduD,EAAKe,YACZf,GAAQ,YAAaA,EACdA,EAAKnD,QAAU,UAAY,SAE3B,UAGlB,IAAIyB,EAAsB7B,EAAsBsE,GAE3CtC,IACDA,EAAU9P,OAAO4K,KAAKF,IAGtBpC,EAAQuH,MACRC,EAAQD,KAAKvH,EAAQuH,MAGzB,IAAK,IAAI7O,EAAI,EAAGA,EAAI8O,EAAQ3O,SAAUH,EAAG,CACrC,IAAI+J,EAAM+E,EAAQ9O,GAEdsH,EAAQkH,WAA0B,OAAb9E,EAAIK,IAG7BqD,EAAYxD,EAAM1F,EACdwF,EAAIK,GACJA,EACA4E,EACArH,EAAQmH,mBACRnH,EAAQkH,UACRlH,EAAQ8D,OAAS9D,EAAQ2G,QAAU,KACnC3G,EAAQsH,OACRtH,EAAQuH,KACRvH,EAAQwG,UACRxG,EAAQgH,cACRhH,EAAQ+G,UACR/G,EAAQ6G,iBACR7G,EAAQyD,UAIhB,IAAIsG,EAASzH,EAAKrF,KAAK+C,EAAQ0G,WAC3BhB,GAAoC,IAA3B1F,EAAQuG,eAA0B,IAAM,GAYrD,OAVIvG,EAAQyG,kBACgB,eAApBzG,EAAQyD,QAERiC,GAAU,uBAGVA,GAAU,mBAIXqE,EAAOlR,OAAS,EAAI6M,EAASqE,EAAS,KG/QjD,SAASC,GAAaC,GACpB,OAAOA,EAAWC,cA0BpB,kBAGE,WAAYC,GAEV,GADAjS,KAAKkS,YAAc,GACfD,EACF,IAAK,IAAMF,KAAcE,EACvBjS,KAAKmS,IAAIJ,EAAYE,EAAWF,IAiHxC,OAtGSK,gBAAP,SAAWL,EAAoBM,GAC7BrS,KAAKkS,YAAYJ,GAAaC,IAAe,CAC3CpN,KAAMoN,EACNxQ,MAAO8Q,EAAYvI,aAShBsI,gBAAP,SAAWL,GACT,IAAMO,EAAqBtS,KAAKkS,YAAYJ,GAAaC,IACzD,OAAQO,EAAqBA,EAAO/Q,WAAnBiG,GAMZ4K,qBAAP,SAAgBL,GACd,QAAS/R,KAAKkS,YAAYJ,GAAaC,KAQlCK,mBAAP,SAAcL,GACZ,IAAMnQ,EAAkB5B,KAAKuS,SAASR,GAEtC,cADO/R,KAAKkS,YAAYJ,GAAaC,IAC9BnQ,GAMFwQ,uBAAP,WACE,IAAMxQ,EAAyB,GAC/B,IAAK,IAAM4Q,KAAaxS,KAAKkS,YAAa,CACxC,IAAMI,EAAqBtS,KAAKkS,YAAYM,GAC5C5Q,EAAO0Q,EAAO3N,KAAKqN,eAAiBM,EAAO/Q,MAE7C,OAAOK,GAMFwQ,yBAAP,WACE,IAAMK,EAAwB,GAC9B,IAAK,IAAMD,KAAaxS,KAAKkS,YAC3BO,EAAQvP,KAAKlD,KAAKkS,YAAYM,IAEhC,OAAOC,GAMFL,wBAAP,WAGE,IAFA,IAAMM,EAAwB,GACxBD,EAAwBzS,KAAK2S,eAC1BnS,EAAI,EAAGA,EAAIiS,EAAQ9R,SAAUH,EACpCkS,EAAYxP,KAAKuP,EAAQjS,GAAGmE,MAE9B,OAAO+N,GAMFN,yBAAP,WAGE,IAFA,IAAMQ,EAAyB,GACzBH,EAAwBzS,KAAK2S,eAC1BnS,EAAI,EAAGA,EAAIiS,EAAQ9R,SAAUH,EACpCoS,EAAa1P,KAAKuP,EAAQjS,GAAGe,OAE/B,OAAOqR,GAMFR,mBAAP,WACE,OAAOpS,KAAKiS,cAMPG,qBAAP,WACE,OAAO7N,KAAKG,UAAU1E,KAAK6S,WAMtBT,kBAAP,WACE,OAAO,IAAIA,EAAYpS,KAAKiS,6BCxIhBa,GAAgBvR,GAE9B,IADA,IAAI8J,EAAM,GACD7K,EAAI,EAAGA,EAAIe,EAAMZ,OAAQH,IAChC6K,GAAOU,OAAOgE,aAAaxO,EAAMf,IAEnC,OAAOuS,KAAK1H,YAOE2H,GAAazR,GAG3B,IAFA,IAAM0R,EAAaC,KAAK3R,GAClBsM,EAAM,IAAIsF,WAAWF,EAAWtS,QAC7BH,EAAI,EAAGA,EAAIyS,EAAWtS,OAAQH,IACrCqN,EAAIrN,GAAKyS,EAAW3G,WAAW9L,GAEjC,OAAOqN,EC5BT,mFCEA,IAAIuF,EAAqC,4BAAeC,OAAOD,iBAAmBC,OAAOD,gBAAgBE,KAAKD,SACnE,8BAAyD,mBAAnCE,OAAOC,SAASJ,iBAAiCI,SAASJ,gBAAgBE,KAAKE,UAEhJ,GAAIJ,EAAiB,CAEnB,IAAIK,EAAQ,IAAIN,WAAW,IAE3BO,UAAiB,WAEf,OADAN,EAAgBK,GACTA,OAEJ,CAKL,IAAIE,EAAO,IAAIhU,MAAM,IAErB+T,UAAiB,WACf,IAAK,IAAWnQ,EAAP/C,EAAI,EAAMA,EAAI,GAAIA,IACN,IAAV,EAAJA,KAAiB+C,EAAoB,WAAhBqQ,KAAKC,UAC/BF,EAAKnT,GAAK+C,MAAY,EAAJ/C,IAAa,GAAK,IAGtC,OAAOmT,MD3BPG,GAAY,GACPtT,GAAI,EAAGA,GAAI,MAAOA,GACzBsT,GAAUtT,KAAMA,GAAI,KAAOsJ,SAAS,IAAIiK,OAAO,GAiBjD,OAdA,SAAqBC,EAAKC,GACxB,IAAIzT,EAAIyT,GAAU,EACdC,EAAMJ,GAEV,MAAO,CAAEI,EAAIF,EAAIxT,MAAO0T,EAAIF,EAAIxT,MACjC0T,EAAIF,EAAIxT,MAAO0T,EAAIF,EAAIxT,MAAO,IAC9B0T,EAAIF,EAAIxT,MAAO0T,EAAIF,EAAIxT,MAAO,IAC9B0T,EAAIF,EAAIxT,MAAO0T,EAAIF,EAAIxT,MAAO,IAC9B0T,EAAIF,EAAIxT,MAAO0T,EAAIF,EAAIxT,MAAO,IAC9B0T,EAAIF,EAAIxT,MAAO0T,EAAIF,EAAIxT,MACvB0T,EAAIF,EAAIxT,MAAO0T,EAAIF,EAAIxT,MACvB0T,EAAIF,EAAIxT,MAAO0T,EAAIF,EAAIxT,OAAQuE,KAAK,KEQrC,OAzBA,SAAY+C,EAASkM,EAAKC,GACxB,IAAIzT,EAAIwT,GAAOC,GAAU,EAEF,qBACrBD,EAAkB,WAAZlM,EAAuB,IAAInI,MAAM,IAAM,KAC7CmI,EAAU,MAIZ,IAAI6L,GAFJ7L,EAAUA,GAAW,IAEF+L,SAAW/L,EAAQqM,KAAOA,MAO7C,GAJAR,EAAK,GAAgB,GAAVA,EAAK,GAAa,GAC7BA,EAAK,GAAgB,GAAVA,EAAK,GAAa,IAGzBK,EACF,IAAK,IAAII,EAAK,EAAGA,EAAK,KAAMA,EAC1BJ,EAAIxT,EAAI4T,GAAMT,EAAKS,GAIvB,OAAOJ,GAAOK,GAAYV,ICtBfW,GAAY,CAMvBC,gBAAiB,kBAQjBC,KAAM,QAQNC,MAAO,SAQPC,WAAY,aAQZC,YAAa,cAEbC,cAAe,CAObC,UAAW,CACTC,IAAK,MACLC,IAAK,MACLC,OAAQ,SACRC,KAAM,OACNC,MAAO,QACPC,KAAM,OACNC,MAAO,SAGTC,YAAa,CACXC,gBAAiB,MAOrBC,gBAAiB,CAOfC,cAAe,gBAEfC,qBAAsB,SAUtBC,YAAa,cAQbC,WAAY,eCtFVC,GAAiB,kFAMF,oBAAZC,WACLA,QAAQvO,WACRuO,QAAQC,UACRD,QAAQC,SAASC,cAmCLC,GAAcC,GAC5B,IAAMC,EAAwB,GAI9B,OAHAA,EAAiBlU,KAAOiU,EAASE,WACjCD,EAAiBzD,QAAUwD,EAASxD,QACpCyD,EAAiBE,OAASH,EAASG,OAC5BF,WAWOG,GAAaC,GAC3B,IAAMC,EAAkBD,EAAQE,QAIhC,OAHID,EAAgB9D,SAClB8D,EAAgB9D,QAAQgE,OAAO,iBAE1BF,WAmBOG,KACd,OAAOC,cA4BOC,GAAStW,EAAWiB,GAClC,OAAO,IAAIJ,QAAQ,SAACC,GAAY,OAAAyV,WAAW,WAAM,OAAAzV,EAAQG,IAAQjB,KAqFnE,IAAMwW,GAAsB,+KAkBZC,GACdxV,EACAyV,EACAC,GAEA,OAAQ1V,GAAUyV,EAAsBzV,EAAM6P,MAAM4F,GAAajS,KAAKkS,GAAgB,IAAtD1V,ECjOlC,kBACE,WACkB2V,EACAC,gBADAD,MAAAlX,kBAAAkX,EACAlX,WAAAmX,EAsOpB,OAnOEC,gCAAA,SAAoBC,EAAgB9V,EAAY+V,GAC9C,IAAMC,EAAiB,SAACC,EAAyCC,GAC/D,MAAM,IAAI3T,MACR,IAAIwT,mBAA2B/V,sCAAyCiW,QAAoBC,QAGhG,GAAIJ,EAAOK,aAAwBlQ,MAATjG,EAAoB,CACtC,IAAAoW,gBACJC,qBACAC,qBACAC,qBACAC,qBACAC,aACAC,cACAC,aACAC,cACAC,eACAC,YACAC,gBA6BF,GA3BwB9Q,MAApBoQ,GAAiCrW,GAASqW,GAC5CL,EAAe,mBAAoBK,GAEbpQ,MAApBqQ,GAAiCtW,GAASsW,GAC5CN,EAAe,mBAAoBM,GAEbrQ,MAApBsQ,GAAiCvW,EAAQuW,GAC3CP,EAAe,mBAAoBO,GAEbtQ,MAApBuQ,GAAiCxW,EAAQwW,GAC3CR,EAAe,mBAAoBQ,GAErBvQ,MAAZwQ,GAAyBzW,EAAMZ,OAASqX,GAC1CT,EAAe,WAAYS,GAEZxQ,MAAbyQ,GAA0B1W,EAAMZ,OAASsX,GAC3CV,EAAe,YAAaU,GAEdzQ,MAAZ0Q,GAAyB3W,EAAMZ,OAASuX,GAC1CX,EAAe,WAAYW,GAEZ1Q,MAAb2Q,GAA0B5W,EAAMZ,OAASwX,GAC3CZ,EAAe,YAAaY,GAEZ3Q,MAAd4Q,GAA2B7W,EAAQ6W,GAAe,GACpDb,EAAe,aAAca,GAE3BC,EAAS,CACX,IAAME,EAAqC,iBAAZF,EAAuB,IAAIG,OAAOH,GAAWA,EACvD,iBAAV9W,GAA+C,OAAzBA,EAAMkX,MAAMF,IAC3ChB,EAAe,UAAWc,GAI5BC,GACA/W,EAAMmX,KAAK,SAAC5N,EAAWtK,EAAWgD,GAAmB,OAAAA,EAAGyH,QAAQH,KAAUtK,KAE1E+W,EAAe,cAAee,KAgBpClB,sBAAA,SAAUC,EAAgBnI,EAAaoI,GACrC,IAAIqB,EAAe,GACbC,EAAavB,EAAOwB,KAAKlU,KAC1B2S,IACHA,EAAaD,EAAOyB,gBAEmB,OAArCF,EAAWH,MAAM,kBACnBE,EAAU,IAGRtB,EAAO0B,aACT7J,EAASmI,EAAO2B,cAaV,IAAAC,aAAUC,aAElB,GAAID,GAAYC,QAAuB1R,IAAX0H,EAC1B,MAAM,IAAIpL,MAASwT,2BAErB,GAAI2B,IAAaC,GAAsB1R,MAAV0H,EAC3B,MAAM,IAAIpL,MAASwT,mCAErB,IAAK2B,IAAyB,IAAbC,GAAiC,OAAXhK,EACrC,MAAM,IAAIpL,MAASwT,sBAGrB,GAAc9P,MAAV0H,EACFyJ,EAAUzJ,OAIV,GADAlP,KAAKmZ,oBAAoB9B,EAAQnI,EAAQoI,GACL,OAAhCsB,EAAWH,MAAM,WACnBE,EAAUzJ,OACL,GAA2E,OAAvE0J,EAAWH,MAAM,kDAC1BE,EA0LR,SAA6BS,EAAkB9B,EAAoB/V,GACjE,GAAIA,MAAAA,EACF,GAAqC,OAAjC6X,EAASX,MAAM,eACjB,GAAqB,iBAAVlX,EACT,MAAM,IAAIuC,MAASwT,iBAAyB/V,mCAEzC,GAAqC,OAAjC6X,EAASX,MAAM,eACxB,GAA+B,iBAApBlX,EAAM8X,UACf,MAAM,IAAIvV,MAASwT,kBAA0B/V,oCAE1C,GAAmC,OAA/B6X,EAASX,MAAM,aACxB,GAAiC,iBAApBlX,EAAM8X,YDlPGC,ECkPyC/X,GDjP5DqU,GAAe2D,KAAKD,ICkPrB,MAAM,IAAIxV,MACLwT,kBAA0B/V,qDAG5B,GAAsC,OAAlC6X,EAASX,MAAM,gBACxB,GAAqB,kBAAVlX,EACT,MAAM,IAAIuC,MAASwT,iBAAyB/V,oCAEzC,GAAqC,OAAjC6X,EAASX,MAAM,cAAwB,CAChD,IAAMe,SAAoBjY,EAC1B,KACiB,WAAfiY,GACe,aAAfA,GACEjY,aAAiB0E,aAClBA,YAAYwT,OAAOlY,IACF,mBAATmY,MAAuBnY,aAAiBmY,MAEjD,MAAM,IAAI5V,MACLwT,+GDrQegC,EC0Q1B,OAAO/X,EA7NSoY,CAAoBf,EAAYtB,EAAYpI,QACjD,GAAqC,OAAjC0J,EAAWH,MAAM,YAAsB,CAEhDE,EA6NR,SAA2BrB,EAAoBsC,EAA2BrY,GACxE,IAAKqY,EACH,MAAM,IAAI9V,MACR,qDAAqDwT,uBASzD,IANkBsC,EAAclB,KAAK,SAAC5N,GACpC,MAA8B,iBAAnBA,EAAKuO,UACPvO,EAAKkH,gBAAkBzQ,EAAMyQ,cAE/BlH,IAASvJ,IAGhB,MAAM,IAAIuC,MACLvC,+BAAkC+V,6BAAqC/S,KAAKG,UAC7EkV,QAIN,OAAOrY,EAhPSsY,CAAkBvC,EADGD,EACoBwB,KAAKe,cAAe1K,QAEO,OAA9E0J,EAAWH,MAAM,yDAEjBE,EAmQR,SAA4BS,EAAkB7X,EAAY+V,GACxD,GAAa9P,MAATjG,EACF,GAAmC,OAA/B6X,EAASX,MAAM,YAAsB,CACvC,KAEIlX,aAAiByM,MACW,iBAApBzM,EAAM8X,YAA2B3I,MAAM1C,KAAKxJ,MAAMjD,KAG5D,MAAM,IAAIuC,MAASwT,gEAErB/V,EACEA,aAAiByM,KACbzM,EAAM0M,cAAc6L,UAAU,EAAG,IACjC,IAAI9L,KAAKzM,GAAO0M,cAAc6L,UAAU,EAAG,SAC5C,GAAuC,OAAnCV,EAASX,MAAM,gBAA0B,CAClD,KAEIlX,aAAiByM,MACW,iBAApBzM,EAAM8X,YAA2B3I,MAAM1C,KAAKxJ,MAAMjD,KAG5D,MAAM,IAAIuC,MAASwT,gEAErB/V,EAAQA,aAAiByM,KAAOzM,EAAM0M,cAAgB,IAAID,KAAKzM,GAAO0M,mBACjE,GAA8C,OAA1CmL,EAASX,MAAM,uBAAiC,CACzD,KAEIlX,aAAiByM,MACW,iBAApBzM,EAAM8X,YAA2B3I,MAAM1C,KAAKxJ,MAAMjD,KAG5D,MAAM,IAAIuC,MAASwT,iEAErB/V,EAAQA,aAAiByM,KAAOzM,EAAMwY,cAAgB,IAAI/L,KAAKzM,GAAOwY,mBACjE,GAAuC,OAAnCX,EAASX,MAAM,gBAA0B,CAClD,KAEIlX,aAAiByM,MACW,iBAApBzM,EAAM8X,YAA2B3I,MAAM1C,KAAKxJ,MAAMjD,KAG5D,MAAM,IAAIuC,MACLwT,0HAIP/V,EAjJN,SAAwBjC,GACtB,IAAKA,EACH,OAGyB,iBAAhBA,EAAE+Z,YACX/Z,EAAI,IAAI0O,KAAK1O,IAEf,OAAOsU,KAAKoG,MAAO1a,EAAW2a,UAAY,KAyI9BC,CAAe3Y,QAClB,GAAuC,OAAnC6X,EAASX,MAAM,gBAA0B,CAClD,aDrOqBlX,GACzB,OAAOuV,GAAoByC,KAAKhY,GCoOvB4Y,CAAiB5Y,GACpB,MAAM,IAAIuC,MACLwT,wDAAgE/V,QAGvEA,EAAQA,EAGZ,OAAOA,EA5TS6Y,CAAmBxB,EAAY1J,EAAQoI,GACF,OAAtCsB,EAAWH,MAAM,iBAC1BE,EA6OR,SAAgCrB,EAAoB/V,GAClD,GAAaiG,MAATjG,EAAoB,CACtB,KAAMA,aAAiB4R,YACrB,MAAM,IAAIrP,MAASwT,kCAErB/V,EAAQ8Y,GAAuB9Y,GAEjC,OAAOA,EApPS+Y,CAAuBhD,EAAYpI,GACE,OAAtC0J,EAAWH,MAAM,iBAC1BE,EAqPR,SAAgCrB,EAAoB/V,GAClD,GAAaiG,MAATjG,EAAoB,CACtB,KAAMA,aAAiB4R,YACrB,MAAM,IAAIrP,MAASwT,kCAErB/V,EA7IJ,SAA2BgZ,GACzB,IAAKA,EACH,OAEF,KAAMA,aAAkBpH,YACtB,MAAM,IAAIrP,MAAM,2EAKlB,OAlBF,SAAiBuH,EAAamP,GAC5B,IAAIC,EAAMpP,EAAI1K,OACd,KAAO8Z,EAAM,GAAK,GAAKpP,EAAIoP,EAAM,KAAOD,KACpCC,EAEJ,OAAOpP,EAAI0I,OAAO,EAAG0G,GAadC,CAFKL,GAAuBE,GAEf,KACjB9O,QAAQ,MAAO,KACfA,QAAQ,MAAO,KAiIRkP,CAAkBpZ,GAE5B,OAAOA,EA5PSqZ,CAAuBtD,EAAYpI,GACC,OAArC0J,EAAWH,MAAM,gBAC1BE,EAyTR,SACEkC,EACAxD,EACAnI,EACAoI,GAEA,IAAK3X,MAAMgK,QAAQuF,GACjB,MAAM,IAAIpL,MAASwT,6BAErB,IAAMwD,EAAczD,EAAOwB,KAAKkC,QAChC,IAAKD,GAAsC,iBAAhBA,EACzB,MAAM,IAAIhX,MACR,gGAC4CwT,OAIhD,IADA,IAAM0D,EAAY,GACTxa,EAAI,EAAGA,EAAI0O,EAAOvO,OAAQH,IACjCwa,EAAUxa,GAAKqa,EAAWI,UAAUH,EAAa5L,EAAO1O,GAAI8W,GAE9D,OAAO0D,EA7USE,CAAsBlb,KAAMqX,EAA0BnI,EAAQoI,GACxB,OAAvCsB,EAAWH,MAAM,kBAC1BE,EA8UR,SACEkC,EACAxD,EACAnI,EACAoI,GAEA,GAAsB,iBAAXpI,EACT,MAAM,IAAIpL,MAASwT,8BAErB,IAAM6D,EAAY9D,EAAOwB,KAAKtX,MAC9B,IAAK4Z,GAAkC,iBAAdA,EACvB,MAAM,IAAIrX,MACR,mGAC4CwT,OAIhD,IADA,IAAM8D,EAAyC,OAC7BzD,EAAAnY,OAAO4K,KAAK8E,GAAZmM,WAAAA,IAAqB,CAAlC,IAAM9Q,OACT6Q,EAAe7Q,GAAOsQ,EAAWI,UAAUE,EAAWjM,EAAO3E,GAAM+M,EAAa,IAAM/M,GAExF,OAAO6Q,EAlWSE,CAAwBtb,KAAMqX,EAA4BnI,EAAQoI,GAC7B,OAAtCsB,EAAWH,MAAM,mBAC1BE,EA4YR,SACEkC,EACAxD,EACAnI,EACAoI,SAEIiE,GAAuCV,EAAYxD,KACrDA,EAASmE,GAAqBX,EAAYxD,EAAQnI,EAAQ,eAG5D,GAAc1H,MAAV0H,EAAqB,CAGvB,IAFA,IAAMyJ,EAAe,GACf8C,EAAaC,GAAuBb,EAAYxD,EAAQC,OAC5CqE,EAAAnc,OAAO4K,KAAKqR,GAAZJ,WAAAA,IAAyB,CAAtC,IAAM9Q,OACHqR,EAAiBH,EAAWlR,GAClC,IAAIqR,EAAeC,SAAnB,CAIA,IAAIC,SACAC,EAAoBpD,EACxB,GAAIkC,EAAW1D,MAEX2E,EADEF,EAAeI,aACNJ,EAAeK,QAEfL,EAAeM,gBAAkBN,EAAeK,YAExD,CACL,IAAME,EAAQC,GAAmBR,EAAe9C,gBAChDgD,EAAWK,EAAMlZ,MAEjB,IAAuB,QAAAoZ,IAAAC,WAAAA,IAAO,CAAzB,IAAMC,OAEU/U,MADCuU,EAAaQ,IACc/U,MAAf0H,EAAO3E,KACrCwR,EAAaQ,GAAY,IAE3BR,EAAeA,EAAaQ,IAIhC,GAAoB/U,MAAhBuU,EAA2B,CAC7B,IAAMS,EAC8B,KAAlCZ,EAAe9C,eACXxB,EAAa,IAAMsE,EAAe9C,eAClCxB,EAEFmF,EAAcvN,EAAO3E,GACnBmS,EAA2BnB,GAAuCV,EAAYxD,GAElFqF,GACAA,EAAyBC,aAAepS,GACzB/C,MAAfiV,IAEAA,EAAcpF,EAAOyB,gBAGvB,IAAM8D,EAAkB/B,EAAWI,UACjCW,EACAa,EACAD,QAEsBhV,IAApBoV,GAA6CpV,MAAZsU,IAC/BF,EAAeiB,gBAIjBd,EAAae,EAAIf,EAAae,GAAK,GACnCf,EAAae,EAAEhB,GAAYc,GAClBhB,EAAeI,aACxBD,EAAaD,WAAeF,EAAeM,gBAAkBU,KAE7Db,EAAaD,GAAYc,KAMjC,IAAMG,EAA6B1F,EAAOwB,KAAKmE,qBAC/C,GAAID,EAA4B,CAC9B,IAAME,EAAYzd,OAAO4K,KAAKqR,cACnByB,GACoBD,EAAUE,MAAM,SAACC,GAAO,OAAAA,IAAOF,MAE1DvE,EAAQuE,GAAkBrC,EAAWI,UACnC8B,EACA7N,EAAOgO,GACP5F,EAAa,KAAO4F,EAAiB,QAN3C,IAAK,IAAMA,KAAkBhO,IAAlBgO,GAYb,OAAOvE,EAET,OAAOzJ,EA1eSmO,CAAuBrd,KAAMqX,EAA2BnI,EAAQoI,IAG9E,OAAOqB,GAcTvB,wBAAA,SAAYC,EAAgBiG,EAAmBhG,GAC7C,GAAoB9P,MAAhB8V,EAWF,OAVItd,KAAKmX,OAA8B,aAArBE,EAAOwB,KAAKlU,OAAwB0S,EAAO2E,eAI3DsB,EAAe,SAGW9V,IAAxB6P,EAAO2B,eACTsE,EAAejG,EAAO2B,cAEjBsE,EAGT,IAAI3E,EACEC,EAAavB,EAAOwB,KAAKlU,KA0D/B,OAzDK2S,IACHA,EAAaD,EAAOyB,gBAGoB,OAAtCF,EAAWH,MAAM,iBACnBE,EA0cN,SACEkC,EACAxD,EACAiG,EACAhG,GAEIiE,GAAuCV,EAAYxD,KACrDA,EAASmE,GAAqBX,EAAYxD,EAAQiG,EAAc,mBAOlE,IAJA,IAAM7B,EAAaC,GAAuBb,EAAYxD,EAAQC,GAC1DiG,EAAmC,GACjCC,EAAiC,OAErB7F,EAAAnY,OAAO4K,KAAKqR,GAAZJ,WAAAA,IAAyB,CAAtC,IAAM9Q,OACHqR,EAAiBH,EAAWlR,GAC5B4R,EAAQC,GAAmBX,EAAWlR,GAAKuO,gBACjD0E,EAAqBta,KAAKiZ,EAAM,IACxB,IAAArD,mBAAgBmD,YAASC,mBAC7BM,EAAqBlF,EACF,KAAnBwB,QAA4CtR,IAAnBsR,IAC3B0D,EAAqBlF,EAAa,IAAMwB,GAG1C,IAAM2E,EAA0B7B,EAAoC6B,uBACpE,GAAIA,EAAwB,CAE1B,IADA,IAAMC,EAAkB,OACApB,EAAA9c,OAAO4K,KAAKkT,GAAZ3B,WAAAA,IAA2B,CAA9C,IAAMnJ,OACLA,EAAUmL,WAAWF,KACvBC,EAAWlL,EAAUsH,UAAU2D,EAAuB9c,SAAWka,EAAW+C,YACzEhC,EAAoC/C,KAAKtX,MAC1C+b,EAAa9K,GACbgK,IAIJgB,EAAqBta,KAAKsP,GAE5B+K,EAAShT,GAAOmT,OACX,GAAI7C,EAAW1D,MACpB,GAAIyE,EAAeiB,gBAAkBS,EAAaR,EAChDS,EAAShT,GAAOsQ,EAAW+C,YACzBhC,EACA0B,EAAaR,EAAEb,GACfO,OAEG,CACL,IACIqB,EAAoBP,EADHpB,GAAkBD,GAAWnD,GAElD,GAAI8C,EAAeI,kBAIgCxU,KAFjDqW,GADAA,EAAoBP,EAAarB,KACQ4B,EAAkB3B,MAIzD2B,EAAoB,IAGxBN,EAAShT,GAAOsQ,EAAW+C,YACzBhC,EACAiC,EACArB,OAGC,CAKL,IAHA,IAAIsB,SACAC,EAAMT,MAESU,IAAAC,WAAAA,IAAO,CAArB,IAAMnT,OACT,IAAKiT,EAAK,MACVA,EAAMA,EAAIjT,GAEZgT,EAAmBC,EACnB,IAAMrB,EAA2BrF,EAAOwB,KAAK6D,yBAW3CA,GACAnS,IAAQmS,EAAyBC,YACbnV,MAApBsW,IAEAA,EAAmBzG,EAAOyB,gBAG5B,IAAI8D,SAEAjd,MAAMgK,QAAQ2T,EAAa/S,KAA4C,KAAnCkR,EAAWlR,GAAKuO,gBACtDgF,EAAmBR,EAAa/S,GAChCgT,EAAW1C,EAAW+C,YAAYhC,EAAgBkC,EAAkBtB,SACtChV,IAArBsW,QAAkEtW,IAAhCoU,EAAe5C,eAC1D4D,EAAkB/B,EAAW+C,YAC3BhC,EACAkC,EACAtB,GAEFe,EAAShT,GAAOqS,IAKtB,IAAMG,EAA6B1F,EAAOwB,KAAKmE,qBAC/C,GAAID,EAA4B,CAC9B,IAAMmB,EAAuB,SAACC,GAC5B,IAAK,IAAMjB,KAAkBzB,EAAY,CAEvC,GADcW,GAAmBX,EAAWyB,GAAgBpE,gBAClD,KAAOqF,EACf,OAAO,EAGX,OAAO,GAGT,IAAK,IAAMA,KAAoBb,EACzBY,EAAqBC,KACvBZ,EAASY,GAAoBtD,EAAW+C,YACtCb,EACAO,EAAaa,GACb7G,EAAa,KAAO6G,EAAmB,YAIxC,GAAIb,EACT,IAAkB,QAAAc,EAAA5e,OAAO4K,KAAKkT,GAAZe,WAAAA,IAA2B,CAAlC9T,YAEW/C,IAAlB+V,EAAShT,IACRiT,EAAqBc,SAAS/T,IAC9BgU,GAAqBhU,KAEtBgT,EAAShT,GAAO+S,EAAa/S,IAKnC,OAAOgT,EAvlBOiB,CAAyBxe,KAAMqX,EAA2BiG,EAAchG,IAE9EtX,KAAKmX,OAMkB3P,MAArB8V,EAAgB,GAAuC9V,MAArB8V,EAAgB,IACpDA,EAAeA,EAAgB,GAII,OAAnC1E,EAAWH,MAAM,eACnBE,EAAU8F,WAAWnB,GACjB5M,MAAMiI,KACRA,EAAU2E,IAEiC,OAApC1E,EAAWH,MAAM,eAExBE,EADmB,SAAjB2E,GAEwB,UAAjBA,GAGCA,EAEuE,OAA1E1E,EAAWH,MAAM,qDAC1BE,EAAU2E,EAC2D,OAA5D1E,EAAWH,MAAM,uCAC1BE,EAAU,IAAI3K,KAAKsP,GAC2B,OAArC1E,EAAWH,MAAM,gBAC1BE,EA4FR,SAAwBlY,GACtB,IAAKA,EACH,OAEF,OAAO,IAAIuN,KAAS,IAAJvN,GAhGAie,CAAepB,GACsB,OAAtC1E,EAAWH,MAAM,iBAC1BE,EAAUgG,GAAoBrB,GACiB,OAAtC1E,EAAWH,MAAM,iBAC1BE,EA4CR,SAA8BtN,GAC5B,IAAKA,EACH,OAEF,GAAIA,GAAgC,iBAAlBA,EAAIgO,UACpB,MAAM,IAAIvV,MAAM,uEAKlB,OAAO6a,GAFPtT,EAAMA,EAAII,QAAQ,MAAO,KAAKA,QAAQ,MAAO,MApD7BmT,CAAqBtB,GACe,OAArC1E,EAAWH,MAAM,gBAC1BE,EA6kBR,SACEkC,EACAxD,EACAiG,EACAhG,GAGA,IAAMyD,EAAU1D,EAAOwB,KAAKkC,QAC5B,IAAKA,GAA8B,iBAAZA,EACrB,MAAM,IAAIjX,MACR,gGAC4CwT,GAGhD,GAAIgG,EAAc,CACX3d,MAAMgK,QAAQ2T,KAEjBA,EAAe,CAACA,IAIlB,IADA,IAAMtC,EAAY,GACTxa,EAAI,EAAGA,EAAI8c,EAAa3c,OAAQH,IACvCwa,EAAUxa,GAAKqa,EAAW+C,YAAY7C,EAASuC,EAAa9c,GAAO8W,MAAc9W,OAEnF,OAAOwa,EAET,OAAOsC,EAvmBSuB,CAAwB7e,KAAMqX,EAA0BiG,EAAchG,GAChC,OAAvCsB,EAAWH,MAAM,oBAC1BE,EAmjBR,SACEkC,EACAxD,EACAiG,EACAhG,GAGA,IAAM/V,EAAQ8V,EAAOwB,KAAKtX,MAC1B,IAAKA,GAA0B,iBAAVA,EACnB,MAAM,IAAIuC,MACR,mGAC4CwT,GAGhD,GAAIgG,EAAc,CAEhB,IADA,IAAMlC,EAAyC,OAC7BzD,EAAAnY,OAAO4K,KAAKkT,GAAZjC,WAAAA,IAA2B,CAAxC,IAAM9Q,OACT6Q,EAAe7Q,GAAOsQ,EAAW+C,YAAYrc,EAAO+b,EAAa/S,GAAM+M,GAEzE,OAAO8D,EAET,OAAOkC,EAxkBSwB,CACR9e,KACAqX,EACAiG,EACAhG,KAKFD,EAAO0B,aACTJ,EAAUtB,EAAO2B,cAGZL,QAwCX,SAASyD,GAAmBxR,GAC1B,IAAMmU,EAAoB,GACtBC,EAAe,GACnB,GAAIpU,EAGF,IAFA,QAEmBqU,EAFFrU,EAAKwG,MAAM,KAETiK,WAAAA,IAAU,CAAxB,IAAMvQ,OAC4B,OAAjCA,EAAKyB,OAAOzB,EAAKnK,OAAS,GAC5Bqe,GAAgBlU,EAAKiJ,OAAO,EAAGjJ,EAAKnK,OAAS,GAAK,KAElDqe,GAAgBlU,EAChBiU,EAAQ7b,KAAK8b,GACbA,EAAe,IAKrB,OAAOD,EAoNT,SAASrD,GACPb,EACAxD,EACAC,GAEA,IAAImE,EAAapE,EAAOwB,KAAKqG,gBAC7B,IAAKzD,EAAY,CACf,IAAM0D,EAAY9H,EAAOwB,KAAKsG,UAC9B,IAAKA,EACH,MAAM,IAAIrb,MACR,yBAAyBwT,sCAA8C/S,KAAKG,UAC1E2S,OACA7P,EACA,SAKN,IAAM4X,EAAcvE,EAAW3D,aAAaiI,GAC5C,IAAKC,EACH,MAAM,IAAItb,MAAM,mDAAmDqb,QAGrE,KADA1D,EAAa2D,EAAYvG,KAAKqG,iBAE5B,MAAM,IAAIpb,MACR,8DACaS,KAAKG,UACd0a,iBACaD,mBAA0B7H,QAKjD,OAAOmE,EAoGT,SAAS8C,GAAqBc,GAC5B,MAAO,CAAC,IAAK,KAAKf,SAASe,GAwM7B,SAAS7D,GACPX,EACAxD,EACAnI,EACAoQ,GAEA,IAAM5C,EAA2BnB,GAAuCV,EAAYxD,GACpF,GAAIqF,EAA0B,CAC5B,IAAM6C,EAAoB7C,EAAyB4C,GACnD,GAAyB9X,MAArB+X,EAAgC,CAClC,IAAMC,EAAqBtQ,EAAOqQ,GAClC,GAA0B/X,MAAtBgY,EAAiC,CACnC,IAAMpG,EAAW/B,EAAOwB,KAAK4G,YAAcpI,EAAOwB,KAAKsG,UACjDO,EACJF,IAAuBpG,EACnBoG,EACApG,EAAW,IAAMoG,EACjBG,EAAoB9E,EAAW3D,aAAa0I,eAAeF,GAC7DC,IACFtI,EAASsI,KAKjB,OAAOtI,EAGT,SAASkE,GACPV,EACAxD,GAEA,OACEA,EAAOwB,KAAK6D,0BACZmD,GAAkChF,EAAYxD,EAAOwB,KAAK4G,aAC1DI,GAAkChF,EAAYxD,EAAOwB,KAAKsG,WAI9D,SAASU,GAAkChF,EAAwBzB,GACjE,OACEA,GACAyB,EAAW3D,aAAakC,IACxByB,EAAW3D,aAAakC,GAAUP,KAAK6D,yBAyJpC,IAAMoD,GARb,SAAmC1c,GAEjC,IADA,IAAMxB,EAAc,OACFme,IAAA1E,WAAAA,IAAG,CAAhB,IAAM9Q,OACT3I,EAAO2I,GAAOA,EAEhB,OAAO3I,EAGiBoe,CAAQ,CAChC,YACA,UACA,YACA,YACA,OACA,WACA,kBACA,aACA,OACA,SACA,SACA,WACA,SACA,SACA,WACA,2BCh8BA,WACEC,EACAC,EACAle,EACAme,EACA1N,EACA2N,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA3gB,KAAKogB,mBAAqBA,EAC1BpgB,KAAKigB,IAAMA,GAAO,GAClBjgB,KAAKkgB,OAASA,GAAU,MACxBlgB,KAAKyS,QAAUA,aAAmBL,GAAcK,EAAU,IAAIL,GAAYK,GAC1EzS,KAAKgC,KAAOA,EACZhC,KAAKmgB,MAAQA,EACbngB,KAAK4gB,cAAWpZ,EAChBxH,KAAKqgB,gBAAkBA,IAAmB,EAC1CrgB,KAAKsgB,YAAcA,EACnBtgB,KAAKugB,QAAUA,GAAW,EAC1BvgB,KAAKwgB,iBAAmBA,EACxBxgB,KAAKygB,mBAAqBA,EAC1BzgB,KAAK0gB,cAAgBA,EACrB1gB,KAAK2gB,UAAYA,EAyQrB,OAjQEE,sCAAA,WACE,IAAK7gB,KAAKkgB,OACR,MAAM,IAAIpc,MAAM,mCAElB,IAAK9D,KAAKigB,IACR,MAAM,IAAInc,MAAM,iCASpB+c,oBAAA,SAAQ/Y,GACN,IAAKA,EACH,MAAM,IAAIhE,MAAM,8BAGlB,GAAsB0D,MAAlBM,EAAQoY,QAA2D,iBAA7BpY,EAAQoY,OAAO7G,UACvD,MAAM,IAAIvV,MAAM,oCAGlB,GAAIgE,EAAQmY,KAAOnY,EAAQgZ,aACzB,MAAM,IAAIhd,MACR,oGAIJ,KAC2B0D,MAAxBM,EAAQgZ,cAAuE,iBAAnChZ,EAAQgZ,aAAazH,WAClD7R,MAAfM,EAAQmY,KAAqD,iBAA1BnY,EAAQmY,IAAI5G,WAEhD,MAAM,IAAIvV,MAAM,sEAIlB,GAAIgE,EAAQmY,IAAK,CACf,GAA2B,iBAAhBnY,EAAQmY,IACjB,MAAM,IAAInc,MAAM,yCAElB9D,KAAKigB,IAAMnY,EAAQmY,IAIrB,GAAInY,EAAQoY,OAAQ,CAClB,IAAMa,EAAe,CAAC,MAAO,MAAO,OAAQ,SAAU,UAAW,OAAQ,QAAS,SAClF,IAA4D,IAAxDA,EAAa9V,QAAQnD,EAAQoY,OAAOnW,eACtC,MAAM,IAAIjG,MACR,wBACEgE,EAAQoY,OACR,6CACA3b,KAAKG,UAAUqc,IAOvB,GAHA/gB,KAAKkgB,OAASpY,EAAQoY,OAAOnW,cAGzBjC,EAAQgZ,aAAc,CAChB,IAAAE,iBAAcC,mBACtB,GAA4B,iBAAjBD,EACT,MAAM,IAAIld,MAAM,kDAEbgE,EAAQoZ,UACXpZ,EAAQoZ,QAAU,gCAEpB,IAAMA,EAAUpZ,EAAQoZ,QACpBC,EACFD,GACCA,EAAQE,SAAS,KAAO,GAAK,MAC7BJ,EAAarD,WAAW,KAAOqD,EAAa7U,MAAM,GAAK6U,GACpDK,EAAWF,EAAI1I,MAAM,mBAC3B,GAAI4I,GAAYA,EAAS1gB,OAAQ,CAC/B,IAAKsgB,EACH,MAAM,IAAInd,MACR,iBAAiBkd,8EAGrBK,EAASxU,QAAQ,SAAS/B,GACxB,IAAMwW,EAAgBxW,EAAKqB,MAAM,GAAI,GAC/BoV,EAAaN,EAA0CK,GAC7D,GACEC,MAAAA,GAEuB,iBAAdA,GAA+C,iBAAdA,EAC1C,CACA,IAAMC,EAA4Bjd,KAAKG,UAAUuc,OAAgBzZ,EAAW,GAC5E,MAAM,IAAI1D,MACR,iBAAiBkd,kCAA4CM,EAC3D,8CAA8CE,6EAC4BF,qEAClCA,iEAQ9C,GAJmC,iBAAxBC,EAAUlI,YACnB8H,EAAMA,EAAI1V,QAAQX,EAAM2W,mBAAmBF,KAGV,iBAAxBA,EAAUlI,UAAwB,CAC3C,IAAKkI,EAAUhgB,MACb,MAAM,IAAIuC,MACR,0BAA0Bwd,uEAI5BH,EADEI,EAAUG,gBACNP,EAAI1V,QAAQX,EAAMyW,EAAUhgB,OAE5B4f,EAAI1V,QAAQX,EAAM2W,mBAAmBF,EAAUhgB,WAK7DvB,KAAKigB,IAAMkB,EAIb,GAAIrZ,EAAQ6Z,gBAAiB,CAC3B,IAAMA,EAAkB7Z,EAAQ6Z,gBAChC,GAA+B,iBAApBA,EACT,MAAM,IAAI7d,MACR,2SAMA9D,KAAKigB,MAAkC,IAA3BjgB,KAAKigB,IAAIhV,QAAQ,OAC/BjL,KAAKigB,KAAO,KAGd,IAAM2B,EAAc,GAGpB,IAAK,IAAMC,KADX7hB,KAAKmgB,MAAQ,GACgBwB,EAAiB,CAC5C,IAAMG,EAAkBH,EAAgBE,GACxC,GAAIC,EACF,GAA0B,iBAAfA,EACTF,EAAY1e,KAAK2e,EAAiB,IAAMJ,mBAAmBK,IAC3D9hB,KAAKmgB,MAAM0B,GAAkBJ,mBAAmBK,QAC3C,GAA0B,iBAAfA,EAAyB,CACzC,IAAKA,EAAWvgB,MACd,MAAM,IAAIuC,MACR,2BAA2B+d,uEAG3BC,EAAWJ,iBACbE,EAAY1e,KAAK2e,EAAiB,IAAMC,EAAWvgB,OACnDvB,KAAKmgB,MAAM0B,GAAkBC,EAAWvgB,QAExCqgB,EAAY1e,KAAK2e,EAAiB,IAAMJ,mBAAmBK,EAAWvgB,QACtEvB,KAAKmgB,MAAM0B,GAAkBJ,mBAAmBK,EAAWvgB,SAMnEvB,KAAKigB,KAAO2B,EAAY7c,KAAK,KAI/B,GAAI+C,EAAQ2K,QAEV,IADA,IAAMA,EAAU3K,EAAQ2K,YACCkF,EAAAnY,OAAO4K,KAAKtC,EAAQ2K,SAApB4I,WAAAA,IAA8B,CAAlD,IAAMtJ,OACT/R,KAAKyS,QAAQN,IAAIJ,EAAYU,EAAQV,IAkDzC,OA9CK/R,KAAKyS,QAAQsP,IAAI,oBACpB/hB,KAAKyS,QAAQN,IAAI,kBAAmB,SAGjCnS,KAAKyS,QAAQsP,IAAI,2BAA8Bja,EAAQka,wBAC1DhiB,KAAKyS,QAAQN,IAAI,yBAA0BuE,MAIxC1W,KAAKyS,QAAQsP,IAAI,iBACpB/hB,KAAKyS,QAAQN,IAAI,eAAgB,mCAInCnS,KAAKgC,KAAO8F,EAAQ9F,KACAwF,MAAhBM,EAAQ9F,OAEN8F,EAAQma,cACLjiB,KAAKyS,QAAQsP,IAAI,sBACpB/hB,KAAKyS,QAAQN,IAAI,oBAAqB,WAEC,6BAArCnS,KAAKyS,QAAQsP,IAAI,iBACnB/hB,KAAKyS,QAAQN,IAAI,eAAgB,8BAG/BrK,EAAQoa,sBACVliB,KAAKgC,KAAO,IAAIoV,GAAWtP,EAAQqa,SAASlH,UAC1CnT,EAAQoa,oBACRpa,EAAQ9F,KACR,gBAGC8F,EAAQsa,6BACXpiB,KAAKgC,KAAOuC,KAAKG,UAAUoD,EAAQ9F,SAKrC8F,EAAQC,cACV/H,KAAK+H,YAAcD,EAAQC,aAG7B/H,KAAKsgB,YAAcxY,EAAQwY,YAC3BtgB,KAAKygB,mBAAqB3Y,EAAQ2Y,mBAClCzgB,KAAKwgB,iBAAmB1Y,EAAQ0Y,iBAEzBxgB,MAOT6gB,kBAAA,WACE,IAAMjf,EAAS,IAAIif,EACjB7gB,KAAKigB,IACLjgB,KAAKkgB,OACLlgB,KAAKgC,KACLhC,KAAKmgB,MACLngB,KAAKyS,SAAWzS,KAAKyS,QAAQ+D,QAC7BxW,KAAKogB,mBACLpgB,KAAKqgB,gBACLrgB,KAAKsgB,YACLtgB,KAAKugB,QACLvgB,KAAKwgB,iBACLxgB,KAAKygB,mBACLzgB,KAAK0gB,cACL1gB,KAAK2gB,WAmBP,OAhBI3gB,KAAK4gB,WACPhf,EAAOgf,SAAW5gB,KAAK4gB,UAGrB5gB,KAAKqiB,gBACPzgB,EAAOygB,cAAgBriB,KAAKqiB,eAG1BriB,KAAKsiB,oBACP1gB,EAAO0gB,kBAAoBtiB,KAAKsiB,mBAG9BtiB,KAAKuiB,0BACP3gB,EAAO2gB,wBAA0BviB,KAAKuiB,yBAGjC3gB,QC3XL4gB,GAAe,IAAIC,QACnBC,GAAa,IAAID,sBA6CrB,aAqCOziB,aAAwC,KApC7CwiB,GAAarQ,IAAInS,KAAM,IACvB0iB,GAAWvQ,IAAInS,MAAM,GAuFzB,OA7EER,sBAAWmjB,2BAAX,WACE,IAAKD,GAAWhZ,IAAI1J,MAClB,MAAM,IAAIgD,UAAU,qDAGtB,OAAO0f,GAAWX,IAAI/hB,uCAWxBR,sBAAkBmjB,cAAlB,WACE,OAAO,IAAIA,mCAiBNA,6BAAP,SAEEC,EACAC,GAEA,IAAKL,GAAa9Y,IAAI1J,MACpB,MAAM,IAAIgD,UAAU,qDAGJwf,GAAaT,IAAI/hB,MACzBkD,KAAK2f,IAUVF,gCAAP,SAEEC,EACAC,GAEA,IAAKL,GAAa9Y,IAAI1J,MACpB,MAAM,IAAIgD,UAAU,qDAGtB,IAAM8f,EAAYN,GAAaT,IAAI/hB,MAE7BqQ,EAAQyS,EAAU7X,QAAQ4X,GAC5BxS,GAAS,GACXyS,EAAUC,OAAO1S,EAAO,IAO5BsS,0BAAA,SAAcK,GACZ,MAAM,IAAIlf,MAAM,mIAcJwc,GAAY2C,GAC1B,IAAIA,EAAOC,QAAX,CAIID,EAAOE,SACTF,EAAOE,QAAQviB,KAAKqiB,GAGtB,IAAMH,EAAYN,GAAaT,IAAIkB,GAC/BH,GACFA,EAAUjW,QAAQ,SAACgW,GACjBA,EAASjiB,KAAKqiB,EAAQ,CAAEpK,KAAM,YAIlC6J,GAAWvQ,IAAI8Q,GAAQ,ICpJzB,ICZYG,kBDaV,WAAYla,GAAZ,MACEma,YAAMna,gBACNoa,EAAK3e,KAAO,eAEhB,OALgC4e,UAAAzf,sBAoD9B,WAAY0f,GAAZ,WAGE,GAFAxjB,KAAKyjB,QAAU,IAAId,GAEda,EAAL,CAIK7jB,MAAMgK,QAAQ6Z,KACjBA,EAAgB9iB,WAElB,IAA2B,QAAAgjB,IAAArI,WAAAA,IAAe,CAArC,IAAMsI,OAGLA,EAAaT,QACfljB,KAAK4jB,QAGLD,EAAaE,iBAAiB,QAAS,WACrCP,EAAKM,YAcbpkB,sBAAWskB,0BAAX,WACE,OAAO9jB,KAAKyjB,yCASdK,kBAAA,WACExD,GAAYtgB,KAAKyjB,UAULK,UAAd,SAAsBC,GACpB,IAAMd,EAAS,IAAIN,GACbqB,EAAQnN,WAAWyJ,GAAayD,EAAId,GAK1C,MAH2B,mBAAhBe,EAAMC,OACfD,EAAMC,QAEDhB,kBEnHT,WACE/Z,EACAF,EACAhF,EACAsS,EACAL,GALF,MAOEoN,YAAMna,gBACNoa,EAAKta,KAAOA,EACZsa,EAAKtf,WAAaA,EAClBsf,EAAKhN,QAAUA,EACfgN,EAAKrN,SAAWA,EAEhBzW,OAAOC,eAAe6jB,EAAMY,EAAUhkB,aAE1C,OAxB+BqjB,OACbW,qBAA6B,qBAC7BA,cAAsB,iBAFTpgB,sBCO/B,cAwGA,OAvGSqgB,wBAAP,SAAmB7N,GACjB,IAAM8N,EAAM,IAAIC,eAEhB,GAAI/N,EAAQoK,cACV,MAAM,IAAI5c,MAAM,sDAGlB,IAAMwc,EAAchK,EAAQgK,YAC5B,GAAIA,EAAa,CACf,GAAIA,EAAY4C,QACd,OAAO/hB,QAAQE,OAAO,IAAIijB,GAAW,+BAGvC,IAAMC,EAAW,WACfH,EAAIR,SAENtD,EAAYuD,iBAAiB,QAASU,GACtCH,EAAIP,iBAAiB,mBAAoB,WACnCO,EAAII,aAAeH,eAAeI,MACpCnE,EAAYoE,oBAAoB,QAASH,KAQ/C,GAHAI,GAAoBP,EAAIQ,OAAQtO,EAAQkK,kBACxCmE,GAAoBP,EAAK9N,EAAQmK,oBAE7BnK,EAAQsK,SAAU,CAUpB,IATA,IAAMA,EAAWtK,EAAQsK,SACnBiE,EAAc,IAAIC,SAClBC,EAAkB,SAACxa,EAAahJ,GAChCA,GAASA,EAAM1B,eAAe,UAAY0B,EAAM1B,eAAe,WACjEglB,EAAYG,OAAOza,EAAKhJ,EAAMA,MAAOA,EAAMuG,SAE3C+c,EAAYG,OAAOza,EAAKhJ,QAGNoW,EAAAnY,OAAO4K,KAAKwW,GAAZvF,WAAAA,IAAuB,CAAxC,IAAM4J,OACHC,EAAYtE,EAASqE,GAC3B,GAAItlB,MAAMgK,QAAQub,GAChB,IAAK,IAAIna,EAAI,EAAGA,EAAIma,EAAUvkB,OAAQoK,IACpCga,EAAgBE,EAASC,EAAUna,SAGrCga,EAAgBE,EAASC,GAI7B5O,EAAQtU,KAAO6iB,EACfvO,EAAQsK,cAAWpZ,EACnB,IAAM2d,EAAc7O,EAAQ7D,QAAQsP,IAAI,gBACpCoD,IAA+D,IAAhDA,EAAYla,QAAQ,wBAErCqL,EAAQ7D,QAAQgE,OAAO,gBAI3B2N,EAAIgB,KAAK9O,EAAQ4J,OAAQ5J,EAAQ2J,KACjCmE,EAAI7D,QAAUjK,EAAQiK,QACtB6D,EAAI/D,gBAAkB/J,EAAQ+J,gBAC9B,IAAqB,QAAA/D,EAAAhG,EAAQ7D,QAAQE,eAAhBgJ,WAAAA,IAAgC,CAAhD,IAAMrJ,OACT8R,EAAIiB,iBAAiB/S,EAAO3N,KAAM2N,EAAO/Q,OAO3C,OALA6iB,EAAIkB,aAAehP,EAAQ8J,mBAAqB,OAAS,OAGzDgE,EAAImB,UAAsB/d,IAAjB8O,EAAQtU,KAAqB,KAAOsU,EAAQtU,MAEjDsU,EAAQ8J,mBACH,IAAIjf,QAAQ,SAACC,EAASC,GAC3B+iB,EAAIP,iBAAiB,mBAAoB,WAEvC,GAAIO,EAAII,aAAeH,eAAemB,iBAAkB,CACtD,IAAMC,EAAW,IAAItkB,QAAc,SAACC,EAASC,GAC3C+iB,EAAIP,iBAAiB,OAAQ,WAC3BziB,EAAQgjB,EAAInO,YAEdyP,GAAsBpP,EAAS8N,EAAK/iB,KAEtCD,EAAQ,CACNkV,UACAF,OAAQgO,EAAIhO,OACZ3D,QAASkT,GAAavB,GACtBqB,gBAINC,GAAsBpP,EAAS8N,EAAK/iB,KAG/B,IAAIF,QAAQ,SAASC,EAASC,GACnC+iB,EAAIP,iBAAiB,OAAQ,WAC3B,OAAAziB,EAAQ,CACNkV,UACAF,OAAQgO,EAAIhO,OACZ3D,QAASkT,GAAavB,GACtBjO,WAAYiO,EAAIwB,iBAGpBF,GAAsBpP,EAAS8N,EAAK/iB,WAM5C,SAASsjB,GACPP,EACAvB,GAEIA,GACFuB,EAAIP,iBAAiB,WAAY,SAACgC,GAChC,OAAAhD,EAAS,CACPiD,YAAaD,EAASE,oBAOdJ,GAAavB,GAM3B,IALA,IAAM4B,EAAkB,IAAI5T,OAKT6T,EAJC7B,EACjB8B,wBACAC,OACA/U,MAAM,WACUiK,WAAAA,IAAa,CAA3B,IAAM+K,OACH/V,EAAQ+V,EAAKnb,QAAQ,KACrB8G,EAAaqU,EAAKja,MAAM,EAAGkE,GAC3BgC,EAAc+T,EAAKja,MAAMkE,EAAQ,GACvC2V,EAAgB7T,IAAIJ,EAAYM,GAElC,OAAO2T,EAGT,SAASN,GACPpP,EACA8N,EACA/iB,GAEA+iB,EAAIP,iBAAiB,QAAS,WAC5B,OAAAxiB,EACE,IAAI6iB,GACF,6BAA6B5N,EAAQ2J,IACrCiE,GAAUmC,wBACV7e,EACA8O,MAIN8N,EAAIP,iBAAiB,QAAS,WAAM,OAAAxiB,EAAO,IAAIijB,GAAW,iCAC1DF,EAAIP,iBAAiB,UAAW,WAC9B,OAAAxiB,EACE,IAAI6iB,GACF,cAAcE,EAAI7D,sBAClB2D,GAAUmC,wBACV7e,EACA8O,OFpKR,SAAY8M,GAIVA,iBAKAA,qBAKAA,yBAKAA,mBAnBF,CAAYA,KAAAA,QGIZ,kBAAA,aACmBpjB,eAAiE,GAwIpF,OAnISsmB,gBAAP,WACE,OAAO9mB,OAAO4K,KAAKpK,KAAKumB,WAAW5lB,OAAS,GAMvC2lB,iBAAP,WACE,OAAO9mB,OAAO4K,KAAKpK,KAAKumB,YAQnBD,gBAAP,SAAWE,EAAuBC,GAChC,GAAID,EACF,GAAsBhf,MAAlBif,EAA6B,CAC/B,IAAMC,EAAW/mB,MAAMgK,QAAQ8c,GAAkBA,EAAiBA,EAAe3c,WACjF9J,KAAKumB,UAAUC,GAAiBE,cAEzB1mB,KAAKumB,UAAUC,IASrBF,gBAAP,SAAWE,GACT,OAAOA,EAAgBxmB,KAAKumB,UAAUC,QAAiBhf,GAMlD8e,qBAAP,WACE,IAAI1kB,EAAS,GACb,IAAK,IAAM4kB,KAAiBxmB,KAAKumB,UAAW,CACtC3kB,IACFA,GAAU,KAEZ,IAAM6kB,EAAiBzmB,KAAKumB,UAAUC,GACtC,GAAI7mB,MAAMgK,QAAQ8c,GAAiB,CAEjC,IADA,IAAME,EAAmB,OACWC,IAAAvL,WAAAA,IAAgB,CAA/C,IAAMwL,OACTF,EAAiBzjB,KAAQsjB,MAAiBK,GAE5CjlB,GAAU+kB,EAAiB5hB,KAAK,UAEhCnD,GAAa4kB,MAAiBC,EAGlC,OAAO7kB,GAMK0kB,QAAd,SAAoBQ,GAClB,IAAMllB,EAAS,IAAI0kB,EAEnB,GAAIQ,EAAM,CACJA,EAAKnJ,WAAW,OAClBmJ,EAAOA,EAAKhN,UAAU,IAOxB,IAJA,IAAIiN,EAAmC,gBAEnCP,EAAgB,GAChBC,EAAiB,GACZjmB,EAAI,EAAGA,EAAIsmB,EAAKnmB,SAAUH,EAAG,CACpC,IAAMwmB,EAA2BF,EAAKtmB,GACtC,OAAQumB,GACN,IAAK,gBACH,OAAQC,GACN,IAAK,IACHD,EAAe,iBACf,MAEF,IAAK,IACHP,EAAgB,GAChBC,EAAiB,GACjB,MAEF,QACED,GAAiBQ,EAGrB,MAEF,IAAK,iBACH,OAAQA,GACN,IAAK,IACHR,EAAgB,GAChBC,EAAiB,GACjBM,EAAe,UACf,MAEF,IAAK,IACHnlB,EAAOuQ,IAAIqU,EAAeC,GAC1BD,EAAgB,GAChBC,EAAiB,GACjBM,EAAe,gBACf,MAEF,QACEN,GAAkBO,EAGtB,MAEF,IAAK,UACsB,MAArBA,IACFD,EAAe,iBAEjB,MAEF,QACE,MAAM,IAAIjjB,MAAM,sCAAwCijB,IAGzC,mBAAjBA,GACFnlB,EAAOuQ,IAAIqU,EAAeC,GAI9B,OAAO7kB,sBAOX,cA6OA,OAlOSqlB,sBAAP,SAAiBC,GACVA,EAGHlnB,KAAKmS,IAAI+U,EAAQ,UAFjBlnB,KAAKmnB,aAAU3f,GASZyf,sBAAP,WACE,OAAOjnB,KAAKmnB,SAOPF,oBAAP,SAAeG,GACRA,EAGHpnB,KAAKmS,IAAIiV,EAAM,kBAFfpnB,KAAKqnB,WAAQ7f,GASVyf,oBAAP,WACE,OAAOjnB,KAAKqnB,OAOPJ,oBAAP,SAAeK,GACD9f,MAAR8f,GAA8B,KAATA,EACvBtnB,KAAKunB,WAAQ/f,EAEbxH,KAAKmS,IAAImV,EAAKxd,WAAY,SAOvBmd,oBAAP,WACE,OAAOjnB,KAAKunB,OAOPN,oBAAP,SAAeO,GACRA,GAG0B,IAAzBA,EAAKvc,QAAQ,OACfjL,KAAKmS,IAAIqV,EAAM,UAEfxnB,KAAKmS,IAAIqV,EAAM,QALjBxnB,KAAKynB,WAAQjgB,GAcVyf,uBAAP,SAAkBO,GAChB,GAAIA,EAAM,CACR,IAAIE,EAAkC1nB,KAAK2nB,UACvCD,IACGA,EAAYtG,SAAS,OACxBsG,GAAe,KAGbF,EAAK7J,WAAW,OAClB6J,EAAOA,EAAK1N,UAAU,IAGxB0N,EAAOE,EAAcF,GAEvBxnB,KAAKmS,IAAIqV,EAAM,UAOZP,oBAAP,WACE,OAAOjnB,KAAKynB,OAMPR,qBAAP,SAAgB9G,GAIZngB,KAAK4nB,OAHFzH,EAGWmG,GAAS9hB,MAAM2b,QAFf3Y,GAWXyf,8BAAP,SAAyBY,EAA4BC,GAC/CD,IACG7nB,KAAK4nB,SACR5nB,KAAK4nB,OAAS,IAAItB,IAEpBtmB,KAAK4nB,OAAOzV,IAAI0V,EAAoBC,KAQjCb,mCAAP,SAA8BY,GAC5B,OAAO7nB,KAAK4nB,OAAS5nB,KAAK4nB,OAAO7F,IAAI8F,QAAsBrgB,GAMtDyf,qBAAP,WACE,OAAOjnB,KAAK4nB,OAAS5nB,KAAK4nB,OAAO9d,gBAAatC,GAMxCyf,gBAAR,SAAYH,EAAciB,GAGxB,IAFA,IAAMC,EAAY,IAAIC,GAAanB,EAAMiB,GAElCC,EAAUvmB,QAAQ,CACvB,IAAMmH,EAA8Bof,EAAUE,UAC9C,GAAItf,EACF,OAAQA,EAAMiQ,MACZ,IAAK,SACH7Y,KAAKmnB,QAAUve,EAAMke,WAAQtf,EAC7B,MAEF,IAAK,OACHxH,KAAKqnB,MAAQze,EAAMke,WAAQtf,EAC3B,MAEF,IAAK,OACHxH,KAAKunB,MAAQ3e,EAAMke,WAAQtf,EAC3B,MAEF,IAAK,OACH,IAAM2gB,EAAgCvf,EAAMke,WAAQtf,EAC/CxH,KAAKynB,OAAwB,MAAfznB,KAAKynB,OAA+B,MAAdU,IACvCnoB,KAAKynB,MAAQU,GAEf,MAEF,IAAK,QACHnoB,KAAK4nB,OAAStB,GAAS9hB,MAAMoE,EAAMke,MACnC,MAEF,QACE,MAAM,IAAIhjB,MAAM,8BAA8B8E,EAAMiQ,SAMvDoO,qBAAP,WACE,IAAIrlB,EAAS,GAyBb,OAvBI5B,KAAKmnB,UACPvlB,GAAa5B,KAAKmnB,eAGhBnnB,KAAKqnB,QACPzlB,GAAU5B,KAAKqnB,OAGbrnB,KAAKunB,QACP3lB,GAAU,IAAI5B,KAAKunB,OAGjBvnB,KAAKynB,QACFznB,KAAKynB,MAAM9J,WAAW,OACzB/b,GAAU,KAEZA,GAAU5B,KAAKynB,OAGbznB,KAAK4nB,QAAU5nB,KAAK4nB,OAAOQ,QAC7BxmB,GAAU,IAAI5B,KAAK4nB,OAAO9d,YAGrBlI,GAOFqlB,uBAAP,SAAkBjQ,EAAqBC,GACjCD,IACFhX,KAAKqoB,UAAUtR,GAAW/W,KAAKsoB,YAAatR,EAAaC,IACzDjX,KAAKuoB,QAAQxR,GAAW/W,KAAKwoB,UAAWxR,EAAaC,IACrDjX,KAAKyoB,QAAQ1R,GAAW/W,KAAK0oB,UAAW1R,EAAaC,IACrDjX,KAAK2oB,QAAQ5R,GAAW/W,KAAK2nB,UAAW3Q,EAAaC,IACrDjX,KAAK4oB,SAAS7R,GAAW/W,KAAK6oB,WAAY7R,EAAaC,MAI7CgQ,QAAd,SAAoBH,GAClB,IAAMllB,EAAS,IAAIqlB,EAEnB,OADArlB,EAAOuQ,IAAI2U,EAAM,kBACVllB,sBAST,WAAmCklB,EAA8BjO,GAA9B7Y,UAAA8mB,EAA8B9mB,UAAA6Y,EAqBnE,OAnBgBiQ,SAAd,SAAqBhC,GACnB,OAAO,IAAIgC,EAAShC,EAAM,WAGdgC,OAAd,SAAmBhC,GACjB,OAAO,IAAIgC,EAAShC,EAAM,SAGdgC,OAAd,SAAmBhC,GACjB,OAAO,IAAIgC,EAAShC,EAAM,SAGdgC,OAAd,SAAmBhC,GACjB,OAAO,IAAIgC,EAAShC,EAAM,SAGdgC,QAAd,SAAoBhC,GAClB,OAAO,IAAIgC,EAAShC,EAAM,eAoB9B,kBAME,WAA4BiC,EAAeC,GAAfhpB,WAAA+oB,EAC1B/oB,KAAKipB,YAAcF,EAAQA,EAAMpoB,OAAS,EAC1CX,KAAKkpB,cAAyB1hB,MAATwhB,EAAqBA,EAAQ,iBAClDhpB,KAAKmpB,cAAgB,EAiDzB,OA1CSlB,oBAAP,WACE,OAAOjoB,KAAKopB,eAMPnB,iBAAP,WACE,GAAKoB,GAAoBrpB,MAGvB,OAAQA,KAAKkpB,eACX,IAAK,SA2HLhC,EAhBR,SAAgCc,GAC9B,OAAOsB,GAAUtB,EAAW,SAACuB,GAAsB,gBApJbA,GACtC,IAAMC,EAAwBD,EAAUjd,WAAW,GACnD,OACG,IAAgBkd,GAAiBA,GAAiB,IAClD,IAAgBA,GAAiBA,GAAiB,IAClD,IAAgBA,GAAiBA,GAAiB,IA+IFC,CAAwBF,KAepDG,CADL1B,EAzHChoB,MA2HnBgoB,EAAUoB,cAAgBN,GAAS5B,OAAOA,GACrCmC,GAAoBrB,GAGvBA,EAAUkB,cAAgB,OAF1BlB,EAAUkB,cAAgB,OA5HpB,MAEF,IAAK,kBAgIb,SAA0BlB,GACxB,IAAM2B,EAAuBC,GAAmB5B,EAAW,IAAK,IAAK,KAChEqB,GAAoBrB,GAGqB,MAAnC6B,GAAoB7B,GACQ,QAAjC8B,GAAe9B,EAAW,IAC5BA,EAAUoB,cAAgBN,GAAS5B,OAAOyC,GAC1C3B,EAAUkB,cAAgB,SAE1BlB,EAAUoB,cAAgBN,GAAS1B,KAAKuC,GACxC3B,EAAUkB,cAAgB,SAG5BlB,EAAUoB,cAAgBN,GAAS1B,KAAKuC,GACD,MAAnCE,GAAoB7B,GACtBA,EAAUkB,cAAgB,OAE1BlB,EAAUkB,cAAgB,UAf5BlB,EAAUoB,cAAgBN,GAAS1B,KAAKuC,GACxC3B,EAAUkB,cAAgB,QAnIpBa,CAAiB/pB,MACjB,MAEF,IAAK,QAmJb,SAAkBgoB,GACqB,QAAjC8B,GAAe9B,EAAW,IAC5BgC,GAAchC,EAAW,GAG3B,IAAMZ,EAAewC,GAAmB5B,EAAW,IAAK,IAAK,KAC7DA,EAAUoB,cAAgBN,GAAS1B,KAAKA,GAEnCiC,GAAoBrB,GAEqB,MAAnC6B,GAAoB7B,GAC7BA,EAAUkB,cAAgB,OACkB,MAAnCW,GAAoB7B,GAC7BA,EAAUkB,cAAgB,OAE1BlB,EAAUkB,cAAgB,QAN1BlB,EAAUkB,cAAgB,OA3JpBe,CAASjqB,MACT,MAEF,IAAK,QAkKb,SAAkBgoB,GACuB,MAAnC6B,GAAoB7B,IACtBgC,GAAchC,GAGhB,IAAMV,EAAesC,GAAmB5B,EAAW,IAAK,KACxDA,EAAUoB,cAAgBN,GAASxB,KAAKA,GAEnC+B,GAAoBrB,GAEqB,MAAnC6B,GAAoB7B,GAC7BA,EAAUkB,cAAgB,OAE1BlB,EAAUkB,cAAgB,QAJ1BlB,EAAUkB,cAAgB,OA1KpBgB,CAASlqB,MACT,MAEF,IAAK,QA+Kb,SAAkBgoB,GAChB,IAAMR,EAAeoC,GAAmB5B,EAAW,KACnDA,EAAUoB,cAAgBN,GAAStB,KAAKA,GAEnC6B,GAAoBrB,GAGvBA,EAAUkB,cAAgB,QAF1BlB,EAAUkB,cAAgB,OAnLpBiB,CAASnqB,MACT,MAEF,IAAK,SAsLb,SAAmBgoB,GACsB,MAAnC6B,GAAoB7B,IACtBgC,GAAchC,GAGhB,IAAM7H,EA5KR,SAAuB6H,GACrB,IAAIpmB,EAAS,GACTomB,EAAUmB,cAAgBnB,EAAUiB,cACtCrnB,EAASomB,EAAUe,MAAMjP,UAAUkO,EAAUmB,eAC7CnB,EAAUmB,cAAgBnB,EAAUiB,aAEtC,OAAOrnB,EAsKewoB,CAAcpC,GACpCA,EAAUoB,cAAgBN,GAAS3I,MAAMA,GACzC6H,EAAUkB,cAAgB,OA5LlBmB,CAAUrqB,MACV,MAEF,QACE,MAAM,IAAI8D,MAAM,mCAAmC9D,KAAKkpB,oBA5B5DlpB,KAAKopB,mBAAgB5hB,EA6H3B,IAAoBwgB,EACZd,EA/FJ,QAASlnB,KAAKopB,oBAmBlB,SAASC,GAAoBrB,GAC3B,OAAOA,EAAUmB,cAAgBnB,EAAUiB,YAM7C,SAASY,GAAoB7B,GAC3B,OAAOA,EAAUe,MAAMf,EAAUmB,eAOnC,SAASa,GAAchC,EAAyBxmB,GAC1C6nB,GAAoBrB,KACjBxmB,IACHA,EAAO,GAETwmB,EAAUmB,eAAiB3nB,GAQ/B,SAASsoB,GAAe9B,EAAyBsC,GAC/C,IAAIC,EAAmBvC,EAAUmB,cAAgBmB,EAIjD,OAHItC,EAAUiB,YAAcsB,IAC1BA,EAAWvC,EAAUiB,aAEhBjB,EAAUe,MAAMjP,UAAUkO,EAAUmB,cAAeoB,GAO5D,SAASjB,GAAUtB,EAAyBwC,GAG1C,IAFA,IAAI5oB,EAAS,GAENynB,GAAoBrB,IAAY,CACrC,IAAMhB,EAA2B6C,GAAoB7B,GACrD,IAAKwC,EAAUxD,GACb,MAEAplB,GAAUolB,EACVgD,GAAchC,GAIlB,OAAOpmB,EAeT,SAASgoB,GAAmB5B,OAAyB,aAAA3M,mBAAAA,IAAAoP,oBACnD,OAAOnB,GACLtB,EACA,SAACuB,GAAsB,OAA8C,IAA9CkB,EAAsBxf,QAAQse,KCljBzD,kBACE,WACWmB,EACAnkB,GADAvG,iBAAA0qB,EACA1qB,cAAAuG,EAuBb,OAbSokB,sBAAP,SAAiBC,GACf,OAAO5qB,KAAKuG,SAASskB,UAAUD,IAS1BD,gBAAP,SAAWC,EAAgC1hB,GACzClJ,KAAKuG,SAASukB,IAAIF,EAAU1hB,uBAQ9B,WAAoB6hB,GAAA/qB,aAAA+qB,EA0BtB,OAnBSC,sBAAP,SAAiBJ,GACf,QACI5qB,KAAK+qB,SACPH,IAAaxH,GAAqB6H,KAClCL,GAAY5qB,KAAK+qB,QAAQG,iBAUtBF,gBAAP,SAAWJ,EAAgC1hB,GACrClJ,KAAK+qB,SAAW/qB,KAAK6qB,UAAUD,IACjC5qB,KAAK+qB,QAAQD,IAAIF,EAAU1hB,SCvE3BiiB,GAAcC,QAAQC,OAASD,QAAQN,ICgE7C,IAGIQ,GAHEC,GACgB,oBAAZ1V,SAA2BA,QAAQ2V,KAAO3V,QAAQ2V,IAAIC,YAAUjkB,EAGtEkkB,GAA8B,GAC9BC,GAA8B,GAC5BC,GAAwB,GAM9B,SAASC,GAAOC,eACdR,GAAgBQ,EAChBJ,GAAoB,GACpBC,GAAoB,GACpB,IAAMI,EAAW,MACXC,EAAgBF,EAAW1a,MAAM,KAAK6a,IAAI,SAACC,GAAO,OAAAA,EAAG/F,OAAO1a,QAAQsgB,EAAU,aACpF,IAAiB,IAAAI,EAAAhpB,EAAA6oB,iCAAe,CAA3B,IAAME,UACLA,EAAGvO,WAAW,KAChBgO,GAAkBzoB,KAAK,IAAIsV,OAAO,IAAI0T,EAAGnY,OAAO,SAEhD2X,GAAkBxoB,KAAK,IAAIsV,OAAO,IAAI0T,8GAG1C,IAAuB,IAAAE,EAAAjpB,EAAAyoB,kCAAW,CAA7B,IAAMrO,UACTA,EAAS8O,QAAUA,GAAQ9O,EAAS+O,8GAIxC,SAASD,GAAQC,eACf,GAAIA,EAAUlL,SAAS,KACrB,OAAO,MAGT,IAAsB,IAAAmL,EAAAppB,EAAAwoB,kCAAmB,CACvC,WAAYpS,KAAK+S,GACf,OAAO,wGAGX,IAAsB,IAAAE,EAAArpB,EAAAuoB,kCAAmB,CACvC,WAAYnS,KAAK+S,GACf,OAAO,oGAGX,OAAO,EAST,SAASG,GAAeH,GAWtB,IAAMI,EAAwBltB,OAAOa,OAVrC,eAAe,aAAAgb,mBAAAA,IAAAsR,kBACRD,EAAYL,UAGbM,EAAKhsB,OAAS,IAChBgsB,EAAK,GAAQL,MAAaK,EAAK,IAEjCD,EAAY5B,UAAZ4B,IAAmBC,MAG8B,CACjDN,QAASA,GAAQC,GACjBM,WACA9B,IAAK+B,GAAS/B,IACdwB,YACAQ,YAKF,OAFAlB,GAAU1oB,KAAKwpB,GAERA,EAGT,SAASE,KACP,IAAMvc,EAAQub,GAAU3gB,QAAQjL,MAChC,OAAIqQ,GAAS,IACXub,GAAU7I,OAAO1S,EAAO,IACjB,GAKX,SAASyc,GAAuBR,GAC9B,IAAMI,EAAcD,GAAkBzsB,KAAKssB,cAAaA,GAExD,OADAI,EAAY5B,IAAM9qB,KAAK8qB,IAChB4B,EAlFLnB,IACFM,GAAON,IAoFT,ICtJIwB,GDsJEF,GAAkBrtB,OAAOa,OAC7B,SAACisB,GACC,OAAOG,GAAeH,IAExB,CACET,UACAQ,WACAW,QApDJ,WACE,IAAMprB,EAAS0pB,IAAiB,GAEhC,OADAO,GAAO,IACAjqB,GAkDLkpB,mBDpKgB,aAAAzP,mBAAAA,IAAAsR,kBAClBxB,kBAAewB,OECXM,GAAoB,IAAIC,IACxBC,GACgB,oBAAZtX,SAA2BA,QAAQ2V,KAAO3V,QAAQ2V,IAAI4B,sBAAoB5lB,EASvE6lB,GAAiChC,GAAM,SACpDgC,GAAYvC,IAAM,eAAC,aAAAzP,mBAAAA,IAAAsR,kBACjBtB,GAAMP,UAANO,KAAasB,KAYf,IAAMW,GAAmB,CAAC,UAAW,OAAQ,UAAW,SASpDH,KAEEI,GAAgBJ,aAoBMK,WAC1B,GAAIA,IAAUD,GAAgBC,GAC5B,MAAM,IAAI1pB,MACR,sBAAsB0pB,2BAA8BF,GAAiBvoB,KAAK,MAG9EgoB,GAAgBS,EAEhB,IAAM9B,EAAoB,OAC1B,IAAqB,IAAA+B,EAAAtqB,EAAA8pB,kCAAmB,CAAnC,IAAMS,UACLC,GAAaD,IACfhC,EAAkBxoB,KAAKwqB,EAAOpB,6GAIlCjB,GAAMQ,OAAOH,EAAkB3mB,KAAK,MAlClC6oB,CAAYT,IAEZ/B,QAAQ3nB,MACN,6CAA6C0pB,oDAAgEG,GAAiBvoB,KAC5H,YAwCR,IAAM8oB,GAAW,CACfC,QAAS,IACTC,KAAM,IACNC,QAAS,IACTvqB,MAAO,cAmCOwqB,GAAmB3B,GACjC,IAAM4B,EAAsCb,GAAYP,OAAOR,GAE/D,OADA6B,GAAed,GAAaa,GACrB,CACLzqB,MAAO2qB,GAAaF,EAAkB,SACtCF,QAASI,GAAaF,EAAkB,WACxCH,KAAMK,GAAaF,EAAkB,QACrCJ,QAASM,GAAaF,EAAkB,YAI5C,SAASC,GAAe5lB,EAA2B2H,GACjDA,EAAM4a,IAAM,eAAC,aAAAzP,mBAAAA,IAAAsR,kBACXpkB,EAAOuiB,UAAPviB,IAAcokB,KAIlB,SAASyB,GAAa7lB,EAA2BilB,GAC/C,IAAME,EAAwBluB,OAAOa,OAAOkI,EAAOukB,OAAOU,GAAQ,CAChEA,UAKF,GAFAW,GAAe5lB,EAAQmlB,GAEnBC,GAAaD,GAAS,CACxB,IAAMhC,EAAoBL,GAAM2B,UAChC3B,GAAMQ,OAAOH,EAAoB,IAAMgC,EAAOpB,WAKhD,OAFAW,GAAkBoB,IAAIX,GAEfA,EAGT,SAASC,GAAaD,GACpB,SAAIX,IAAiBc,GAASH,EAAOF,QAAUK,GAASd,KAO1D,SAASQ,GAAgB3C,GACvB,OAAO0C,GAAiBhP,SAASsM,GCxK5B,IAAM8C,GAASO,GAAmB,aC+CnCK,GAA4B,CAChC,yBACA,gCACA,cAEA,SACA,gBACA,aACA,iBACA,eACA,OACA,OACA,UACA,WACA,oBACA,gBACA,sBACA,gBACA,SACA,aACA,cACA,SACA,oBACA,cAGIC,GAA0C,CAC9C,eAsBF,mBAME,WACEC,EACA1mB,EACA4lB,EACA/V,gBADA+V,EAActC,QAAQN,SACtBnP,kBAAEW,uBAAAmS,kBAAyBxQ,2BAAAyQ,oBAE3BrL,YAAMmL,EAAY1mB,gBAClBwb,EAAKoK,OAASA,EAEde,EACEA,GAAsBA,aAA8B9uB,MAChD2uB,GAA0B3qB,OAAO8qB,GACjCH,GAENI,EACEA,GAA0BA,aAAkC/uB,MACxD4uB,GAA8B5qB,OAAO+qB,GACrCH,GAENjL,EAAKmL,mBAAqB,IAAIvB,IAAIuB,GAClCnL,EAAKoL,uBAAyB,IAAIxB,IAAIwB,KA8F1C,OAxH+BnL,OA6BtBoL,wBAAP,SAAmBrY,GAAnB,WACE,OAAKoX,GAAOK,KAAK1B,SAEjBrsB,KAAK4uB,WAAWtY,GACTtW,KAAK0qB,YAAYmE,YAAYvY,GAASxU,KAAK,SAACmU,GAAa,OAAAqN,EAAKwL,YAAY7Y,MAHhDjW,KAAK0qB,YAAYmE,YAAYvY,IAMxDqY,uBAAR,SAAmBrY,GACjBtW,KAAK0tB,OAAO,YAAYnpB,KAAKG,UAAU4R,EAAStW,KAAK+uB,SAASzb,KAAKtT,MAAO,KAGpE2uB,qBAAR,SAAiBpkB,EAAahJ,GAC5B,MAAY,gBAARgJ,EACKvK,KAAKgvB,gBAAgBzkB,EAAKhJ,GAChB,QAARgJ,EACFvK,KAAKivB,YAAY1tB,GACP,UAARgJ,EACFvK,KAAKkvB,cAAc3tB,GACT,SAARgJ,GAGQ,aAARA,GAGQ,kBAARA,EAMJhJ,OAZA,GAeDotB,4BAAR,SAAwBvsB,EAAWb,GACjC,OAAOvB,KAAKmvB,eAAe5tB,EAAOvB,KAAKyuB,mBAAoB,SAAC3rB,EAAGssB,GAAM,OAAAtsB,EAAEssB,GAAG7tB,SAGpEotB,0BAAR,SAAsBptB,GACpB,OAAOvB,KAAKmvB,eAAe5tB,EAAOvB,KAAK0uB,uBAAwB,SAAC5rB,EAAGssB,GAAM,OAAAtsB,EAAEssB,MAGrET,2BAAR,SACEptB,EACA8tB,EACAC,GAEA,GAAqB,iBAAV/tB,GAAgC,OAAVA,EAC/B,OAAOA,EAKT,IAFA,IAAMguB,EAAqC,OAE3B5X,EAAAnY,OAAO4K,KAAK7I,GAAZ8Z,WAAAA,IAAoB,CAA/B,IAAM+T,OACLC,EAAY3lB,IAAI0lB,GAClBG,EAAUH,GAAKE,EAAS/tB,EAAO6tB,GAE/BG,EAAUH,GAxIK,WA4InB,OAAOG,GAGDZ,wBAAR,SAAoBptB,GAClB,GAAqB,iBAAVA,GAAgC,OAAVA,EAC/B,OAAOA,EAGT,IAAMiuB,EAAavI,GAAWziB,MAAMjD,GAC9BkuB,EAAcD,EAAW3G,WAE/B,IAAK4G,EACH,OAAOluB,EAIT,IADA,IAAM4e,EAAQmG,GAAS9hB,MAAMirB,OACb9X,EAAAwI,EAAM/V,OAANiR,WAAAA,IAAc,CAAzB,IAAM+T,OACJpvB,KAAK0uB,uBAAuBhlB,IAAI0lB,IACnCjP,EAAMhO,IAAIid,EA9JK,YAmKnB,OADAI,EAAW5G,SAASzI,EAAMrW,YACnB0lB,EAAW1lB,YAGZ6kB,wBAAR,SAAoB1Y,GAGlB,OAFAjW,KAAK0tB,OAAO,yBAAyBzX,EAASG,QAC9CpW,KAAK0tB,OAAO,YAAYnpB,KAAKG,UAAUuR,EAASxD,QAASzS,KAAK+uB,SAASzb,KAAKtT,MAAO,IAC5EiW,MAtHoB0U,aCzCf+E,GAA2BC,GACzC,OAAOC,GAA+BD,EAAUE,cAAeF,EAAUtY,iBAG3DuY,GACdC,EACAxY,GAUA,MAP6B,iBAAlBwY,EACAA,EACAlwB,MAAMgK,QAAQkmB,GACdA,EAAc9qB,KAAK,KAEnBsS,EAAOyB,wBCcJgX,GAAkBzN,GAChC,IAAIzgB,GAAS,EACb,IAAK,IAAMoC,KAAcqe,EAAc0N,UAAW,CAChD,IAAMC,EAAuC3N,EAAc0N,UAAU/rB,GACrE,GACEgsB,EAAkBC,YAClBD,EAAkBC,WAAWpX,KAAKlU,OAASmb,GAAWoQ,OACtD,CACAtuB,GAAS,EACT,OAGJ,OAAOA,EC5FT,IAAMuuB,GAAMC,SAASC,eAAeC,eAAe,KAAM,KAAM,MAEzDC,GAAS,IAAIC,mBACHC,GAASplB,EAAawF,GACpC,IACE,IAAM6f,EAAMH,GAAOI,gBAAgBtlB,EAAK,oBAwB5C,SAAsBqlB,GACpB,GAAIE,GAAS,CACX,IAAMC,EAAeH,EAAII,uBAAuBF,GAAS,eACzD,GAAIC,EAAalwB,OACf,MAAM,IAAImD,MAAM+sB,EAAa/lB,KAAK,GAAIimB,YA3BxCC,CAAaN,GAEb,IAAIxmB,SAOJ,OALEA,EADE2G,GAAQA,EAAKogB,YACTC,GAAYR,GAEZQ,GAAYR,EAAIS,WAAW,IAG5BhwB,QAAQC,QAAQ8I,GACvB,MAAOpB,GACP,OAAO3H,QAAQE,OAAOyH,IAI1B,IAAI8nB,GAAU,GACd,IACEA,GAAUL,GAAOI,gBAAgB,UAAW,YAAYS,qBAAqB,eAAe,GACzFC,aACH,MAAOC,IAyBT,SAASJ,GAAYnb,GACnB,IAAInU,EAAc,GAEZ2vB,EAAyBxb,EAAKob,WAAWxwB,OAEzC6wB,EAAuBzb,EAAKob,WAAW,GACvCM,EACHD,GACoB,IAAnBD,GACAC,EAAeE,WAAaC,KAAKC,WACjCJ,EAAeK,gBACjBrqB,EAEIsqB,EAjBR,SAAiC/b,GAC/B,OATF,SAAmBA,GACjB,QAAUA,EAAiBgc,WAQpBC,CAAUjc,IAASA,EAAKkc,gBAAkBlc,OAAOvO,EAgBL0qB,CAAwBnc,GAC3E,GAAI+b,EAAuB,CACzBlwB,EAAU,EAAI,GAEd,IAAK,IAAIpB,EAAI,EAAGA,EAAIsxB,EAAsBC,WAAWpxB,OAAQH,IAAK,CAChE,IAAM2xB,EAAOL,EAAsBC,WAAWvxB,GAC9CoB,EAAU,EAAEuwB,EAAKC,UAAYD,EAAKN,UAGhCJ,IACF7vB,EAAU,EAAI6vB,QAEY,IAAnBF,EACT3vB,EAAS,GACA6vB,IACT7vB,EAAS6vB,GAGX,IAAKA,EACH,IAASjxB,EAAI,EAAGA,EAAI+wB,EAAgB/wB,IAAK,CACvC,IAAM0P,EAAQ6F,EAAKob,WAAW3wB,GAE9B,GAAI0P,EAAMwhB,WAAaC,KAAKC,UAAW,CACrC,IAAMS,EAAmBnB,GAAYhhB,GAChCtO,EAAOsO,EAAMkiB,UAEPzyB,MAAMgK,QAAQ/H,EAAOsO,EAAMkiB,WACpCxwB,EAAOsO,EAAMkiB,UAAUlvB,KAAKmvB,GAE5BzwB,EAAOsO,EAAMkiB,UAAY,CAACxwB,EAAOsO,EAAMkiB,UAAWC,GAJlDzwB,EAAOsO,EAAMkiB,UAAYC,GAUjC,OAAOzwB,EAGT,IAAMiZ,GAAa,IAAIyX,uBAEPC,GAAaC,EAAc3hB,GACzC,IACM6f,EAgBR,SAAS+B,EAAUvoB,EAAUwoB,GAC3B,GACSlrB,MAAP0C,GACe,iBAARA,GACQ,iBAARA,GACQ,kBAARA,EACP,CACA,IAAMyoB,EAAOxC,GAAIyC,cAAcF,GAE/B,OADAC,EAAKE,YAAqBrrB,MAAP0C,EAAmB,GAAKA,EAAIJ,WACxC,CAAC6oB,GACH,GAAIhzB,MAAMgK,QAAQO,GAAM,CAE7B,IADA,IAAMtI,EAAS,OACSkxB,IAAAzX,WAAAA,IACtB,IADG,IAAM0X,WACWpX,EAAA8W,EAAUM,EAAWL,GAArB/a,WAAAA,IAAmC,CAAlD,IAAMzH,OACTtO,EAAOsB,KAAKgN,GAGhB,OAAOtO,EACF,GAAmB,iBAARsI,EAAkB,CAElC,IADA,IAAMyoB,EAAOxC,GAAIyC,cAAcF,OACbzU,EAAAze,OAAO4K,KAAKF,GAAZoS,WAAAA,IAAkB,CAA/B,IAAM/R,OACT,GAAY,MAARA,EACF,IAAmB,QAAA6T,EAAA4U,GAAgB9oB,EAAIK,IAApB8T,WAAAA,IAA2B,CAAzC,IAAM8T,OACTQ,EAAKZ,WAAWkB,aAAad,QAE1B,GAAY,MAAR5nB,EACTooB,EAAKE,YAAc3oB,EAAIK,GAAKT,gBAE5B,IAAoB,QAAAopB,EAAAT,EAAUvoB,EAAIK,GAAMA,GAApB4oB,WAAAA,IAA0B,CAAzC,IAAMjjB,OACTyiB,EAAKS,YAAYljB,IAIvB,MAAO,CAACyiB,GAER,MAAM,IAAI7uB,MAAM,wCAAwCoG,GAnD9CuoB,CAAUD,EADJ3hB,GAAQA,EAAKwiB,UAAa,QACH,GACzC,MACE,0DAA4DxY,GAAWyY,kBAAkB5C,GAI7F,SAASsC,GAAgBO,GAEvB,IADA,IAAM3xB,EAAS,OACG+V,EAAAnY,OAAO4K,KAAKmpB,GAAZlY,WAAAA,IAAoB,CAAjC,IAAM9Q,OACH4nB,EAAOhC,GAAIqD,gBAAgBjpB,GACjC4nB,EAAK5wB,MAAQgyB,EAAMhpB,GAAKT,WACxBlI,EAAOsB,KAAKivB,GAEd,OAAOvwB,EC7DF,IAAM6xB,GAA0B,CAAC,mBAAoB,YAAa,cAC5DC,GAAyB,CAAC,kBAAmB,uCAiBxD,WACElF,EACAmF,EACA7rB,GAHF,MAKEub,YAAMmL,EAAY1mB,gBAElBwb,EAAKsQ,iBACFD,GAA+BA,EAA4BE,MAASJ,GACvEnQ,EAAKwQ,gBACFH,GAA+BA,EAA4BI,KAAQL,KAU1E,OAxB2CnQ,OAiB5ByQ,wBAAb,SAAyB1d,+EACvB,SAAOtW,KAAK0qB,YACTmE,YAAYvY,GACZxU,KAAK,SAACmU,GACL,gBA0CN2d,EACAE,EACA7d,GAEA,OAqIF,SACE2d,EACAE,EACA9D,GAEA,IAAMiE,EAAe,SAACnrB,GACpB,IAAMorB,EAAM,UAAUprB,kDAAmDknB,EAAkB7Z,eACrFge,EAAUrrB,EAAIE,MAAQkb,GAAUkQ,YAChC1yB,EAAI,IAAIwiB,GACZgQ,EACAC,EACAnE,EAAkB5Z,OAClB4Z,EAAkB1Z,QAClB0Z,GAEF,OAAO7uB,QAAQE,OAAOK,IAGxB,IAAKsuB,EAAkB1Z,QAAQ8J,oBAAsB4P,EAAkB7Z,WAAY,CACjF,IAAMke,EAAOrE,EAAkB7Z,WACzBgP,EAAsB6K,EAAkBvd,QAAQsP,IAAI,iBAAmB,GACvEuS,EAA+BnP,EAEjCA,EAAY/T,MAAM,KAAK6a,IAAI,SAACsI,GAAc,OAAAA,EAAUviB,gBADpD,GAEJ,GAC+B,IAA7BsiB,EAAkB3zB,QAClB2zB,EAAkB5b,KAAK,SAAC6b,GAAc,OAAyC,IAAzCX,EAAiB3oB,QAAQspB,KAE/D,OAAO,IAAIpzB,QAA+B,SAACC,GACzC4uB,EAAkBwE,WAAajwB,KAAKC,MAAM6vB,GAC1CjzB,EAAQ4uB,KACPyE,MAAMR,GACJ,GAAIK,EAAkB5b,KAAK,SAAC6b,GAAc,OAAwC,IAAxCT,EAAgB7oB,QAAQspB,KACvE,OAAO9D,GAAS4D,GACbvyB,KAAK,SAACE,GAEL,OADAguB,EAAkBwE,WAAaxyB,EACxBguB,IAERyE,MAAMR,GAIb,OAAO9yB,QAAQC,QAAQ4uB,GA/KhBxrB,CAAMovB,EAAkBE,EAAiB7d,GAAUnU,KAAK,SAAC4yB,GAE9D,GArBJ,SAAmCA,GACjC,IAEI9yB,EAFE0gB,EACJoS,EAAepe,QAAQgM,kBAGvB1gB,OADwB4F,IAAtB8a,IAEoC,kBAAtBA,EACPA,EAEAA,EAAkBoS,IAE7B,OAAO9yB,EAS8B+yB,CAA0BD,GACtC,CACrB,IAAMrS,EAA2CqS,EAAepe,QAAQ+L,cACxE,GAAIA,GAAiBA,EAAc0N,UAAW,CAC5C,IAAM/rB,EAAqB0wB,EAAete,OAEpCwe,EAAgCp1B,OAAO4K,KAAKiY,EAAc0N,WAE1D8E,EAC2B,IAA/BD,EAAoBj0B,QACY,IAA/Bi0B,EAAoBj0B,QAA2C,YAA3Bi0B,EAAoB,GAErDE,EAtDd,SACEJ,GAEA,IAAI9yB,EACE0U,EAAuBoe,EAAepe,QACtC+L,EAA2C/L,EAAQ+L,cACzD,GAAIA,EAAe,CACjB,IAAME,EAKoCjM,EAAQiM,wBAIhD3gB,EAHG2gB,EAGMA,EAAwBF,EAAeqS,GAFvCrS,EAAc0N,UAAU2E,EAAete,QAKpD,OAAOxU,EAmCmDmzB,CAAqBL,GAKzE,GAHsCG,EAClC,KAAO7wB,GAAcA,EAAa,MAChC8wB,GA0EC,GAAIA,EAAc,CACvB,GAAIA,EAAa7E,WAAY,CACvB+E,EAA0BN,EAAeF,WACzCnS,EAAclL,OAAS2d,EAAa7E,WAAWpX,KAAKlU,OAASmb,GAAWmV,WAC1ED,EACgC,iBAAvBA,EACHA,EAAmBF,EAAa7E,WAAW/T,gBAC3C,IAER,IACEwY,EAAeF,WAAanS,EAAcxH,WAAW+C,YACnDkX,EAAa7E,WACb+E,EACA,2BAEF,MAAOvxB,GACP,IAAMyxB,EAAY,IAAIhR,GACpB,SAASzgB,mDAAsDixB,EAAeve,YAIhF,OAFA+e,EAAU5e,QAAU6e,GAAmBT,EAAepe,SACtD4e,EAAUjf,SAAWmf,GAAoBV,GAClCvzB,QAAQE,OAAO6zB,QAEc,SAA7B7S,EAAcgT,aAEvBX,EAAeF,WAAave,EAASG,QAAU,KAAOH,EAASG,OAAS,KAGtE0e,EAAaQ,gBACfZ,EAAea,cAAgBlT,EAAcxH,WAAW+C,YACtDkX,EAAaQ,cACbZ,EAAejiB,QAAQR,aACvB,oCAzGqB,CACzB,IAAMujB,EAAyCnT,EAAc0N,UAAU3iB,QACvE,GAAIooB,EAAqB,CACvB,IAAMC,EAA8B3F,GAAkBzN,GAClD,2BAA2Bre,EAC1B0wB,EAAeve,WAEd1S,EAAQ,IAAIygB,GAAUuR,GAC5BhyB,EAAMO,WAAaA,EACnBP,EAAM6S,QAAU6e,GAAmBT,EAAepe,SAClD7S,EAAMwS,SAAWmf,GAAoBV,GAErC,IAAIgB,EAA8ChB,EAAeF,WACjE,IACE,GAAIkB,EAAqB,CACvB,IAAMC,EACJH,EAAoBvF,WACtB,GACE0F,GAC6C,eAA7CA,EAA0B7c,eAEtB4c,EAAoBjyB,QACtBiyB,EAAsBA,EAAoBjyB,OAExCiyB,EAAoB1sB,OACtBvF,EAAMuF,KAAO0sB,EAAoB1sB,MAE/B0sB,EAAoBxsB,UACtBzF,EAAMyF,QAAUwsB,EAAoBxsB,aAEjC,CACL,IAAI0sB,EAAqBF,EACrBA,EAAoBjyB,QACtBmyB,EAAgBF,EAAoBjyB,OAGtCA,EAAMuF,KAAO4sB,EAAc5sB,KACvB4sB,EAAc1sB,UAChBzF,EAAMyF,QAAU0sB,EAAc1sB,SAIlC,GAAIysB,EAA2B,CAC7B,IAAIX,EAA0BU,EAE5BrT,EAAclL,OACdwe,EAA0B9c,KAAKlU,OAASmb,GAAWmV,WAEnDD,EACiC,iBAAxBU,EACHA,EAAoBC,EAA0BzZ,gBAC9C,IAERzY,EAAMwS,SAAUue,WAAanS,EAAcxH,WAAW+C,YACpD+X,EACAX,EACA,8BAKFN,EAAejiB,SAAW+iB,EAAoBF,gBAChD7xB,EAAMwS,SAAUsf,cAAgBlT,EAAcxH,WAAW+C,YACvD4X,EAAoBF,cACpBZ,EAAejiB,QAAQR,aACvB,+BAGJ,MAAO4jB,GACPpyB,EAAMyF,QAAU,UAAW2sB,EAAa3sB,2DAA4DwrB,EAAeve,yCAErH,OAAOhV,QAAQE,OAAOoC,MAwC9B,OAAOtC,QAAQC,QAAQszB,KA/KnBoB,CAAwBxS,EAAKsQ,iBAAkBtQ,EAAKwQ,gBAAiB7d,cArBlC0U,IC9B3C,IAQYoL,GARNC,GAAgC,IAChCC,GAA6B,EAC7BC,GAAoC,KAM1C,SAAYH,GACVA,iCADF,CAAYA,KAAAA,QA0CZ,mBAuBE,WACEvH,EACA1mB,EACAquB,EACAC,EACAC,GALF,MAOEhT,YAAMmL,EAAY1mB,SAClB,SAASwuB,EAAS71B,GAChB,MAAoB,iBAANA,SAEhB6iB,EAAK6S,WAAaG,EAASH,GAAcA,EAAaF,GACtD3S,EAAK8S,cAAgBE,EAASF,GAAiBA,EAAgBJ,GAC/D1S,EAAK+S,iBAAmBC,EAASD,GAC7BA,EACAH,KASR,OA/C4C3S,OAyCnCgT,wBAAP,SAAmBjgB,GAAnB,WACE,OAAOtW,KAAK0qB,YACTmE,YAAYvY,EAAQE,SACpB1U,KAAK,SAACmU,GAAa,OAAAugB,GAAMlT,EAAMhN,EAASL,KACxCwe,MAAM,SAAChxB,GAAU,OAAA+yB,GAAMlT,EAAMhN,EAAS7S,EAAMwS,cAAUzO,EAAW/D,SA7C5BknB,IA8H5C,SAAS6L,GACPC,EACAngB,EACAL,EACAygB,EACAC,GAEAD,EA7CF,SACED,EACAC,EACA5tB,GAEK4tB,IACHA,EAAY,CACVP,WAAY,EACZC,cAAe,IAIfttB,IACE4tB,EAAUjzB,QACZqF,EAAI8tB,WAAaF,EAAUjzB,OAG7BizB,EAAUjzB,MAAQqF,GAIpB4tB,EAAUP,aAGV,IAAIU,EAAiBjjB,KAAKkjB,IAAI,EAAGJ,EAAUP,YAAc,EAWzD,OAPAU,GAFyB,GAAvBJ,EAAOL,cACPxiB,KAAKoG,MAAMpG,KAAKC,UAAmC,IAAvB4iB,EAAOL,cAA6C,GAAvBK,EAAOL,gBAGlEM,EAAUN,cAAgBxiB,KAAKmjB,IAC7BF,EACAJ,EAAOJ,kBAGFK,EAUKM,CAAgBP,EAAQC,EAAWC,GAC/C,IAAMM,EAAiC3gB,EAAQgK,aAAehK,EAAQgK,YAAY4C,QAClF,IAAK+T,GA9EP,SACER,EACAzyB,EACA0yB,GAEA,GACgBlvB,MAAdxD,GACCA,EAAa,KAAsB,MAAfA,GACN,MAAfA,GACe,MAAfA,EAEA,OAAO,EAIT,IAAK0yB,EACH,MAAM,IAAI5yB,MAAM,kEAKlB,OAHiB4yB,GAAaA,EAAUP,YAGlBM,EAAON,WAyDXe,CAAYT,EAAQxgB,GAAYA,EAASG,OAAQsgB,GAEjE,OADAhJ,GAAOK,KAAK,uBAAuB2I,EAAUN,eACtCe,GACET,EAAUN,eAChBt0B,KAAK,WAAM,OAAA20B,EAAO/L,YAAYmE,YAAYvY,EAAQE,WAClD1U,KAAK,SAACic,GAAQ,OAAAyY,GAAMC,EAAQngB,EAASyH,EAAK2Y,OAAWlvB,KACrDitB,MAAM,SAAC3rB,GAAQ,OAAA0tB,GAAMC,EAAQngB,EAASL,EAAUygB,EAAW5tB,KACzD,GAAImuB,GAAaN,IAAiB1gB,EAAU,CAEjD,IAAMnN,EACJ4tB,EAAUjzB,OACV,IAAIygB,GACF,8BACAA,GAAUmC,mBACVpQ,GAAYA,EAASG,OACrBH,GAAYA,EAASK,QACrBL,GAEJ,OAAO9U,QAAQE,OAAOyH,GAEtB,OAAO3H,QAAQC,QAAQ6U,GCnO3B,mBACE,WACEuY,EACA1mB,EACQsvB,GAHV,MAKE/T,YAAMmL,EAAY1mB,gBAFVwb,uBAAA8T,IAWZ,OAfmD7T,OAS1C8T,wBAAP,SAAmB/gB,GAIjB,OAHKA,EAAQ7D,QAAQF,SAASvS,KAAKo3B,uBACjC9gB,EAAQ7D,QAAQN,IAAInS,KAAKo3B,qBAAsBE,MAE1Ct3B,KAAK0qB,YAAYmE,YAAYvY,OAbWqU,aCRnC4M,KACd,MAAO,oBCkCF,IAAMC,GAAgCD,YAE7BE,KACd,IDjCMC,ECkBNC,EACAC,EACAC,EAaMC,EAnBC,CALe,CACpBvtB,IAAK,YACLhJ,MAAO+S,GAAUC,kBAuBbwjB,ED5BC,CALQ,CACbxtB,IAAK,KACLhJ,QAHIm2B,EAAYnkB,OAAOmkB,WAGLM,OAASN,EAAUO,UAAUxsB,QAAQ,IAAK,MCiC9D,OAlBAksB,EAiBqCG,EAAYn0B,OAAOo0B,gBAhBxDH,oBACAC,OAEOF,EACJ1L,IAAI,SAAC8B,GACJ,IAAMxsB,EAAQwsB,EAAKxsB,MAAQ,GAAGs2B,EAAiB9J,EAAKxsB,MAAU,GAC9D,MAAO,GAAGwsB,EAAKxjB,IAAMhJ,IAEtBwD,KAAK6yB,GA2BV,mBACE,WACWlN,EACAnkB,EACCiM,EACAH,GAJZ,MAMEgR,YAAMqH,EAAankB,gBALV+c,cAAAoH,EACApH,WAAA/c,EACC+c,YAAA9Q,EACA8Q,cAAAjR,IAmBd,OAxBqCkR,OAUnC2U,wBAAA,SAAY5hB,GAEV,OADAtW,KAAKm4B,mBAAmB7hB,GACjBtW,KAAK0qB,YAAYmE,YAAYvY,IAGtC4hB,+BAAA,SAAmB5hB,GACZA,EAAQ7D,UACX6D,EAAQ7D,QAAU,IAAIL,KAGnBkE,EAAQ7D,QAAQsP,IAAI/hB,KAAKwS,YAAcxS,KAAKqS,aAC/CiE,EAAQ7D,QAAQN,IAAInS,KAAKwS,UAAWxS,KAAKqS,iBArBVsY,IChCrC,mBACE,WAAY6D,EAA2B1mB,EAAwCswB,gBAAAA,MAA/E,MACE/U,YAAMmL,EAAY1mB,gBAD2Dwb,aAAA8U,IASjF,OAVoC7U,OAK3B8U,wBAAP,SAAmB/hB,GAAnB,WACE,OAAOtW,KAAK0qB,YACTmE,YAAYvY,GACZxU,KAAK,SAACmU,GAAa,OAI1B,SAASqiB,EACP7B,EACAxgB,EACAsiB,GAEQ,IAAAjiB,YAASF,WACjB,IAAMoiB,EAAiBviB,EAASxD,QAAQsP,IAAI,YAC5C,GACEyW,IACY,MAAXpiB,GAA6B,MAAXA,GAA8B,MAAXA,GAAqC,SAAnBE,EAAQ4J,WAC9DuW,EAAO2B,YAAcG,EAAiB9B,EAAO2B,YAC/C,CACA,IAAMK,EAAUxR,GAAWziB,MAAM8R,EAAQ2J,KAUzC,OATAwY,EAAQ9P,QAAQ6P,GAChBliB,EAAQ2J,IAAMwY,EAAQ3uB,WAIP,MAAXsM,IACFE,EAAQ4J,OAAS,OAGZuW,EAAO/L,YACXmE,YAAYvY,GACZxU,KAAK,SAACic,GAAQ,OAAAua,EAAe7B,EAAQ1Y,EAAKwa,EAAiB,KAGhE,OAAOp3B,QAAQC,QAAQ6U,GA/BCqiB,CAAehV,EAAMrN,EAAU,SARrB0U,ICtBpC,mBACE,WACE6D,EACA1mB,EACS4wB,gBAAAA,MAHX,MAKErV,YAAMmL,EAAY1mB,gBAFTwb,gBAAAoV,IAUb,OAd0CnV,OASjCoV,wBAAP,SAAmBriB,GAAnB,WACE,OAAOtW,KAAK0qB,YACTmE,YAAYvY,EAAQE,SACpB1U,KAAK,SAACmU,GAAa,OAI1B,SACEwgB,EACAngB,EACAL,GAEA,GAAwB,MAApBA,EAASG,OAAgB,CAC3B,IAAMwiB,EAqDV,SAAmC52B,GACjC,IAAIJ,EAAQ0b,EACZ,GAAItb,EAAM,CACR,IACEsb,EAAe/Y,KAAKC,MAAMxC,GAC1B,MAAO8G,IAGT,GACEwU,GACAA,EAAa7Z,OACb6Z,EAAa7Z,MAAMyF,SACnBoU,EAAa7Z,MAAMuF,MACS,oCAA5BsU,EAAa7Z,MAAMuF,KACnB,CACA,IAAM6vB,EAAWvb,EAAa7Z,MAAMyF,QAAQuP,MAAM,aAC9CogB,IACFj3B,EAASi3B,EAAS51B,QAIxB,OAAOrB,EA1EUk3B,CAA0B7iB,EAASE,YAClD,GAAIyiB,EAAQ,CACV,IAAMG,EAiFZ,SAAgC9Y,GAC9B,IAAIre,EACEi3B,EAAW5Y,EAAIxH,MAAM,qCAC3B,IAAIogB,IAAYA,EAAS,GAGvB,MAAM,IAAI/0B,MAAM,yDAAyDmc,OAFzEre,EAASi3B,EAAS,GAIpB,OAAOj3B,EAzFeo3B,CAAuB1iB,EAAQ2J,KACjD,OAoGN,SACEwW,EACAsC,EACAE,EACAC,GAEA,IAAMC,EAAaJ,eAAsBE,qCACnCG,EAAYL,eAAsBE,4BAClCI,EAAaC,GAAqBJ,GAIxC,OAHAG,EAAWnZ,OAAS,OACpBmZ,EAAWpZ,IAAMkZ,EAEV1C,EAAO/L,YAAYmE,YAAYwK,GAAYv3B,KAAK,SAACmU,GACtD,GAAwB,MAApBA,EAASG,OACX,MAAM,IAAItS,MAAM,uBAAuBm1B,+CAEzC,OAaJ,SAASM,EACP9C,EACAxW,EACAiZ,GAEA,IAAMG,EAAkBC,GAAqBJ,GAC7CG,EAAWpZ,IAAMA,EACjBoZ,EAAWnZ,OAAS,MAEpB,OAAOuW,EAAO/L,YAAYmE,YAAYwK,GAAYv3B,KAAK,SAACic,GACtD,IAAM7T,EAAM6T,EAAIyW,WAChB,SAAIzW,EAAIyW,aAActqB,EAAIsvB,mBAA+C,eAA1BtvB,EAAIsvB,oBAG1CC,GACyB,IAAvBhD,EAAOiC,eACb52B,KAAK,WAAM,OAAAy3B,EAAsB9C,EAAQxW,EAAKiZ,OA7B5CK,CAAsB9C,EAAQ2C,EAAQF,KAnHzCQ,CAAWjD,EAAQsC,EAAWH,EAAQtiB,GAInCme,MAAM,WAAM,OAAA,IACZ3yB,KAAK,SAAC63B,GACL,OAAIA,GAGFrjB,EAAQ7D,QAAQN,IAAI,yBAA0BmlB,MACvCb,EAAO/L,YAAYmE,YAAYvY,EAAQE,UAEzCP,KAMjB,OAAO9U,QAAQC,QAAQ6U,GAhCC2jB,CAAiBtW,EAAMhN,EAASL,SAZhB0U,IAqD1C,SAAS2O,GAAqBJ,EAA8BW,gBAAAA,MAC1D,IAAMR,EAA0BH,EAAgB1iB,QAYhD,OAXIqjB,IACFR,EAAWpZ,IAAMiZ,EAAgBjZ,KAKnCoZ,EAAW5mB,QAAQN,IAAI,yBAA0BmlB,MAGjD+B,EAAW5mB,QAAQN,IAAI,eAAgB,mCAEhCknB,EC9EF,IAAMS,GAAuB,mBAkClC,WAAYC,gBAAAA,MANJ/5B,sBAA4BwH,EAOlCxH,KAAK+5B,qBAAuBA,EAiBhC,OAdEC,2BAAA,SAAeC,GACbj6B,KAAKk6B,YAAcD,GAGrBD,2BAAA,WAQE,OANEh6B,KAAKk6B,aACLlsB,KAAKmsB,MAAQn6B,KAAK+5B,sBAAwB/5B,KAAKk6B,YAAYE,qBAE3Dp6B,KAAKk6B,iBAAc1yB,GAGdxH,KAAKk6B,kBCXhB,mBAUE,WACE1L,EACA1mB,EACQuyB,EACA1xB,EACA2xB,GALV,MAOEjX,YAAMmL,EAAY1mB,gBAJVwb,aAAA+W,EACA/W,SAAA3a,EACA2a,aAAAgX,IA4BZ,OA3CqD/W,OAwBtCgX,wBAAb,SAAyBC,iGAET,OADTA,EAAY/nB,UAAS+nB,EAAY/nB,QAAU,IAAIL,OAChCpS,KAAK6I,SAAS,CAChCyX,YAAaka,EAAYla,YACzBvY,YAAayyB,EAAYzyB,sBAG3B,OALMa,EAAQ+O,SAId6iB,EAAY/nB,QAAQN,IAAImC,GAAUiB,gBAAgBC,cAAe,UAAU5M,MACpE5I,KAAK0qB,YAAYmE,YAAY2L,UAGxBD,qBAAd,SAAuBzyB,6GAEDN,KADhByyB,EAAcj6B,KAAKs6B,WAAWG,2BAEXz6B,KAAKq6B,WAAWxxB,SAAS7I,KAAK2I,OAAQb,WAA3DmyB,EAAetiB,eAAyDnQ,EACxExH,KAAKs6B,WAAWI,eAAeT,oBAGjC,SAAOA,EAAcA,EAAYrxB,WAAQpB,YAzCQmjB,ICQrD,ICjDYgQ,kBD2DV,WACEnM,EACA1mB,EACAquB,EACAC,EACAwE,EACAvE,GANF,MAQEhT,YAAMmL,EAAY1mB,gBAbpBwb,gCAAgC,IAChCA,6BAA6B,EAC7BA,oCAAoC,IACpCA,oCAAoC,IAWlCA,EAAK6S,WAAmC,iBAAfA,EAA0BA,EAAa7S,EAAK2S,2BACrE3S,EAAK8S,cACsB,iBAAlBA,EAA6BA,EAAgB9S,EAAK0S,8BAC3D1S,EAAKsX,iBACyB,iBAArBA,EACHA,EACAtX,EAAKuX,kCACXvX,EAAK+S,iBACyB,iBAArBA,EACHA,EACA/S,EAAK4S,oCAQf,OArC4C3S,OAgCnCuX,wBAAP,SAAmBxkB,GAAnB,WACE,OAAOtW,KAAK0qB,YACTmE,YAAYvY,EAAQE,SACpB1U,KAAK,SAACmU,GAAa,OAiE1B,SAASugB,EACPC,EACAngB,EACA0Z,EACA0G,EACA5tB,GAEA4tB,EA7CF,SACED,EACAC,EACA5tB,GAEK4tB,IACHA,EAAY,CACVP,WAAY,EACZC,cAAe,IAIfttB,IACE4tB,EAAUjzB,QACZqF,EAAI8tB,WAAaF,EAAUjzB,OAG7BizB,EAAUjzB,MAAQqF,GAIpB4tB,EAAUP,aAGV,IAAIU,EAAiBjjB,KAAKkjB,IAAI,EAAGJ,EAAUP,YAAc,EACnD4E,EACmB,GAAvBtE,EAAOL,cACPxiB,KAAKoG,MAAMpG,KAAKC,UAAmC,IAAvB4iB,EAAOL,cAA6C,GAAvBK,EAAOL,gBAQlE,OAPAS,GAAkBkE,EAElBrE,EAAUN,cAAgBxiB,KAAKmjB,IAC7BN,EAAOmE,iBAAmB/D,EAC1BJ,EAAOJ,kBAGFK,EAUKM,CAAgBP,EAAQC,EAAW5tB,GAC/C,OACEA,GACAA,EAAIE,MAhER,SAAqBytB,EAAgCC,GACnD,IAAIsE,EACJ,IAAKtE,EACH,MAAM,IAAI5yB,MAAM,kEAEhBk3B,EAAetE,GAAaA,EAAUP,WAExC,OAAO6E,EAAevE,EAAON,WA0D3Be,CAAYT,EAAQC,KACN,cAAb5tB,EAAIE,MACU,oBAAbF,EAAIE,MACS,iBAAbF,EAAIE,MACS,eAAbF,EAAIE,MACS,WAAbF,EAAIE,MAGCmuB,GACET,EAAUN,eAChBt0B,KAAK,WAAM,OAAA20B,EAAO/L,YAAYmE,YAAYvY,EAAQE,WAClD1U,KAAK,SAACic,GAAQ,OAAAyY,EAAMC,EAAQngB,EAASyH,EAAK2Y,EAAW5tB,KACrD2rB,MAAM,SAAC3rB,GAAQ,OAAA0tB,EAAMC,EAAQngB,EAAS0Z,EAAmB0G,EAAW5tB,KAE5DtB,MAAPsB,GAEFA,EAAM4tB,EAAUjzB,MACTtC,QAAQE,OAAOyH,IAEjB3H,QAAQC,QAAQ4uB,GA/FDwG,CAAMlT,EAAMhN,EAASL,SAnCH0U,KCjD5C,SAAYgQ,GACVA,UACAA,UACAA,WACAA,YACAA,gBALF,CAAYA,KAAAA,QCOZ,IAAMM,GAA6B,IAAIn3B,MAAM,oEAe3C,WAAY0qB,EAA2B1mB,GACrCub,YAAMmL,EAAY1mB,GAClB,MAAMmzB,GAHuB1X,OAMxB2X,wBAAP,SAAmBC,GACjB,MAAMF,KAPuBtQ,IAAjC,ICTMtV,GAAcf,GAAUM,cAAcS,YAgB5C,mBAGE,WACEmZ,EACA1mB,EACAszB,GAHF,MAKE/X,YAAMmL,EAAY1mB,gBAClBwb,EAAK8X,gBAAkBA,GAAmB9X,EAAK+X,0BAqDnD,OA9D2C9X,OAY5B+X,wBAAb,SAAyBC,+EACvB,SAAOv7B,KAAK0qB,YAAYmE,YAAY0M,EAAY/kB,SAAS1U,KAAK,SAACmU,GAC7D,OAAIA,EAASG,SAAWf,GAAYC,gBAC3BW,EAEAqN,EAAK8X,gBAAgBG,EAAatlB,WAKjCqlB,oCAAd,SACEC,EACAC,mFAMA,OAJMC,EAAuCD,EAAa/oB,QAAQsP,IAChEzN,GAAUiB,gBAAgBG,gBAIpBgmB,EAAgCJ,EAAsBK,sBAC1DF,OAGO7kB,GAAM8kB,GAAW55B,KAAK,SAACM,GAAW,OAAAkhB,EAAKoH,YAAYmE,YAAY0M,SAInEC,QAGKF,wBAAd,SAAoCjpB,GAClC,IAAMupB,EAAsBC,OAAOxpB,GACnC,OAAIwpB,OAAOnrB,MAAMkrB,GACRN,EAAsBQ,0BAA0BzpB,GAE1B,IAAtBupB,GAIGN,4BAAd,SAAwCjpB,GACtC,IACE,IAAM8nB,EAAcnsB,KAAKmsB,MAEnB4B,EADe/tB,KAAKxJ,MAAM6N,GACZ8nB,EAEpB,OAAO0B,OAAOnrB,MAAMqrB,QAAQv0B,EAAYu0B,EACxC,MAAOt4B,GACP,YA3DqCknB,ICX3C,mBACE,WACE6D,EACA1mB,EACOk0B,GAHT,MAKE3Y,YAAMmL,EAAY1mB,gBAFXwb,yBAAA0Y,IAcX,OAlBmCzY,OASjC0Y,wBAAA,SAAY3lB,GACV,OAAOtW,KAAKg8B,uBAAuBE,YAAY5lB,IAG1C2lB,wBAAP,SAAmB3lB,GAAnB,WACE,OAAOtW,KAAKk8B,YAAY5lB,GAASxU,KAAK,SAACq6B,GACrC,OAAA7Y,EAAKoH,YAAYmE,YAAYsN,SAfAxR,ICFnC,mBACE,WAAY6D,EAA2B1mB,UACrCub,YAAMmL,EAAY1mB,SAiCtB,OAnCmCyb,OAKpB6Y,wBAAb,SAAyB9lB,6GACvB,IAAKA,EAAQvO,cAAgBuO,EAAQvO,YAAYQ,OAC/C,SAAOvI,KAAK0qB,YAAYmE,YAAYvY,IAIhC/O,EAASG,IACTQ,EAAOX,EAAOY,UAAU,YAAamO,EAAQvO,8BAehC,6BAXXs0B,EAAcn0B,EAAKo0B,WACnBC,WjDMyBF,GACnC,IAAMG,EAA0B,GAQhC,GAPKH,EAAYh3B,SACfm3B,EAAct5B,KAAK,WAEhBm5B,EAAY72B,QACfg3B,EAAct5B,KAAK,WAGjBs5B,EAAc77B,OAAlB,CAIA,IACM87B,GADQJ,EAAYK,YAAc51B,EAAW61B,WAC5B7yB,SAAS,IAC1B4yB,EAAiC,IAApBD,EAAS97B,OAAe,IAAI87B,EAAaA,EAG5D,OAAU90B,MAAW00B,EAAYh3B,YAAWg3B,EAAY72B,WAAUk3B,GiDxBpCE,CAAqBP,MAE7C/lB,EAAQ7D,QAAQN,IAAI,cAAeoqB,IAC7BM,EAAaR,EAAYQ,YAAcR,EAAYQ,WAAW5hB,cAGlE3E,EAAQ7D,QAAQN,IAAI,aAAc0qB,OAIf78B,KAAK0qB,YAAYmE,YAAYvY,WAEpD,OAFML,EAAW0B,SACjBzP,EAAKiB,SACE8M,UAGP,iBADA/N,EAAKiB,MACC2zB,4BAhCuBnS,kBC4JjC,WACEoS,EACAj1B,GAFF,IAYMk1B,EF/KNhB,EEgMYiB,EACAC,ECpJoB7C,SDmI9B,GATKvyB,IACHA,EAAU,IAGZ9H,KAAKm9B,iBAAmBr1B,EAAQuY,kBAAmB,EACnDrgB,KAAKo9B,YAAct1B,EAAQu1B,YAAc,IAAIC,GAC7Ct9B,KAAKu9B,sBAAwB,IAAIvS,GAAqBljB,EAAQ01B,oBAG1D79B,MAAMgK,QAAQ7B,EAAQk1B,wBACxBtP,GAAOK,KAAK,gDACZiP,EAAyBl1B,EAAQk1B,2BAC5B,CACL,IAAIS,OAAsDj2B,EAC1D,ICxI4B6yB,EDwIN0C,IChIO,mBAAxB1C,EAAWxxB,gBACUrB,IAA3B6yB,EAAW6B,aAA6B7B,EAAWxxB,SAASlI,OAAS,GD+HhC,CAClC+sB,GAAOK,KACL,wFASIkP,OAA6Dz1B,EAC7D01B,EAAgB5Z,EAetBma,EAdS,CACLt9B,OAAA,SAAOquB,EAA2B1mB,GAQhC,YAPiCN,IAA7By1B,IACFA,WP5Ld5C,EACA1xB,GAEA,IAAM2xB,EAA+B,IAAIN,GACzC,MAAO,CACL75B,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIyyB,GACT/L,EACA1mB,EACAuyB,EACA1xB,EACA2xB,KOiLmCoD,CACzBX,GACGG,EAAcS,SAAW,kBAIzBV,EAAyB98B,OAAOquB,EAAY1mB,UAMpD,GAAIi1B,GAAkD,mBAA5BA,EAAYb,YAC3CxO,GAAOK,KAAK,oEFlNlBiO,EEmNwCe,EAAlCU,EFjNC,CACLt9B,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIm0B,GAAczN,EAAY1mB,EAASk0B,UEgNvC,QAAoBx0B,IAAhBu1B,EACT,MAAM,IAAIj5B,MAAM,yEAKlB,GAFA4pB,GAAOK,KAAK,iDACZiP,EAmWN,SACES,EACA31B,GAEA,IAAM81B,EAAoC,GAEtC91B,EAAQ+1B,+BACVD,EAAU16B,gBbnkBZ46B,EamkB+Ch2B,EAAQi2B,6BbnkBvDD,4BAEO,CACL39B,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIuvB,GAA8B7I,EAAY1mB,EAASg2B,WAJlEA,EaskBIL,GACFG,EAAU16B,KAAKu6B,GAGjB,IAAMO,EAA8BC,GAClCn2B,EAAQk2B,oBACRxG,IAEI0G,EAA+BD,GACnCn2B,EAAQq2B,UACR1G,IAEEuG,GAAuBE,GACzBN,EAAU16B,MXriBNqH,GADwB6zB,EWsiBG,CAAE7zB,IAAKyzB,EAAqBz8B,MAAO28B,KXpiB3B12B,MAArB42B,EAAc7zB,IAA8C6zB,EAAc7zB,ID7CvF,oBC8CDhJ,EACH68B,GAAwC52B,MAAvB42B,EAAc78B,MAE5B68B,EAAc78B,MADdk2B,KAGC,CACLt3B,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIowB,GAAgB1J,EAAY1mB,EAASyC,EAAKhJ,WAV3B68B,EACxB7zB,EAEAhJ,EWqiBNq8B,EAAU16B,cVjkBmBm7B,GAC7B,oBAD6BA,MACtB,CACLl+B,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIuwB,GAAe7J,EAAY1mB,EAASu2B,KU8jBpCC,IACfV,EAAU16B,cTxlByBq7B,GACnC,oBADmCA,MAC5B,CACLp+B,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAI6wB,GAAqBnK,EAAY1mB,EAASy2B,KSqlB1CC,CAAqB12B,EAAQ22B,6BAEvC32B,EAAQ42B,gBACXd,EAAU16B,KdvkBL,CACL/C,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIyuB,GACT/H,EACA1mB,EACAquB,EACAC,EACAC,McikBJuH,EAAU16B,cN9kBZizB,EACAC,EACAwE,EACAvE,GAEA,MAAO,CACLl2B,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIgzB,GACTtM,EACA1mB,EACAquB,EACAC,EACAwE,EACAvE,KMikBWsI,IACff,EAAU16B,KHplBL,CACL/C,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIwzB,GAAsB9M,EAAY1mB,WXKjDquB,EACAC,EACAC,Ec8kBAuH,EAAU16B,cfxjBVywB,GAEA,MAAO,CACLxzB,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAIksB,GAAsBxF,EAAYmF,EAA6B7rB,KeojB/D82B,CAAsB92B,EAAQ6rB,8BAEvB7rB,EAAQ4Y,cAE5Bkd,EAAU16B,KJ5lBL,CACL/C,OAAQ,SAACuqB,EAA4BnkB,GACnC,MAAM00B,WIwlBqC4D,EAO/C,OAFAjB,EAAU16B,cnB5hBVwqB,EACAoR,GAEA,oBAHApR,EAAcqR,GAAWhR,KAAKza,KAAKyrB,kBACnCD,MAEO,CACL3+B,OAAQ,SAACquB,EAA2B1mB,GAClC,OAAO,IAAI6mB,GAAUH,EAAY1mB,EAAS4lB,EAAQoR,KmBuhBvCE,CAAUtR,GAAOK,KAAM,KAE/B6P,EA9YsBqB,CAAoCxB,EAAmB31B,GAC5EA,EAAQk1B,uBAAwB,CAGlC,IAAMkC,EAEuBp3B,EAAQk1B,uBAAuBA,GACxDkC,IACFlC,EAAyBkC,IAI/Bl/B,KAAKm/B,wBAA0BnC,EAwPnC,OAlPEoC,wBAAA,SAAYt3B,GACV,GAAIA,MAAAA,GAAgE,iBAAZA,EACtD,MAAM,IAAIhE,MAAM,sEAGlB,IAAIy3B,EACJ,IACMzzB,aAAmB+Y,IACrB/Y,EAAQu3B,4BACR9D,EAAczzB,GAGdyzB,GADAA,EAAc,IAAI1a,IACQye,QAAQx3B,GAEpC,MAAOrE,GACP,OAAOtC,QAAQE,OAAOoC,GAGxB,IAAI87B,EAA8Bv/B,KAAKo9B,YACvC,GAAIp9B,KAAKm/B,yBAA2Bn/B,KAAKm/B,wBAAwBx+B,OAAS,EACxE,IAAK,IAAIH,EAAIR,KAAKm/B,wBAAwBx+B,OAAS,EAAGH,GAAK,IAAKA,EAC9D++B,EAAev/B,KAAKm/B,wBAAwB3+B,GAAGL,OAC7Co/B,EACAv/B,KAAKu9B,uBAIX,OAAOgC,EAAa1Q,YAAY0M,IAS5B6D,iCAAN,SACEI,EACAnd,EACAod,2JAE0C,mBAA/BD,EAAmB13B,UAC5B23B,EAAWD,EAAmB13B,QAC9B03B,EAAmB13B,aAAUN,GAGzB+zB,EAAc,IAAI1a,oBAKtB,2BADM8c,EAA8Btb,EAAcnB,SAAWlhB,KAAK29B,SAEhE,MAAM,IAAI75B,MACR,4IAWJ,GAPAy3B,EAAYrb,OAASmC,EAAcgT,WACnCkG,EAAYlZ,cAAgBA,EAEtBqd,EAAyBzY,GAAWziB,MAAMm5B,GAC5Ctb,EAAcmF,MAChBkY,EAAWC,WAAWtd,EAAcmF,MAElCnF,EAAcud,eAAiBvd,EAAcud,cAAcj/B,OAAS,EACtE,QAA2BgX,EAAA0K,EAAcud,cAAdvkB,WAAAA,IAAhBwkB,OACLC,EAA4BC,GAC9B//B,KACAw/B,EACAK,EACAxd,EAAcxH,YAEhBilB,EAAoBzd,EAAcxH,WAAWI,UAC3C4kB,EAAaxoB,OACbyoB,EACApQ,GAA2BmQ,IAExBA,EAAaG,eAChBF,EAAoBre,mBAAmBqe,IAEzCJ,EAAW3oB,WACT,KAAI8oB,EAAaxoB,OAAOyB,gBAAkB4W,GAA2BmQ,QACrEC,GAIN,GAAIzd,EAAcV,iBAAmBU,EAAcV,gBAAgBhhB,OAAS,EAC1E,QAA6B2b,EAAA+F,EAAcV,gBAAdhG,WAAAA,IAO3B,GAPSskB,OAOkBz4B,OANvBsgB,EAA2BiY,GAC7B//B,KACAw/B,EACAS,EACA5d,EAAcxH,aAEsB,CAMpC,GALAiN,EAAsBzF,EAAcxH,WAAWI,UAC7CglB,EAAe5oB,OACfyQ,EACA4H,GAA2BuQ,IAEUz4B,MAAnCy4B,EAAeC,iBACjB,GAAID,EAAeC,mBAAqBvF,GAAsBwF,MAC5D,GAAmC,IAA/BrY,EAAoBnnB,OACtBmnB,EAAsB,QAEtB,IAAWzX,KAASyX,EACZhd,EAAOgd,EAAoBzX,GACjCyX,EAAoBzX,GAAiB7I,MAARsD,EAAoB,GAAKA,EAAKhB,gBAI/Dge,EAAsBA,EAAoB/iB,KAAKk7B,EAAeC,kBAGlE,IAAKD,EAAeD,aAClB,GAAIrgC,MAAMgK,QAAQme,GAChB,IAAWzX,KAASyX,EAClBA,EAAoBzX,GAASoR,mBAAmBqG,EAAoBzX,SAGtEyX,EAAsBrG,mBAAmBqG,GAG7C4X,EAAWU,kBACTH,EAAe5oB,OAAOyB,gBAAkB4W,GAA2BuQ,GACnEnY,GAYR,GAPAyT,EAAYtb,IAAMyf,EAAW51B,YAEvBqb,EAAc9C,EAAc8C,aAAenlB,KAAKqgC,qBAEpD9E,EAAY9oB,QAAQN,IAAI,eAAgBgT,GAGtC9C,EAAcie,iBAChB,QAA8BjiB,EAAAgE,EAAcie,iBAAdriB,WAAAA,IAO5B,GAPSsiB,OAOU/4B,OANf6K,EAAmB0tB,GACrB//B,KACAw/B,EACAe,EACAle,EAAcxH,aAUd,GAPAxI,EAAcgQ,EAAcxH,WAAWI,UACrCslB,EAAgBlpB,OAChBhF,EACAqd,GAA2B6Q,IAEvB9iB,EAA0B8iB,EAAgBlpB,OAC7CoG,uBAED,QAAkB0V,EAAA3zB,OAAO4K,KAAKiI,GAAZ+L,WAAAA,IAAP7T,OACTgxB,EAAY9oB,QAAQN,IAAIsL,EAAyBlT,EAAK8H,EAAY9H,SAGpEgxB,EAAY9oB,QAAQN,IAClBouB,EAAgBlpB,OAAOyB,gBACrB4W,GAA2B6Q,GAC7BluB,GAQV,GADMvK,EAA0C03B,EAAmB13B,QACtD,CACX,GAAIA,EAAQ04B,cACV,IAAWC,KAAoB34B,EAAQ04B,cACrCjF,EAAY9oB,QAAQN,IAAIsuB,EAAkB34B,EAAQ04B,cAAcC,IAIhE34B,EAAQwY,cACVib,EAAYjb,YAAcxY,EAAQwY,aAGhCxY,EAAQyY,UACVgb,EAAYhb,QAAUzY,EAAQyY,SAG5BzY,EAAQ0Y,mBACV+a,EAAY/a,iBAAmB1Y,EAAQ0Y,kBAGrC1Y,EAAQ2Y,qBACV8a,EAAY9a,mBAAqB3Y,EAAQ2Y,oBAGvC3Y,EAAQC,cACVwzB,EAAYxzB,YAAcD,EAAQC,aAItCwzB,EAAYlb,gBAAkBrgB,KAAKm9B,0BAgDvCD,EACA3B,EACAiE,EACAnd,GAEA,GAAIA,EAAcqe,aAAere,EAAcqe,YAAYrpB,OAAQ,CACjEkkB,EAAYv5B,KAAO+9B,GACjB7C,EACAsC,EACAnd,EAAcqe,YACdre,EAAcxH,YAGhB,IAAMoV,EAAa5N,EAAcqe,YAAYrpB,OACrC4B,aAAUgD,YAASC,mBAAgBpD,mBACrCM,EAAW6W,EAAWpX,KAAKlU,KACjC,IACE,GAAwB6C,MAApB+zB,EAAYv5B,MAAqBiX,EAAU,CAC7C,IAAM0nB,EAAyCjR,GAC7CrN,EAAcqe,aAEhBnF,EAAYv5B,KAAOqgB,EAAcxH,WAAWI,UAC1CgV,EACAsL,EAAYv5B,KACZ2+B,GAEF,IAAMC,EAAWxnB,IAAa0G,GAAWoQ,OACrC7N,EAAclL,MACZiC,IAAa0G,GAAWmV,SAC1BsG,EAAYv5B,KAAOuwB,YjC/UIroB,EAAUwoB,SAI3C,OAHK/yB,MAAMgK,QAAQO,KACjBA,EAAM,CAACA,WAECwoB,GAAcxoB,IiC4UZ22B,CACEtF,EAAYv5B,KACZka,GAAkBD,GAAWnD,GAE/B,CAAEua,SAAUpX,GAAWnD,IAEf8nB,IACVrF,EAAYv5B,KAAOuwB,GAAagJ,EAAYv5B,KAAM,CAChDqxB,SAAUpX,GAAWnD,KAGf8nB,IACVrF,EAAYv5B,KAAOuC,KAAKG,UAAU62B,EAAYv5B,QAGlD,MAAOyB,GACP,MAAM,IAAIK,MACR,UAAUL,EAAMyF,mDAAkD3E,KAAKG,UACrEoU,OACAtR,EACA,iBAID,GAAI6a,EAAcye,oBAAsBze,EAAcye,mBAAmBngC,OAAS,EAAG,CAC1F46B,EAAY3a,SAAW,GACvB,IAAgC,QAAAjJ,EAAA0K,EAAcye,mBAAdzlB,WAAAA,IAAkC,CAA7D,IAAM0lB,OACHC,EAA8BjB,GAClC7C,EACAsC,EACAuB,EACA1e,EAAcxH,YAEhB,GAA8BrT,MAA1Bw5B,EAAqC,CACvC,IAAMC,EACJF,EAAkB1pB,OAAOyB,gBAAkB4W,GAA2BqR,GACxExF,EAAY3a,SAASqgB,GAAiC5e,EAAcxH,WAAWI,UAC7E8lB,EAAkB1pB,OAClB2pB,EACAtR,GAA2BqR,OAnH/BG,CAAqBlhC,KAAMu7B,EAAaiE,EAAoBnd,GAEtB7a,MAAlC+zB,EAAYnb,qBACdmb,EAAYnb,mBAAqB0P,GAAkBzN,IAGjD8e,SACAC,0BAEY,gCAAMphC,KAAK6uB,YAAY0M,kBAArC4F,EAAcjO,wCAEdkO,EAAmBC,sBAEjBD,GACEA,EAAiBnrB,WACnBmrB,EAAiBE,QAAUC,GACzBH,EAAiBnrB,SACjBoM,EAAc0N,UAAUqR,EAAiBp9B,aACvCqe,EAAc0N,UAAmB,UAGvCnuB,EAAST,QAAQE,OACf+/B,IAGFx/B,EAAST,QAAQC,QACfmgC,GAAgBJ,EAAc9e,EAAc0N,UAAUoR,EAAa/qB,yCAIvExU,EAAST,QAAQE,OAAOmgC,gBAW1B,OARMC,EAAKhC,IAET79B,EAEGE,KAAK,SAACic,GAAQ,OAAA0jB,EAAG,KAAM1jB,EAAI2jB,UAAUlN,WAAYzW,EAAI2jB,UAAUprB,QAASyH,EAAI2jB,aAC5EjN,MAAM,SAAC3rB,GAAQ,OAAA24B,EAAG34B,QAGhBlH,cAiFX,SAASq8B,GACP18B,EACAogC,GAEA,IAAI//B,EASJ,MARqB,iBAAVL,EACTK,EAASL,GAETK,EAAS+/B,IACY,mBAAVpgC,IACTK,EAASL,EAAMK,KAGZA,EAsKT,SAASm+B,GACP7C,EACAsC,EACA7P,EACA9U,GAEA,gBASc+mB,EACd1E,EACAsC,EACA3P,EACAgS,EACAhnB,GAEA,IAAItZ,EACyB,iBAAlBsuB,IACTA,EAAgB,CAACA,IAEnB,GAAIlwB,MAAMgK,QAAQkmB,IAChB,GAAIA,EAAclvB,OAAS,EAAG,CAC5B,GAAIkhC,EAAgB9oB,WAClBxX,EAAQsgC,EAAgB7oB,iBACnB,CACL,IAAI8oB,EAA6CC,GAC/CvC,EACA3P,GAEGiS,EAAqBE,gBACxBF,EAAuBC,GAA6B7E,EAAerN,IAGrE,IAAIoS,GAAkB,EACjBH,EAAqBE,gBACxBC,EACEJ,EAAgB5oB,UACM,YAArB4W,EAAc,IAA6C,IAAzBA,EAAclvB,QAErDY,EAAQ0gC,EAAkBJ,EAAgB7oB,aAAe8oB,EAAqBI,cAIhF,IAAMC,EAA8BvS,GAClCC,EACAgS,GAEFhnB,EAAWI,UAAU4mB,EAAiBtgC,EAAO4gC,SAO/C,IAAK,IAAM9iB,KAJPwiB,EAAgB5oB,WAClB1X,EAAQ,IAGiBsuB,EAAe,CACxC,IAAMjU,EAA0BimB,EAAoChpB,KAAKqG,gBACvEG,GAEI+iB,EAA8BvS,EAAcxQ,GAC5C6iB,EAAqBN,EACzB1E,EACAsC,EACA4C,EACAxmB,EACAf,GAGIwnB,EAA6BzS,GACjCwS,EACAxmB,GAEFf,EAAWI,UAAUW,EAAgBsmB,EAAeG,QAC9B76B,IAAlB06B,IACG3gC,IACHA,EAAQ,IAEVA,EAAM8d,GAAgB6iB,GAI5B,OAAO3gC,EAhFAqgC,CACL1E,EACAsC,EACA7P,EAAUE,cACVF,EAAUtY,OACVwD,GAmFJ,SAASknB,GACPx5B,EACAsnB,GAIA,IAFA,IAAMjuB,EAA+B,CAAEogC,eAAe,GAClDxhC,EAAI,EACDA,EAAIqvB,EAAclvB,SAAUH,EAAG,CACpC,IAAM8hC,EAA4BzS,EAAcrvB,GAEhD,KAAcgH,MAAVe,GAAuB+5B,KAAqB/5B,GAG9C,MAFAA,EAASA,EAAO+5B,GASpB,OAJI9hC,IAAMqvB,EAAclvB,SACtBiB,EAAOsgC,cAAgB35B,EACvB3G,EAAOogC,eAAgB,GAElBpgC,WAGO2/B,GACdG,EACA5M,GAEA,IjCrnB8BvzB,EiCqnBxBg0B,EAAgBmM,EAAUnM,cAC1BtF,EAAa6E,GAAgBA,EAAa7E,WAE1CsS,EAAuB,SAACr4B,GAC5B,OAAA1K,OAAOgjC,eAAet4B,EAAK,YAAa,CACtC3I,MAAOmgC,KAGX,GAAIzR,EAAY,CACd,IAAM7W,EAAW6W,EAAWpX,KAAKlU,KACjC,GAAiB,WAAbyU,EACF,OAAOmpB,OACFhN,GACH9P,SAAUic,EAAUjc,SACpBgd,mBAAoBf,EAAUe,sBAIlC,IAAMC,EACU,cAAbtpB,GAA6B6W,EAA+BpX,KAAKqG,iBAAoB,GAClFyjB,EAAqBnjC,OAAO4K,KAAKs4B,GAAiBhqB,KACtD,SAAC0W,GAAM,MAAsC,KAAtCsT,EAAgBtT,GAAGtW,iBAE5B,GAAiB,aAAbM,GAA2BupB,EAAoB,CAGjD,IAFA,IAAMC,GAAqBlB,EAAUlN,YAAc,gBAEjC7c,EAAAnY,OAAO4K,KAAKs4B,GAAZrnB,WAAAA,IAA8B,CAA3C,IAAM9Q,OACLm4B,EAAgBn4B,GAAKuO,iBACvB8pB,EAAcr4B,GAAOm3B,EAAUlN,WAAWjqB,IAI9C,GAAIgrB,EACF,IAAkB,QAAAjZ,EAAA9c,OAAO4K,KAAKmrB,GAAZ5Z,WAAAA,IAA4B,CAC5CinB,EADSr4B,QACYgrB,EAAchrB,GAIvC,OADAg4B,EAAqBK,GACdA,EAGT,GAAiB,cAAbxpB,GAAyC,eAAbA,EAC9B,OAAOmpB,OACFhN,EACAmM,EAAUlN,aAKnB,OACEvE,GAC6B,SAA7ByR,EAAUprB,QAAQ4J,SjCvqBK,iBADK3e,EiCyqBNmgC,EAAUlN,ajCxqBoB,mBAAVjzB,GAAmC,OAAVA,GiC2qB5DghC,OACFhN,GACHvzB,KAAM0/B,EAAUlN,cAIb+N,OACFhN,EACAmM,EAAUlN,mBE55BJ9G,GAASO,GAAmB,YCYnC4U,GAAuB,0CAkBhBC,WAAuB1D,GAGlCr7B,YAAY+D,GAMV,GAJArD,WAAM+C,EADNM,EAAUA,GAAWg7B,GAAeC,qBAGpC/iC,KAAK29B,QAAU39B,KAAKgjC,cAAgBl7B,EAAQk7B,eAAiBH,IAExD7iC,KAAK29B,QAAQhgB,WAAW,UAC3B,MAAM,IAAI7Z,MAAM,4DAIpBC,kBAAkBk/B,GAChB,MAAMzI,EAAc,IAAI3Z,GAExB,OADA2Z,EAAY8E,QAAQ2D,GACbzI,EAGHz2B,iBACJy2B,EACA0I,2CAEAxV,GAAOK,kDAAkDyM,EAAYva,QACrE,MAAMhK,QAAiBjW,KAAK6uB,YAAY2L,GAQxC,GANA0I,EACEA,IACE5lB,GACOtP,KAAKmsB,MAAkC,IAA1B7c,EAAa6lB,YAGb,MAApBltB,EAASG,QAAsC,MAApBH,EAASG,OAAgB,CACtD,MAAMxN,EAAQ,CACZqxB,YAAa,CACXrxB,MAAOqN,EAASue,WAAW4O,aAC3BhJ,mBAAoB8I,EAAgBjtB,EAASue,aAE/C6O,aAAcptB,EAASue,WAAW8O,eAIpC,OADA5V,GAAOK,yBAAyByM,EAAYva,mCAAmCrX,EAAMqxB,YAAYG,sBAC1FxxB,EACF,CACL,MAAMnF,EAAQ,IAAII,EAAoBoS,EAASG,OAAQH,EAASue,YAAcve,EAASE,YAEvF,MADAuX,GAAOM,8DAA8D/X,EAASG,WAAW3S,EAAMS,cAAcC,oBACvGV,KAIJM,mBACJw/B,EACAC,EACA76B,EACA06B,EACAI,EACAP,EACAp7B,2CAEA,QAAqBN,IAAjB67B,EACF,OAAO,KAET3V,GAAOK,gEAAgEyV,cAAqB76B,aAE5F,MAAMT,KAAEA,EAAMJ,QAASO,GAAeT,EAAW,oCAAqCE,GAEhF47B,EAAgB,CACpBC,WAAY,gBACZC,UAAWJ,EACXF,cAAeD,EACfQ,MAAOl7B,QAGYnB,IAAjBi8B,IACDC,EAAsBI,cAAgBL,GAGzC,IACE,MAAMjJ,EAAcx6B,KAAK+jC,kBAAkB,CACzC9jB,OAAQjgB,KAAKgjC,iBAAiBO,sBAC9BrjB,OAAQ,OACRkC,4BAA4B,EAC5B4hB,2BAAuBx8B,EACvBxF,KAAMiiC,GAAGv/B,UAAUg/B,GACnBjxB,QAAS,CACPyxB,OAAQ,mBACRC,eAAgB,qCAElBp8B,YAAaM,EAAWN,YACxBuY,YAAaxY,GAAWA,EAAQwY,cAG5BrK,QAAiBjW,KAAKokC,iBAAiB5J,EAAa0I,GAE1D,OADAxV,GAAOK,uDAAuDyV,KACvDvtB,EACP,MAAOnN,GACP,GACEA,EAAInE,OAASf,GACe,yBAA5BkF,EAAI5E,cAAcT,MAWlB,OANAiqB,GAAOK,4DAA4DyV,KACnEt7B,EAAKa,UAAU,CACbC,KAAMpC,EAAcqC,gBACpBC,QAASJ,EAAII,UAGR,KAOP,MALAwkB,GAAOM,kEAAkEwV,MAAa16B,KACxFZ,EAAKa,UAAU,CACXC,KAAMpC,EAAcy9B,QACpBn7B,QAASJ,EAAII,UAETJ,UAGRZ,EAAKiB,SAITpF,2BACE,MAAO,CACLi/B,cAAeH,GACf7F,uBAAyBY,GAChB,CJxJN,CACLz9B,OAAA,SAAOquB,EAA2B1mB,GAChC,OAAO,IAAIs0B,GAAc5N,EAAY1mB,QIsJP81B,KC9JpC,MAAMx0B,GAA2B,IAAItF,MACnC,gECHF,kBAAA,cAqIA,OA/HWwgC,gBAAP,WAsBI,IAAMC,EAAoBhxB,OAAOF,OACjC,GAAIkxB,GAAaA,EAAUnxB,gBAAiB,CAC5C,IAAMmH,EAAqB,IAAIpH,WAAW,IAW1C,OAVAoxB,EAAUnxB,gBAAgBmH,GAG1BA,EAAO,IAAM,GACbA,EAAO,IAAM,GAGbA,EAAO,IAAM,IACbA,EAAO,IAAM,IAEN+pB,EAAYE,aAAajqB,EAAO,IAAM+pB,EAAYE,aAAajqB,EAAO,IACvE+pB,EAAYE,aAAajqB,EAAO,IAAM+pB,EAAYE,aAAajqB,EAAO,IACtE,IAAM+pB,EAAYE,aAAajqB,EAAO,IAAM+pB,EAAYE,aAAajqB,EAAO,IAC5E,IAAM+pB,EAAYE,aAAajqB,EAAO,IAAM+pB,EAAYE,aAAajqB,EAAO,IAC5E,IAAM+pB,EAAYE,aAAajqB,EAAO,IAAM+pB,EAAYE,aAAajqB,EAAO,IAC5E,IAAM+pB,EAAYE,aAAajqB,EAAO,KAAO+pB,EAAYE,aAAajqB,EAAO,KAC7E+pB,EAAYE,aAAajqB,EAAO,KAAO+pB,EAAYE,aAAajqB,EAAO,KACvE+pB,EAAYE,aAAajqB,EAAO,KAAO+pB,EAAYE,aAAajqB,EAAO,KAO7E,IAJA,IAAMkqB,EAAqB,uCACrBC,EAAc,mBAChBnhC,EAAY,EACZohC,EAAuB,GAClBnkC,EAAY,EAAGA,EAAI,GAAIA,IACN,MAAlBikC,EAAWjkC,IAAgC,MAAlBikC,EAAWjkC,KAExC+C,EAAqB,GAAjBqQ,KAAKC,SAAiB,GAEJ,MAAlB4wB,EAAWjkC,GACfmkC,GAAgBD,EAAInhC,GACS,MAAlBkhC,EAAWjkC,IAEtB+C,GAAK,EAELohC,GAAgBD,EADhBnhC,GAAK,IAGLohC,GAAgBF,EAAWjkC,GAG/B,OAAOmkC,GASJL,eAAP,SAAoBM,GAEhB,IADA,IAAIF,EAAcE,EAAI96B,SAAS,IACxB46B,EAAI/jC,OAAS,GACpB+jC,EAAM,IAAMA,EAEZ,OAAOA,GAWJJ,eAAP,SAAoBO,GAChB,OAAO9xB,KAAK0O,mBAAmBojB,GAAOp5B,QAAQ,kBAC1C,SAAsBgN,EAAOqsB,GACzB,OAAO/4B,OAAOgE,aAAa8rB,OAAO,KAAOiJ,QAS9CR,eAAP,SAAoBO,GAChB,OAAOl5B,mBAAmBuH,KAAK2xB,GAAOzzB,MAAM,IAAI6a,IAAI,SAAS5f,GACzD,MAAO,KAAO,KAAOA,EAAEC,WAAW,GAAGxC,SAAS,KAAKqC,OAAO,KAC3DpH,KAAK,MAQLu/B,cAAP,SAAmBnkB,GACf,IAAI1H,EACEssB,EAAK,MACLC,EAAS,oBACT55B,EAAS,SAAC7K,GAAc,OAAAoL,mBAAmBpL,EAAEkL,QAAQs5B,EAAI,OACzD76B,EAAU,GAEhB,IADAuO,EAAQusB,EAAO50B,KAAK+P,GACb1H,GACPvO,EAAIkB,EAAOqN,EAAM,KAAOrN,EAAOqN,EAAM,IACrCA,EAAQusB,EAAO50B,KAAK+P,GAEpB,OAAOjW,sBC/Hf,cA6EA,OA5EE1K,sBAAW8U,0BAAX,WAAwC,MAAO,qDAC/C9U,sBAAW8U,eAAX,WAA6B,MAAO,yCAEpC9U,sBAAW8U,eAAX,WAA6B,MAAO,yCACpC9U,sBAAW8U,oBAAX,WAAkC,MAAO,+CACzC9U,sBAAW8U,kBAAX,WAAgC,MAAO,4CAEvC9U,sBAAW8U,iBAAX,WAA+B,MAAO,4CACtC9U,sBAAW8U,qBAAX,WAAmC,MAAO,gDAC1C9U,sBAAW8U,qBAAX,WAAmC,MAAO,gDAC1C9U,sBAAW8U,mBAAX,WAAiC,MAAO,8CACxC9U,sBAAW8U,sBAAX,WAAoC,MAAO,iDAC3C9U,sBAAW8U,gBAAX,WAA8B,MAAO,0CAErC9U,sBAAW8U,wBAAX,WAAsC,MAAO,oDAC7C9U,sBAAW8U,mBAAX,WAAiC,MAAO,8CACxC9U,sBAAW8U,8BAAX,WAA4C,MAAO,0DAEnD9U,sBAAW8U,0BAAX,WAAwC,MAAO,sDAC/C9U,sBAAW8U,mBAAX,WAAiC,MAAO,mDACxC9U,sBAAW8U,wBAAX,WAAsC,MAAO,yDAC7C9U,sBAAW8U,uBAAX,WAAqC,MAAO,uDAC5C9U,sBAAW8U,oBAAX,WAAkC,MAAO,oDACzC9U,sBAAW8U,2BAAX,WAAyC,MAAO,2DAChD9U,sBAAW8U,oBAAX,WAAkC,MAAO,oDACzC9U,sBAAW8U,sBAAX,WAAoC,MAAO,sDAC3C9U,sBAAW8U,kBAAX,WAAgC,MAAO,iDACvC9U,sBAAW8U,oBAAX,WAAkC,MAAO,gDACzC9U,sBAAW8U,sBAAX,WAAoC,MAAO,sDAC3C9U,sBAAW8U,oBAAX,WAAkC,MAAO,oDACzC9U,sBAAW8U,qBAAX,WAAmC,MAAO,2DAC1C9U,sBAAW8U,iBAAX,WAA+B,MAAO,gDACtC9U,sBAAW8U,6BAAX,WAA2C,MAAO,8DAClD9U,sBAAW8U,cAAX,WAA4B,MAAO,wCAEnC9U,sBAAW8U,oBAAX,WAAkC,MAAO,8CACzC9U,sBAAW8U,uBAAX,WAAqC,MAAO,wEAC5C9U,sBAAW8U,aAAX,WAA2B,MAAO,uCAElC9U,sBAAW8U,+BAAX,WAA6C,MAAO,0DACpD9U,sBAAW8U,qBAAX,WAAmC,MAAO,gDAC1C9U,sBAAW8U,gBAAX,WAA8B,MAAO,0CAErC9U,sBAAW8U,gCAAX,WAA8C,MAAO,2DACrD9U,sBAAW8U,2BAAX,WAAyC,MAAO,qCAEhD9U,sBAAW8U,mCAAX,WAAiD,MAAO,4CACxD9U,sBAAW8U,mCAAX,WAAiD,MAAO,6CACxD9U,sBAAW8U,oCAAX,WAAkD,MAAO,+CAGzD9U,sBAAW8U,oBAAX,WAAkC,OAAOtU,KAAKilC,iBAC9C,SAAsBC,GACpBllC,KAAKilC,YAAcC,mCAGrB1lC,sBAAW8U,qBAAX,WAAmC,OAAOtU,KAAKmlC,kBAC/C,SAAuBC,GACrBplC,KAAKmlC,aAAeC,mCAGtB5lC,sBAAW8U,eAAX,WAA6B,MAAO,yCACpC9U,sBAAW8U,oBAAX,WAAkC,MAAO,+CACzC9U,sBAAW8U,iBAAX,WAA+B,MAAO,2CAEtC9U,sBAAW8U,+BAAX,WAA6C,MAAO,yDAEpD9U,sBAAW8U,gBAAX,WAA8B,MAAO,0CACrC9U,sBAAW8U,qBAAX,WAAmC,MAAO,0CAC1C9U,sBAAW8U,sBAAX,WAAoC,MAAO,2CAE3C9U,sBAAW8U,4BAAX,WAAiD,MAAO,gDACxD9U,sBAAW8U,8BAAX,WAAmD,MAAO,kDAE1D9U,sBAAW8U,iCAAX,WAAwD,MAAO,uDAC/D9U,sBAAW8U,8BAAX,WAAqD,MAAO,oDAzB7CA,cAAsB,IAKtBA,eAAuB,SA2B3B+wB,GACE,iBADFA,GAEc,2BAGdC,GAAsB,CACjCC,oBAAqB,oBACrBC,yBAA0B,yBAC1BC,uBAAwB,uBACxBC,4BAA6B,4BAC7BC,2BAA4B,2BAC5BC,2BAA4B,4BAOjBC,GAEJ,MAFIA,GAGG,aAHHA,GAIC,WAJDA,GAKI,cALJA,GAMM,gBANNA,GAOE,YAPFA,GASO,wBATPA,GAUE,YAVFA,GAWG,aAMHC,GAAsB,CACjCD,GACAA,IAWWE,GAAc,CAC1BC,MAAO,QACPC,eAAgB,iBAChBC,QAAS,UACTC,KAAM,QC7IP,kBAAA,cAiEA,OAxDSC,uBAAP,SAA4BC,EAA6B19B,GACvD09B,EAAermC,KAAKsmC,mBAAmBD,GACvC,IAAK,IAAI7lC,EAAI,EAAGA,EAAImI,EAAOhI,OAAQH,IACjC,GAAI6lC,EAAap7B,QAAQtC,EAAOnI,GAAGwR,gBAAkB,EACjD,OAAO,EAGb,OAAO,GASFo0B,gBAAP,SAAqBC,EAA6B19B,GAEhD,OADA09B,EAAermC,KAAKsmC,mBAAmBD,GAChC19B,EAAOwU,MAAM,SAAC5b,GAAwB,OAAA8kC,EAAap7B,QAAQ1J,EAAMuI,WAAWkI,gBAAkB,KAShGo0B,qBAAP,SAA0Bz9B,GACxB,OAAOA,EAAOsjB,IAAI,SAAA4X,GAAS,OAAAA,EAAM7xB,iBAU5Bo0B,gBAAP,SAAqBz9B,EAAuBk7B,GAC1C,OAAOl7B,EAAOyG,OAAO,SAAA7N,GAAS,OAAAA,IAAUsiC,KAOnCuC,aAAP,SAAkBz9B,GAChB,IAAI49B,EAAoB,GACxB,GAAI59B,EACA,IAAK,IAAInI,EAAY,EAAGA,EAAImI,EAAOhI,SAAUH,EAC7C+lC,GAAc/lC,IAAMmI,EAAOhI,OAAS,EAAKgI,EAAOnI,GAAK,IAAMmI,EAAOnI,GAItE,OAAO+lC,sBC5DX,cASA,OAHWC,UAAP,SAAen7B,GACX,YAAuB,IAARA,IAAwBA,GAAO,IAAMA,EAAI1K,2BCDhE,cA8MA,OAxMS8lC,oBAAP,SAAyBC,GACvB,IAAMr7B,EAAMrL,KAAK2mC,0BAA0BD,GACvCE,EAAuBF,EAAoBG,kBAAkBC,sBASjE,OAPIF,EAAa37B,QAAQ,KAAO,EAC9B27B,GAAgB,IAEhBA,GAAgB,IAGS,GAAGA,EAAev7B,EAAItG,KAAK,MAQjD0hC,4BAAP,SAAiCC,GAC/B,IAAI/9B,EAAS+9B,EAAoB/9B,QAEqB,IAAlDA,EAAOsC,QAAQy7B,EAAoBlD,WACrC76B,EAAOzF,KAAKwjC,EAAoBlD,UAElC,IAAMn4B,EAAqB,GA+B3B,OA9BAA,EAAInI,KAAK,iBAAmBwjC,EAAoBphB,cAEhDtlB,KAAK+mC,6BAA6Bp+B,EAAQ+9B,EAAoBlD,UAC9Dn4B,EAAInI,KAAK,SAAWue,mBAAmB2kB,GAASY,WAAWr+B,KAC3D0C,EAAInI,KAAK,aAAeue,mBAAmBilB,EAAoBlD,WAC/Dn4B,EAAInI,KAAK,gBAAkBue,mBAAmBilB,EAAoBO,cAElE57B,EAAInI,KAAK,SAAWue,mBAAmBilB,EAAoB1d,QAC3D3d,EAAInI,KAAK,SAAWue,mBAAmBilB,EAAoBQ,QAE3D77B,EAAInI,KAAK,iBACTmI,EAAInI,KAAK,gBAAgBwjC,EAAoBS,YAC7C97B,EAAInI,KAAK,gBAAgBwjC,EAAoBU,YACzCV,EAAoBW,aACtBh8B,EAAInI,KAAK,UAAYue,mBAAmBilB,EAAoBW,cAG1DX,EAAoBY,aACtBj8B,EAAInI,KAAK,UAAYue,mBAAmBilB,EAAoBY,cAG1DZ,EAAoB/kB,iBACtBtW,EAAInI,KAAKwjC,EAAoB/kB,iBAG3B+kB,EAAoBa,sBACtBl8B,EAAInI,KAAKwjC,EAAoBa,sBAG/Bl8B,EAAInI,KAAK,qBAAuBue,mBAAmBilB,EAAoB1hC,gBAChEqG,GAOMo7B,+BAAf,SAA4C99B,EAAuB66B,GACjE,IAAMgE,EAAwB7+B,EAAOsC,QAAQu4B,GACzCgE,GAAiB,IACnB7+B,EAAOoa,OAAOykB,EAAe,IACK,IAA9B7+B,EAAOsC,QAAQ,WACjBtC,EAAOzF,KAAK,WAEqB,IAA/ByF,EAAOsC,QAAQ,YACjBtC,EAAOzF,KAAK,aAQXujC,wBAAP,WACE,OAAOlzB,OAAOk0B,SAASC,KAAKt2B,MAAM,KAAK,GAAGA,MAAM,KAAK,IAQhDq1B,oBAAP,SAAyBxmB,EAAasjB,GACpCtjB,EAAMA,EAAIjO,cACV,IAAI21B,EAAY3nC,KAAK4nC,iBAAiB3nB,GAClC4nB,EAAYF,EAAUG,aAI1B,OAHIvE,GAAkC,IAArBsE,EAAUlnC,QAAiBknC,EAAU,KAAOvzB,GAAUyzB,QAAUF,EAAU,KAAOhC,KAChGgC,EAAU,GAAKtE,GAEVvjC,KAAKgoC,gCAAgCL,EAAWE,IAGlDpB,kCAAP,SAAuCkB,EAAiBE,GACtD,OAAO7nC,KAAKioC,gBAAgBN,EAAUO,SAAW,KAAOP,EAAUQ,gBAAkB,IAAMN,EAAU9iC,KAAK,OAOpG0hC,mBAAP,SAAwBxmB,GACtB,IAAKA,EACH,KAAM,eAIR,IAAImoB,EAAQ5vB,OAAO,8DAEfC,EAAQwH,EAAIxH,MAAM2vB,GAEtB,IAAK3vB,GAASA,EAAM9X,OAAS,EAC3B,KAAM,qBAGR,IAAI0nC,EAAsB,CACxBH,SAAUzvB,EAAM,GAChB0vB,gBAAiB1vB,EAAM,GACvB6vB,aAAc7vB,EAAM,IAGlB8vB,EAAeF,EAAcC,aAAal3B,MAAM,KAGpD,OAFAm3B,EAAeA,EAAan5B,OAAO,SAACpE,GAAQ,OAAAA,GAAOA,EAAIrK,OAAS,IAChE0nC,EAAcP,aAAeS,EACtBF,GAQF5B,kBAAP,SAAuBxmB,GASrB,OARIA,IACFA,EAAMA,EAAIjO,eAGRiO,IAAQwmB,EAASrlB,SAASnB,EAAK,OACjCA,GAAO,KAGFA,GAUFwmB,WAAP,SAAgBxmB,EAAauoB,GAC3B,SAAKvoB,IAAQuoB,KAI+C,IAArDvoB,EAAIhV,QAAQu9B,EAAQvoB,EAAItf,OAAS6nC,EAAO7nC,SAQ1C8lC,gCAAP,SAAqCxmB,EAAatb,GAChD,GAAI6hC,GAAYiC,QAAQxoB,GACtB,OAAOA,EAGT,IAAIyoB,EAAQ,IAAIlwB,OAAO,OAAS7T,EAAO,WAQvC,OAPAsb,EAAMA,EAAIxU,QAAQi9B,EAAO,IAEzBA,EAAQ,IAAIlwB,OAAO,IAAM7T,EAAO,YAChCsb,EAAMA,EAAIxU,QAAQi9B,EAAO,IAEzBA,EAAQ,IAAIlwB,OAAO,IAAM7T,EAAO,WAChCsb,EAAMA,EAAIxU,QAAQi9B,EAAO,KAUpBjC,iBAAP,SAAsBkC,GACpB,IAAMC,EAAaD,EAAoB19B,QAAQ,KACzC49B,EAAaF,EAAoB19B,QAAQ,MAC/C,OAAI49B,GAAc,EACTF,EAAoB7uB,UAAU+uB,EAAa,GACzCD,GAAc,EAChBD,EAAoB7uB,UAAU8uB,EAAa,GAE7CD,WCxMT,SAAYG,EAAmBtF,EAAkB76B,EAAgBogC,EAAaC,GAC5EhpC,KAAK8oC,UAAYrC,GAASwB,gBAAgBa,GAC1C9oC,KAAKwjC,SAAWA,EAChBxjC,KAAK2I,OAASA,EACd3I,KAAKipC,sBAAwB3E,GAAY4E,aAAaH,GAAO,IAAMzE,GAAY4E,aAAaF,OCP9F,SAAY/O,EAAqBkP,EAAiBC,EAAmBH,GACnEjpC,KAAKi6B,YAAcA,EACnBj6B,KAAKmpC,QAAUA,EACfnpC,KAAKopC,UAAYA,EACjBppC,KAAKipC,sBAAwBA,GCdpBI,GACQ,CACbrgC,KAAM,mBACNsgC,KAAM,sDAYV,WAAYC,EAAmBC,GAA/B,MACInmB,YAAMmmB,gBACNhqC,OAAOC,eAAe6jB,EAAMmmB,EAAUvpC,WAEtCojB,EAAKimB,UAAYA,EACjBjmB,EAAKkmB,aAAeA,EACpBlmB,EAAK3e,KAAO,cAMpB,OAjB+B4e,OAcpBkmB,wBAAP,SAA6BC,GACzB,OAAO,IAAID,EAAUJ,GAAiCrgC,KAASqgC,GAAiCC,UAASI,OAflF5lC,OCNlB6lC,GACe,CACpB3gC,KAAM,2BACNsgC,KAAM,uIAHDK,GAMiB,CACtB3gC,KAAM,uBACNsgC,KAAM,gFARDK,GAUgB,CACrB3gC,KAAM,6BACNsgC,KAAM,2EAZDK,GAcS,CACd3gC,KAAM,qBACNsgC,KAAM,4GAhBDK,GAkBU,CACf3gC,KAAM,sBACNsgC,KAAM,kDApBDK,GAsBO,CACZ3gC,KAAM,mBACNsgC,KAAM,4BAxBDK,GA0BU,CACf3gC,KAAM,sBACNsgC,KAAM,kBA5BDK,GA8BW,CAChB3gC,KAAM,uBACNsgC,KAAM,2CAhCDK,GAkCW,CAChB3gC,KAAM,uBACNsgC,KAAM,8EApCDK,GAsCkB,CACvB3gC,KAAM,8BACNsgC,KAAM,qFAxCDK,GA0CW,CAChB3gC,KAAM,iBACNsgC,KAAM,4BA5CDK,GA8CM,CACX3gC,KAAM,iBACNsgC,KAAM,uDAhDDK,GAkDe,CACpB3gC,KAAM,mBACNsgC,KAAM,2BApDDK,GAsDc,CACnB3gC,KAAM,oBACNsgC,KAAM,wDAxDDK,GA0DgB,CACrB3gC,KAAM,6BACNsgC,KAAM,+GA5DDK,GA8DoB,CACzB3gC,KAAM,kCACNsgC,KAAM,iGAhEDK,GAkEW,CAChB3gC,KAAM,yBACNsgC,KAAM,sFApEDK,GAsES,CACd3gC,KAAM,yBACNsgC,KAAM,iFAxEDK,GA0EW,CAChB3gC,KAAM,uBACNsgC,KAAM,qDA5EDK,GA8Ee,CACpB3gC,KAAM,2BACNsgC,KAAM,sFASV,WAAYC,EAAmBC,GAA/B,MACInmB,YAAMkmB,EAAWC,gBACjBlmB,EAAK3e,KAAO,kBAEZnF,OAAOC,eAAe6jB,EAAMsmB,EAAgB1pC,aA8GpD,OApHqCqjB,OAS1BqmB,gCAAP,SAAqCC,GACjC,IAAIL,EAAeG,GAA+CL,KAIlE,OAHIO,IAAcrD,GAAYiC,QAAQoB,KAClCL,GAAgB,aAAaK,GAE1B,IAAID,EAAgBD,GAA+C3gC,KAAMwgC,IAG7EI,2CAAP,SAAgD/F,GAC5C,OAAO,IAAI+F,EAAgBD,GAA8C3gC,KACrE,yBAAyB66B,OAAU8F,GAA8CL,WAGlFM,wCAAP,SAA6C/F,GACzC,OAAO,IAAI+F,EAAgBD,GAAgD3gC,KACvE,yBAAyB66B,OAAU8F,GAAgDL,WAGpFM,yBAAP,SAA8BC,GAC1B,IAAIL,EAAeG,GAAwCL,KAI3D,OAHIO,IAAcrD,GAAYiC,QAAQoB,KAClCL,GAAgB,aAAaK,GAE1B,IAAID,EAAgBD,GAAwC3gC,KAAMwgC,IAGtEI,iCAAP,WACI,OAAO,IAAIA,EAAgBD,GAAyC3gC,KAChE2gC,GAAyCL,OAG1CM,4BAAP,SAAiCT,GAC7B,OAAO,IAAIS,EAAgBD,GAAsC3gC,KAC1D2gC,GAAsCL,sBAAqBH,IAI/DS,0BAAP,SAA+BE,EAAsBC,GACjD,OAAO,IAAIH,EAAgBD,GAAyC3gC,KAC7D2gC,GAAyCL,SAAQQ,wBAAkCC,QAIvFH,2BAAP,SAAgCI,EAAsBC,GAClD,OAAO,IAAIL,EAAgBD,GAA0C3gC,KAC9D2gC,GAA0CL,SAAQU,wBAAkCC,QAGxFL,6BAAP,WACI,OAAO,IAAIA,EAAgBD,GAA0C3gC,KACjE2gC,GAA0CL,OAG3CM,oCAAP,WACI,OAAO,IAAIA,EAAgBD,GAAiD3gC,KACxE2gC,GAAiDL,OAGlDM,2BAAP,WACI,OAAO,IAAIA,EAAgBD,GAA0C3gC,KACjE2gC,GAA0CL,OAG3CM,gCAAP,SAAqCM,GACjC,OAAO,IAAIN,EAAgBD,GAAqC3gC,KACzD2gC,GAAqCL,SAAQY,QAGjDN,+BAAP,WACI,OAAO,IAAIA,EAAgBD,GAA8C3gC,KACrE2gC,GAA8CL,OAG/CM,8BAAP,WACI,OAAO,IAAIA,EAAgBD,GAA6C3gC,KACpE2gC,GAA6CL,OAG9CM,gCAAP,SAAqCO,GACjC,OAAO,IAAIP,EAAgBD,GAA+C3gC,KACnE2gC,GAA+CL,4BAA2Ba,IAG9EP,oCAAP,SAAyCO,GACrC,OAAO,IAAIP,EAAgBD,GAAmD3gC,KACvE2gC,GAAmDL,4BAA2Ba,IAGlFP,gCAAP,SAAqCQ,GACjC,OAAO,IAAIR,EAAgBD,GAA0C3gC,KAC9D2gC,GAA0CL,6BAA4Bc,IAG1ER,4BAAP,SAAiCS,GAC7B,OAAO,IAAIT,EAAgBD,GAAwC3gC,KAC5D2gC,GAAwCL,4BAA2Be,IAGvET,2BAAP,SAAgCU,GAC5B,OAAO,IAAIV,EAAgBD,GAA0C3gC,KAC9D2gC,GAA0CL,8BAA6BgB,IAG3EV,oCAAP,WACI,OAAO,IAAIA,EAAgBD,GAA8C3gC,KACrE2gC,GAA8CL,UAlHrBG,ICvFxBc,GAAkC,CAC3CC,oBAAqB,CACjBxhC,KAAM,gBACNsgC,KAAM,uHAEVmB,qBAAsB,CAClBzhC,KAAM,yBACNsgC,KAAM,6CAEVoB,mBAAoB,CAChB1hC,KAAM,gCACNsgC,KAAM,sDAEVqB,uBAAwB,CACpB3hC,KAAM,wBACNsgC,KAAM,+PAGVsB,sBAAuB,CACnB5hC,KAAM,0BACNsgC,KAAM,4KAGVuB,eAAgB,CACZ7hC,KAAM,kBACNsgC,KAAM,kDAEVwB,YAAa,CACT9hC,KAAM,2BACNsgC,KAAM,2CAEVyB,eAAgB,CACZ/hC,KAAM,8BACNsgC,KAAM,yCAEV0B,YAAa,CACThiC,KAAM,8BACNsgC,KAAM,qDAEV2B,cAAe,CACXjiC,KAAM,uBACNsgC,KAAM,+EAEV4B,qBAAsB,CAClBliC,KAAM,yBACNsgC,KAAM,qIAEV6B,qBAAsB,CAClBniC,KAAM,yBACNsgC,KAAM,kCAEV8B,wBAAyB,CACrBpiC,KAAM,6BACNsgC,KAAM,mCAEV+B,+BAAgC,CAC5BriC,KAAM,mCACNsgC,KAAM,sEAEVgC,2BAA4B,CACxBtiC,KAAM,iCACNsgC,KAAM,mDAEViC,0BAA2B,CACvBviC,KAAM,+BACNsgC,KAAM,oDAEVkC,kBAAmB,CACfxiC,KAAM,sBACNsgC,KAAM,+BAEVmC,qBAAsB,CAClBziC,KAAM,yBACNsgC,KAAM,2EASV,WAAYC,EAAmBC,GAA/B,MACInmB,YAAMkmB,EAAWC,gBACjBlmB,EAAK3e,KAAO,2BACZnF,OAAOC,eAAe6jB,EAAMooB,EAAyBxrC,aA6E7D,OAlF8CqjB,OAQnCmoB,gCAAP,WACI,OAAO,IAAIA,EAAyBnB,GAAgCC,oBAAoBxhC,KACpF,GAAGuhC,GAAgCC,oBAAoBlB,OAGxDoC,wCAAP,SAA6CC,GACzC,OAAO,IAAID,EAAyBnB,GAAgCE,qBAAqBzhC,KAClFuhC,GAAgCE,qBAAqBnB,yBAAwBqC,4BAA4Cr3B,GAAUs3B,wBAAuBt3B,GAAUu3B,2BAGxKH,gCAAP,WACI,OAAO,IAAIA,EAAyBnB,GAAgCG,mBAAmB1hC,KACnFuhC,GAAgCG,mBAAmBpB,OAGpDoC,qCAAP,WACI,OAAO,IAAIA,EAAyBnB,GAAgCI,uBAAuB3hC,KAAMuhC,GAAgCI,uBAAuBrB,OAGrJoC,mCAAP,SAAwCI,GACpC,OAAO,IAAIJ,EAAyBnB,GAAgCK,sBAAsB5hC,KACnFuhC,GAAgCK,sBAAsBtB,4CAA2CwC,IAGrGJ,8BAAP,SAAmCK,GAC/B,OAAO,IAAIL,EAAyBnB,GAAgCO,YAAY9hC,KACzEuhC,GAAgCO,YAAYxB,sBAAqByC,QAGrEL,4BAAP,SAAiCK,GAC7B,OAAO,IAAIL,EAAyBnB,GAAgCQ,eAAe/hC,KAC5EuhC,GAAgCQ,eAAezB,sBAAqByC,QAGxEL,iCAAP,SAAsCK,GAClC,OAAO,IAAIL,EAAyBnB,GAAgCS,YAAYhiC,KACzEuhC,GAAgCS,YAAY1B,sBAAqByC,QAGrEL,4BAAP,SAAiCK,GAC7B,OAAO,IAAIL,EAAyBnB,GAAgCM,eAAe7hC,KAC5EuhC,GAAgCM,eAAevB,sBAAqByC,IAGxEL,2BAAP,SAAgCrE,GAC5B,OAAO,IAAIqE,EAAyBnB,GAAgCU,cAAcjiC,KAC3EuhC,GAAgCU,cAAc3B,sBAAqBjC,IAGvEqE,kCAAP,SAAuCM,GACnC,OAAO,IAAIN,EAAyBnB,GAAgCgB,0BAA0BviC,KACvFuhC,GAAgCgB,0BAA0BjC,sBAAqB0C,IAGnFN,0BAAP,WACU,IAAA/zB,uBACN,OAAO,IAAI+zB,kBAGRA,6BAAP,SAAkCO,GACxB,IAAAt0B,0BAAE3O,SAAMsgC,SACR4C,EAAe,CACjBC,gBAAiB,SACjBC,mBAAoB,SACpBC,iBAAkB,YAQtB,OAAO,IAAIX,EAAyB1iC,EAASsgC,qBALzB9pC,OAAO4K,KAAK8hC,GAC3B7hC,OAAO,SAACD,EAAMG,GACX,OAAO0hC,EAAO1hC,GAAOH,EAAOA,EAAKzG,OAAO,CAAK4G,OAAQ2hC,EAAa3hC,UACnE,IAEyExF,KAAK,UAhF/C6kC,ICtE9C,ICLY0C,iBDyCV,WAAaxD,EAAsBtF,EAAkBK,EAAsBve,EAAsB2hB,EAAqBje,GACpHhpB,KAAK6mC,kBAAoBiC,EACzB9oC,KAAKwjC,SAAWA,EAIdxjC,KAAK2I,OAHFk7B,EAGgBA,UAFL,CAACL,GAKjBxjC,KAAKknC,MAAQ5C,GAAYiI,gBACzBvsC,KAAKgpB,MAAQA,IAAUwd,GAAYiC,QAAQzf,GAAUsb,GAAYiI,gBAAkB,IAAMvjB,EAAUsb,GAAYiI,gBAG/GvsC,KAAKgF,cAAgBs/B,GAAYiI,gBAGjCvsC,KAAKmnC,WAAa,UAClBnnC,KAAKonC,WTiFA,QS/ELpnC,KAAKslB,aAAeA,EACpBtlB,KAAKinC,YAAcA,EA+RvB,OAhUEznC,sBAAWgtC,6BAAX,WACE,OAAOxsC,KAAK6mC,kBAAoB7mC,KAAK6mC,kBAAkB4F,mBAAqB,sCA2C9ED,gCAAA,SAAoBE,EAAkBp2B,EAAmCq2B,GACvE,IA8BIC,EA9BAjrB,EAA8B,GAE9BrL,IAEEA,EAAQu2B,SACV7sC,KAAK8sC,wBAAwBx2B,EAAQu2B,QACrC7sC,KAAKqnC,YAAc/wB,EAAQu2B,QAIzBv2B,EAAQy2B,0BEtEoBz2B,GAClC,GAAKA,EAAQy2B,cAIb,IACaxoC,KAAKC,MAAM8R,EAAQy2B,eAC9B,MAAOrrC,GACL,MAAMgqC,GAAyBsB,gCAAgCtrC,IF+D/DurC,CAAsB32B,GACtBtW,KAAKsnC,YAAchxB,EAAQy2B,eAIzBP,EAAwBU,WAAW52B,KACrCqL,EAAkB3hB,KAAKmtC,oCAAoC72B,EAAS,QAIpEq2B,IACFhrB,EAAkB3hB,KAAKmtC,oCAAoC,KAAMR,IAKnEhrB,EAAkB3hB,KAAKotC,kBAAkBV,EAAS/qB,GAI9CrL,IACFs2B,EAAW5sC,KAAKqtC,iBAAiB/2B,IAInCtW,KAAK2hB,gBAAkB6qB,EAAwBc,8BAA8B3rB,GAC7E3hB,KAAKunC,qBAAuBiF,EAAwBc,8BAA8BV,IAY5EJ,oCAAR,SAAiCK,GAC/B,KAAM,CAAC9G,GAAYC,MAAOD,GAAYE,eAAgBF,GAAYG,QAASH,GAAYI,MAAMl7B,QAAQ4hC,IAAW,GAC5G,MAAMnB,GAAyB6B,yBAAyBV,IAatDL,gDAAR,SAA4Cl2B,EAAmCk3B,GAG7E,IAAIC,EACAC,EACAC,EAA6B,GAEjC,GAAIr3B,EACF,GAAIA,EAAQo2B,QAAS,CACnB,IAAMA,EAAmBp2B,EAAQo2B,QAC7BA,EAAQkB,KACVH,EAAU5H,GACV6H,EAAUhB,EAAQkB,KAEXlB,EAAQmB,WACfJ,EAAU5H,GACV6H,EAAUhB,EAAQmB,eAIbv3B,EAAQs3B,KACfH,EAAU5H,GACV6H,EAAUp3B,EAAQs3B,KAGXt3B,EAAQw3B,YACfL,EAAU5H,GACV6H,EAAUp3B,EAAQw3B,gBAIbN,IACHA,EAAc3tC,eAAeyU,GAAUy5B,MACzCN,EAAU5H,GACV6H,EAAUF,EAAcO,MAGxBN,EAAU5H,GACV6H,EAAU,OAWd,OAPAC,EAAiB3tC,KAAKguC,gBAAgBP,EAASC,GAG3Cp3B,GAAWA,EAAQo2B,SAAWp2B,EAAQo2B,QAAQzD,wBAC9C0E,EAAiB3tC,KAAKguC,gBAAgBnI,GAAyBvvB,EAAQo2B,QAAQzD,sBAAuB0E,IAGnGA,GAiBDnB,8BAAR,SAA0BE,EAAkBuB,GAG1C,GAAIvB,IAAYuB,EAAQpI,IAAe,CAGrC,IADqBoI,EAAQpI,KAAwB6G,EAAQkB,KAAO5tC,KAAKqnC,cAAgBtB,GAAYI,KAEjG8H,EAAUjuC,KAAKguC,gBAAgBnI,GAAc6G,EAAQkB,IAAKK,QAIjCA,EAAQpI,KAAwB6G,EAAQmB,WAAarH,GAAYiC,QAAQiE,EAAQmB,YAE1GI,EAAUjuC,KAAKguC,gBAAgBnI,GAAqB6G,EAAQmB,SAAUI,KAI/CA,EAAQpI,MAAyBoI,EAAQpI,MAElEoI,EAAUjuC,KAAKguC,gBAAgBnI,GAAyB6G,EAAQzD,sBAAuBgF,IAI3F,OAAOA,GAODzB,4BAAR,SAAwBiB,EAAiBC,EAAiBQ,GAKxD,GAJKA,IACHA,EAAW,KAGRR,EACD,OAAOQ,EAGX,OAAQT,GACN,KAAK5H,GACHqI,EAASrI,IAAgB6H,EACzB,MAEF,KAAK7H,GACHqI,EAASrI,IAAuB6H,EAChCQ,EAASrI,IAAwBA,GACjC,MAEF,KAAKA,GACHqI,EAASrI,IAAuB6H,EAChC,MAEF,KAAK7H,GACHqI,EAASrI,IAAwBA,GACjC,MAEF,KAAKA,GACHqI,EAASrI,IAAwBA,GACjC,MAEF,KAAKA,GACH,IAAIsI,EAAgBT,EAAQt8B,MAAM,KAC5B23B,EAAMzE,GAAY8J,aAAaD,EAAc,IAC7CnF,EAAO1E,GAAY8J,aAAaD,EAAc,IAGpDD,EAASrI,IAAsBkD,EAC/BmF,EAASrI,IAAuBmD,EAE5BA,IAAS10B,GAAU+5B,cACnBH,EAASrI,IAAwBA,GAGjCqI,EAASrI,IAAwBA,GAErC,MAEF,KAAKA,GACHqI,EAASrI,IAAsB6H,EAC/B,MAEF,KAAK7H,GACHqI,EAASrI,IAAuB6H,EAKpC,OAAOQ,GASD1B,6BAAR,SAAyBl2B,GACvB,IAAIs2B,EAAwBt2B,EAAQixB,qBACpC,OAAKqF,GAGDt2B,EAAQy2B,sBAEHH,EAASt4B,GAAUg6B,QAE5BxI,GAAoBj5B,QAAQ,SAAA0hC,GACtB3B,EAAS2B,WAEJ3B,EAAS2B,KAGb3B,GAZE,MAmBJJ,gCAAP,SAAqC7qB,GACnC,IAAI6sB,EAAuB,KAa3B,OAXI7sB,GACFniB,OAAO4K,KAAKuX,GAAiB9U,QAAQ,SAACtC,GAChB,MAAhBikC,EACFA,EAAkBjkC,MAAOkX,mBAAmBE,EAAgBpX,IAG5DikC,GAAgB,IAAIjkC,MAAOkX,mBAAmBE,EAAgBpX,MAK7DikC,GASFhC,aAAP,SAAkBl2B,GACd,OAAOA,IAAYA,EAAQo2B,SAAWp2B,EAAQs3B,KAAOt3B,EAAQw3B,+BGxUjE,WAAYW,GACV,IAAKA,GAAiBjI,GAAYiC,QAAQgG,GAGxC,OAFAzuC,KAAK+oC,IAAM,QACX/oC,KAAKgpC,KAAO,IAId,IACE,IAAM0F,EAA4BpK,GAAY8J,aAAaK,GACrDE,EAAqCpqC,KAAKC,MAAMkqC,GAClDC,IACEA,EAAW9uC,eAAe,SAC5BG,KAAK+oC,IAAM4F,EAAW5F,KAGpB4F,EAAW9uC,eAAe,UAC5BG,KAAKgpC,KAAO2F,EAAW3F,OAG3B,MAAOtnC,GACP,MAAMkoC,GAAgBgF,8BAA8BltC,IAG1D,OAxCElC,sBAAIqvC,uBAAJ,WACE,OAAO7uC,KAAK8uC,KAAO9uC,KAAK8uC,KAAO,QAGjC,SAAQ/F,GACN/oC,KAAK8uC,KAAO/F,mCAIdvpC,sBAAIqvC,wBAAJ,WACE,OAAO7uC,KAAK+uC,MAAQ/uC,KAAK+uC,MAAQ,QAGnC,SAAS/F,GACPhpC,KAAK+uC,MAAQ/F,sDClBjB,cAmDA,OA5CSgG,YAAP,SAAiBC,GACf,GAAIzI,GAAYiC,QAAQwG,GACtB,OAAO,KAET,IACMC,EADoB,uCACQ9+B,KAAK6+B,GACvC,OAAKC,GAAWA,EAAQvuC,OAAS,EAExB,KAEY,CACnB2R,OAAQ48B,EAAQ,GAChBC,WAAYD,EAAQ,GACpBE,OAAQF,EAAQ,KAUbF,iBAAP,SAAsBK,GAEpB,IAAMC,EAAetvC,KAAKuvC,UAAUF,GACpC,IAAKC,EACH,OAAO,KAET,IACE,IAAME,EAAgBF,EAAaH,WAC7BM,EAAgBnL,GAAY8J,aAAaoB,GAC/C,OAAKC,EAKElrC,KAAKC,MAAMirC,GAHT,KAIT,MAAO3mC,IAIT,OAAO,cC/BT,SAAY4mC,GACV,GAAIlJ,GAAYiC,QAAQiH,GACtB,MAAM9F,GAAgB+F,8BAA8BD,GAEtD,IACE1vC,KAAK0vC,WAAaA,EAClB1vC,KAAKsuC,OAASU,GAAWY,eAAeF,GACpC1vC,KAAKsuC,SACHtuC,KAAKsuC,OAAOzuC,eAAe,SAC7BG,KAAK6vC,OAAS7vC,KAAKsuC,OAAY,KAG7BtuC,KAAKsuC,OAAOzuC,eAAe,SAC3BG,KAAK8vC,SAAW9vC,KAAKsuC,OAAY,KAGjCtuC,KAAKsuC,OAAOzuC,eAAe,SAC7BG,KAAK+vC,QAAU/vC,KAAKsuC,OAAY,KAG9BtuC,KAAKsuC,OAAOzuC,eAAe,SAC7BG,KAAKujC,SAAWvjC,KAAKsuC,OAAY,KAG/BtuC,KAAKsuC,OAAOzuC,eAAe,SAC7BG,KAAKsH,QAAUtH,KAAKsuC,OAAY,KAG9BtuC,KAAKsuC,OAAOzuC,eAAe,wBAC7BG,KAAKgwC,cAAgBhwC,KAAKsuC,OAA2B,oBAGnDtuC,KAAKsuC,OAAOzuC,eAAe,UAC7BG,KAAK2E,KAAO3E,KAAKsuC,OAAa,MAG5BtuC,KAAKsuC,OAAOzuC,eAAe,WAC7BG,KAAKknC,MAAQlnC,KAAKsuC,OAAc,OAG9BtuC,KAAKsuC,OAAOzuC,eAAe,SAC7BG,KAAKiwC,WAAajwC,KAAKsuC,OAAY,KAGjCtuC,KAAKsuC,OAAOzuC,eAAe,cAC3BG,KAAKkwC,aAAelwC,KAAKsuC,OAAiB,UAG1CtuC,KAAKsuC,OAAOzuC,eAAe,SAC3BG,KAAK4tC,IAAM5tC,KAAKsuC,OAAY,MAIlC,MAAO5sC,GAGP,MAAMkoC,GAAgBuG,0BAA0BzuC,QCrEpD,SAAY6I,EAAqBhJ,GAC/BvB,KAAKuK,IAAMA,EACXvK,KAAKuB,MAAQA,iBCEf,WAAY6uC,GACV,GAAIC,EAAQ9yB,SACV,OAAO8yB,EAAQ9yB,SAOjB,GAJAvd,KAAKowC,cAAgBA,EACrBpwC,KAAKswC,2BAA8D,IAA/B/8B,OAAOvT,KAAKowC,gBAAgE,MAA9B78B,OAAOvT,KAAKowC,eAC9FpwC,KAAKuwC,6BAA2D,IAA1Bh9B,OAAO68B,IAA2D,MAAzB78B,OAAO68B,GACtFC,EAAQ9yB,SAAWvd,MACdA,KAAKswC,wBAA0BtwC,KAAKuwC,wBACvC,MAAM7E,GAAyB8E,gCAGjC,OAAOH,EAAQ9yB,SAmKnB,OA/JI8yB,oBAAA,SAAQ9lC,EAAahJ,EAAekvC,GAC5Bl9B,OAAOvT,KAAKowC,gBACZ78B,OAAOvT,KAAKowC,eAAeM,QAAQnmC,EAAKhJ,GAExCkvC,GACAzwC,KAAK2wC,cAAcpmC,EAAKhJ,IAKhC8uC,oBAAA,SAAQ9lC,EAAakmC,GACjB,OAAIA,GAAuBzwC,KAAK4wC,cAAcrmC,GACnCvK,KAAK4wC,cAAcrmC,GAE1BgJ,OAAOvT,KAAKowC,eACL78B,OAAOvT,KAAKowC,eAAeS,QAAQtmC,GAEvC,MAIX8lC,uBAAA,SAAW9lC,GACP,GAAIgJ,OAAOvT,KAAKowC,eACZ,OAAO78B,OAAOvT,KAAKowC,eAAeU,WAAWvmC,IAKrD8lC,kBAAA,WACI,GAAI98B,OAAOvT,KAAKowC,eACZ,OAAO78B,OAAOvT,KAAKowC,eAAeW,SAI1CV,+BAAA,SAAmB7M,EAAkByF,GACjC,IACI+H,EADEC,EAAuC,GAEvCC,EAAU39B,OAAOvT,KAAKowC,eAC5B,GAAIc,EAAS,CACT,IAAI3mC,SACJ,IAAKA,KAAO2mC,EACR,GAAIA,EAAQrxC,eAAe0K,IACnBA,EAAIkO,MAAM+qB,IAAaj5B,EAAIkO,MAAMwwB,GAAwB,CACzD,IAAM1nC,EAAQvB,KAAK6wC,QAAQtmC,GACvBhJ,IACAyvC,EAAuB,IAAIG,GAAqB5sC,KAAKC,MAAM+F,GAAMhG,KAAKC,MAAMjD,IAC5E0vC,EAAQ/tC,KAAK8tC,KAOjC,OAAOC,GAGXZ,sCAAA,SAA0BrnB,GACtB,IAAMkoB,EAAU39B,OAAOvT,KAAKowC,eAC5B,GAAIc,EAAS,CACT,IAAI3mC,SACJ,IAAKA,KAAO2mC,EACR,GAAIA,EAAQrxC,eAAe0K,OACoB,IAAtCA,EAAIU,QAAQo6B,KAAgF,IAAjD96B,EAAIU,QAAQo6B,KAA6Crc,IAAiC,IAAxBze,EAAIU,QAAQ+d,IAAgB,CAC1I,IAAMooB,EAAW7mC,EAAI6G,MAAMkD,GAAU+8B,mBACjCC,SACAF,EAASzwC,OAAS,IAClB2wC,EAAQF,EAAS,IAEjBE,IAAUtxC,KAAKuxC,uBAAuBD,KACtCtxC,KAAK8wC,WAAWvmC,GAChBvK,KAAK8wC,WAAWx8B,GAAUk9B,YAAcF,GACxCtxC,KAAK8wC,WAAWx8B,GAAUm9B,YAC1BzxC,KAAK8wC,WAAWx8B,GAAUo9B,mBAC1B1xC,KAAK2wC,cAAcpmC,EAAK,IAAK,KAOjDvK,KAAK2xC,eAGDtB,mCAAR,SAA+BuB,GAC3B,IACMJ,EADUj+B,OAAOvT,KAAKowC,eACA97B,GAAUk9B,YAAcI,GACpD,SAAUJ,GAAeA,IAAgBl9B,GAAUu9B,6BAGvDxB,4BAAA,WACI,IAAMa,EAAU39B,OAAOvT,KAAKowC,eAC5B,GAAIc,EAAS,CACT,IAAI3mC,SACJ,IAAKA,KAAO2mC,EACJA,EAAQrxC,eAAe0K,KACc,IAAjCA,EAAIU,QAAQqJ,GAAUw9B,OACtB9xC,KAAK8wC,WAAWvmC,GAI5BvK,KAAK+xC,8BAIb1B,0BAAA,SAAc2B,EAAeC,EAAgBC,GACzC,IAAIC,EAAYH,EAAQ,IAAMC,EAAS,IACnCC,IAEAC,GAAa,WADMnyC,KAAKoyC,wBAAwBF,GACT,KAG3C9hB,SAASiiB,OAASF,GAGtB9B,0BAAA,SAAc2B,GAGV,IAFA,IAAMrtC,EAAOqtC,EAAQ,IACfM,EAAKliB,SAASiiB,OAAOjhC,MAAM,KACxB5Q,EAAI,EAAGA,EAAI8xC,EAAG3xC,OAAQH,IAAK,CAEhC,IADA,IAAI6L,EAAIimC,EAAG9xC,GACY,MAAhB6L,EAAEE,OAAO,IACZF,EAAIA,EAAEyN,UAAU,GAEpB,GAAwB,IAApBzN,EAAEpB,QAAQtG,GACV,OAAO0H,EAAEyN,UAAUnV,EAAKhE,OAAQ0L,EAAE1L,QAG1C,MAAO,IAGX0vC,oCAAA,SAAwBkC,GACpB,IAAMC,EAAQ,IAAIxkC,KAElB,OADa,IAAIA,KAAKwkC,EAAMv4B,UAA6B,GAAjBs4B,EAAsB,GAAK,GAAK,KAC5Dx4B,eAGhBs2B,wBAAA,WACIrwC,KAAK2wC,cAAcr8B,GAAUm+B,aAAc,IAAK,GAChDzyC,KAAK2wC,cAAcr8B,GAAUm9B,WAAY,IAAK,GAC9CzxC,KAAK2wC,cAAcr8B,GAAUo+B,aAAc,IAAK,GAChD1yC,KAAK2wC,cAAcr8B,GAAUo9B,kBAAmB,IAAK,IAQlDrB,iCAAP,SAAsCsC,EAAgB3pB,GAClD,OAAOqc,GAAkC/wB,GAAU+8B,kBAC/C,GAAGsB,EAAcr+B,GAAU+8B,kBAAwBroB,GAOpDqnB,uBAAP,SAA4BrnB,GACxB,OAAOqc,GAAsB/wB,GAAU+8B,kBAAoB,GAAGroB,sBCzJlE,WAAY4pB,EAA2B3J,EAA+B4E,EAAkBlpC,EAAckuC,EAA2BjF,EAAckF,GAC7I9yC,KAAK4yC,kBAAoBA,EACzB5yC,KAAKipC,sBAAwBA,EAC7BjpC,KAAK6tC,SAAWA,EAChB7tC,KAAK2E,KAAOA,EAEZ3E,KAAKmpC,QAAU0J,EACf7yC,KAAK6yC,cAAgBA,EACrB7yC,KAAK4tC,IAAMA,EACX5tC,KAAK8yC,YAAcA,EAyCzB,OAjCWC,gBAAP,SAAqB5J,EAAkBwF,GAGnC,IAMI1F,EANE2J,EAA4BzJ,EAAQ2G,UAAa3G,EAAQ4G,QAGzDhH,EAAc4F,EAAaA,EAAW5F,IAAM,GAC5CC,EAAe2F,EAAaA,EAAW3F,KAAO,GAMpD,OAHKxC,GAAYiC,QAAQM,IAASvC,GAAYiC,QAAQO,KAClDC,EAAwB3E,GAAY4E,aAAaH,GAAO,IAAMzE,GAAY4E,aAAaF,IAEpF,IAAI+J,EAAQH,EAAmB3J,EAAuBE,EAAQ6G,cAAe7G,EAAQxkC,KAAMwkC,EAAQmF,OAAQnF,EAAQyE,IAAKzE,EAAQ0G,SASpIkD,kBAAP,SAAuBC,EAAaC,GAChC,SAAKD,IAAOC,OAGRD,EAAG/J,wBAAyBgK,EAAGhK,uBAC/B+J,EAAG/J,wBAA0BgK,EAAGhK,2CC7E5C,cAoBA,OAdWiK,iBAAP,SAAsB9J,GAKlB,OAHKA,IACLA,EAAY,QAELl9B,SAASk9B,EAAW,KAMxB8J,MAAP,WACI,OAAOt/B,KAAKu/B,OAAM,IAAInlC,MAAOiM,UAAY,yBCfjD,cAsBA,OApBWm5B,qBAAP,SAA0BC,EAAgCC,GACtD,IAAKD,EACD,OAAO,KACJ,IAAKC,EACR,OAAOD,EAGX,IAAIE,EAAM1X,OAAOyX,EAAWrD,YAK5B,OAJIsD,IAAQF,EAAiBG,YACzBH,EAAiBG,UAAY,IAAIxlC,KAAW,IAANulC,SAIrCF,GACHlK,QAASmK,EACTT,cAAeS,EAAWhF,OAC1BmF,SAAUH,EAAWxD,UAAYwD,EAAWvD,QAC5CxM,SAAU+P,EAAW/P,+BCpB/B,cAkDA,OAjDSmQ,6BAAP,SAAwBzzB,EAAaC,EAAgByzB,GAArD,WACE,OAAO,IAAIxyC,QAAgB,SAACC,EAASC,GACnC,IAAI+iB,EAAM,IAAIC,eAyBd,GAxBAD,EAAIgB,KAAKlF,EAAQD,GAAiB,GAMlCmE,EAAIwvB,OAAS,SAACC,IACNzvB,EAAIhO,OAAS,KAAOgO,EAAIhO,QAAU,MAClC/U,EAAOiiB,EAAKwwB,YAAY1vB,EAAIwB,eAGhC,IACI,IAAImuB,EAAexvC,KAAKC,MAAM4f,EAAIwB,cACpC,MAAOlkB,GACLL,EAAOiiB,EAAKwwB,YAAY1vB,EAAIwB,eAGhCxkB,EAAQ2yC,IAGZ3vB,EAAI4vB,QAAU,SAACH,GACbxyC,EAAO+iB,EAAIhO,SAGE,QAAX8J,EAIF,KAAM,kBAHNkE,EAAImB,UAQAmuB,wBAAV,SAAsB9tB,GACpB,IAAImuB,EACJ,IAEE,IADAA,EAAexvC,KAAKC,MAAMohB,IACTniB,MACb,OAAOswC,EAAatwC,MAEpB,MAAMmiB,EAEV,MAAOlkB,GACP,OAAOkkB,UV3Cb,SAAY0mB,GACVA,iBACAA,mBACAA,iBAHF,CAAYA,KAAAA,QASZ,IWXY2H,kBCOV,WAAmBnL,EAAmBoL,UACpC7wB,YAAMylB,EAAWoL,SAuCrB,OA/CkC3wB,OAGhC/jB,sBAAY20C,mDAAZ,WACI,OAAUA,EAAaC,wEAAuEp0C,KAAKysC,4EAOvGjtC,sBAAW20C,iCAAX,WACE,OAAO7H,GAAc+H,qCAOhBF,gDAAP,WAAA,WACUG,EAAiC,IAAInzC,QAAgB,SAACC,EAASC,GACrE,OAAAD,EAAQkiB,EAAKixB,sCAEf,IAAKv0C,KAAKw0C,oBACR,OAAOF,EAGT,IAAIltB,EAAepnB,KAAKy0C,gCAAgCtM,gBACxD,OAAInoC,KAAK00C,oBAAoBttB,GACpBktB,GAGe,IAAIZ,IAEdiB,iBAAiB30C,KAAK40C,gCAAiC,OAAO,GACzE9yC,KAAK,SAACmU,GACL,OAAOA,EAAS4+B,6BAQfV,gCAAP,SAA2B/sB,GACzB,OAAOke,GAAmBle,EAAKpV,gBA5CTmiC,+BAAuC,4EZW/D,WAAYrL,EAAmBoL,GAC7Bl0C,KAAKw0C,oBAAsBN,EAC3Bl0C,KAAKysC,mBAAqB3D,EAE1B9oC,KAAK80C,gBAwHT,OAjHEt1C,sBAAWu1C,0BAAX,WACE,OAAO/0C,KAAKy0C,gCAAgC3M,aAAa,oCAK3DtoC,sBAAWu1C,yCAAX,WAEE,OADA/0C,KAAKg1C,mBACEh1C,KAAKi1C,wBAAwBnO,sBAAsBr7B,QAAQ,WAAYzL,KAAKk1C,yCAGrF11C,sBAAWu1C,sCAAX,WAEE,OADA/0C,KAAKg1C,mBACEh1C,KAAKi1C,wBAAwBE,mBAAmB1pC,QAAQ,WAAYzL,KAAKk1C,yCAGlF11C,sBAAWu1C,yCAAX,WAEE,OADA/0C,KAAKg1C,mBACEh1C,KAAKi1C,wBAAwBG,OAAO3pC,QAAQ,WAAYzL,KAAKk1C,yCAG9DH,6BAAR,WACE,IAAK/0C,KAAKi1C,wBACR,KAAM,2CAOVz1C,sBAAWu1C,sCAAX,WACE,OAAO/0C,KAAKq1C,wBAGd,SAA8Bp1B,GAC5BjgB,KAAKq1C,mBAAqB5O,GAASwB,gBAAgBhoB,GACnDjgB,KAAKs1C,gCAAkC,sCAMzC91C,sBAAWu1C,mDAAX,WAKE,OAJK/0C,KAAKs1C,kCACRt1C,KAAKs1C,gCAAkC7O,GAASmB,iBAAiB5nC,KAAKysC,qBAGjEzsC,KAAKs1C,iEAMd91C,sBAAcu1C,sDAAd,WACE,OAAU/0C,KAAKysC,4FAMTsI,0BAAR,WACE,IAAIQ,EACJ,IACEA,EAAav1C,KAAKy0C,gCAClB,MAAO/yC,GACP,MAAM6oC,GAAgCW,qBAGxC,IAAKqK,EAAWrN,UAAkD,WAAtCqN,EAAWrN,SAASl2B,cAC9C,MAAMu4B,GAAgCY,qBAGxC,IAAKoK,EAAWzN,cAAgByN,EAAWzN,aAAannC,OAAS,EAC/D,MAAM4pC,GAAgCa,yBAOlC2J,8BAAR,SAA0BS,GAExB,OADe,IAAI9B,IACLiB,iBAAiBa,EAA6B,OAA2B,GAClF1zC,KAAK,SAACmU,GACH,MAAiC,CAC7B6wB,sBAAuB7wB,EAASw/B,uBAChCN,mBAAoBl/B,EAASy/B,qBAC7BN,OAAQn/B,EAAS45B,WAWxBkF,kCAAP,WAAA,WACMS,EAA8B,GAClC,OAAOx1C,KAAK21C,sCAAsC7zC,KAAK,SAAA8zC,GAErD,OADAJ,EAA8BI,EACvBtyB,EAAKuyB,kBAAkBL,KAC7B1zC,KAAK,SAACmzC,GAEP,OADA3xB,EAAK2xB,wBAA0BA,EACxB3xB,0Ba7HX,WAAmBwlB,EAAmBoL,GAAtC,MACE7wB,YAAMylB,EAAWoL,SACX7L,EAAgB5B,GAASmB,iBAAiBkB,GAE1CP,EAAeF,EAAcP,aACnC,GAAIS,EAAa5nC,OAAS,EACtB,MAAM4pC,GAAgCe,kCAG1ChoB,EAAKmpB,mBAAqB,WAAWpE,EAAcF,oBAAmBI,EAAa,OAAMA,EAAa,OAAMA,EAAa,SAyB7H,OApCkChlB,OAchC/jB,sBAAWs2C,iCAAX,WACE,OAAOxJ,GAAcyJ,qCAMhBD,gDAAP,WAAA,WACQxB,EAAgB,IAAInzC,QAAgB,SAACC,EAASC,GAClD,OAAAD,EAAQkiB,EAAKixB,sCAEf,OAAKv0C,KAAKw0C,oBAINx0C,KAAK00C,oBAAoB10C,KAAKy0C,gCAAgCtM,iBACzDmM,EAGF,IAAInzC,QAAgB,SAACC,EAASC,GACnC,OAAAA,EAAOkpC,GAAgCc,kCARhCiJ,GAzBGwB,aAAqB,SADH3B,kBCElC,cAsCA,OAlCmB6B,yBAAf,SAAsCC,GAIlC,OAHAA,EAAexP,GAASwB,gBAAgBgO,GACrBxP,GAASmB,iBAAiBqO,GACbnO,aACX,IACjB,IAAK,MACD,OAAOwE,GAAcyJ,IACzB,IAAK,OACD,OAAOzJ,GAAc4J,KACzB,QACI,OAAO5J,GAAc+H,MAQnB2B,iBAAd,SAA6BC,EAAsB/B,GAC/C,GAAI1N,GAAYiC,QAAQwN,GACpB,OAAO,KAIX,OAFaD,EAAiBG,uBAAuBF,IAGjD,KAAK3J,GAAcyJ,IACf,OAAO,IAAID,GAAaG,EAAc/B,GAC1C,KAAK5H,GAAc+H,IACf,OAAO,IAAIF,GAAa8B,EAAc/B,GAC1C,QACI,MAAM3J,GAAgCW,6BHrCtD,SAAY+I,GACVA,qBACAA,yBACAA,mBACAA,yBAJF,CAAYA,KAAAA,QAOZ,kBA4BE,WAAYmC,EACRtuC,gBAAAA,MAbI9H,WAAkBi0C,GAASoC,KAoB3B,IAAA1+B,kBAAA3S,kBACA2W,UAAA6R,uBACAlR,sBAAAg6B,gBAGJt2C,KAAKo2C,cAAgBA,EACrBp2C,KAAKgF,cAAgBA,EACrBhF,KAAKwtB,MAAQA,EACbxtB,KAAKs2C,kBAAoBA,EAyF/B,OAnFUC,uBAAR,SAAmB3rB,EAAoB4rB,EAAoBC,GACzD,KAAK7rB,EAAW5qB,KAAKwtB,QAAYxtB,KAAKs2C,mBAAqBG,GAA3D,CAGA,IACI3rB,EADE1lB,GAAY,IAAI4I,MAAO+L,cAM3B+Q,EAJG0b,GAAYiC,QAAQzoC,KAAKgF,eAItBI,EAAY,UAA+B6uC,GAASrpB,GAAY,IAAM4rB,EAHtEpxC,EAAY,IAAMpF,KAAKgF,cAAgB,UAA+BivC,GAASrpB,GAAY,IAAM4rB,EAKzGx2C,KAAK02C,gBAAgB9rB,EAAUE,EAAK2rB,KAMtCF,4BAAA,SAAgB/oB,EAAiBtkB,EAAiButC,GAC5Cz2C,KAAKo2C,eACPp2C,KAAKo2C,cAAc5oB,EAAOtkB,EAASutC,IAOvCF,kBAAA,SAAMrtC,GACJlJ,KAAKw2C,WAAWvC,GAASnwC,MAAOoF,GAAS,IAM3CqtC,qBAAA,SAASrtC,GACPlJ,KAAKw2C,WAAWvC,GAASnwC,MAAOoF,GAAS,IAM3CqtC,oBAAA,SAAQrtC,GACNlJ,KAAKw2C,WAAWvC,GAAS0C,QAASztC,GAAS,IAM7CqtC,uBAAA,SAAWrtC,GACTlJ,KAAKw2C,WAAWvC,GAAS0C,QAASztC,GAAS,IAM7CqtC,iBAAA,SAAKrtC,GACHlJ,KAAKw2C,WAAWvC,GAASoC,KAAMntC,GAAS,IAM1CqtC,oBAAA,SAAQrtC,GACNlJ,KAAKw2C,WAAWvC,GAASoC,KAAMntC,GAAS,IAM1CqtC,oBAAA,SAAQrtC,GACNlJ,KAAKw2C,WAAWvC,GAAS2C,QAAS1tC,GAAS,IAM7CqtC,uBAAA,SAAWrtC,GACTlJ,KAAKw2C,WAAWvC,GAAS2C,QAAS1tC,GAAS,IAG7CqtC,gCAAA,WACE,OAAOv2C,KAAKs2C,wBIpCVO,GAAoC,CACxCrT,SAAU,GACVsF,UAAW,KACXoL,mBAAmB,EACnBjN,YAAa,WAAM,OAAAR,GAASqQ,yBAC5BC,sBAAuB,WAAM,OAAAtQ,GAASqQ,yBACtCE,2BAA2B,GAGvBC,GAAsC,CAC1C7G,cAAe,iBACf8G,wBAAwB,GAGpBC,GAAwC,CAC5CzpB,OAAQ,IAAI6oB,GAAO,MACnBa,iBA/GoB,IAgHpBC,0BA/Ga,IAgHbC,kBA/G0B,KAkHtBC,GAA8C,CAClDC,WAAW,EACXC,qBAAsB,IAAI93C,MAC1B+3C,qBAAsB,IAAIC,KCnIrB,IAAMC,GACU,CACf5uC,KAAM,qBACNsgC,KAAM,sCAHDsO,GAKW,CAChB5uC,KAAM,uCASV,WAAYugC,EAAmBC,GAA/B,MACInmB,YAAMkmB,EAAWC,gBACjBlmB,EAAK3e,KAAO,cAEZnF,OAAOC,eAAe6jB,EAAMu0B,EAAY33C,aAYhD,OAlBiCqjB,OAStBs0B,+BAAP,WACI,OAAO,IAAIA,EAAYD,GAAqC5uC,KACxD4uC,GAAqCtO,OAGtCuO,2BAAP,SAAgC3N,GAC5B,OAAO,IAAI2N,EAAYD,GAAsC5uC,KACzDkhC,OAhBqBT,ICbpBqO,GACY,CACjB9uC,KAAM,wBAFD8uC,GAIQ,CACb9uC,KAAM,oBALD8uC,GAOM,CACX9uC,KAAM,iCASV,WAAYugC,EAAmBC,GAA/B,MACInmB,YAAMkmB,EAAWC,gBACjBlmB,EAAK3e,KAAO,+BAEZnF,OAAOC,eAAe6jB,EAAMy0B,EAA6B73C,aAwBjE,OA9BkDqjB,OASvCw0B,6BAAP,SAAkCC,GAC9B,IAAMC,EAA2B,CAC7BH,GAAwD9uC,KACxD8uC,GAAoD9uC,KACpD8uC,GAAkD9uC,MAGtD,OAAOgvC,GAAeC,EAAyBhtC,QAAQ+sC,IAAgB,GAGpED,+BAAP,SAAoC7N,GAChC,OAAO,IAAI6N,EAA6BD,GAAkD9uC,KAAMkhC,IAG7F6N,qCAAP,SAA0C7N,GACtC,OAAO,IAAI6N,EAA6BD,GAAwD9uC,KAAMkhC,IAGnG6N,iCAAP,SAAsC7N,GAClC,OAAO,IAAI6N,EAA6BD,GAAoD9uC,KAAMkhC,OA5BxD2N,aCAlCK,GAAuBlvB,GACnC,MAAO,CACHyqB,SAAU,GACVlQ,SAAU,GACV4U,UAAW,GACXhP,QAAS,KACT0J,cAAe,KACf5Y,YAAa,GACbtxB,OAAQ,KACR6qC,UAAW,KACX9G,QAAS,KACT0L,aAAcpvB,GC/Bf,IACMqvB,GAAiB,aACjBC,GAAiB,aACjBC,GAAoB,eAEpBC,GAA8B,CACvCC,6BAA8B,gCAC9BC,sBAAuB,oBACvBC,iBAAkB,cAClBC,qBAAsB,4BACtBC,2BAA4B,mCAC5BC,gCAAiC,kCACjCC,eAAgB,qBAChBC,0BAA2B,GAC3BC,wBAAyB,+BACzBC,wBAAyB,+BACzBC,oBAAqB,2BACrBC,8BAA+B,iCCkBtBC,GAAyB,SAAC7Q,GAA2B,MDnCjC,SCmCwDA,GAAU,oBC5B/F,WAAYvQ,EAA6BjzB,EAAuBw+B,EAAkB8V,GAAlF,MACIj2B,YAAMg2B,GAAuB,iBAAkBr0C,gBAC/Cse,EAAKN,MAAMq2B,GAAuB,cAAgB7V,EAClDlgB,EAAKN,MAAMq2B,GAAuB,gBAAkBphB,EAASshB,IAC7Dj2B,EAAKN,MAAMq2B,GAAuB,gBAAkBphB,EAASuhB,WAC7Dl2B,EAAKN,MAAMq2B,GAAuB,qBAAuBphB,EAASkU,gBAClE7oB,EAAKN,MAAMq2B,GAAuB,wBAA0BphB,EAASmU,mBACrE9oB,EAAKN,MAAM,GAAGw1B,GAA2BY,+BAAmC91B,EAAKm2B,cAAcJ,GAAuB,YAAaC,GACnIh2B,EAAKN,MAAM,GAAGw1B,GAA2BM,iCAAqCx1B,EAAKm2B,cAAcJ,GAAuB,cAAeC,GACvIh2B,EAAKN,MAAM,GAAGw1B,GAA2BK,4BAAgCv1B,EAAKm2B,cAAcJ,GAAuB,eAAgBC,KAU3I,OArB0C/1B,OAe9Bm2B,0BAAR,SAAsBC,EAAmBL,GACrC,OAAKA,EAAWK,GAGTL,EAAWK,GAFP,iBCPf,WAAYA,EAAmB30C,SAE3BhF,KAAK45C,eAAiB5rC,KAAKmsB,MAC3Bn6B,KAAK65C,QAAUvV,GAAYiI,gBAC3BvsC,KAAKgjB,cACAq2B,GAAuBhB,KAAkBsB,EAC1ChiC,EAAC0hC,GAAuBf,KAAkBt4C,KAAK45C,eAC/CjiC,EAAC0hC,GAAuBd,MAAqB,EAC7C5gC,EAAC,GAAG6gC,GAA2BC,8BAAiCzzC,KA+B5E,OA3BY80C,2BAAR,SAAuBC,GACnB/5C,KAAKgjB,MAAMq2B,GAAuBd,KAAqBwB,GAGpDD,iBAAP,WAEI95C,KAAKg6C,gBAAgBhsC,KAAKmsB,OAASn6B,KAAK45C,iBAG5Cp6C,sBAAWs6C,0CAAX,WACI,OAAO95C,KAAKgjB,MAAM,GAAGw1B,GAA2BC,mCAGpD,SAAkCl3C,GAC9BvB,KAAKgjB,MAAM,GAAGw1B,GAA2BC,8BAAkCl3C,mCAG/E/B,sBAAWs6C,6BAAX,WACI,OAAO95C,KAAKgjB,MAAMq2B,GAAuBhB,sCAGtCyB,gBAAP,WACI,YACO95C,KAAKgjB,OACR62B,QAAS75C,KAAK65C,iBCnCpBI,GAAiB,SAACj3B,GAAkC,OACnDA,EAAMk3B,2BAA0Bl3B,EAAM62B,YAAW72B,EAAM22B,yBAkB1D,WAAY1N,EAAyBI,GAZ7BrsC,qBAAmC,GAEnCA,sBAAqC,GAErCA,+BAAuD,GAGvDA,+BAAoC,EAOxCA,KAAKm6C,kBAAoBlO,EAAOhU,SAChCj4B,KAAKwjC,SAAWyI,EAAOzI,SACvBxjC,KAAKo6C,yBAA2BnO,EAAOmO,yBAIvCp6C,KAAKqsC,iBAAmBA,EAuFhC,OApFIgO,uBAAA,SAAWr3B,GACP,GAAKhjB,KAAKqsC,iBAAV,CAGA,IAAMiO,EAAWL,GAAej3B,GAChChjB,KAAKu6C,iBAAiBD,GAAYt3B,IAGtCq3B,sBAAA,SAAUr3B,GACN,IAAMs3B,EAAWL,GAAej3B,GAChC,GAAKhjB,KAAKqsC,kBAAqBrsC,KAAKu6C,iBAAiBD,GAArD,CAGAt3B,EAAMw3B,OACNx6C,KAAKy6C,oBAAoBz3B,GAEzB,IAAM03B,EAAkB16C,KAAK06C,gBAAgB13B,EAAMk3B,wBAEnDl6C,KAAK06C,gBAAgB13B,EAAMk3B,yBAA+BQ,GAAmB,YAAK13B,WAE3EhjB,KAAKu6C,iBAAiBD,KAGjCD,kBAAA,SAAMr1C,GAAN,WAGI,GAAKhF,KAAKqsC,kBAAqBrsC,KAAK06C,gBAAgB11C,GAApD,CAIA,IAAM21C,EAAiB36C,KAAK46C,kBAAkB51C,GAC9C21C,EAAe9tC,QAAQ,SAAAmW,GAAS,OAAAM,EAAKm3B,oBAAoBz3B,KACzD,IAAM63B,EACC76C,KAAK06C,gBAAgB11C,UACrB21C,UAGA36C,KAAK06C,gBAAgB11C,GAC5B,IAAM81C,EAAiC96C,KAAK+6C,0BAA0B/1C,GAKtE,UAHOhF,KAAK+6C,0BAA0B/1C,GAGjC61C,GAAkBA,EAAcl6C,OAArC,CAIA,IAAMq6C,EAA6B,IAAItB,GACnC15C,KAAKm6C,kBACLn1C,EACAhF,KAAKwjC,SACLsX,GAGEG,EAA8BJ,UAAeG,IAEnDh7C,KAAKqsC,iBAAiB4O,EAAuBhvB,IAAI,SAAAvqB,GAAK,OAAAA,EAAEqgB,YAGpDs4B,gCAAR,SAA4Br3B,SAGlB22B,EAAY32B,EAAM22B,UAClBL,EAAat5C,KAAK+6C,0BAA0B/3B,EAAMk3B,wBACnDZ,EAKDA,EAAWK,GAAaL,EAAWK,GAAaL,EAAWK,GAAa,EAAI,EAJ5E35C,KAAK+6C,0BAA0B/3B,EAAMk3B,gCAChCP,GAAY,MAOjBU,8BAAR,SAA0Br1C,GAA1B,WACI,OAAOxF,OAAO4K,KAAKpK,KAAKu6C,kBACnBlwC,OAAO,SAAC6wC,EAAMZ,GACX,IAAyC,IAArCA,EAASrvC,QAAQjG,GAAuB,CACxC,IAAMm2C,EAAQ73B,EAAKi3B,iBAAiBD,GAEpC,cADOh3B,EAAKi3B,iBAAiBD,GAClBY,UAAMC,IAErB,OAAOD,GACR,UC7FTE,GAAoB,2CA2BpBC,GACM,WADNA,GAEG,QAFHA,GAGY,iBAyDZC,GAAgC,SAAC50C,EAAa60C,EAAqBC,GACvE,IAAMC,EAAyBD,EAAWj6C,MAQ1C,OAPAi6C,EAAWj6C,MAAQ,eAAU,aAAA8Z,mBAAAA,IAAAsR,kBACzB,OAAO3sB,KAAK07C,aACN,IAAIv6C,QAAQ,cAGZs6C,EAAuB56C,MAAMb,KAAM2sB,IAEtC6uB,iBAsFP,WAAYG,GAxEJ37C,0BAA6C,KAC7CA,2BAA+C,KAC/CA,2BAA+C,KAyErDA,KAAKisC,gBTtE0Bt0B,OAAEikC,SAAMjgC,UAAAhV,kBAAY2V,WAAAu/B,kBAAa59B,cAAA69B,kBAOlE,MANuC,CACrCF,UAAW/E,GAAyB+E,GACpCj1C,WAAYswC,GAA0BtwC,GACtCk1C,YAAa1E,GAA2B0E,GACxCC,eAAgBvE,GAA8BuE,ISiEhCC,CAAmBJ,GAGjC37C,KAAKg8C,sBAAuB,EAE5Bh8C,KAAK0tB,OAAS1tB,KAAKisC,OAAO4P,OAAOnuB,OACjC1tB,KAAKwjC,SAAWxjC,KAAKisC,OAAO2P,KAAKpY,SACjCxjC,KAAKi8C,SAAWj8C,KAAKisC,OAAOtlC,MAAMuwC,uBAElCl3C,KAAKk8C,iBAAmBl8C,KAAKm8C,8BAA8Bn8C,KAAKisC,OAAO4P,OAAOO,UAAWp8C,KAAKwjC,UAG9FxjC,KAAK8oC,UAAY9oC,KAAKisC,OAAO2P,KAAK9S,WAAasS,GAG/Cp7C,KAAKq8C,iBAAkB,EACvBr8C,KAAKs8C,wBAAyB,EAG9B,IACEt8C,KAAKu8C,aAAe,IAAIlM,GAAQrwC,KAAKisC,OAAOtlC,MAAMypC,eAClD,MAAO1uC,GACL,MAAMgqC,GAAyB8Q,sCAAsCx8C,KAAKisC,OAAOtlC,MAAMypC,eAI3F78B,OAAOkpC,cAAgB,GACvBlpC,OAAOmpC,eAAiB,GACxBnpC,OAAOopC,YAAc,GACrBppC,OAAOqpC,4BAA8B,GACrCrpC,OAAOspC,2BAA6B,GACpCtpC,OAAOu+B,KAAO9xC,KAEd,IAAM88C,EAAUvpC,OAAOk0B,SAASsV,KAC1BC,EAAkBh9C,KAAKg9C,gBAAgBF,GAGxC98C,KAAKisC,OAAO6P,UAAUtE,WACrBwF,GACFh9C,KAAKi9C,6BAA6BH,GAogE1C,OAzlEEt9C,sBAAW09C,6BASX,WACE,OAAOl9C,KAAK6mC,kBAAkB4F,wBAVhC,SAAqBzhC,GACnBhL,KAAK6mC,kBAAoBmP,GAAiBmH,eAAenyC,EAAKhL,KAAKisC,OAAO2P,KAAK1H,oDAiB1EgJ,iCAAP,WACE,OAAOl9C,KAAK6mC,mBAkFdqW,mCAAA,SAAuBE,EAAmEC,GACxF,IAAKD,EAEH,MADAp9C,KAAKg8C,sBAAuB,EACtBtQ,GAAyB4R,iCAAiCF,GAelE,GAXIC,GACFr9C,KAAKu9C,sBAAwBH,EAC7Bp9C,KAAKq9C,sBAAwBA,EAC7Br9C,KAAK0tB,OAAOM,QAAQ,kKAEpBhuB,KAAKw9C,qBAAuBJ,EAG9Bp9C,KAAKg8C,sBAAuB,GAGvBh8C,KAAKisC,OAAO6P,UAAUtE,UAAW,CACpC,IAAMiG,EAAaz9C,KAAKu8C,aAAa1L,QAAQv8B,GAAUwoC,SACnDW,GACFz9C,KAAK09C,gBAAgBD,EAAY,QAK/BP,gCAAR,SAA4BS,EAAkC1nC,EAAwB7U,GACpF,GAAIu8C,IAAoBrpC,GAAUspC,wBAC5B59C,KAAKq9C,sBACPr9C,KAAKu9C,sBAAsBtnC,GAClBjW,KAAKw9C,sBACdx9C,KAAKw9C,qBAAqB,KAAMvnC,OAE7B,CAAA,GAAI0nC,IAAoBrpC,GAAUupC,qBAGvC,MAAMjU,GAAgBkU,oCAFtB18C,EAAQ6U,KAMJinC,6BAAR,SAAyBS,EAAkCI,EAAoB9nC,EAAwB5U,GACrG,GAAIs8C,IAAoBrpC,GAAUspC,wBAC5B59C,KAAKq9C,sBACPr9C,KAAKq9C,sBAAsBU,EAAS9nC,EAASmiC,cAE7Cp4C,KAAKw9C,qBAAqBO,EAAS9nC,OAEhC,CAAA,GAAI0nC,IAAoBrpC,GAAUupC,qBAGvC,MAAMjU,GAAgBkU,oCAFtBz8C,EAAO08C,KAWXb,0BAAA,SAAc5mC,GAEZ,IAAKtW,KAAKg8C,qBACR,MAAMtQ,GAAyBsS,qCAEjCh+C,KAAKi+C,wBAAwB3pC,GAAUspC,yBAAyB,EAAMtnC,IASxE4mC,iCAAA,SAAqB5mC,GACnB,IAAKA,EACH,MAAMo1B,GAAyBwS,0BAIjC,IAAKl+C,KAAKg8C,qBACR,MAAMtQ,GAAyBsS,qCAEjCh+C,KAAKi+C,wBAAwB3pC,GAAUspC,yBAAyB,EAAOtnC,IAUzE4mC,uBAAA,SAAW5mC,GAAX,WACE,OAAO,IAAInV,QAAsB,SAACC,EAASC,GACzCiiB,EAAK26B,wBAAwB3pC,GAAUupC,sBAAsB,EAAMvnC,EAASlV,EAASC,MAWzF67C,8BAAA,SAAkB5mC,GAAlB,WACE,IAAKA,EACH,MAAMo1B,GAAyBwS,0BAGjC,OAAO,IAAI/8C,QAAsB,SAACC,EAASC,GACzCiiB,EAAK26B,wBAAwB3pC,GAAUupC,sBAAsB,EAAOvnC,EAASlV,EAASC,MAalF67C,oCAAR,SAAgCS,EAAkCQ,EAAsB7nC,EAAoClV,EAAeC,GAA3I,WAGE,GAAIrB,KAAKq8C,iBAAmBr8C,KAAKs8C,uBAAjC,CACE,IAAM8B,EAAcp+C,KAAKq8C,gBAAkBzS,GAAgByU,6BAA+BzU,GAAgB0U,oCACpGC,EAAoBrG,GAAuBl4C,KAAKw+C,gBAAgBloC,GAAWA,EAAQ0S,QACzFhpB,KAAKy+C,iBAAiBd,EACpBS,EACAG,EACAl9C,OANJ,CAWA,IAAMsH,EAAwBw1C,EAAcn+C,KAAK0+C,aAAapoC,GAAWA,EAAQ3N,OAGjF3I,KAAK2+C,mBAAmBh2C,GAASw1C,GAGjC,IAAMzR,EAAoBp2B,GAAWA,EAAQo2B,UAAYyR,EAAe7nC,EAAQo2B,QAAU1sC,KAAK4+C,aAG/F,GAAKlS,GAAYF,GAAwBU,WAAW52B,GAsClDtW,KAAK6+C,mBAAmBnS,EAASiR,EAAiBQ,EAAa7nC,EAAS3N,EAAQvH,EAASC,OAtC7B,CAC5D,IAAI88C,EAgCF,MADAn+C,KAAK0tB,OAAOK,KAAK,0BACX6b,GAAgBkV,+BA3BtB,GAHkB9+C,KAAK++C,uBAGHp2C,EAAQ,CAC1B3I,KAAK0tB,OAAOK,KAAK,4EACjB,IAAIixB,EAAyCh/C,KAAKi/C,oBAAoB3oC,GAEtEtW,KAAKk/C,aAAc,EACnBl/C,KAAKm/C,mBAAmBH,GAAcl9C,KAAK,SAAAmU,GACzCqN,EAAK47B,aAAc,EACnB57B,EAAKoK,OAAOK,KAAK,oCAEjBzK,EAAK87B,oBAAoBzB,EAAiB1nC,EAAU7U,IAEnD,SAACqC,GACF6f,EAAK47B,aAAc,EACnB57B,EAAKoK,OAAOjqB,MAAM,4CAA8CA,GAGhE6f,EAAKu7B,mBAAmB,KAAMlB,EAAiBQ,EAAa7nC,EAAS3N,EAAQvH,EAASC,UAKxFrB,KAAK6+C,mBAAmB,KAAMlB,EAAiBQ,EAAa7nC,EAAS3N,EAAQvH,EAASC,MAqBtF67C,+BAAR,SAA2BxQ,EAAkBiR,EAAkCQ,EAAsB7nC,EAAoC3N,EAAwBvH,EAAeC,GAAhL,WAEM88C,EACFn+C,KAAKq8C,iBAAkB,EAEvBr8C,KAAKs8C,wBAAyB,EAGhC,IAEI+C,EAGAC,EALEzb,EAAQl7B,EAASA,EAAO5D,KAAK,KAAKiN,cAAgBhS,KAAKwjC,SAASxxB,cAGhEutC,GAA0BpB,GAAe7nC,GAAWA,EAAQwyB,UAAakN,GAAiBmH,eAAe7mC,EAAQwyB,UAAW9oC,KAAKisC,OAAO2P,KAAK1H,mBAAqBl0C,KAAK6mC,mBAGzK8W,IAAoBrpC,GAAUupC,uBAEhCyB,EAAct/C,KAAKw/C,WAAW,cAAe,SAAU,EAAGx/C,KAAMoB,EAASC,MAO3Ek+C,EAAsBE,wBAAwB39C,KAAK,WAEjD,IACI49C,EADEp6B,EAAuB64B,EAAc9C,GAAyB/3B,EAAKq8B,aAAajT,EAAS/jC,GAAQ,GAGnGw1C,KAEFuB,EAAiBp8B,EAAKi5B,aAAa1L,QAAQv8B,GAAUsrC,uBACX,KAAnBF,EAGrBp8B,EAAKi5B,aAAa7L,QAAQp8B,GAAUsrC,oBAAqB,IAFzDF,EAAiBnsC,OAAOk0B,SAASC,MAMrC2X,EAA8B,IAAI7S,GAChC+S,EACAj8B,EAAKkgB,SACL76B,EACA2c,EACAhC,EAAKu8B,iBACLvpC,GAAWA,EAAQ0S,OAGrB1F,EAAKw8B,mBAAmBT,EAA6B3S,EAASgT,GAG9DL,EAA4BU,oBAAoBrT,EAASp2B,GAGzD,IAAI0pC,EAAcvZ,GAASwZ,kBAAkBZ,GAA+B/qC,GAAU4rC,uBAGtF,GAAIvC,IAAoBrpC,GAAUspC,wBAC3BO,GACH76B,EAAKi5B,aAAa7L,QAAQp8B,GAAUo9B,kBAAmB2N,EAA4Br2B,MAAO1F,EAAK24B,cAE5F,CAAA,GAAI0B,IAAoBrpC,GAAUupC,qBAOvC,MAAMjU,GAAgBkU,oCANtBvqC,OAAOopC,YAAYz5C,KAAKm8C,EAA4Br2B,OACpDzV,OAAO4sC,YAAchC,EAAc7pC,GAAU8rC,MAAQ9rC,GAAU+rC,WAG/D/8B,EAAKg9B,iBAAiBjB,EAA4Br2B,MAAO6a,EAAOziC,EAASC,GAM3EiiB,EAAKi9B,eAAeP,EAAaV,KAChC7qB,MAAM,SAAC3rB,GACRwa,EAAKoK,OAAOM,QAAQ,+BACpB1K,EAAKm7B,iBAAiBd,EAAiB/T,GAAgB4W,8BAA8B13C,EAAIgB,UAAWouC,GAAuB5hC,EAAQ0S,OAAQ3nB,GACvIi+C,GACFA,EAAYmB,WAkBlBvD,+BAAA,SAAmB5mC,GADnB,WAEE,IAAKA,EACH,MAAMo1B,GAAyBwS,0BAEjC,OAAO,IAAI/8C,QAAsB,SAACC,EAASC,GAGzCiiB,EAAKq7B,mBAAmBroC,EAAQ3N,QAAQ,GAExC,IAAMk7B,EAAQvtB,EAAQ3N,OAAO5D,KAAK,KAAKiN,cAGjC06B,EAAmBp2B,EAAQo2B,SAAWppB,EAAKs7B,aAG3C8B,EAAcp9B,EAAKi5B,aAAa1L,QAAQv8B,GAAUosC,aAGxD,IAAKhU,IAAap2B,EAAQs3B,MAAQt3B,EAAQw3B,WAActH,GAAYiC,QAAQiY,GAE1E,OADAp9B,EAAKoK,OAAOK,KAAK,0BACV1sB,EAAOuoC,GAAgBkV,gCAGhC,IAAMx5B,EAAehC,EAAKq8B,aAAajT,EAASp2B,EAAQ3N,QAAQ,GAE5D02C,EAA8B,IAAI7S,GACpCwJ,GAAiBmH,eAAe7mC,EAAQwyB,UAAWxlB,EAAK2oB,OAAO2P,KAAK1H,mBACpE5wB,EAAKkgB,SACLltB,EAAQ3N,OACR2c,EACAhC,EAAKu8B,iBACLvpC,GAAWA,EAAQ0S,OAGrB,GAAIwjB,GAAwBU,WAAW52B,IAAYo2B,EACjD2S,EAA4BU,oBAAoBrT,EAASp2B,QAGtD,IAAKo2B,IAAYlG,GAAYiC,QAAQiY,GAAc,CAEtD,IAAM/T,EAAoBqC,GAAWY,eAAe8Q,GACpDp9B,EAAKoK,OAAOI,QAAQ,4EACpBuxB,EAA4BU,oBAAoBrT,EAAS,KAAMC,GAEjE,IAEIoR,EACA4C,EAHEC,EAAsBtqC,EAAQy2B,eAAiBsS,EAA4B/X,YAKjF,IAAKsZ,IAAwBtqC,EAAQuqC,aACnC,IACEF,EAAsBr9B,EAAKmX,eAAe4kB,EAA6B3S,GACvE,MAAOhrC,GACPq8C,EAAUr8C,EAKd,GAAIi/C,EAGF,OAFAr9B,EAAKoK,OAAOK,KAAK,uCAAyC8V,GAC1DziC,EAAQu/C,GACD,KAEJ,GAAI5C,EAGP,OAFAz6B,EAAKoK,OAAOozB,QAAQ/C,EAAQxU,UAAY,IAAMwU,EAAQvU,cACtDnoC,EAAO08C,GACA,KAIP,IAAIvH,SAeJ,OAbEA,EADEoK,EACW,gDACJtqC,EAAQuqC,aACJ,yEAEA,mCAAqChd,EAEpDvgB,EAAKoK,OAAOI,QAAQ0oB,GAGf6I,EAA4BxY,oBAC7BwY,EAA4BxY,kBAAoBvwB,EAAQwyB,UAAYkN,GAAiBmH,eAAe7mC,EAAQwyB,UAAWxlB,EAAK2oB,OAAO2P,KAAK1H,mBAAqB5wB,EAAKujB,mBAG/JwY,EAA4BxY,kBAAkB4Y,wBACpD39C,KAAK,WAGAyR,OAAOmpC,eAAe7Y,IACxBvgB,EAAKoK,OAAOI,QAAQ,0BAA4B+V,EAAQ,yCAExDvgB,EAAKg9B,iBAAiB/sC,OAAOmpC,eAAe7Y,GAAQA,EAAOziC,EAASC,IAGhEiV,EAAQ3N,QAAU2N,EAAQ3N,OAAOsC,QAAQqY,EAAKkgB,WAAa,GAA+B,IAA1BltB,EAAQ3N,OAAOhI,QAGjF2iB,EAAKoK,OAAOI,QAAQ,oBACpBxK,EAAK47B,aAAc,EACnB57B,EAAKy9B,aAAazqC,EAAQ3N,OAAQvH,EAASC,EAAQqrC,EAAS2S,KAG5D/7B,EAAKoK,OAAOI,QAAQ,wBACpBxK,EAAK+8B,WAAW/pC,EAAQ3N,OAAQvH,EAASC,EAAQqrC,EAAS2S,MAG7D5qB,MAAM,SAAC3rB,GAGR,OAFAwa,EAAKoK,OAAOM,QAAQ,+BACpB3sB,EAAOuoC,GAAgB4W,8BAA8B13C,EAAIgB,aAClD,UAwBPozC,uBAAR,SAAmB8C,EAAqBgB,EAAeC,EAAkB1jC,EAAgBnc,EAAoBC,GAA7G,IAEM6/C,SACJ,IACEA,EAAclhD,KAAKmhD,UAAUnB,EAAagB,EAAO1sC,GAAU8sC,WAAY9sC,GAAU+sC,aACjF,MAAO3/C,GAUP,OATA6b,EAAS8+B,iBAAkB,EAC3B9+B,EAAS++B,wBAAyB,EAElCt8C,KAAK0tB,OAAOK,KAAK4b,GAAwC3gC,KAAO,IAAM2gC,GAAwCL,MAC9GtpC,KAAKu8C,aAAa7L,QAAQp8B,GAAUgtC,UAAW3X,GAAwC3gC,MACvFhJ,KAAKu8C,aAAa7L,QAAQp8B,GAAUitC,qBAAsB5X,GAAwCL,MAC9FjoC,GACFA,EAAOuoC,GAAgB4X,0BAElB,KAITjuC,OAAOkpC,cAAcv5C,KAAKg+C,GAE1B,IAAMO,EAAYluC,OAAOmuC,YAAY,WAEnC,GAAIR,GAAeA,EAAYS,SAAWpkC,EAAS8+B,iBAAmB9+B,EAAS++B,wBAAyB,CAKtG,GAJIj7C,GACFA,EAAOuoC,GAAgBgY,4BAEzBruC,OAAOsuC,cAAcJ,GACjBn+B,EAAK2oB,OAAO6P,UAAUtE,UAEtB,YADAl0B,EAAKw+B,UAAU,mBAAoBnY,GAA0C3gC,KAAOsL,GAAU+8B,kBAAoB1H,GAA0CL,MAGhK/rB,EAAS8+B,iBAAkB,EAC3B9+B,EAAS++B,wBAAyB,EAGpC,IACE,IAAMyF,EAAsBb,EAAYzZ,SAGxC,IAAiE,IAA7Dsa,EAAoBra,KAAKz8B,QAAQqY,EAAKu8B,oBACxCtsC,OAAOsuC,cAAcJ,GACrBlkC,EAAS8+B,iBAAkB,EAC3B9+B,EAAS++B,wBAAyB,EAClCh5B,EAAKoK,OAAOK,KAAK,wBAEbzK,EAAK2oB,OAAO6P,UAAUtE,WAAW,CACjCl0B,EAAKw+B,UAAU,wBAAyBC,EAAoBhF,MAC5D,IAAK,IAAIv8C,EAAI,EAAGA,EAAI+S,OAAOkpC,cAAc97C,OAAQH,IAC7C+S,OAAOkpC,cAAcj8C,GAAGigD,SAIlC,MAAO/+C,MAMXu/C,GAEA,OAAOC,GAeDhE,sBAAR,SAAkB8C,EAAqBgB,EAAeI,EAAoBC,GACxE,IAKE,IAAMW,EAAUzuC,OAAO0uC,WAAa1uC,OAAO0uC,WAAa1uC,OAAO2uC,QACzDC,EAAS5uC,OAAO6uC,UAAY7uC,OAAO6uC,UAAY7uC,OAAO8uC,QAKtDnd,EAAQ3xB,OAAO+uC,YAAclyB,SAASmyB,gBAAgBC,aAAepyB,SAASpuB,KAAKwgD,YACnFpd,EAAS7xB,OAAOkvC,aAAeryB,SAASmyB,gBAAgBG,cAAgBtyB,SAASpuB,KAAK0gD,aACtFC,EAASzd,EAAQ,EAAMkc,EAAa,EAAMY,EAC1CY,EAAQxd,EAAS,EAAMic,EAAc,EAAMc,EAG3CjB,EAAc3tC,OAAO6R,KAAK46B,EAAagB,EAAO,SAAWI,EAAa,YAAcC,EAAc,SAAWuB,EAAM,UAAYD,GACrI,IAAKzB,EACH,MAAMtX,GAAgB4X,yBAMxB,OAJIN,EAAY2B,OACd3B,EAAY2B,QAGP3B,EACP,MAAOx/C,GAIP,MAHA1B,KAAK0tB,OAAOjqB,MAAM,uBAAyB/B,EAAEwH,SAC7ClJ,KAAKq8C,iBAAkB,EACvBr8C,KAAKs8C,wBAAyB,EACxB1S,GAAgB4X,uBAAuB9/C,EAAEoI,cAa5CozC,uBAAP,WACI,OAAO3pC,OAAOhL,SAAWgL,QAOrB2pC,yBAAR,WACE,OAAO3pC,OAAOhL,SAAWgL,QAAUA,OAAOhL,OAAOupC,MAS3CoL,8BAAR,SAA0B8C,EAAqB8C,EAAmBjf,GAAlE,WAEQkf,EAAgBxvC,OAAOmpC,eAAe7Y,GAC5C7jC,KAAK0tB,OAAOI,QAAQ,qCAAuC+V,EAAQ,IAAMkf,GACzE/iD,KAAKu8C,aAAa7L,QAAQp8B,GAAUk9B,YAAcuR,EAAezuC,GAAUu9B,4BAC3E7xC,KAAKgjD,UAAUhD,EAAa8C,GAC5BjsC,WAAW,WACLyM,EAAKi5B,aAAa1L,QAAQv8B,GAAUk9B,YAAcuR,KAAmBzuC,GAAUu9B,6BAEjFvuB,EAAKoK,OAAOI,QAAQ,sCAAyCxK,EAAK2oB,OAAO4P,OAAOzE,iBAAmB,IAAQ,sBAAwBvT,EAAQ,IAAMkf,GAE7IA,GAAiBxvC,OAAOqpC,4BAA4BmG,IACtDxvC,OAAOqpC,4BAA4BmG,GAAe,KAAMnZ,GAAgBqZ,kCAG1E3/B,EAAKi5B,aAAa7L,QAAQp8B,GAAUk9B,YAAcuR,EAAezuC,GAAU4uC,6BAE5EljD,KAAKisC,OAAO4P,OAAOzE,mBAQhB8F,sBAAR,SAAkB8C,EAAqB8C,GAAvC,WAGE9iD,KAAK0tB,OAAOK,KAAK,cAAgB+0B,GACjC,IAAMK,EAAaL,EAEnBjsC,WAAW,WACT,IAAMusC,EAAc9/B,EAAK+/B,gBAAgBF,GACjB,KAApBC,EAAYE,KAAkC,gBAApBF,EAAYE,MACxCF,EAAYE,IAAMtD,EAClB18B,EAAKoK,OAAOozB,QAAQ,gBAAkBgC,EAAY,kBAAoB9C,KAG1EhgD,KAAKisC,OAAO4P,OAAOvE,oBAQb4F,4BAAR,SAAwBqG,GACtB,QAAwB,IAAbA,EACT,OAAO,KAGTvjD,KAAK0tB,OAAOK,KAAK,8BAAgCw1B,GACjD,IAAIC,EAAYpzB,SAASqzB,eAAeF,GACxC,IAAKC,EAAW,CACd,GAAIpzB,SAASwC,eACXxC,SAASmyB,kBAC4C,IAApDhvC,OAAOmkB,UAAUyG,UAAUlzB,QAAQ,YAAqB,CACzD,IAAMy4C,EAAMtzB,SAASwC,cAAc,UACnC8wB,EAAIt7C,aAAa,KAAMm7C,GACvBG,EAAIC,MAAMC,WAAa,SACvBF,EAAIC,MAAME,SAAW,WACrBH,EAAIC,MAAMze,MAAQwe,EAAIC,MAAMve,OAAS,IACrCse,EAAIC,MAAMG,OAAS,IACnBN,EAAapzB,SAASgB,qBAAqB,QAAQ,GAAGgC,YAAYswB,QACzDtzB,SAASpuB,MAAQouB,SAASpuB,KAAK+hD,oBACtC3zB,SAASpuB,KAAK+hD,mBAAmB,YAAa,iBAAmBR,EAAW,SAAWA,EAAW,oCAGlGhwC,OAAOywC,QAAUzwC,OAAOywC,OAAOT,KACjCC,EAAYjwC,OAAOywC,OAAOT,IAI9B,OAAOC,GAYDtG,2BAAR,SAAuB8C,EAAqBkB,GAE1C,IAAIlB,GAAgBxZ,GAAYiC,QAAQuX,GAQtC,MADAhgD,KAAK0tB,OAAOK,KAAK,yBACX0b,GAAUwa,sBAAsB,yBAPtC,IAAI1D,EAAyBW,GAA4B3tC,OACrDijC,EAAqB0K,EAAc,6BAA+BlB,EAAc,eAAiBA,EACrGhgD,KAAK0tB,OAAOozB,QAAQtK,GACpB+J,EAAe9Y,SAASh8B,QAAQu0C,IAiB5B9C,6BAAR,SAAyB6F,EAAuBlf,EAAeziC,EAAmBC,GAAlF,WAEEkS,OAAOmpC,eAAe7Y,GAASkf,EAG1BxvC,OAAOspC,2BAA2BkG,KACnCxvC,OAAOspC,2BAA2BkG,GAAiB,IAGvDxvC,OAAOspC,2BAA2BkG,GAAe7/C,KAAK,CAAE9B,QAASA,EAASC,OAAQA,IAG7EkS,OAAOqpC,4BAA4BmG,KACtCxvC,OAAOqpC,4BAA4BmG,GACnC,SAAC9sC,EAAwBxS,GAEvB8P,OAAOmpC,eAAe7Y,GAAS,KAG/B,IAAK,IAAIrjC,EAAI,EAAGA,EAAI+S,OAAOspC,2BAA2BkG,GAAepiD,SAAUH,EAC7E,IACE,GAAIiD,EACA8P,OAAOspC,2BAA2BkG,GAAeviD,GAAGa,OAAOoC,OACxD,CAAA,IAAIwS,EAGT,MAAMwzB,GAAUwa,sBAAsB,oCAFpC1wC,OAAOspC,2BAA2BkG,GAAeviD,GAAGY,QAAQ6U,IAIhE,MAAOvU,GACP4hB,EAAKoK,OAAOM,QAAQtsB,GAKxB6R,OAAOspC,2BAA2BkG,GAAiB,KACnDxvC,OAAOqpC,4BAA4BmG,GAAiB,QAa1D7F,mBAAA,WAAA,WACEl9C,KAAKkkD,aACLlkD,KAAK0sC,QAAU,KACf,IAAIyX,EAAS,GACTnkD,KAAKokD,6BACPD,EAAS,4BAA8B1iC,mBAAmBzhB,KAAKokD,6BAEjEpkD,KAAK6mC,kBAAkB4Y,wBAAwB39C,KAAK,SAAAgnC,GAChD,IAAMkX,EAAclX,EAAUqM,mBACrBrM,EAAUqM,uBAAsBgP,EAChC7gC,EAAKwlB,gCAA+Bqb,EAC7C7gC,EAAKi9B,eAAeP,MAShB9C,uBAAV,WACE3pC,OAAOopC,YAAc,GAErB,IADA,IAAM0H,EAAmBrkD,KAAKu8C,aAAa+H,mBAAmBhwC,GAAUkvB,SAAUlvB,GAAU20B,uBACnFzoC,EAAI,EAAGA,EAAI6jD,EAAiB1jD,OAAQH,IAC3CR,KAAKu8C,aAAazL,WAAWvsC,KAAKG,UAAU2/C,EAAiB7jD,GAAG+J,MAElEvK,KAAKu8C,aAAagI,kBAClBvkD,KAAKu8C,aAAa5K,eASVuL,+BAAV,SAA6BjjB,GAE3B,IADA,IAAMoqB,EAAmBrkD,KAAKu8C,aAAa+H,mBAAmBhwC,GAAUkvB,SAAUlvB,GAAU20B,uBACnFzoC,EAAI,EAAGA,EAAI6jD,EAAiB1jD,OAAQH,IAAK,CAC9C,IAAIoI,EAAQy7C,EAAiB7jD,GACzBoI,EAAMrH,MAAM04B,cAAgBA,GAC5Bj6B,KAAKu8C,aAAazL,WAAWvsC,KAAKG,UAAUkE,EAAM2B,QAgB5D2yC,uBAAA,SAAWH,GAET,OADA/8C,KAAK0tB,OAAOK,KAAK,8EACV/tB,KAAKg9C,gBAAgBD,IAGtBG,4BAAR,SAAwBsH,GACtB,IAAMC,EAAazkD,KAAK0kD,gBAAgBF,GACxC,OACEC,EAAW5kD,eAAeyU,GAAUnQ,mBACpCsgD,EAAW5kD,eAAeyU,GAAU7Q,QACpCghD,EAAW5kD,eAAeyU,GAAU2lB,cACpCwqB,EAAW5kD,eAAeyU,GAAU60B,UAShC+T,4BAAR,SAAwBH,EAAc4H,EAA8BC,GAOlE,IAAI3uC,EACA8nC,EAPJ/9C,KAAK0tB,OAAOK,KAAK,kDAEZ42B,IACHA,EAAY3kD,KAAK6kD,iBAAiB9H,IAMpC,IACE9mC,EAAWjW,KAAK8kD,kBAAkB/H,EAAM4H,GACxC,MAAO77C,GACPi1C,EAAUj1C,EAIZ9I,KAAKu8C,aAAazL,WAAWx8B,GAAUwoC,SAEvC,IAEE98C,KAAKu8C,aAAa5K,cAClB,IAAMyG,EAAuBp4C,KAAKw+C,gBAAgBmG,EAAU37B,OAC5D,GAAI/S,GAYF,GAXK0uC,EAAUxE,cAAgB7rC,GAAU+rC,YAAepqC,EAASgkB,aAC3D1mB,OAAOhL,SAAWgL,OACpBvT,KAAK0tB,OAAOI,QAAQ,iDAEpB9tB,KAAK0tB,OAAOI,QAAQ,2CAEtB7X,EAASkiC,UAAY7jC,GAAU2lB,aAExB0qB,EAAUxE,cAAgB7rC,GAAU8rC,QAC3CnqC,EAASkiC,UAAY7jC,GAAU60B,UAE5Byb,EAEH,YADA5kD,KAAKo/C,oBAAoB9qC,GAAUspC,wBAAyB3nC,QAGzD,IAAK2uC,EAEV,YADA5kD,KAAKy+C,iBAAiBnqC,GAAUspC,wBAAyBG,EAAS7F,GAAuBE,IAI3FwM,EAAe3uC,EAAU8nC,GACzB,MAAOj1C,GAEP,MADA9I,KAAK0tB,OAAOjqB,MAAM,uDAAyDqF,GACrE8gC,GAAgBmb,8BAA8Bj8C,EAAIgB,cAUpDozC,yCAAR,SAAqCH,GAEvB,MAARA,IACFA,EAAOxpC,OAAOk0B,SAASsV,MAGzB,IAAI31C,EAAO,KACP49C,GAAmB,EACnBC,GAAqB,EAGzB,IACEA,EAAqB1xC,OAAO2xC,QAAU3xC,OAAO2xC,OAAOpT,MAAQv+B,OAAO2xC,OAAOpT,OAASv+B,OAAOu+B,KAC1F,MAAOhpC,GAEPm8C,GAAqB,EAInBA,GACF79C,EAAOmM,OAAO2xC,OAAOpT,KACrBkT,GAAU,GACDzxC,OAAOhL,QAAUgL,OAAOhL,OAAOupC,OACxC1qC,EAAOmM,OAAOhL,OAAOupC,MAIvB,IAAM6S,EAAYv9C,EAAKy9C,iBAAiB9H,GAEpCoI,EAA4E,KAIhF,GAFA/9C,EAAKsmB,OAAOK,KAAK,8BAEb/tB,KAAKolD,eACLD,EAAwB5xC,OAAOhL,OAAOq0C,4BAA4B+H,EAAU37B,YAG3E,GAAIi8B,EACLE,EAAwB5xC,OAAO2xC,OAAOtI,4BAA4B+H,EAAU37B,WAG3E,CAGH,GAFAm8B,EAAwB,KAEpB/9C,EAAK6kC,OAAO2P,KAAK5E,0BAKnB,OAJA5vC,EAAKm1C,aAAa7L,QAAQp8B,GAAUwoC,QAASC,QACzCxpC,OAAOhL,SAAWgL,QAAWyxC,IAC/BzxC,OAAOk0B,SAASC,KAAOtgC,EAAKm1C,aAAa1L,QAAQv8B,GAAUo+B,aAActrC,EAAK60C,YAOlF,GAFE1oC,OAAOk0B,SAASsV,KAAO,IAEpB/8C,KAAKg8C,qBAGR,YADA50C,EAAKm1C,aAAa7L,QAAQp8B,GAAUwoC,QAASC,GAQjD,GAHA31C,EAAKs2C,gBAAgBX,EAAM4H,EAAWQ,GAGlCF,EACF,IAAK,IAAIzkD,EAAI,EAAGA,EAAI+S,OAAO2xC,OAAOzI,cAAc97C,OAAQH,IACtD+S,OAAO2xC,OAAOzI,cAAcj8C,GAAGigD,SAU7BvD,4BAAR,SAAwBmI,GACtB,IAAItI,EAAOtW,GAAS6e,eAAeD,GACnC,OAAO/gB,GAAY1mB,YAAYm/B,IAUvBG,6BAAV,SAA2BH,GACzB,IACIwI,EADEd,EAAazkD,KAAK0kD,gBAAgB3H,GAExC,IAAK0H,EACH,MAAMhb,GAAUwa,sBAAsB,kCAExC,IAAIQ,EAAW5kD,eAAe,SAO5B,MAAM4pC,GAAUwa,sBAAsB,gCAMxC,IAZEsB,EAAgB,CACdpF,YAAa7rC,GAAUkxC,QACvBx8B,MAAOy7B,EAAWz7B,MAClBy8B,YAAY,IASEz8B,QAAUhpB,KAAKu8C,aAAa1L,QAAQv8B,GAAUm9B,WAAYzxC,KAAKi8C,WAAasJ,EAAcv8B,QAAUhpB,KAAK0lD,0BAGzH,OAFAH,EAAcpF,YAAc7rC,GAAU8rC,MACtCmF,EAAcE,YAAa,EACpBF,EAGJ,GAAIA,EAAcv8B,QAAUhpB,KAAKu8C,aAAa1L,QAAQv8B,GAAUo9B,kBAAmB1xC,KAAKi8C,UAG3F,OAFAsJ,EAAcpF,YAAc7rC,GAAU+rC,WACtCkF,EAAcE,YAAa,EACpBF,EAIT,IAAKA,EAAcE,WAAY,CAC7BF,EAAcpF,YAAc5sC,OAAO4sC,YAEnC,IADA,IAAMwF,EAAwBpyC,OAAOopC,YAC5Bn8C,EAAI,EAAGA,EAAImlD,EAAsBhlD,OAAQH,IAChD,GAAImlD,EAAsBnlD,KAAO+kD,EAAcv8B,MAAO,CACpDu8B,EAAcE,YAAa,EAC3B,OAKN,OAAOF,GAaDrI,2BAAR,SAAuBmC,EAAsD3S,GAC3E,IAAIsE,EAA6C,KAC3CroC,EAAS02C,EAA4B12C,OAGrCi9C,EAAkB5lD,KAAKu8C,aAAa+H,mBAAmBtkD,KAAKwjC,SAAUkJ,EAAUA,EAAQzD,sBAAwB,MAGtH,GAA+B,IAA3B2c,EAAgBjlD,OAClB,OAAO,KAGT,IAAMklD,EAA6C,GAGnD,GAAKxG,EAA4BvW,UA8B5B,CAEH,IAAStoC,EAAI,EAAGA,EAAIolD,EAAgBjlD,OAAQH,IAAK,CAEzC6lC,GADAyf,EAAYF,EAAgBplD,IACH+J,IAAI5B,OAAOyI,MAAM,KAC5Cg1B,GAAS2f,cAAc1f,EAAc19B,IAAW89B,GAASwB,gBAAgB6d,EAAUv7C,IAAIu+B,aAAeuW,EAA4BvW,WACpI+c,EAAc3iD,KAAK4iD,GAIvB,GAA6B,IAAzBD,EAAcllD,OAChB,OAAO,KAGJ,GAA6B,IAAzBklD,EAAcllD,OAKrB,MAAMipC,GAAgBoc,yCAAyCr9C,EAAOmB,YAJtEknC,EAAuB6U,EAAc,OA7CG,CAE1C,IAAK,IAAIrlD,EAAI,EAAGA,EAAIolD,EAAgBjlD,OAAQH,IAAK,CAC/C,IAAMslD,EACAzf,GADAyf,EAAYF,EAAgBplD,IACH+J,IAAI5B,OAAOyI,MAAM,KAC5Cg1B,GAAS2f,cAAc1f,EAAc19B,IACvCk9C,EAAc3iD,KAAK4iD,GAKvB,GAA6B,IAAzBD,EAAcllD,OAChBqwC,EAAuB6U,EAAc,GACrCxG,EAA4BxY,kBAAoBmP,GAAiBmH,eAAenM,EAAqBzmC,IAAIu+B,UAAW9oC,KAAKisC,OAAO2P,KAAK1H,uBAGlI,CAAA,GAAI2R,EAAcllD,OAAS,EAC9B,MAAMipC,GAAgBoc,yCAAyCr9C,EAAOmB,YAItE,IAAMm8C,EAAgBjmD,KAAKkmD,mBAAmBN,EAAiB,aAC/D,GAAIK,EAActlD,OAAS,EACzB,MAAMipC,GAAgBuc,sCAAsCx9C,EAAOmB,YAGrEu1C,EAA4BxY,kBAAoBmP,GAAiBmH,eAAe8I,EAAc,GAAIjmD,KAAKisC,OAAO2P,KAAK1H,oBA2BvH,GAA4B,MAAxBlD,EAA8B,CAChC,IAAIoV,EAAUvqB,OAAOmV,EAAqBzvC,MAAM6nC,WAE1Cn1B,EAASjU,KAAKisC,OAAO4P,OAAOxE,2BAA6B,IAC/D,GAAI+O,GAAYA,EAAUlT,GAAU/Y,MAAQlmB,EAAS,CACnD,IAAIq/B,EAAa,IAAI+S,GAAQrV,EAAqBzvC,MAAM4nC,SACxD,IAAKuD,KACHA,EAAU1sC,KAAK4+C,cAEb,MAAMnV,GAAUwa,sBAAsB,oCAG1C,IAAMqC,EAAStmD,KAAKw+C,gBAAgBa,EAA4Br2B,OAC5D/S,EAA0B,CAC5Bw9B,SAAU,GACVlQ,SAAU,GACV4U,UAAYnH,EAAqBzvC,MAAM4nC,UAAY6H,EAAqBzvC,MAAM04B,YAAe3lB,GAAU60B,QAAU70B,GAAU2lB,YAC3HkP,QAASmK,EACTT,cAAeS,EAAWhF,OAC1BrU,YAAa+W,EAAqBzvC,MAAM04B,YACxCtxB,OAAQqoC,EAAqBzmC,IAAI5B,OAAOyI,MAAM,KAC9CoiC,UAAW,IAAIxlC,KAAe,IAAVo4C,GACpB1Z,QAASA,EACT0L,aAAckO,GAGhB,OADAlT,GAAcmT,mBAAmBtwC,EAAUq9B,GACpCr9B,EAGP,OADAjW,KAAKu8C,aAAazL,WAAWvsC,KAAKG,UAAUmhD,EAAc,GAAGt7C,MACtD,KAGT,OAAO,MAUH2yC,+BAAR,SAA2BsJ,EAAoDC,GAC7E,IAAMR,EAA+B,GAC/BS,EAAuB,GAO7B,OANAF,EAAsB35C,QAAQ,SAAAkO,GACxBA,EAAQxQ,IAAI1K,eAAe4mD,KAAwD,IAA1CC,EAAMz7C,QAAQ8P,EAAQxQ,IAAIk8C,MACrEC,EAAMxjD,KAAK6X,EAAQxQ,IAAIk8C,IACvBR,EAAc/iD,KAAK6X,EAAQxQ,IAAIk8C,OAG5BR,GAQD/I,+BAAR,WACE,IAAMwD,EAAc1gD,KAAKu8C,aAAa1L,QAAQv8B,GAAUosC,aACxD,OAAKla,GAAYiC,QAAQiY,GAGlB,KAFE1R,GAAWY,eAAe8Q,IAU7BxD,uBAAR,SAAmBv0C,EAAuBvH,EAAmBC,EAAkBqrC,EAAkB2S,GAC/F,IAAMxb,EAAQl7B,EAAO5D,KAAK,KAAKiN,cAC/BhS,KAAK0tB,OAAOI,QAAQ,kCAAoC+V,GACxD,IAAMuf,EAAcpjD,KAAKqjD,gBAAgB,iBAAmBxf,GAE5D7jC,KAAK8/C,mBAAmBT,EAA6B3S,GACrD1sC,KAAK0tB,OAAOI,QAAQ,+BAAiCuxB,EAA4Br2B,OAGjF,IAAIg3B,EAAcvZ,GAASkgB,8BAA8BlgB,GAASwZ,kBAAkBZ,GAA8B/qC,GAAUu4B,QAAUv4B,GAAUsyC,YAEhJrzC,OAAOopC,YAAYz5C,KAAKm8C,EAA4Br2B,OACpDzV,OAAO4sC,YAAc7rC,GAAU+rC,WAC/BrgD,KAAKsgD,iBAAiBjB,EAA4Br2B,MAAO6a,EAAOziC,EAASC,GACzErB,KAAK0tB,OAAOozB,QAAQ,eAAiBd,GACrCoD,EAAYE,IAAM,cAClBtjD,KAAK6mD,kBAAkB7G,EAAa,iBAAmBnc,EAAOA,IAQxDqZ,yBAAR,SAAqBv0C,EAAuBvH,EAAmBC,EAAkBqrC,EAAkB2S,GAEjGr/C,KAAK0tB,OAAOK,KAAK,0BACjB,IAAMq1B,EAAcpjD,KAAKqjD,gBAAgB,oBAEzCrjD,KAAK8/C,mBAAmBT,EAA6B3S,GAErD1sC,KAAK0tB,OAAOI,QAAQ,iCAAmCuxB,EAA4Br2B,OAGnF,IAAIg3B,EAAcvZ,GAASkgB,8BAA8BlgB,GAASwZ,kBAAkBZ,GAA8B/qC,GAAUu4B,QAAUv4B,GAAUsyC,YAE5I5mD,KAAKk/C,aACL3rC,OAAO4sC,YAAc7rC,GAAU8rC,MAC/BpgD,KAAK0lD,0BAA4BrG,EAA4Br2B,QAE7DzV,OAAO4sC,YAAc7rC,GAAU+rC,WAC/B9sC,OAAOopC,YAAYz5C,KAAKm8C,EAA4Br2B,QAIxDhpB,KAAKsgD,iBAAiBjB,EAA4Br2B,MAAOhpB,KAAKwjC,SAAUpiC,EAASC,GACjFrB,KAAK0tB,OAAOozB,QAAQ,eAAiBd,GACrCoD,EAAYE,IAAM,cAClBtjD,KAAK6mD,kBAAkB7G,EAAa,mBAAoBhgD,KAAKwjC,WAgBvD0Z,4BAAR,SAAwBjnC,EAAwB6yB,EAAmB2b,EAAiB9V,EAAoB2E,GACtG,IAAIzP,EAGAoM,EAFA6W,OAA2B7wC,GACzB8wC,EAAwB,IAAIlY,GAAWF,GAI7C,GAAI8V,EAAW5kD,eAAe,SAAU,CAQtC,IALA,IAAMmnD,GADNnjB,EAAQ4gB,EAAkB,OACIrzC,MAAM,KAG9Bo1C,EAAwBxmD,KAAKu8C,aAAa+H,mBAAmBtkD,KAAKwjC,SAAUsF,GAEzEtoC,EAAI,EAAGA,EAAIgmD,EAAsB7lD,OAAQH,IAAK,CACrD,IAAMwwC,EAAuBwV,EAAsBhmD,GAEnD,GAAIwwC,EAAqBzmC,IAAI0+B,wBAA0BhzB,EAASy2B,QAAQzD,sBAAuB,CAC7F,IAAM5C,EAAe2K,EAAqBzmC,IAAI5B,OAAOyI,MAAM,KACvDg1B,GAAS6gB,qBAAqB5gB,EAAc2gB,IAC9ChnD,KAAKu8C,aAAazL,WAAWvsC,KAAKG,UAAUssC,EAAqBzmC,OAMvE,IAAM6+B,EAAY8J,GAAUgU,eAAezC,EAAWnwC,GAAU80B,YAChE6G,EAAaiD,GAAU/Y,MAAQiP,EAC/B,IAAM+d,EAAiB,IAAIC,GAAete,EAAW9oC,KAAKwjC,SAAUK,EAAOkjB,EAAUhe,IAAKge,EAAU/d,MAC9Fqe,EAAmB,IAAIC,GAAiB7C,EAAWnwC,GAAU2lB,aAAcqZ,EAAW5D,WAAYO,EAAWnmC,WAAY6kC,GAE/H3uC,KAAKu8C,aAAa7L,QAAQnsC,KAAKG,UAAUyiD,GAAiB5iD,KAAKG,UAAU2iD,IAEzEP,EAAoB7sB,YAAewqB,EAAWnwC,GAAU2lB,aACxD6sB,EAAoBn+C,OAASq+C,MAG1B,CACHnjB,EAAQ7jC,KAAKwjC,SAGP2jB,EAAiB,IAAIC,GAAete,EAAW9oC,KAAKwjC,SAAUK,EAAOkjB,EAAUhe,IAAKge,EAAU/d,MACpGiH,EAAapU,OAAOyX,EAAWrD,YACzBoX,EAAmB,IAAIC,GAAiB7C,EAAWnwC,GAAU60B,SAAUsb,EAAWnwC,GAAU60B,SAAU8G,EAAWnmC,WAAY6kC,GACnI3uC,KAAKu8C,aAAa7L,QAAQnsC,KAAKG,UAAUyiD,GAAiB5iD,KAAKG,UAAU2iD,IACzEP,EAAoBn+C,OAAS,CAACk7B,GAC9BijB,EAAoB7sB,YAAcwqB,EAAWnwC,GAAU60B,SASzD,OANI8G,EACA6W,EAAoBtT,UAAY,IAAIxlC,KAAkB,IAAbiiC,GAEzCjwC,KAAK0tB,OAAOjqB,MAAM,uCAGfqjD,GAQC5J,8BAAV,SAA4BH,EAAc4H,GACxC3kD,KAAK0tB,OAAOK,KAAK,gBAAkB42B,EAAUc,WAAa,kBAAoBd,EAAUxE,aACxFngD,KAAKu8C,aAAa7L,QAAQp8B,GAAUgtC,UAAW,IAC/CthD,KAAKu8C,aAAa7L,QAAQp8B,GAAUitC,qBAAsB,IAE1D,IAaI99C,EAbAwS,EAA0B,CAC5Bw9B,SAAU,GACVlQ,SAAU,GACV4U,UAAW,GACXhP,QAAS,KACT0J,cAAe,KACf5Y,YAAa,KACbtxB,OAAQ,GACR6qC,UAAW,KACX9G,QAAS,KACT0L,aAAc,IAIVmP,EAAavnD,KAAK0kD,gBAAgB3H,GACpCyK,EAAuB,GACvBC,EAAiC,GACjCnU,EAAsB,KAG1B,GAAIiU,EAAW1nD,eAAeyU,GAAUnQ,mBAAqBojD,EAAW1nD,eAAeyU,GAAU7Q,OAAQ,CAavG,GAZAzD,KAAK0tB,OAAOozB,QAAQ,UAAYyG,EAAWjzC,GAAU7Q,OAAS,uBAAyB8jD,EAAWjzC,GAAUnQ,mBAC5GnE,KAAKu8C,aAAa7L,QAAQp8B,GAAUgtC,UAAWiG,EAAWjzC,GAAU7Q,QACpEzD,KAAKu8C,aAAa7L,QAAQp8B,GAAUitC,qBAAsBgG,EAAWjzC,GAAUnQ,mBAG3EwgD,EAAUxE,cAAgB7rC,GAAU8rC,QACtCpgD,KAAKq8C,iBAAkB,EACvBr8C,KAAKu8C,aAAa7L,QAAQp8B,GAAUozC,WAAYH,EAAWjzC,GAAUnQ,kBAAoB,IAAMojD,EAAWjzC,GAAU7Q,QACpH+jD,EAAenX,GAAQsX,qBAAqBhD,EAAU37B,QAIpD27B,EAAUxE,cAAgB7rC,GAAU+rC,WAAY,CAClDrgD,KAAKs8C,wBAAyB,EAC9BkL,EAAenX,GAAQsX,qBAAqBhD,EAAU37B,OAEtD,IAAM0jB,EAAmB1sC,KAAK4+C,aAC1BjM,SAGAA,EADAjG,IAAYlG,GAAYiC,QAAQiE,EAAQzD,uBAC5ByD,EAAQzD,sBAGR30B,GAAUszC,WAG1BH,EAAyBpX,GAAQwX,+BAA+BlV,EAAWgS,EAAU37B,OAIrF,IAAA8+B,cACAC,yBAIAtkD,EAFEs0C,GAA6BiQ,2BAA2BF,IAC1D/P,GAA6BiQ,2BAA2BD,GAChD,IAAIhQ,GAA6BwP,EAAWjzC,GAAU7Q,OAAQ8jD,EAAWjzC,GAAUnQ,mBAEnF,IAAI0zC,GAAY0P,EAAWjzC,GAAU7Q,OAAQ8jD,EAAWjzC,GAAUnQ,wBAM5E,GAAIwgD,EAAUc,WAAY,CACxBzlD,KAAK0tB,OAAOK,KAAK,kBACbw5B,EAAW1nD,eAAeyU,GAAU2zC,eACpCjoD,KAAKu8C,aAAa7L,QAAQp8B,GAAU4zC,iBAAkBX,EAAWjzC,GAAU2zC,eAE/EhyC,EAASmiC,aAAep4C,KAAKw+C,gBAAgBmG,EAAU37B,OAEvD,IAAI2lB,EAAqB,GAGzB,GAAI4Y,EAAW1nD,eAAeyU,GAAU2lB,aAAc,CACpDj6B,KAAK0tB,OAAOK,KAAK,6BACjB/tB,KAAKs8C,wBAAyB,EAG1BiL,EAAW1nD,eAAeyU,GAAU60B,UACtCmK,EAAa,IAAI+S,GAAQkB,EAAWjzC,GAAU60B,UAC9ClzB,EAASkzB,QAAUmK,EACnBr9B,EAAS48B,cAAgBS,EAAWhF,SAEpCgF,EAAa,IAAI+S,GAAQrmD,KAAKu8C,aAAa1L,QAAQv8B,GAAU6zC,aAC7DlyC,EAAWm9B,GAAcmT,mBAAmBtwC,EAAUq9B,IAIxD,IAAM8U,EAAe/X,GAAQsX,qBAAqBhD,EAAU37B,OACxD8f,EAAoB9oC,KAAKu8C,aAAa1L,QAAQuX,EAAcpoD,KAAKi8C,UAOrE,GALKzV,GAAYiC,QAAQK,KACvBA,EAAYrC,GAAS4hB,kBAAkBvf,EAAW7yB,EAASstB,YAIzDgkB,EAAW1nD,eAAeyU,GAAUq6B,YAItC,MADA3uC,KAAK0tB,OAAOM,QAAQ,oDACd4b,GAAgB0e,kCAAkC,2DAHxD3Z,EAAa4Y,EAAWjzC,GAAUq6B,YAMpC14B,EAASy2B,QAAUqG,GAAQwV,cAAcjV,EAAY,IAAIzE,GAAWF,IAEpE,IAAI6Z,SAEFA,EADEvyC,EAASy2B,UAAYlG,GAAYiC,QAAQxyB,EAASy2B,QAAQzD,uBAC/ChzB,EAASy2B,QAAQzD,sBAGjB30B,GAAUszC,WAGzBH,EAAyBpX,GAAQwX,+BAA+BW,EAAY7D,EAAU37B,OACtF,IAAMy/B,EAAmCpY,GAAQwX,+BAA+BvzC,GAAUszC,WAAYjD,EAAU37B,OAE5G0/B,EAAwB1oD,KAAKu8C,aAAa1L,QAAQ4W,GAClDkB,SAGCniB,GAAYiC,QAAQigB,GAWfliB,GAAYiC,QAAQzoC,KAAKu8C,aAAa1L,QAAQ4X,MACtDxyC,EAAWjW,KAAK4oD,gBAAgB3yC,EAAU6yB,EAAWye,EAAY5Y,EAAY2E,KAX7EqV,EAAsBpkD,KAAKC,MAAMkkD,GAC7BzyC,EAASy2B,SAAWic,GAAuB5V,GAAQ8V,gBAAgB5yC,EAASy2B,QAASic,IACvF1yC,EAAWjW,KAAK4oD,gBAAgB3yC,EAAU6yB,EAAWye,EAAY5Y,EAAY2E,GAC7EtzC,KAAK0tB,OAAOK,KAAK,uGAGjB/tB,KAAK0tB,OAAOM,QACV,+GASR,GAAIu5B,EAAW1nD,eAAeyU,GAAU60B,SAAU,CAC9CnpC,KAAK0tB,OAAOK,KAAK,yBAGjB/tB,KAAKq8C,iBAAkB,EAGvB/I,EAAa,IAAI+S,GAAQkB,EAAWjzC,GAAU60B,UAE9ClzB,EAAWm9B,GAAcmT,mBAAmBtwC,EAAUq9B,GAClDiU,EAAW1nD,eAAeyU,GAAUq6B,YACtCA,EAAa4Y,EAAWjzC,GAAUq6B,YAElC3uC,KAAK0tB,OAAOM,QAAQ,oDAGtBw5B,EAAenX,GAAQsX,qBAAqBhD,EAAU37B,OAClD8f,EAAoB9oC,KAAKu8C,aAAa1L,QAAQ2W,EAAcxnD,KAAKi8C,UAEhEzV,GAAYiC,QAAQK,KACvBA,EAAYrC,GAAS4hB,kBAAkBvf,EAAWwK,EAAW/P,WAG/DvjC,KAAK0sC,QAAUqG,GAAQwV,cAAcjV,EAAY,IAAIzE,GAAWF,IAChE14B,EAASy2B,QAAU1sC,KAAK0sC,QAEpB4G,GAAcA,EAAWpM,MAEvBoM,EAAWpM,QAAUlnC,KAAKu8C,aAAa1L,QAAQv8B,GAAUm+B,aAAczyC,KAAKi8C,WAC9Ej8C,KAAK0sC,QAAU,KACf1sC,KAAKu8C,aAAa7L,QAAQp8B,GAAUozC,WAAY,mCAAqC1nD,KAAKu8C,aAAa1L,QAAQv8B,GAAUm+B,aAAczyC,KAAKi8C,UAAY,kBAAyB3I,EAAWpM,OAC5LlnC,KAAK0tB,OAAOjqB,MAAM,kCAAoCzD,KAAKu8C,aAAa1L,QAAQv8B,GAAUm+B,aAAczyC,KAAKi8C,UAAY,kBAAyB3I,EAAWpM,OAC7JzjC,EAAQmmC,GAAgBkf,yBAAyB9oD,KAAKu8C,aAAa1L,QAAQv8B,GAAUm+B,aAAczyC,KAAKi8C,UAAW3I,EAAWpM,SAI9HlnC,KAAKu8C,aAAa7L,QAAQp8B,GAAU6zC,WAAYZ,EAAWjzC,GAAU60B,UACrEnpC,KAAKu8C,aAAa7L,QAAQp8B,GAAUy0C,eAAgBpa,GAGpD3uC,KAAK4oD,gBAAgB3yC,EAAU6yB,EAAWye,EAAY5Y,EAAY2E,KAGpEkU,EAAe7C,EAAU37B,MACzBy+B,EAAyB9C,EAAU37B,MAEnChpB,KAAK0tB,OAAOjqB,MAAM,6CAClBA,EAAQmmC,GAAgBof,0BAA0B1V,GAClDtzC,KAAKu8C,aAAa7L,QAAQp8B,GAAUgtC,UAAW79C,EAAM8lC,WACrDvpC,KAAKu8C,aAAa7L,QAAQp8B,GAAUitC,qBAAsB99C,EAAM+lC,oBAKnE,CACHge,EAAe7C,EAAU37B,MACzBy+B,EAAyB9C,EAAU37B,MAEnC,IAAM+5B,EAAgB/iD,KAAKu8C,aAAa1L,QAAQv8B,GAAUm9B,WAAYzxC,KAAKi8C,UAC3Ej8C,KAAK0tB,OAAOjqB,MAAM,kCAAoCs/C,EAAgB,kBAAyB4B,EAAU37B,OACzGvlB,EAAQmmC,GAAgBqf,wBAAwBtE,EAAU37B,MAAO+5B,GACjE/iD,KAAKu8C,aAAa7L,QAAQp8B,GAAUgtC,UAAW79C,EAAM8lC,WACrDvpC,KAAKu8C,aAAa7L,QAAQp8B,GAAUitC,qBAAsB99C,EAAM+lC,cAWpE,GAPAxpC,KAAKu8C,aAAa7L,QAAQp8B,GAAUk9B,YAAcmT,EAAU37B,MAAO1U,GAAU40C,2BAC7ElpD,KAAKu8C,aAAaxK,0BAA0B4S,EAAU37B,OAElDhpB,KAAKi8C,WACPj8C,KAAKu8C,aAAa5L,cAAc6W,EAAc,IAAK,GACnDxnD,KAAKu8C,aAAa5K,eAEhBluC,EACF,MAAMA,EAGR,IAAKwS,EACD,MAAMwzB,GAAUwa,sBAAsB,oBAE1C,OAAOhuC,GAcTinC,uBAAA,WAEE,GAAIl9C,KAAK0sC,QACP,OAAO1sC,KAAK0sC,QAId,IAAMgD,EAAa1vC,KAAKu8C,aAAa1L,QAAQv8B,GAAU6zC,YACjD1Z,EAAgBzuC,KAAKu8C,aAAa1L,QAAQv8B,GAAUy0C,gBAE1D,IAAKviB,GAAYiC,QAAQiH,KAAgBlJ,GAAYiC,QAAQgG,GAAgB,CAC3E,IAAMtF,EAAU,IAAIkd,GAAQ3W,GACtBf,EAAa,IAAIE,GAAWJ,GAElC,OADAzuC,KAAK0sC,QAAUqG,GAAQwV,cAAcpf,EAASwF,GACvC3uC,KAAK0sC,QAGd,OAAO,MAUTwQ,4BAAA,SAAiBl0B,GACf,GAAIA,EAAO,CACT,IAAMmgC,EAAangC,EAAM/d,QAAQ,KACjC,GAAIk+C,GAAc,GAAKA,EAAa,EAAIngC,EAAMroB,OAC5C,OAAOqoB,EAAMlP,UAAUqvC,EAAa,GAGxC,OAAOngC,GAQTk0B,2BAAA,WAIE,IAHA,IAAMkM,EAA2B,GAC3B5C,EAAwBxmD,KAAKu8C,aAAa+H,mBAAmBhwC,GAAUkvB,SAAUlvB,GAAU20B,uBAExFzoC,EAAI,EAAGA,EAAIgmD,EAAsB7lD,OAAQH,IAAK,CACrD,IAAM2oC,EAAU,IAAIkd,GAAQG,EAAsBhmD,GAAGe,MAAM4nC,SACrDwF,EAAa,IAAIE,GAAW2X,EAAsBhmD,GAAGe,MAAM0nC,uBAC3DyD,EAAmBqG,GAAQwV,cAAcpf,EAASwF,GACxDya,EAASlmD,KAAKwpC,GAGhB,OAAO1sC,KAAKqpD,kBAAkBD,IAUxBlM,8BAAR,SAA0BkM,GACxB,IAAKA,GAAYA,EAASzoD,QAAU,EAClC,OAAOyoD,EAKT,IAFA,IAAM1C,EAAuB,GACvB4C,EAAiC,GAC9Bj5C,EAAQ,EAAGA,EAAQ+4C,EAASzoD,SAAU0P,EACzC+4C,EAAS/4C,GAAO44B,wBAAmF,IAA1Dyd,EAAMz7C,QAAQm+C,EAAS/4C,GAAO44B,yBACzEyd,EAAMxjD,KAAKkmD,EAAS/4C,GAAO44B,uBAC3BqgB,EAAepmD,KAAKkmD,EAAS/4C,KAIjC,OAAOi5C,GAkBDpM,+BAAR,SAA2Bv0C,EAAuBkiC,GAChD,GAAKliC,EAAL,CASA,IAAKhJ,MAAMgK,QAAQhB,GACjB,MAAM+iC,GAAyB6d,0BAA0B5gD,GAI3D,GAAIA,EAAOhI,OAAS,EAClB,MAAM+qC,GAAyB8d,4BAA4B7gD,EAAOmB,YAIpE,GAAInB,EAAOsC,QAAQjL,KAAKwjC,WAAa,GAC/B76B,EAAOhI,OAAS,EAClB,MAAM+qC,GAAyB+d,+BAA+B9gD,EAAOmB,iBApBvE,GAAI+gC,EACF,MAAMa,GAAyBge,0BAA0B/gD,IAgCvDu0C,8BAAR,SAA0Bl0B,GACxB,GAAIA,EAAO,CACT,IAAMmgC,EAAangC,EAAM/d,QAAQ,KACjC,GAAIk+C,GAAc,GAAKA,EAAa,EAAIngC,EAAMroB,OAC5C,OAAOqoB,EAAMlP,UAAUqvC,EAAa,GAGxC,MAAO,IAQDjM,yBAAR,SAAqB5mC,GAEnB,IAAI3N,EAWJ,OATI2N,GAAWA,EAAQ3N,SAEfA,EADA2N,EAAQqzC,qBACKrzC,EAAQ3N,cAAW2N,EAAQqzC,sBAGnCrzC,EAAQ3N,QAIdA,GAcDu0C,sBAAR,SAAkBvD,EAAmBiQ,GACnC,IAAMC,EAAM,IAAIC,YAAYnQ,EAAW,CAAEoQ,OAAQH,IACjDr2C,OAAOy2C,cAAcH,IAab3M,mCAAV,SAAiCv0C,EAAyB+jC,EAAkB1jB,GAE1E,IAAMihC,EAAyBvd,GAAW1sC,KAAK4+C,aAC/C,IAAKqL,EACD,OAAO,KAIX,IAAMC,EAAelqD,KAAK6mC,kBAAoB7mC,KAAK6mC,kBAAoBmP,GAAiBmH,eAAen9C,KAAK8oC,UAAW9oC,KAAKisC,OAAO2P,KAAK1H,mBAClI5uB,EAAetlB,KAAK2/C,aAAasK,EAAethD,GAAQ,GACxD02C,EAA8B,IAAI7S,GACtC0d,EACAlqD,KAAKwjC,SACL76B,EACA2c,EACAtlB,KAAK6/C,iBACL72B,GAIF,OAAOhpB,KAAKy6B,eAAe4kB,EAA6B3S,IAUhDwQ,iCAAV,SAA+BiN,GAE7B,GAAInqD,KAAKisC,OAAO6P,UAAUrE,qBAAqB92C,OAAS,EACpD,IAAK,IAAIH,EAAI,EAAGA,EAAIR,KAAKisC,OAAO6P,UAAUrE,qBAAqB92C,OAAQH,IACnE,GAAI2pD,EAASl/C,QAAQjL,KAAKisC,OAAO6P,UAAUrE,qBAAqBj3C,KAAO,EACnE,OAAO,KAMnB,GAAIR,KAAKisC,OAAO6P,UAAUpE,qBAAqB0S,KAAO,EAClD,IAAgB,QAAAzyC,EAAAhY,MAAM0qD,KAAKrqD,KAAKisC,OAAO6P,UAAUpE,qBAAqBttC,QAAtDiR,WAAAA,IAA+D,CAA1E,IAAI9Q,OAEL,GAAI4/C,EAASl/C,QAAQV,IAAQ,EACzB,OAAOvK,KAAKisC,OAAO6P,UAAUpE,qBAAqB31B,IAAIxX,GAQlE,OAAI4/C,EAASl/C,QAAQ,YAAc,GAAKk/C,EAASl/C,QAAQ,aAAe,EAChEjL,KAAKsqD,eAAeH,KAAcnqD,KAAKsqD,eAAetqD,KAAK6/C,kBACpD,IAAIlgD,MAAcK,KAAKwjC,UAS/B,KAJI,IAAI7jC,MAAcK,KAAKwjC,WAW7B0Z,+BAAP,WAEE,QADwBl9C,KAAKu8C,aAAa1L,QAAQv8B,GAAUwoC,UAIrD98C,KAAKq8C,iBASJa,+BAAV,SAA6Bb,GAC3Br8C,KAAKq8C,gBAAkBA,GASfa,sCAAV,WACI,OAAOl9C,KAAKs8C,wBASNY,sCAAV,SAAoCZ,GAChCt8C,KAAKs8C,uBAAyBA,GASxBY,sBAAV,WACI,OAAOl9C,KAAKisC,OAAO4P,OAAOnuB,QAcvBwvB,2BAAP,WACE,MAA4C,mBAAjCl9C,KAAKisC,OAAO2P,KAAK3U,YACnBjnC,KAAKisC,OAAO2P,KAAK3U,cAEnBjnC,KAAKisC,OAAO2P,KAAK3U,aASnBiW,qCAAP,WACE,MAAsD,mBAA3Cl9C,KAAKisC,OAAO2P,KAAK7E,sBACnB/2C,KAAKisC,OAAO2P,KAAK7E,wBAEnB/2C,KAAKisC,OAAO2P,KAAK7E,uBAQnBmG,oCAAP,WACE,IAAKl9C,KAAKisC,OACR,MAAMP,GAAyB6e,gCAEjC,OAAOvqD,KAAKisC,QAgBNiR,2BAAR,SAAuBsN,GAErB,IAAIC,EAAe1+C,OAAOy+C,GAAK/+C,QAAQ,iBAAkB,IAEzD,OADAg/C,EAAeA,EAAar5C,MAAM,KAAK,IAgBjC8rC,yBAAR,SAAqB+M,EAAwBthD,EAAkB+hD,GAO7D,OAAIA,EACE3X,GAAQ8V,gBAAgBoB,EAAejqD,KAAK4+C,cACjCj2C,EAAOsC,QAAQjL,KAAKisC,OAAO2P,KAAKpY,WAAa,EAAK6X,GAAyBA,GAG1E1yC,EAAOsC,QAAQjL,KAAKisC,OAAO2P,KAAKpY,WAAa,EAAK6X,GAAyBA,GAOtFtI,GAAQ8V,gBAAgBoB,EAAejqD,KAAK4+C,cAIlCj2C,EAAOsC,QAAQjL,KAAKwjC,WAAa,EAAK6X,GAAyBA,GAHhEA,IAoBV6B,4BAAR,SAAwBxQ,EAAkB1jB,GAGxC,IAAI2pB,EAAYjG,EAAU1sC,KAAK2qD,aAAaje,GAAWp4B,GAAUszC,WAE3DH,EAAyBpX,GAAQwX,+BAA+BlV,EAAW3pB,GACjFhpB,KAAKu8C,aAAa7L,QAAQ+W,EAAwBljD,KAAKG,UAAUgoC,KAY3DwQ,8BAAR,SAA0Bl0B,EAAe8f,GAEvC,IAAM0e,EAAenX,GAAQsX,qBAAqB3+B,GAClDhpB,KAAKu8C,aAAa7L,QAAQ8W,EAAc/gB,GAASwB,gBAAgBa,GAAY9oC,KAAKi8C,WAU5EiB,+BAAR,SAA2BmC,EAAsD3S,EAAkBgT,GAE7FA,GAEF1/C,KAAKu8C,aAAa7L,QAAQp8B,GAAUo+B,aAAcgN,EAAgB1/C,KAAKi8C,UACvEj8C,KAAKu8C,aAAa7L,QAAQp8B,GAAUozC,WAAY,IAEhD1nD,KAAKu8C,aAAa7L,QAAQp8B,GAAUm9B,WAAY4N,EAA4Br2B,MAAOhpB,KAAKi8C,UAExFj8C,KAAKu8C,aAAa7L,QAAQp8B,GAAUgtC,UAAW,IAC/CthD,KAAKu8C,aAAa7L,QAAQp8B,GAAUitC,qBAAsB,KAE1DvhD,KAAK4qD,gBAAgBle,EAAS2S,EAA4Br2B,OAG5DhpB,KAAK6qD,kBAAkBxL,EAA4Br2B,MAAOq2B,EAA4BvW,WAGtF9oC,KAAKu8C,aAAa7L,QAAQp8B,GAAUm+B,aAAc4M,EAA4BnY,MAAOlnC,KAAKi8C,WASpFiB,yBAAR,SAAqBxQ,GAUnB,OAPKlG,GAAYiC,QAAQiE,EAAQzD,uBAIjB30B,GAAUszC,WAHTlb,EAAQzD,uBAiBnBiU,gCAAR,SAA4B5mC,GAS1B,MAP6C,CAC3C3N,OAAQ,CAAC3I,KAAKwjC,UACdsF,UAAW9oC,KAAK8oC,UAChB4D,QAAS1sC,KAAK4+C,aACdrX,qBAAsBjxB,EAAQixB,uBAQ1B2V,0CAAR,SAAsCjR,EAA0BzI,GAC9D,IAAKyI,EACH,OAAO,KAGD,IAAAE,oBAAiBC,uBAAoBC,qBAC7C,IAAKF,IAAoBC,IAAwBC,EAC/C,MAAMX,GAAyBof,2BAA2B7e,GAa5D,OAAO,IAAIoO,GAJqC,CAC9CpiB,SAP2C,CAC3CshB,IAAK,UACLC,WlCtmEG,QkCumEHrN,kBACAC,sBAIA5I,SAAUA,GAEwC6I,ItGjtEjD,SAAoB0e,EAAYrkD,EAAQ6D,EAAK++B,GAChD,IAA2HhqC,EAAvH+M,EAAI3L,UAAUC,OAAQ4C,EAAI8I,EAAI,EAAI3F,EAAkB,OAAT4iC,EAAgBA,EAAO9pC,OAAOwrD,yBAAyBtkD,EAAQ6D,GAAO++B,EACrH,GAAuB,iBAAZ2hB,SAAoD,mBAArBA,QAAQC,SAAyB3nD,EAAI0nD,QAAQC,SAASH,EAAYrkD,EAAQ6D,EAAK++B,QACpH,IAAK,IAAI9oC,EAAIuqD,EAAWpqD,OAAS,EAAGH,GAAK,EAAGA,KAASlB,EAAIyrD,EAAWvqD,MAAI+C,GAAK8I,EAAI,EAAI/M,EAAEiE,GAAK8I,EAAI,EAAI/M,EAAEoH,EAAQ6D,EAAKhH,GAAKjE,EAAEoH,EAAQ6D,KAAShH,GACzI8I,EAAI,GAAK9I,GAAK/D,OAAOgjC,eAAe97B,EAAQ6D,EAAKhH,GsG4f1D4nD,EADC7P,gDCxiBI,MAAM8P,GAA0B,uCAO1BC,GAAkB,SCT/B,MAAMjiD,GAA2B,IAAItF,MAAM,yDCD3C,MAAMsF,GAA2B,IAAItF,MACnC,mSAmBAC,YACEw/B,EACAC,EACA8nB,EACAC,EACAC,EACA1jD,GAEA,MAAMsB,GAGDrF,SACL4E,EACAb,GAEA,MAAMsB,oEvC9BRrF,YACEw/B,EACAC,EACAioB,EACA3jD,GAEA,MAAMsB,GAGDrF,SACL4E,EACAb,GAEA,MAAMsB,oCwCQRrF,YACEw/B,EACAC,EACAC,EACA37B,GAEA9H,KAAK0rD,eAAiB,IAAI5oB,GAAeh7B,GACzC9H,KAAKujC,SAAWA,EAChBvjC,KAAKwjC,SAAWA,EAChBxjC,KAAKyjC,aAAeA,EAaT1/B,SACX4E,EACAb,2CAEA,MAAMI,KAAEA,EAAMJ,QAASO,GAAeT,EAAW,kCAAmCE,GACpF,IACE,MAAM0yB,EAAcx6B,KAAK0rD,eAAe3nB,kBAAkB,CACxD9jB,OAAQjgB,KAAK0rD,eAAe1oB,iBAAiBhjC,KAAKujC,6BAClDrjB,OAAQ,OACRkC,4BAA4B,EAC5B4hB,2BAAuBx8B,EACvBxF,KAAMiiC,GAAGv/B,UAAU,CACjBinD,cAAe,QACfhoB,WAAY,qBACZC,UAAW5jC,KAAKwjC,SAChBM,cAAe9jC,KAAKyjC,aACpBI,MAAyB,iBAAXl7B,EAAsBA,EAASA,EAAO5D,KAAK,OAE3D0N,QAAS,CACPyxB,OAAQ,mBACRC,eAAgB,qCAElB7jB,YAAaxY,GAAWA,EAAQwY,YAChCvY,YAAaM,EAAWN,cAGpB6jD,QAAsB5rD,KAAK0rD,eAAetnB,iBAAiB5J,GACjE,OAAQoxB,GAAiBA,EAAc3xB,aAAgB,KACvD,MAAOnxB,GACP,MAAME,EACJF,EAAInE,OAASf,EACTgD,EAAcqC,gBACdrC,EAAcy9B,QAKpB,MAJAn8B,EAAKa,UAAU,CACbC,KAAAA,EACAE,QAASJ,EAAII,UAETJ,UAENZ,EAAKiB,mEFnFTpF,YACEw/B,EACAC,EACAqoB,EACA/jD,GAEA,MAAMsB,GAGDrF,SACL4E,EACAb,GAEA,MAAMsB,oEGSRrF,YAAY+D,GAYV,GAXAA,mBACKg7B,GAAeC,oBACfj7B,GACHy7B,SAAWz7B,GAAWA,EAAQy7B,UAAa8nB,GAI3C7nB,SAAW17B,GAAWA,EAAQ07B,UAAa4nB,KAG7CprD,KAAK8rD,WAAahkD,EAAQgkD,YAAc,SACgB,IAApD,CAAC,WAAY,SAAS7gD,QAAQjL,KAAK8rD,YACrC,MAAM,IAAIhoD,6BAA6BgE,EAAQgkD,cAGjD9rD,KAAK+rD,WAAa,CAChBnQ,oBACEpY,SAAU17B,EAAQ07B,SAClBsF,aAAchhC,EAAQk7B,iBAAiBl7B,EAAQy7B,YAC3Cz7B,EAAQm/B,aAAe,CAAEA,YAAan/B,EAAQm/B,aAC9Cn/B,EAAQivC,uBAAyB,CAAE9P,YAAan/B,EAAQivC,wBAE9DpwC,MAAO,CACLypC,cAAe,eACf8G,wBAAwB,IAI5Bl3C,KAAKgsD,WAAa,IAAIC,GAA0BjsD,KAAK+rD,YAG/ChoD,QACN,OAAQ/D,KAAK8rD,YACX,IAAK,WAAY,CACf,MAAMI,EAAe,IAAI/qD,QAA2B,CAACC,EAASC,KAC5DrB,KAAKgsD,WAAWG,uBAAuB/qD,EAASC,KAGlD,OADArB,KAAKgsD,WAAWI,gBACTF,EAET,IAAK,QACH,OAAOlsD,KAAKgsD,WAAWK,cAIftoD,aACZuoD,2CAEA,IAAIC,EAqBAC,EApBJ,IACE9+B,GAAOK,KAAK,sEACZw+B,QAAqBvsD,KAAKgsD,WAAW7M,mBAAmBmN,GACxD,MAAOxjD,GACP,GAAIA,aAAe2jD,GACjB,OAAQ3jD,EAAIygC,WACV,IAAK,mBACL,IAAK,uBACL,IAAK,iBACH7b,GAAOM,2EAC8DllB,EAAIygC,aAEzE,MACF,QAEE,MADA7b,GAAOM,kEAAkEllB,KACnEA,GAMd,QAAqBtB,IAAjB+kD,EAA4B,CAI9B,OAHA7+B,GAAOM,0GAC6FhuB,KAAK8rD,cAEjG9rD,KAAK8rD,YACX,IAAK,WACHU,EAAc,IAAIrrD,QAAQ,CAACC,EAASC,KAClCrB,KAAKgsD,WAAWG,uBAAuB/qD,EAASC,KAElDrB,KAAKgsD,WAAWU,qBAAqBJ,GACrC,MACF,IAAK,QACHE,EAAcxsD,KAAKgsD,WAAWW,kBAAkBL,GAIpDC,EAAeC,UAAsBA,GAGvC,OAAOD,IAaHxoD,SACJ4E,EACAb,2CAEA,MAAMI,KAAEA,GAASN,EAAW,wCAAyCE,GACrE,IACO9H,KAAKgsD,WAAWpN,qBACb5+C,KAAKogD,SAGb,MAAMmM,QAAqBvsD,KAAK4sD,aAAa,CAC3CjkD,OAAQhJ,MAAMgK,QAAQhB,GAAUA,EAASA,EAAOyI,MAAM,OAGxD,OAAIm7C,EACK,CACL3jD,MAAO2jD,EAAatyB,YACpBG,mBAAoBmyB,EAAa/Y,UAAUv5B,WAGtC,KAET,MAAOnR,GAKP,MAJAZ,EAAKa,UAAU,CACbC,KAAMpC,EAAcy9B,QACpBn7B,QAASJ,EAAII,UAETJ,UAENZ,EAAKiB,4ECpITpF,YACE8oD,EACArpB,EACAspB,EACAC,EACAjlD,GAEA9H,KAAK0rD,eAAiB,IAAI5oB,GAAeh7B,GACzC9H,KAAKujC,SAAWspB,EAChB7sD,KAAKwjC,SAAWA,EAChBxjC,KAAK8sD,SAAWA,EAChB9sD,KAAK+sD,SAAWA,EAaLhpD,SACX4E,EACAb,2CAEA,MAAMI,KAAEA,EAAMJ,QAASO,GAAeT,EACpC,sCACAE,GAEF,IACE,MAAM0yB,EAAcx6B,KAAK0rD,eAAe3nB,kBAAkB,CACxD9jB,OAAQjgB,KAAK0rD,eAAe1oB,iBAAiBhjC,KAAKujC,6BAClDrjB,OAAQ,OACRkC,4BAA4B,EAC5B4hB,2BAAuBx8B,EACvBxF,KAAMiiC,GAAGv/B,UAAU,CACjBinD,cAAe,QACfhoB,WAAY,WACZC,UAAW5jC,KAAKwjC,SAChBspB,SAAU9sD,KAAK8sD,SACfC,SAAU/sD,KAAK+sD,SACflpB,MAAyB,iBAAXl7B,EAAsBA,EAASA,EAAO5D,KAAK,OAE3D0N,QAAS,CACPyxB,OAAQ,mBACRC,eAAgB,qCAElB7jB,YAAaxY,GAAWA,EAAQwY,YAChCvY,YAAaM,EAAWN,cAGpB6jD,QAAsB5rD,KAAK0rD,eAAetnB,iBAAiB5J,GACjE,OAAQoxB,GAAiBA,EAAc3xB,aAAgB,KACvD,MAAOnxB,GACP,MAAME,EACJF,EAAInE,OAASf,EACTgD,EAAcqC,gBACdrC,EAAcy9B,QAKpB,MAJAn8B,EAAKa,UAAU,CACbC,KAAAA,EACAE,QAASJ,EAAII,UAETJ,UAENZ,EAAKiB,kDC5DT,OAAO,IAAIK"}