{"version":3,"sources":["../lib/httpHeaders.ts","../lib/util/base64.browser.ts","../node_modules/uuid/lib/bytesToUuid.js","../node_modules/uuid/lib/rng-browser.js","../node_modules/uuid/v4.js","../lib/util/constants.ts","../lib/util/utils.ts","../lib/serializer.ts","../lib/webResource.ts","../../../../common/temp/node_modules/.registry.npmjs.org/tslib/1.10.0/node_modules/tslib/tslib.es6.js","../../../../common/temp/node_modules/.registry.npmjs.org/@azure/abort-controller/1.0.0-preview.2/node_modules/@azure/abort-controller/src/AbortSignal.ts","../../../../common/temp/node_modules/.registry.npmjs.org/@azure/abort-controller/1.0.0-preview.2/node_modules/@azure/abort-controller/src/AbortController.ts","../lib/httpPipelineLogLevel.ts","../lib/restError.ts","../lib/xhrHttpClient.ts","../../core-auth/src/tokenCredential.ts","../lib/url.ts","../lib/policies/requestPolicy.ts","../../logger/src/log.browser.ts","../../logger/src/debug.ts","../../logger/src/logger.ts","../lib/log.ts","../lib/policies/logPolicy.ts","../lib/operationParameter.ts","../lib/operationSpec.ts","../lib/util/xml.browser.ts","../lib/policies/deserializationPolicy.ts","../lib/policies/exponentialRetryPolicy.ts","../lib/policies/generateClientRequestIdPolicy.ts","../lib/policies/msRestUserAgentPolicy.browser.ts","../lib/policies/userAgentPolicy.ts","../lib/policies/redirectPolicy.ts","../lib/policies/rpRegistrationPolicy.ts","../lib/credentials/accessTokenCache.ts","../lib/policies/bearerTokenAuthenticationPolicy.ts","../lib/policies/systemErrorRetryPolicy.ts","../lib/queryCollectionFormat.ts","../lib/policies/proxyPolicy.browser.ts","../lib/policies/throttlingRetryPolicy.ts","../lib/policies/signingPolicy.ts","../lib/policies/keepAlivePolicy.ts","../../core-tracing/lib/tracers/noop/noOpSpan.ts","../../core-tracing/lib/tracers/noop/noOpBinaryFormat.ts","../../core-tracing/lib/tracers/noop/noOpHttpTextFormat.ts","../../core-tracing/lib/tracers/noop/noOpTracer.ts","../../core-tracing/lib/utils/cache.ts","../../core-tracing/lib/interfaces/trace_flags.ts","../../core-tracing/lib/utils/global.browser.ts","../../core-tracing/lib/utils/traceParentHeader.ts","../lib/policies/tracingPolicy.ts","../../core-tracing/lib/tracerProxy.ts","../lib/serviceClient.ts","../lib/credentials/basicAuthenticationCredentials.ts","../lib/credentials/apiKeyCredentials.ts","../lib/credentials/topicCredentials.ts"],"names":["getHeaderKey","headerName","toLowerCase","HttpHeaders","rawHeaders","this","_headersMap","set","prototype","headerValue","name","value","toString","get","header","undefined","contains","remove","result","headerKey","headersArray","headers","push","headerNames","i","length","headerValues","toJson","JSON","stringify","clone","encodeByteArray","str","String","fromCharCode","btoa","decodeString","byteString","atob","arr","Uint8Array","charCodeAt","getRandomValues","crypto","bind","window","msCrypto","rnds8","module","exports","rnds","Array","r","Math","random","byteToHex","substr","bytesToUuid_1","buf","offset","bth","join","v4_1","options","rng","ii","bytesToUuid","Constants","coreHttpVersion","HTTP","HTTPS","HTTP_PROXY","HTTPS_PROXY","HttpConstants","HttpVerbs","PUT","GET","DELETE","POST","MERGE","HEAD","PATCH","StatusCodes","TooManyRequests","HeaderConstants","AUTHORIZATION","AUTHORIZATION_SCHEME","RETRY_AFTER","USER_AGENT","validUuidRegex","isNode","process","version","versions","node","stripResponse","response","strippedResponse","body","bodyAsText","status","stripRequest","request","strippedRequest","isValidUuid","uuid","test","generateUuid","uuidv4","delay","t","Promise","resolve","setTimeout","validateISODuration","isDuration","replaceAll","searchValue","replaceValue","split","Serializer","modelMappers","isXML","validateConstraints","mapper","objectName","failValidation","constraintName","constraintValue","Error","constraints","_a","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","pattern","RegExp","match","some","item","ar","indexOf","serialize","object","payload","mapperType","type","serializedName","isConstant","defaultValue","required","nullable","typeName","valueOf","utils.isValidUuid","objectType","ArrayBuffer","isView","Blob","serializeBasicTypes","allowedValues","serializeEnumType","Date","isNaN","parse","toISOString","substring","toUTCString","d","floor","getTime","dateToUnixTime","utils.isDuration","serializeDateTypes","base64.encodeByteArray","serializeByteArrayType","buffer","ch","len","trimEnd","replace","bufferToBase64Url","serializeBase64UrlType","serializer","isArray","elementType","element","tempArray","serializeSequenceType","valueType","tempDictionary","_i","Object","keys","key","serializeDictionaryType","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","modelProps","resolveModelProperties","_b","propertyMapper","readOnly","propName","parentObject","xmlIsWrapped","xmlName","xmlElementName","paths","splitSerializeName","pop","_c","paths_1","pathName","propertyObjectName","toSerialize","polymorphicDiscriminator","clientName","serializedValue","xmlIsAttribute","$","additionalPropertiesMapper","additionalProperties","propNames","clientPropName","every","pn","serializeCompositeType","deserialize","responseBody","instance","handledPropertyNames","headerCollectionPrefix","dictionary","startsWith","unwrappedProperty","propertyInstance","res","_d","paths_2","isAdditionalProperty","responsePropName","_e","_f","includes","isSpecialXmlProperty","deserializeCompositeType","parseFloat","n","unixTimeToDate","base64.decodeString","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","prop","classes","partialclass","subwords_1","charAt","modelProperties","className","modelMapper","propertyName","polymorphicPropertyName","discriminatorName","discriminatorValue","uberParent","indexDiscriminator","polymorphicMapper","discriminators","getPolymorphicDiscriminatorSafely","MapperType","o","o_1","strEnum","WebResource","url","method","query","streamResponseBody","withCredentials","abortSignal","timeout","onUploadProgress","onDownloadProgress","proxySettings","keepAlive","formData","validateRequestProperties","prepare","pathTemplate","validMethods","toUpperCase","pathTemplate_1","pathParameters_1","pathParameters","baseUrl","url_1","endsWith","slice","segments","forEach","pathParamName","pathParam","stringifiedPathParameters","encodeURIComponent","skipUrlEncoding","queryParameters","queryParams","queryParamName","queryParam","disableClientRequestId","bodyIsStream","serializationMapper","mappers","disableJsonStringifyOnBody","spanOptions","operationSpec","shouldDeserialize","operationResponseGetter","extendStatics","b","setPrototypeOf","__proto__","p","hasOwnProperty","__extends","__","constructor","create","__assign","assign","s","arguments","call","apply","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","step","next","e","rejected","done","then","__generator","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","TypeError","__values","m","__read","error","__spread","concat","listenersMap","WeakMap","abortedMap","AbortSignal","onabort","defineProperty","has","addEventListener","_type","listener","removeEventListener","listeners","index","splice","dispatchEvent","event","signal","aborted","HttpPipelineLogLevel","AbortError","_super","message","_this","tslib_1.__extends","RestError","AbortController","parentSignals","_signal","parentSignals_1","parentSignal","abort","ms","timer","unref","code","statusCode","REQUEST_SEND_ERROR","PARSE_ERROR","XhrHttpClient","sendRequest","xhr","XMLHttpRequest","listener_1","readyState","DONE","addProgressListener","upload","requestForm_1","FormData","appendFormValue","append","formKey","formValue","j","contentType","open","setRequestHeader","responseType","send","HEADERS_RECEIVED","blobBody","rejectOnTerminalEvent","parseHeaders","responseText","rawEvent","loadedBytes","loaded","responseHeaders","headerLines_1","getAllResponseHeaders","trim","line","isTokenCredential","credential","getToken","signRequest","URLQuery","_rawQuery","any","parameterName","parameterValue","newValue","parameterStrings","parameterValue_1","parameterValueElement","text","currentState","currentCharacter","URLBuilder","setScheme","scheme","_scheme","getScheme","setHost","host","_host","getHost","setPort","port","_port","getPort","setPath","path","_path","appendPath","currentPath","getPath","setQuery","_query","setQueryParameter","queryParameterName","queryParameterValue","getQueryParameterValue","getQuery","startState","tokenizer","URLTokenizer","token","current","tokenPath","URLToken","_text","state","_textLength","_currentState","_currentIndex","_currentToken","hasCurrentCharacter","readWhile","character","characterCode","isAlphaNumericCharacter","readWhileLetterOrDigit","schemeOrHost","readUntilCharacter","getCurrentCharacter","peekCharacters","nextSchemeOrHost","nextCharacter","nextHost","nextPort","nextPath","readRemaining","nextQuery","charactersToPeek","endIndex","condition","terminatingCharacters","BaseRequestPolicy","_nextPolicy","_options","shouldLog","logLevel","log","RequestPolicyOptions","_logger","OFF","minimumLogLevel","logFunction","console","debug","enabledString","debugEnvVariable","env","DEBUG","enabledNamespaces","skippedNamespaces","debuggers","enable","namespaces","wildcard","namespaceList","map","ns","namespaceList_1","namespaceList_1_1","debuggers_1","debuggers_1_1","enabled","namespace","skippedNamespaces_1","skippedNamespaces_1_1","enabledNamespaces_1","enabledNamespaces_1_1","createDebugger","newDebugger","args","destroy","debugObj","extend","azureLogLevel","disable","registeredLoggers","Set","logLevelFromEnv","AZURE_LOG_LEVEL","AzureLogger","AZURE_LOG_LEVELS","isAzureLogLevel","level","registeredLoggers_1","registeredLoggers_1_1","logger","shouldEnable","setLogLevel","levelMap","verbose","info","warning","patchLogMethod","parent","child","createLogger","add","clientRootLogger","defaultAllowedHeaderNames","defaultAllowedQueryParameters","DefaultLoggingOptions","logPolicyOptions","allowedHeaderNames","allowedQueryParameters","logPolicy","logOptions","logger$1","coreLogger","nextPolicy","LogPolicy","logRequest","logResponse","sanitize","sanitizeHeaders","sanitizeUrl","sanitizeQuery","sanitizeObject","k","allowedKeys","accessor","sanitized","urlBuilder","queryString","getPathStringFromParameter","parameter","getPathStringFromParameterPath","parameterPath","isStreamOperation","responses","operationResponse","bodyMapper","Stream","doc","document","implementation","createDocument","parser","DOMParser","parseXML","opts","dom","parseFromString","errorNS","parserErrors","getElementsByTagNameNS","innerHTML","throwIfError","obj","includeRoot","domToObject","childNodes","err","getElementsByTagName","namespaceURI","ignored","childNodeCount","firstChildNode","onlyChildTextValue","nodeType","Node","TEXT_NODE","nodeValue","elementWithAttributes","attributes","isElement","hasAttributes","asElementWithAttributes","attr","nodeName","childObject","XMLSerializer","stringifyXML","content","buildNode","elementName","elem","createElement","textContent","obj_1","arrayElem","buildAttributes","setNamedItem","_g","_h","appendChild","rootName","serializeToString","attrs","createAttribute","deserializationPolicy","deserializationContentTypes","DeserializationPolicy","defaultJsonContentTypes","defaultXmlContentTypes","DefaultDeserializationOptions","expectedContentTypes","json","xml","jsonContentTypes","xmlContentTypes","deserializeResponseBody","errorHandler","msg","errCode","text_1","contentComponents","component","parsedBody","catch","parsedResponse","shouldDeserializeResponse","expectedStatusCodes","hasNoExpectedStatusCodes","responseSpec","getOperationResponse","valueToDeserialize","Sequence","restError","utils.stripRequest","utils.stripResponse","httpMethod","headersMapper","parsedHeaders","defaultResponseSpec","default","initialErrorMessage","parsedErrorResponse","defaultResponseBodyMapper","internalError","defaultError","exponentialRetryPolicy","retryCount","retryInterval","maxRetryInterval","ExponentialRetryPolicy","RetryMode","DEFAULT_CLIENT_RETRY_INTERVAL","DEFAULT_CLIENT_RETRY_COUNT","DEFAULT_CLIENT_MAX_RETRY_INTERVAL","DefaultRetryOptions","maxRetries","retryDelayInMs","maxRetryDelayInMs","isNumber","retry","policy","retryData","requestError","innerError","incrementDelta","pow","min","updateRetryData","isAborted","shouldRetry","utils\n            .delay","generateClientRequestIdPolicy","requestIdHeaderName","GenerateClientRequestIdPolicy","_requestIdHeaderName","utils.generateUuid","getDefaultUserAgentKey","getDefaultUserAgentHeaderName","getDefaultUserAgentValue","navigator","telemetryInfo","keySeparator","valueSeparator","runtimeInfo","platformSpecificData","oscpu","platform","userAgentPolicy","userAgentData","UserAgentPolicy","addUserAgentHeader","DefaultRedirectOptions","handleRedirects","redirectPolicy","maximumRetries","RedirectPolicy","handleRedirect","currentRetries","locationHeader","builder","RPRegistrationPolicy","_retryTimeout","rpName","matchRes","checkRPNotRegisteredError","urlPrefix","extractSubscriptionUrl","provider","originalRequest","postUrl","getUrl","reqOptions","getRequestEssentials","getRegistrationStatus","registrationState","utils\n                .delay","registerRP","registrationStatus","registerIfNeeded","reuseUrlToo","TokenRefreshBufferMs","ExpiringAccessTokenCache","tokenRefreshBufferMs","cachedToken","setCachedToken","accessToken","getCachedToken","now","expiresOnTimestamp","bearerTokenAuthenticationPolicy","scopes","tokenCache","BearerTokenAuthenticationPolicy","webResource","systemErrorRetryPolicy","minRetryInterval","SystemErrorRetryPolicy","QueryCollectionFormat","DEFAULT_CLIENT_MIN_RETRY_INTERVAL","boundedRandDelta","currentCount","proxyNotSupportedInBrowser","getDefaultProxySettings","_proxyUrl","proxyPolicy","_proxySettings","ProxyPolicy","_request","throttlingRetryPolicy","ThrottlingRetryPolicy","_handleResponse","_defaultResponseHandler","httpRequest","httpResponse","retryAfterHeader","delayInMs","parseRetryAfterHeader","retryAfterInSeconds","Number","parseDateRetryAfterHeader","diff","signingPolicy","authenticationProvider","SigningPolicy","nextRequest","DefaultKeepAliveOptions","keepAlivePolicy","keepAliveOptions","KeepAlivePolicy","NoOpSpan","context","spanId","traceId","end","_endTime","setAttribute","_key","_value","setAttributes","_attributes","addEvent","_name","addLink","_spanContext","setStatus","_status","updateName","isRecordingEvents","NoOpBinaryFormat","toBytes","fromBytes","_buffer","NoOpHttpTextFormat","inject","_format","_carrier","extract","NoOpTracer","startSpan","getCurrentSpan","withSpan","_span","fn","target","recordSpanData","getBinaryFormat","getHttpTextFormat","cache","TraceFlags","GLOBAL_TRACER_VERSION","GLOBAL_TRACER_SYMBOL","for","loadTracerCache","globalObj","self","existingCache","tracer","getCache","VERSION","tracingPolicy","TracingPolicy","getTracer","span","spanContext","traceParentHeader","missingFields","hexFlags","traceFlags","UNSAMPLED","getTraceParentHeader","traceState","err_1","ServiceClient","credentials","requestPolicyFactories","bearerTokenPolicyFactory","serviceClient","_withCredentials","_httpClient","httpClient","DefaultHttpClient","_requestPolicyOptions","httpPipelineLogger","authPolicyFactory","baseUri","factories","generateClientRequestIdHeader","clientRequestIdHeaderName","userAgentHeaderName","getValueOrFunctionResult","userAgentHeaderValue","userAgent","retryTimeout","rpRegistrationPolicy","rpRegistrationRetryTimeout","noRetryPolicy","createDefaultRequestPolicyFactories","newRequestPolicyFactories","_requestPolicyFactories","httpPipeline","sendOperationRequest","operationArguments","callback","requestUrl","urlParameters","urlParameter","urlParameterValue","getOperationArgumentValueFromParameter","skipEncoding","queryParameter","collectionFormat","Multi","requestContentType","headerParameters","headerParameter","customHeaders","customHeaderName","requestBody","requestBodyParameterPathString","isStream","utils.prepareXMLRootList","formDataParameters","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializeRequestBody","rawResponse","sendRequestError","error_1","details","flattenResponse","error_2","cb","_response","defaultValueCreator","getOperationArgumentValueFromParameterPath","parameterMapper","propertySearchResult","getPropertyFromParameterPath","propertyFound","useDefaultValue","propertyValue","parameterPathString","propertyPath","propertyPathString","parameterPathPart","addOperationResponse","readableStreamBody","modelProperties_1","isPageableResponse","arrayResponse","DEFAULT_AUTHORIZATION_SCHEME","BasicAuthenticationCredentials","userName","password","authorizationScheme","encodedCredentials","ApiKeyCredentials","inHeader","inQuery","TopicCredentials","topicKey","aeg-sas-key","targetCtor","sourceCtors","getOwnPropertyNames","pipelineOptions","userAgentValue","userAgentOptions","userAgentPrefix","userAgentInfo","defaultUserAgentInfo","retryOptions","redirectOptions","proxyOptions","deserializationOptions","loggingOptions","updatePipelinePolicies","uri","promiseFactories","kickstart","promiseFactory","promise","data","nextTick","serializeObject","array","property"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * A collection of HttpHeaders that can be sent with a HTTP request.\n */\nfunction getHeaderKey(headerName: string) {\n  return headerName.toLowerCase();\n}\n\n/**\n * An individual header within a HttpHeaders collection.\n */\nexport interface HttpHeader {\n  /**\n   * The name of the header.\n   */\n  name: string;\n\n  /**\n   * The value of the header.\n   */\n  value: string;\n}\n\n/**\n * A HttpHeaders collection represented as a simple JSON object.\n */\nexport type RawHttpHeaders = { [headerName: string]: string };\n\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport class HttpHeaders {\n  private readonly _headersMap: { [headerKey: string]: HttpHeader };\n\n  constructor(rawHeaders?: RawHttpHeaders) {\n    this._headersMap = {};\n    if (rawHeaders) {\n      for (const headerName in rawHeaders) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName The name of the header to set. This value is case-insensitive.\n   * @param headerValue The value of the header to set.\n   */\n  public set(headerName: string, headerValue: string | number): void {\n    this._headersMap[getHeaderKey(headerName)] = {\n      name: headerName,\n      value: headerValue.toString()\n    };\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName The name of the header.\n   */\n  public get(headerName: string): string | undefined {\n    const header: HttpHeader = this._headersMap[getHeaderKey(headerName)];\n    return !header ? undefined : header.value;\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  public contains(headerName: string): boolean {\n    return !!this._headersMap[getHeaderKey(headerName)];\n  }\n\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName The name of the header to remove.\n   */\n  public remove(headerName: string): boolean {\n    const result: boolean = this.contains(headerName);\n    delete this._headersMap[getHeaderKey(headerName)];\n    return result;\n  }\n\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  public rawHeaders(): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    for (const headerKey in this._headersMap) {\n      const header: HttpHeader = this._headersMap[headerKey];\n      result[header.name.toLowerCase()] = header.value;\n    }\n    return result;\n  }\n\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  public headersArray(): HttpHeader[] {\n    const headers: HttpHeader[] = [];\n    for (const headerKey in this._headersMap) {\n      headers.push(this._headersMap[headerKey]);\n    }\n    return headers;\n  }\n\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  public headerNames(): string[] {\n    const headerNames: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerNames.push(headers[i].name);\n    }\n    return headerNames;\n  }\n\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  public headerValues(): string[] {\n    const headerValues: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerValues.push(headers[i].value);\n    }\n    return headerValues;\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJson(): RawHttpHeaders {\n    return this.rawHeaders();\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJson());\n  }\n\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  public clone(): HttpHeaders {\n    return new HttpHeaders(this.rawHeaders());\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * Encodes a string in base64 format.\n * @param value the string to encode\n */\nexport function encodeString(value: string): string {\n  return btoa(value);\n}\n\n/**\n * Encodes a byte array in base64 format.\n * @param value the Uint8Aray to encode\n */\nexport function encodeByteArray(value: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < value.length; i++) {\n    str += String.fromCharCode(value[i]);\n  }\n  return btoa(str);\n}\n\n/**\n * Decodes a base64 string into a byte array.\n * @param value the base64 string to decode\n */\nexport function decodeString(value: string): Uint8Array {\n  const byteString = atob(value);\n  const arr = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    arr[i] = byteString.charCodeAt(i);\n  }\n  return arr;\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport const Constants = {\n  /**\n   * The core-http version\n   * @const\n   * @type {string}\n   */\n  coreHttpVersion: \"1.0.0-preview.2\",\n\n  /**\n   * Specifies HTTP.\n   *\n   * @const\n   * @type {string}\n   */\n  HTTP: \"http:\",\n\n  /**\n   * Specifies HTTPS.\n   *\n   * @const\n   * @type {string}\n   */\n  HTTPS: \"https:\",\n\n  /**\n   * Specifies HTTP Proxy.\n   *\n   * @const\n   * @type {string}\n   */\n  HTTP_PROXY: \"HTTP_PROXY\",\n\n  /**\n   * Specifies HTTPS Proxy.\n   *\n   * @const\n   * @type {string}\n   */\n  HTTPS_PROXY: \"HTTPS_PROXY\",\n\n  HttpConstants: {\n    /**\n     * Http Verbs\n     *\n     * @const\n     * @enum {string}\n     */\n    HttpVerbs: {\n      PUT: \"PUT\",\n      GET: \"GET\",\n      DELETE: \"DELETE\",\n      POST: \"POST\",\n      MERGE: \"MERGE\",\n      HEAD: \"HEAD\",\n      PATCH: \"PATCH\"\n    },\n\n    StatusCodes: {\n      TooManyRequests: 429\n    }\n  },\n\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     *\n     * @const\n     * @type {string}\n     */\n    AUTHORIZATION: \"authorization\",\n\n    AUTHORIZATION_SCHEME: \"Bearer\",\n\n    /**\n     * The Retry-After response-header field can be used with a 503 (Service\n     * Unavailable) or 349 (Too Many Requests) responses to indicate how long\n     * the service is expected to be unavailable to the requesting client.\n     *\n     * @const\n     * @type {string}\n     */\n    RETRY_AFTER: \"Retry-After\",\n\n    /**\n     * The UserAgent header.\n     *\n     * @const\n     * @type {string}\n     */\n    USER_AGENT: \"User-Agent\"\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport uuidv4 from \"uuid/v4\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { RestError } from \"../restError\";\nimport { WebResource } from \"../webResource\";\nimport { Constants } from \"./constants\";\n\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/gi;\n\n/**\n * A constant that indicates whether the environment is node.js or browser based.\n */\nexport const isNode =\n  typeof process !== \"undefined\" &&\n  !!process.version &&\n  !!process.versions &&\n  !!process.versions.node;\n\n/**\n * Checks if a parsed URL is HTTPS\n *\n * @param {object} urlToCheck The url to check\n * @return {boolean} True if the URL is HTTPS; false otherwise.\n */\nexport function urlIsHTTPS(urlToCheck: { protocol: string }): boolean {\n  return urlToCheck.protocol.toLowerCase() === Constants.HTTPS;\n}\n\n/**\n * Encodes an URI.\n *\n * @param {string} uri The URI to be encoded.\n * @return {string} The encoded URI.\n */\nexport function encodeUri(uri: string): string {\n  return encodeURIComponent(uri)\n    .replace(/!/g, \"%21\")\n    .replace(/\"/g, \"%27\")\n    .replace(/\\(/g, \"%28\")\n    .replace(/\\)/g, \"%29\")\n    .replace(/\\*/g, \"%2A\");\n}\n\n/**\n * Returns a stripped version of the Http Response which only contains body,\n * headers and the status.\n *\n * @param {HttpOperationResponse} response The Http Response\n *\n * @return {object} The stripped version of Http Response.\n */\nexport function stripResponse(response: HttpOperationResponse): any {\n  const strippedResponse: any = {};\n  strippedResponse.body = response.bodyAsText;\n  strippedResponse.headers = response.headers;\n  strippedResponse.status = response.status;\n  return strippedResponse;\n}\n\n/**\n * Returns a stripped version of the Http Request that does not contain the\n * Authorization header.\n *\n * @param {WebResource} request The Http Request object\n *\n * @return {WebResource} The stripped version of Http Request.\n */\nexport function stripRequest(request: WebResource): WebResource {\n  const strippedRequest = request.clone();\n  if (strippedRequest.headers) {\n    strippedRequest.headers.remove(\"authorization\");\n  }\n  return strippedRequest;\n}\n\n/**\n * Validates the given uuid as a string\n *\n * @param {string} uuid The uuid as a string that needs to be validated\n *\n * @return {boolean} True if the uuid is valid; false otherwise.\n */\nexport function isValidUuid(uuid: string): boolean {\n  return validUuidRegex.test(uuid);\n}\n\n/**\n * Generated UUID\n *\n * @return {string} RFC4122 v4 UUID.\n */\nexport function generateUuid(): string {\n  return uuidv4();\n}\n\n/**\n * Executes an array of promises sequentially. Inspiration of this method is here:\n * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!\n *\n * @param {Array} promiseFactories An array of promise factories(A function that return a promise)\n *\n * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.\n * If not provided then the promise chain starts with undefined.\n *\n * @return A chain of resolved or rejected promises\n */\nexport function executePromisesSequentially(promiseFactories: Array<any>, kickstart: any) {\n  let result = Promise.resolve(kickstart);\n  promiseFactories.forEach((promiseFactory) => {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @param {number} t The number of milliseconds to be delayed.\n * @param {T} value The value to be resolved with after a timeout of t milliseconds.\n * @returns {Promise<T>} Resolved promise\n */\nexport function delay<T>(t: number, value?: T): Promise<T> {\n  return new Promise((resolve) => setTimeout(() => resolve(value), t));\n}\n\n/**\n * Service callback that is returned for REST requests initiated by the service client.\n */\nexport interface ServiceCallback<TResult> {\n  /**\n   * A method that will be invoked as a callback to a service function.\n   * @param {Error | RestError | null} err The error occurred if any, while executing the request; otherwise null.\n   * @param {TResult} [result] The deserialized response body if an error did not occur.\n   * @param {WebResource} [request] The raw/actual request sent to the server if an error did not occur.\n   * @param {HttpOperationResponse} [response] The raw/actual response from the server if an error did not occur.\n   */\n  (\n    err: Error | RestError | null,\n    result?: TResult,\n    request?: WebResource,\n    response?: HttpOperationResponse\n  ): void;\n}\n\n/**\n * Converts a Promise to a callback.\n * @param {Promise<any>} promise The Promise to be converted to a callback\n * @returns {Function} A function that takes the callback (cb: Function): void\n * @deprecated generated code should instead depend on responseToBody\n */\nexport function promiseToCallback(promise: Promise<any>): Function {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n  return (cb: Function): void => {\n    promise.then(\n      (data: any) => {\n        cb(undefined, data);\n      },\n      (err: Error) => {\n        cb(err);\n      }\n    );\n  };\n}\n\n/**\n * Converts a Promise to a service callback.\n * @param {Promise<HttpOperationResponse>} promise - The Promise of HttpOperationResponse to be converted to a service callback\n * @returns {Function} A function that takes the service callback (cb: ServiceCallback<T>): void\n */\nexport function promiseToServiceCallback<T>(promise: Promise<HttpOperationResponse>): Function {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n  return (cb: ServiceCallback<T>): void => {\n    promise.then(\n      (data: HttpOperationResponse) => {\n        process.nextTick(cb, undefined, data.parsedBody as T, data.request, data);\n      },\n      (err: Error) => {\n        process.nextTick(cb, err);\n      }\n    );\n  };\n}\n\nexport function prepareXMLRootList(obj: any, elementName: string) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  return { [elementName]: obj };\n}\n\n/**\n * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor\n * @param {object} targetCtor The target object on which the properties need to be applied.\n * @param {Array<object>} sourceCtors An array of source objects from which the properties need to be taken.\n */\nexport function applyMixins(targetCtor: any, sourceCtors: any[]): void {\n  sourceCtors.forEach((sourceCtors) => {\n    Object.getOwnPropertyNames(sourceCtors.prototype).forEach((name) => {\n      targetCtor.prototype[name] = sourceCtors.prototype[name];\n    });\n  });\n}\n\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n/**\n * Indicates whether the given string is in ISO 8601 format.\n * @param {string} value The value to be validated for ISO 8601 duration format.\n * @return {boolean} `true` if valid, `false` otherwise.\n */\nexport function isDuration(value: string): boolean {\n  return validateISODuration.test(value);\n}\n\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param {string | undefined} value The value to search and replace in.\n * @param {string} searchValue The value to search for in the value argument.\n * @param {string} replaceValue The value to replace searchValue with in the value argument.\n * @returns {string | undefined} The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(\n  value: string | undefined,\n  searchValue: string,\n  replaceValue: string\n): string | undefined {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}\n\n/**\n * Determines whether the given entity is a basic/primitive type\n * (string, number, boolean, null, undefined).\n * @param {any} value Any entity\n * @return {boolean} - true is it is primitive type, false otherwise.\n */\nexport function isPrimitiveType(value: any): boolean {\n  return (typeof value !== \"object\" && typeof value !== \"function\") || value === null;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\n\nexport class Serializer {\n  constructor(\n    public readonly modelMappers: { [key: string]: any } = {},\n    public readonly isXML?: boolean\n  ) {}\n\n  validateConstraints(mapper: Mapper, value: any, objectName: string): void {\n    const failValidation = (constraintName: keyof MapperConstraints, constraintValue: any) => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`\n      );\n    };\n    if (mapper.constraints && value != undefined) {\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems\n      } = mapper.constraints;\n      if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum != undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum != undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      if (MaxItems != undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength != undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems != undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength != undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf != undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        value.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param {Mapper} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized\n   *\n   * @param {string} objectName Name of the serialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object\n   */\n  serialize(mapper: Mapper, object: any, objectName?: string): any {\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/gi) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && object == undefined) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      // Validate Constraints if any\n      this.validateConstraints(mapper, object, objectName);\n      if (mapperType.match(/^any$/gi) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/gi) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/gi) !== null) {\n        const enumMapper: EnumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/gi) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/gi) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/gi) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/gi) !== null) {\n        payload = serializeSequenceType(this, mapper as SequenceMapper, object, objectName);\n      } else if (mapperType.match(/^Dictionary$/gi) !== null) {\n        payload = serializeDictionaryType(this, mapper as DictionaryMapper, object, objectName);\n      } else if (mapperType.match(/^Composite$/gi) !== null) {\n        payload = serializeCompositeType(this, mapper as CompositeMapper, object, objectName);\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param {object} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized\n   *\n   * @param {string} objectName Name of the deserialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object\n   */\n  deserialize(mapper: Mapper, responseBody: any, objectName: string): any {\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/gi) !== null) {\n      payload = deserializeCompositeType(this, mapper as CompositeMapper, responseBody, objectName);\n    } else {\n      if (this.isXML) {\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\") and body (\"_\") properties, then just reduce the responseBody value to\n         * the body (\"_\") property.\n         */\n        if (responseBody[\"$\"] != undefined && responseBody[\"_\"] != undefined) {\n          responseBody = responseBody[\"_\"];\n        }\n      }\n\n      if (mapperType.match(/^Number$/gi) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/gi) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/gi) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/gi) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/gi) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/gi) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/gi) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/gi) !== null) {\n        payload = deserializeSequenceType(this, mapper as SequenceMapper, responseBody, objectName);\n      } else if (mapperType.match(/^Dictionary$/gi) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\nfunction trimEnd(str: string, ch: string) {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: any): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\")\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/gi) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/gi) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/gi) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`\n        );\n      }\n    } else if (typeName.match(/^Boolean$/gi) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/gi) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        objectType !== \"function\" &&\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        !(typeof Blob === \"function\" && value instanceof Blob)\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues\n      )}.`\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: any): any {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: any): any {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/gi) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`\n        );\n      }\n      value = value;\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string\n) {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  const elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    tempArray[i] = serializer.serialize(elementType, object[i], objectName);\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string\n) {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    tempDictionary[key] = serializer.serialize(valueType, object[key], objectName + \".\" + key);\n  }\n  return tempDictionary;\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer the serializer containing the entire set of mappers\n * @param mapper the composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const className = mapper.type.className;\n    if (!className) {\n      throw new Error(\n        `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n          mapper,\n          undefined,\n          2\n        )}\".`\n      );\n    }\n\n    const modelMapper = serializer.modelMappers[className];\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${className}\".`);\n    }\n    modelProps = modelMapper.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(\n            modelMapper\n          )}\" of type \"${className}\" for object \"${objectName}\".`\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string\n) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (childObject == undefined && object[key] != undefined) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          toSerialize == undefined\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName\n        );\n        if (serializedValue !== undefined && propName != undefined) {\n          if (propertyMapper.xmlIsAttribute) {\n            // $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject.$ = parentObject.$ || {};\n            parentObject.$[propName] = serializedValue;\n          } else if (propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: serializedValue };\n          } else {\n            parentObject[propName] = serializedValue;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = mapper.type.additionalProperties;\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]'\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction isSpecialXmlProperty(propertyName: string): boolean {\n  return [\"$\", \"_\"].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody.$) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody.$[xmlName!],\n          propertyObjectName\n        );\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        let unwrappedProperty = responseBody[propertyName!];\n        if (propertyMapper.xmlIsWrapped) {\n          unwrappedProperty = responseBody[xmlName!];\n          unwrappedProperty = unwrappedProperty && unwrappedProperty[xmlElementName!];\n\n          const isEmptyWrappedList = unwrappedProperty === undefined;\n          if (isEmptyWrappedList) {\n            unwrappedProperty = [];\n          }\n        }\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          unwrappedProperty,\n          propertyObjectName\n        );\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      for (const item of paths) {\n        if (!res) break;\n        res = res[item];\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        propertyInstance == undefined\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string) => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]'\n        );\n      }\n    }\n  } else if (responseBody) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  /*jshint validthis: true */\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  /*jshint validthis: true */\n  const element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`);\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\"\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      const discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        const typeName = mapper.type.uberParent || mapper.type.className;\n        const indexDiscriminator =\n          discriminatorValue === typeName\n            ? discriminatorValue\n            : typeName + \".\" + discriminatorValue;\n        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer: Serializer, typeName?: string) {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\nexport interface MapperConstraints {\n  InclusiveMaximum?: number;\n  ExclusiveMaximum?: number;\n  InclusiveMinimum?: number;\n  ExclusiveMinimum?: number;\n  MaxLength?: number;\n  MinLength?: number;\n  Pattern?: RegExp;\n  MaxItems?: number;\n  MinItems?: number;\n  UniqueItems?: true;\n  MultipleOf?: number;\n}\n\nexport type MapperType =\n  | SimpleMapperType\n  | CompositeMapperType\n  | SequenceMapperType\n  | DictionaryMapperType\n  | EnumMapperType;\n\nexport interface SimpleMapperType {\n  name:\n    | \"Base64Url\"\n    | \"Boolean\"\n    | \"ByteArray\"\n    | \"Date\"\n    | \"DateTime\"\n    | \"DateTimeRfc1123\"\n    | \"Object\"\n    | \"Stream\"\n    | \"String\"\n    | \"TimeSpan\"\n    | \"UnixTime\"\n    | \"Uuid\"\n    | \"Number\"\n    | \"any\";\n}\n\nexport interface CompositeMapperType {\n  name: \"Composite\";\n\n  // Only one of the two below properties should be present.\n  // Use className to reference another type definition,\n  // and use modelProperties/additionalProperties when the reference to the other type has been resolved.\n  className?: string;\n\n  modelProperties?: { [propertyName: string]: Mapper };\n  additionalProperties?: Mapper;\n\n  uberParent?: string;\n  polymorphicDiscriminator?: PolymorphicDiscriminator;\n}\n\nexport interface SequenceMapperType {\n  name: \"Sequence\";\n  element: Mapper;\n}\n\nexport interface DictionaryMapperType {\n  name: \"Dictionary\";\n  value: Mapper;\n}\n\nexport interface EnumMapperType {\n  name: \"Enum\";\n  allowedValues: any[];\n}\n\nexport interface BaseMapper {\n  xmlName?: string;\n  xmlIsAttribute?: boolean;\n  xmlElementName?: string;\n  xmlIsWrapped?: boolean;\n  readOnly?: boolean;\n  isConstant?: boolean;\n  required?: boolean;\n  nullable?: boolean;\n  serializedName?: string;\n  type: MapperType;\n  defaultValue?: any;\n  constraints?: MapperConstraints;\n}\n\nexport type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;\n\nexport interface PolymorphicDiscriminator {\n  serializedName: string;\n  clientName: string;\n  [key: string]: string;\n}\n\nexport interface CompositeMapper extends BaseMapper {\n  type: CompositeMapperType;\n}\n\nexport interface SequenceMapper extends BaseMapper {\n  type: SequenceMapperType;\n}\n\nexport interface DictionaryMapper extends BaseMapper {\n  type: DictionaryMapperType;\n  headerCollectionPrefix?: string;\n}\n\nexport interface EnumMapper extends BaseMapper {\n  type: EnumMapperType;\n}\n\nexport interface UrlParameterValue {\n  value: string;\n  skipUrlEncoding: boolean;\n}\n\n// TODO: why is this here?\nexport function serializeObject(toSerialize: any): any {\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    const array = [];\n    for (let i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    const dictionary: { [key: string]: any } = {};\n    for (const property in toSerialize) {\n      dictionary[property] = serializeObject(toSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum<T extends string>(o: Array<T>): { [K in T]: K } {\n  const result: any = {};\n  for (const key of o) {\n    result[key] = key;\n  }\n  return result;\n}\n\nexport const MapperType = strEnum([\n  \"Base64Url\",\n  \"Boolean\",\n  \"ByteArray\",\n  \"Composite\",\n  \"Date\",\n  \"DateTime\",\n  \"DateTimeRfc1123\",\n  \"Dictionary\",\n  \"Enum\",\n  \"Number\",\n  \"Object\",\n  \"Sequence\",\n  \"String\",\n  \"Stream\",\n  \"TimeSpan\",\n  \"UnixTime\"\n]);\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { OperationSpec } from \"./operationSpec\";\nimport { Mapper, Serializer } from \"./serializer\";\nimport { generateUuid } from \"./util/utils\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { ProxySettings } from \"./serviceClient\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { SpanOptions } from \"@azure/core-tracing\";\n\nexport type HttpMethods =\n  | \"GET\"\n  | \"PUT\"\n  | \"POST\"\n  | \"DELETE\"\n  | \"PATCH\"\n  | \"HEAD\"\n  | \"OPTIONS\"\n  | \"TRACE\";\nexport type HttpRequestBody =\n  | Blob\n  | string\n  | ArrayBuffer\n  | ArrayBufferView\n  | (() => NodeJS.ReadableStream);\n\n/**\n * Fired in response to upload or download progress.\n */\nexport type TransferProgressEvent = {\n  /**\n   * The number of bytes loaded so far.\n   */\n  loadedBytes: number;\n};\n\n/**\n * Creates a new WebResource object.\n *\n * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary\n * properties to initiate a request.\n *\n * @constructor\n */\nexport class WebResource {\n  url: string;\n  method: HttpMethods;\n  body?: any;\n  headers: HttpHeaders;\n  /**\n   * Whether or not the body of the HttpOperationResponse should be treated as a stream.\n   */\n  streamResponseBody?: boolean;\n  /**\n   * Whether or not the HttpOperationResponse should be deserialized. If this is undefined, then the\n   * HttpOperationResponse should be deserialized.\n   */\n  shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);\n  /**\n   * A function that returns the proper OperationResponse for the given OperationSpec and\n   * HttpOperationResponse combination. If this is undefined, then a simple status code lookup will\n   * be used.\n   */\n  operationResponseGetter?: (\n    operationSpec: OperationSpec,\n    response: HttpOperationResponse\n  ) => undefined | OperationResponse;\n  formData?: any;\n  query?: { [key: string]: any };\n  operationSpec?: OperationSpec;\n  withCredentials: boolean;\n  timeout: number;\n  proxySettings?: ProxySettings;\n  keepAlive?: boolean;\n\n  abortSignal?: AbortSignalLike;\n\n  /** Callback which fires upon upload progress. */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Options used to create a span when tracing is enabled.\n   */\n  spanOptions?: SpanOptions;\n\n  constructor(\n    url?: string,\n    method?: HttpMethods,\n    body?: any,\n    query?: { [key: string]: any },\n    headers?: { [key: string]: any } | HttpHeaders,\n    streamResponseBody?: boolean,\n    withCredentials?: boolean,\n    abortSignal?: AbortSignalLike,\n    timeout?: number,\n    onUploadProgress?: (progress: TransferProgressEvent) => void,\n    onDownloadProgress?: (progress: TransferProgressEvent) => void,\n    proxySettings?: ProxySettings,\n    keepAlive?: boolean\n  ) {\n    this.streamResponseBody = streamResponseBody;\n    this.url = url || \"\";\n    this.method = method || \"GET\";\n    this.headers = headers instanceof HttpHeaders ? headers : new HttpHeaders(headers);\n    this.body = body;\n    this.query = query;\n    this.formData = undefined;\n    this.withCredentials = withCredentials || false;\n    this.abortSignal = abortSignal;\n    this.timeout = timeout || 0;\n    this.onUploadProgress = onUploadProgress;\n    this.onDownloadProgress = onDownloadProgress;\n    this.proxySettings = proxySettings;\n    this.keepAlive = keepAlive;\n  }\n\n  /**\n   * Validates that the required properties such as method, url, headers[\"Content-Type\"],\n   * headers[\"accept-language\"] are defined. It will throw an error if one of the above\n   * mentioned properties are not defined.\n   */\n  validateRequestProperties(): void {\n    if (!this.method) {\n      throw new Error(\"WebResource.method is required.\");\n    }\n    if (!this.url) {\n      throw new Error(\"WebResource.url is required.\");\n    }\n  }\n\n  /**\n   * Prepares the request.\n   * @param {RequestPrepareOptions} options Options to provide for preparing the request.\n   * @returns {WebResource} Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.\n   */\n  prepare(options: RequestPrepareOptions): WebResource {\n    if (!options) {\n      throw new Error(\"options object is required\");\n    }\n\n    if (options.method == undefined || typeof options.method.valueOf() !== \"string\") {\n      throw new Error(\"options.method must be a string.\");\n    }\n\n    if (options.url && options.pathTemplate) {\n      throw new Error(\n        \"options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.\"\n      );\n    }\n\n    if (\n      (options.pathTemplate == undefined || typeof options.pathTemplate.valueOf() !== \"string\") &&\n      (options.url == undefined || typeof options.url.valueOf() !== \"string\")\n    ) {\n      throw new Error(\"Please provide exactly one of options.pathTemplate or options.url.\");\n    }\n\n    // set the url if it is provided.\n    if (options.url) {\n      if (typeof options.url !== \"string\") {\n        throw new Error('options.url must be of type \"string\".');\n      }\n      this.url = options.url;\n    }\n\n    // set the method\n    if (options.method) {\n      const validMethods = [\"GET\", \"PUT\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"POST\", \"PATCH\", \"TRACE\"];\n      if (validMethods.indexOf(options.method.toUpperCase()) === -1) {\n        throw new Error(\n          'The provided method \"' +\n            options.method +\n            '\" is invalid. Supported HTTP methods are: ' +\n            JSON.stringify(validMethods)\n        );\n      }\n    }\n    this.method = options.method.toUpperCase() as HttpMethods;\n\n    // construct the url if path template is provided\n    if (options.pathTemplate) {\n      const { pathTemplate, pathParameters } = options;\n      if (typeof pathTemplate !== \"string\") {\n        throw new Error('options.pathTemplate must be of type \"string\".');\n      }\n      if (!options.baseUrl) {\n        options.baseUrl = \"https://management.azure.com\";\n      }\n      const baseUrl = options.baseUrl;\n      let url =\n        baseUrl +\n        (baseUrl.endsWith(\"/\") ? \"\" : \"/\") +\n        (pathTemplate.startsWith(\"/\") ? pathTemplate.slice(1) : pathTemplate);\n      const segments = url.match(/({\\w*\\s*\\w*})/gi);\n      if (segments && segments.length) {\n        if (!pathParameters) {\n          throw new Error(\n            `pathTemplate: ${pathTemplate} has been provided. Hence, options.pathParameters must also be provided.`\n          );\n        }\n        segments.forEach(function(item) {\n          const pathParamName = item.slice(1, -1);\n          const pathParam = (pathParameters as { [key: string]: any })[pathParamName];\n          if (\n            pathParam === null ||\n            pathParam === undefined ||\n            !(typeof pathParam === \"string\" || typeof pathParam === \"object\")\n          ) {\n            const stringifiedPathParameters = JSON.stringify(pathParameters, undefined, 2);\n            throw new Error(\n              `pathTemplate: ${pathTemplate} contains the path parameter ${pathParamName}` +\n                ` however, it is not present in parameters: ${stringifiedPathParameters}.` +\n                `The value of the path parameter can either be a \"string\" of the form { ${pathParamName}: \"some sample value\" } or ` +\n                `it can be an \"object\" of the form { \"${pathParamName}\": { value: \"some sample value\", skipUrlEncoding: true } }.`\n            );\n          }\n\n          if (typeof pathParam.valueOf() === \"string\") {\n            url = url.replace(item, encodeURIComponent(pathParam));\n          }\n\n          if (typeof pathParam.valueOf() === \"object\") {\n            if (!pathParam.value) {\n              throw new Error(\n                `options.pathParameters[${pathParamName}] is of type \"object\" but it does not contain a \"value\" property.`\n              );\n            }\n            if (pathParam.skipUrlEncoding) {\n              url = url.replace(item, pathParam.value);\n            } else {\n              url = url.replace(item, encodeURIComponent(pathParam.value));\n            }\n          }\n        });\n      }\n      this.url = url;\n    }\n\n    // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.\n    if (options.queryParameters) {\n      const queryParameters = options.queryParameters;\n      if (typeof queryParameters !== \"object\") {\n        throw new Error(\n          `options.queryParameters must be of type object. It should be a JSON object ` +\n            `of \"query-parameter-name\" as the key and the \"query-parameter-value\" as the value. ` +\n            `The \"query-parameter-value\" may be fo type \"string\" or an \"object\" of the form { value: \"query-parameter-value\", skipUrlEncoding: true }.`\n        );\n      }\n      // append question mark if it is not present in the url\n      if (this.url && this.url.indexOf(\"?\") === -1) {\n        this.url += \"?\";\n      }\n      // construct queryString\n      const queryParams = [];\n      // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().\n      this.query = {};\n      for (const queryParamName in queryParameters) {\n        const queryParam: any = queryParameters[queryParamName];\n        if (queryParam) {\n          if (typeof queryParam === \"string\") {\n            queryParams.push(queryParamName + \"=\" + encodeURIComponent(queryParam));\n            this.query[queryParamName] = encodeURIComponent(queryParam);\n          } else if (typeof queryParam === \"object\") {\n            if (!queryParam.value) {\n              throw new Error(\n                `options.queryParameters[${queryParamName}] is of type \"object\" but it does not contain a \"value\" property.`\n              );\n            }\n            if (queryParam.skipUrlEncoding) {\n              queryParams.push(queryParamName + \"=\" + queryParam.value);\n              this.query[queryParamName] = queryParam.value;\n            } else {\n              queryParams.push(queryParamName + \"=\" + encodeURIComponent(queryParam.value));\n              this.query[queryParamName] = encodeURIComponent(queryParam.value);\n            }\n          }\n        }\n      } // end-of-for\n      // append the queryString\n      this.url += queryParams.join(\"&\");\n    }\n\n    // add headers to the request if they are provided\n    if (options.headers) {\n      const headers = options.headers;\n      for (const headerName of Object.keys(options.headers)) {\n        this.headers.set(headerName, headers[headerName]);\n      }\n    }\n    // ensure accept-language is set correctly\n    if (!this.headers.get(\"accept-language\")) {\n      this.headers.set(\"accept-language\", \"en-US\");\n    }\n    // ensure the request-id is set correctly\n    if (!this.headers.get(\"x-ms-client-request-id\") && !options.disableClientRequestId) {\n      this.headers.set(\"x-ms-client-request-id\", generateUuid());\n    }\n\n    // default\n    if (!this.headers.get(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n\n    // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicilty\n    this.body = options.body;\n    if (options.body != undefined) {\n      // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.\n      if (options.bodyIsStream) {\n        if (!this.headers.get(\"Transfer-Encoding\")) {\n          this.headers.set(\"Transfer-Encoding\", \"chunked\");\n        }\n        if (this.headers.get(\"Content-Type\") !== \"application/octet-stream\") {\n          this.headers.set(\"Content-Type\", \"application/octet-stream\");\n        }\n      } else {\n        if (options.serializationMapper) {\n          this.body = new Serializer(options.mappers).serialize(\n            options.serializationMapper,\n            options.body,\n            \"requestBody\"\n          );\n        }\n        if (!options.disableJsonStringifyOnBody) {\n          this.body = JSON.stringify(options.body);\n        }\n      }\n    }\n\n    if (options.spanOptions) {\n      this.spanOptions = options.spanOptions;\n    }\n\n    this.abortSignal = options.abortSignal;\n    this.onDownloadProgress = options.onDownloadProgress;\n    this.onUploadProgress = options.onUploadProgress;\n\n    return this;\n  }\n\n  /**\n   * Clone this WebResource HTTP request object.\n   * @returns {WebResource} The clone of this WebResource HTTP request object.\n   */\n  clone(): WebResource {\n    const result = new WebResource(\n      this.url,\n      this.method,\n      this.body,\n      this.query,\n      this.headers && this.headers.clone(),\n      this.streamResponseBody,\n      this.withCredentials,\n      this.abortSignal,\n      this.timeout,\n      this.onUploadProgress,\n      this.onDownloadProgress,\n      this.proxySettings,\n      this.keepAlive\n    );\n\n    if (this.formData) {\n      result.formData = this.formData;\n    }\n\n    if (this.operationSpec) {\n      result.operationSpec = this.operationSpec;\n    }\n\n    if (this.shouldDeserialize) {\n      result.shouldDeserialize = this.shouldDeserialize;\n    }\n\n    if (this.operationResponseGetter) {\n      result.operationResponseGetter = this.operationResponseGetter;\n    }\n\n    return result;\n  }\n}\n\nexport interface RequestPrepareOptions {\n  /**\n   * The HTTP request method. Valid values are \"GET\", \"PUT\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"POST\",\n   * or \"PATCH\".\n   */\n  method: HttpMethods;\n  /**\n   * The request url. It may or may not have query parameters in it. Either provide the \"url\" or\n   * provide the \"pathTemplate\" in the options object. Both the options are mutually exclusive.\n   */\n  url?: string;\n  /**\n   * A dictionary of query parameters to be appended to the url, where\n   * the \"key\" is the \"query-parameter-name\" and the \"value\" is the \"query-parameter-value\".\n   * The \"query-parameter-value\" can be of type \"string\" or it can be of type \"object\".\n   * The \"object\" format should be used when you want to skip url encoding. While using the object format,\n   * the object must have a property named value which provides the \"query-parameter-value\".\n   * Example:\n   *    - query-parameter-value in \"object\" format: { \"query-parameter-name\": { value: \"query-parameter-value\", skipUrlEncoding: true } }\n   *    - query-parameter-value in \"string\" format: { \"query-parameter-name\": \"query-parameter-value\"}.\n   * Note: \"If options.url already has some query parameters, then the value provided in options.queryParameters will be appended to the url.\n   */\n  queryParameters?: { [key: string]: any | ParameterValue };\n  /**\n   * The path template of the request url. Either provide the \"url\" or provide the \"pathTemplate\" in\n   * the options object. Both the options are mutually exclusive.\n   * Example: \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}\"\n   */\n  pathTemplate?: string;\n  /**\n   * The base url of the request. Default value is: \"https://management.azure.com\". This is\n   * applicable only with pathTemplate. If you are providing options.url then it is expected that\n   * you provide the complete url.\n   */\n  baseUrl?: string;\n  /**\n   * A dictionary of path parameters that need to be replaced with actual values in the pathTemplate.\n   * Here the key is the \"path-parameter-name\" and the value is the \"path-parameter-value\".\n   * The \"path-parameter-value\" can be of type \"string\"  or it can be of type \"object\".\n   * The \"object\" format should be used when you want to skip url encoding. While using the object format,\n   * the object must have a property named value which provides the \"path-parameter-value\".\n   * Example:\n   *    - path-parameter-value in \"object\" format: { \"path-parameter-name\": { value: \"path-parameter-value\", skipUrlEncoding: true } }\n   *    - path-parameter-value in \"string\" format: { \"path-parameter-name\": \"path-parameter-value\" }.\n   */\n  pathParameters?: { [key: string]: any | ParameterValue };\n  formData?: { [key: string]: any };\n  /**\n   * A dictionary of request headers that need to be applied to the request.\n   * Here the key is the \"header-name\" and the value is the \"header-value\". The header-value MUST be of type string.\n   *  - ContentType must be provided with the key name as \"Content-Type\". Default value \"application/json; charset=utf-8\".\n   *  - \"Transfer-Encoding\" is set to \"chunked\" by default if \"options.bodyIsStream\" is set to true.\n   *  - \"Content-Type\" is set to \"application/octet-stream\" by default if \"options.bodyIsStream\" is set to true.\n   *  - \"accept-language\" by default is set to \"en-US\"\n   *  - \"x-ms-client-request-id\" by default is set to a new Guid. To not generate a guid for the request, please set options.disableClientRequestId to true\n   */\n  headers?: { [key: string]: any };\n  /**\n   * When set to true, instructs the client to not set \"x-ms-client-request-id\" header to a new Guid().\n   */\n  disableClientRequestId?: boolean;\n  /**\n   * The request body. It can be of any type. This value will be serialized if it is not a stream.\n   */\n  body?: any;\n  /**\n   * Provides information on how to serialize the request body.\n   */\n  serializationMapper?: Mapper;\n  /**\n   * A dictionary of mappers that may be used while [de]serialization.\n   */\n  mappers?: { [x: string]: any };\n  /**\n   * Provides information on how to deserialize the response body.\n   */\n  deserializationMapper?: object;\n  /**\n   * Indicates whether this method should JSON.stringify() the request body. Default value: false.\n   */\n  disableJsonStringifyOnBody?: boolean;\n  /**\n   * Indicates whether the request body is a stream (useful for file upload scenarios).\n   */\n  bodyIsStream?: boolean;\n  abortSignal?: AbortSignalLike;\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n  spanOptions?: SpanOptions;\n}\n\n/**\n * The Parameter value provided for path or query parameters in RequestPrepareOptions\n */\nexport interface ParameterValue {\n  value: any;\n  skipUrlEncoding: boolean;\n  [key: string]: any;\n}\n\n/**\n * Describes the base structure of the options object that will be used in every operation.\n */\nexport interface RequestOptionsBase {\n  /**\n   * @property {object} [customHeaders] User defined custom request headers that\n   * will be applied before the request is sent.\n   */\n  customHeaders?: { [key: string]: string };\n\n  /**\n   * The signal which can be used to abort requests.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   */\n  timeout?: number;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Callback which fires upon download progress.\n   */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Options used to create a span when tracing is enabled.\n   */\n  spanOptions?: SpanOptions;\n\n  [key: string]: any;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/// <reference path=\"./shims-public.d.ts\" />\ntype AbortEventListener = (this: AbortSignalLike, ev?: any) => any;\n\nconst listenersMap = new WeakMap<AbortSignal, AbortEventListener[]>();\nconst abortedMap = new WeakMap<AbortSignal, boolean>();\n\n/**\n * Allows the request to be aborted upon firing of the \"abort\" event.\n * Compatible with the browser built-in AbortSignal and common polyfills.\n */\nexport interface AbortSignalLike {\n  /**\n   * Indicates if the signal has already been aborted.\n   */\n  readonly aborted: boolean;\n  /**\n   * Add new \"abort\" event listener, only support \"abort\" event.\n   */\n  addEventListener(\n    type: \"abort\",\n    listener: (this: AbortSignalLike, ev: any) => any,\n    options?: any\n  ): void;\n  /**\n   * Remove \"abort\" event listener, only support \"abort\" event.\n   */\n  removeEventListener(\n    type: \"abort\",\n    listener: (this: AbortSignalLike, ev: any) => any,\n    options?: any\n  ): void;\n}\n\n/**\n * An aborter instance implements AbortSignal interface, can abort HTTP requests.\n *\n * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.\n * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation\n * cannot or will not ever be cancelled.\n *\n * @example\n * // Abort without timeout\n * await doAsyncWork(AbortSignal.none);\n *\n * @export\n * @class AbortSignal\n * @implements {AbortSignalLike}\n */\nexport class AbortSignal implements AbortSignalLike {\n  constructor() {\n    listenersMap.set(this, []);\n    abortedMap.set(this, false);\n  }\n\n  /**\n   * Status of whether aborted or not.\n   *\n   * @readonly\n   * @type {boolean}\n   * @memberof AbortSignal\n   */\n  public get aborted(): boolean {\n    if (!abortedMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n\n    return abortedMap.get(this)!;\n  }\n\n  /**\n   * Creates a new AbortSignal instance that will never be aborted.\n   *\n   * @readonly\n   * @static\n   * @type {AbortSignal}\n   * @memberof AbortSignal\n   */\n  public static get none(): AbortSignal {\n    return new AbortSignal();\n  }\n\n  /**\n   * onabort event listener.\n   *\n   * @memberof AbortSignal\n   */\n  public onabort: ((ev?: Event) => any) | null = null;\n\n  /**\n   * Added new \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof AbortSignal\n   */\n  public addEventListener(\n    // tslint:disable-next-line:variable-name\n    _type: \"abort\",\n    listener: (this: AbortSignalLike, ev: any) => any\n  ): void {\n    if (!listenersMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n\n    const listeners = listenersMap.get(this)!;\n    listeners.push(listener);\n  }\n\n  /**\n   * Remove \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof AbortSignal\n   */\n  public removeEventListener(\n    // tslint:disable-next-line:variable-name\n    _type: \"abort\",\n    listener: (this: AbortSignalLike, ev: any) => any\n  ): void {\n    if (!listenersMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n\n    const listeners = listenersMap.get(this)!;\n\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  /**\n    * Dispatches a synthetic event to the AbortSignal.\n    */\n  dispatchEvent(event: Event): boolean {\n    throw new Error(\"This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.\")\n  }\n}\n\n/**\n * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.\n * Will try to trigger abort event for all linked AbortSignal nodes.\n *\n * - If there is a timeout, the timer will be cancelled.\n * - If aborted is true, nothing will happen.\n *\n * @returns\n * @internal\n */\nexport function abortSignal(signal: AbortSignal) {\n  if (signal.aborted) {\n    return;\n  }\n\n  if (signal.onabort) {\n    signal.onabort.call(signal);\n  }\n\n  const listeners = listenersMap.get(signal)!;\n  if (listeners) {\n    listeners.forEach((listener) => {\n      listener.call(signal, { type: \"abort\" });\n    });\n  }\n\n  abortedMap.set(signal, true);\n}\n","import { AbortSignal, abortSignal, AbortSignalLike } from \"./AbortSignal\";\n\n/**\n * This error is thrown when an asynchronous operation has been aborted.\n * Check for this error by testing the `name` that the name property of the\n * error matches `\"AbortError\"`.\n *\n * @example\n * const controller = new AbortController();\n * controller.abort();\n * try {\n *   doAsyncWork(controller.signal)\n * } catch (e) {\n *   if (e.name === 'AbortError') {\n *     // handle abort error here.\n *   }\n * }\n */\nexport class AbortError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"AbortError\";\n  }\n}\n\n/**\n * An AbortController provides an AbortSignal and the associated controls to signal\n * that an asynchronous operation should be aborted.\n *\n * @example\n * // Abort an operation when another event fires\n * const controller = new AbortController();\n * const signal = controller.signal;\n * doAsyncWork(signal);\n * button.addEventListener('click', () => controller.abort());\n *\n * @example\n * // Share aborter cross multiple operations in 30s\n * // Upload the same data to 2 different data centers at the same time,\n * // abort another when any of them is finished\n * const controller = AbortController.withTimeout(30 * 1000);\n * doAsyncWork(controller.signal).then(controller.abort);\n * doAsyncWork(controller.signal).then(controller.abort);\n *\n * @example\n * // Cascaded aborting\n * // All operations can't take more than 30 seconds\n * const aborter = Aborter.timeout(30 * 1000);\n *\n * // Following 2 operations can't take more than 25 seconds\n * await doAsyncWork(aborter.withTimeout(25 * 1000));\n * await doAsyncWork(aborter.withTimeout(25 * 1000));\n *\n * @export\n * @class AbortController\n * @implements {AbortSignalLike}\n */\nexport class AbortController {\n  private _signal: AbortSignal;\n\n  /**\n   * @param {AbortSignalLike[]} [parentSignals] The AbortSignals that will signal aborted on the AbortSignal associated with this controller.\n   * @constructor\n   */\n  constructor(parentSignals?: AbortSignalLike[]);\n  /**\n   * @param {...AbortSignalLike} parentSignals The AbortSignals that will signal aborted on the AbortSignal associated with this controller.\n   * @constructor\n   */\n  constructor(...parentSignals: AbortSignalLike[]);\n  constructor(parentSignals?: any) {\n    this._signal = new AbortSignal();\n\n    if (!parentSignals) {\n      return;\n    }\n    // coerce parentSignals into an array\n    if (!Array.isArray(parentSignals)) {\n      parentSignals = arguments;\n    }\n    for (const parentSignal of parentSignals) {\n      // if the parent signal has already had abort() called,\n      // then call abort on this signal as well.\n      if (parentSignal.aborted) {\n        this.abort();\n      } else {\n        // when the parent signal aborts, this signal should as well.\n        parentSignal.addEventListener(\"abort\", () => {\n          this.abort();\n        });\n      }\n    }\n  }\n\n  /**\n   * The AbortSignal associated with this controller that will signal aborted\n   * when the abort method is called on this controller.\n   *\n   * @readonly\n   * @type {AbortSignal}\n   * @memberof AbortController\n   */\n  public get signal() {\n    return this._signal;\n  }\n\n  /**\n   * Signal that any operations passed this controller's associated abort signal\n   * to cancel any remaining work and throw an `AbortError`.\n   *\n   * @memberof AbortController\n   */\n  abort() {\n    abortSignal(this._signal);\n  }\n\n  /**\n   * Creates a new AbortSignal instance that will abort after the provided ms.\n   *\n   * @static\n   * @params {number} ms Elapsed time in milliseconds to trigger an abort.\n   * @returns {AbortSignal}\n   */\n  public static timeout(ms: number): AbortSignal {\n    const signal = new AbortSignal();\n    const timer = setTimeout(abortSignal, ms, signal);\n    // Prevent the active Timer from keeping the Node.js event loop active.\n    if (typeof timer.unref === \"function\") {\n      timer.unref();\n    }\n    return signal;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * The different levels of logs that can be used with the HttpPipelineLogger.\n */\nexport enum HttpPipelineLogLevel {\n  /**\n   * A log level that indicates that no logs will be logged.\n   */\n  OFF,\n\n  /**\n   * An error log.\n   */\n  ERROR,\n\n  /**\n   * A warning log.\n   */\n  WARNING,\n\n  /**\n   * An information log.\n   */\n  INFO\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { WebResource } from \"./webResource\";\n\nexport class RestError extends Error {\n  static readonly REQUEST_SEND_ERROR: string = \"REQUEST_SEND_ERROR\";\n  static readonly PARSE_ERROR: string = \"PARSE_ERROR\";\n\n  code?: string;\n  statusCode?: number;\n  request?: WebResource;\n  response?: HttpOperationResponse;\n  details?: unknown;\n  constructor(\n    message: string,\n    code?: string,\n    statusCode?: number,\n    request?: WebResource,\n    response?: HttpOperationResponse\n  ) {\n    super(message);\n    this.code = code;\n    this.statusCode = statusCode;\n    this.request = request;\n    this.response = response;\n\n    Object.setPrototypeOf(this, RestError.prototype);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { WebResource, TransferProgressEvent } from \"./webResource\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { RestError } from \"./restError\";\n\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nexport class XhrHttpClient implements HttpClient {\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    const xhr = new XMLHttpRequest();\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    const abortSignal = request.abortSignal;\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n\n      const listener = () => {\n        xhr.abort();\n      };\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n      const appendFormValue = (key: string, value: any) => {\n        if (value && value.hasOwnProperty(\"value\") && value.hasOwnProperty(\"options\")) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n    xhr.responseType = request.streamResponseBody ? \"blob\" : \"text\";\n\n    // tslint:disable-next-line:no-null-keyword\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (request.streamResponseBody) {\n      return new Promise((resolve, reject) => {\n        xhr.addEventListener(\"readystatechange\", () => {\n          // Resolve as soon as headers are loaded\n          if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n            const blobBody = new Promise<Blob>((resolve, reject) => {\n              xhr.addEventListener(\"load\", () => {\n                resolve(xhr.response);\n              });\n              rejectOnTerminalEvent(request, xhr, reject);\n            });\n            resolve({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr),\n              blobBody\n            });\n          }\n        });\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function(resolve, reject) {\n        xhr.addEventListener(\"load\", () =>\n          resolve({\n            request,\n            status: xhr.status,\n            headers: parseHeaders(xhr),\n            bodyAsText: xhr.responseText\n          })\n        );\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n}\n\nfunction addProgressListener(\n  xhr: XMLHttpRequestEventTarget,\n  listener?: (progress: TransferProgressEvent) => void\n) {\n  if (listener) {\n    xhr.addEventListener(\"progress\", (rawEvent) =>\n      listener({\n        loadedBytes: rawEvent.loaded\n      })\n    );\n  }\n}\n\n// exported locally for testing\nexport function parseHeaders(xhr: XMLHttpRequest) {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr\n    .getAllResponseHeaders()\n    .trim()\n    .split(/[\\r\\n]+/);\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(\n  request: WebResource,\n  xhr: XMLHttpRequest,\n  reject: (err: any) => void\n) {\n  xhr.addEventListener(\"error\", () =>\n    reject(\n      new RestError(\n        `Failed to send request to ${request.url}`,\n        RestError.REQUEST_SEND_ERROR,\n        undefined,\n        request\n      )\n    )\n  );\n  xhr.addEventListener(\"abort\", () => reject(new AbortError(\"The operation was aborted.\")));\n  xhr.addEventListener(\"timeout\", () =>\n    reject(\n      new RestError(\n        `timeout of ${xhr.timeout}ms exceeded`,\n        RestError.REQUEST_SEND_ERROR,\n        undefined,\n        request\n      )\n    )\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { SpanOptions } from \"@azure/core-tracing\";\n\n/**\n * Represents a credential capable of providing an authentication token.\n */\nexport interface TokenCredential {\n  /**\n   * Gets the token provided by this credential.\n   *\n   * @param scopes The list of scopes for which the token will have access.\n   * @param options The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;\n}\n\n/**\n * Defines options for TokenCredential.getToken.\n */\nexport interface GetTokenOptions {\n  /**\n   * An AbortSignalLike implementation that can be used to cancel\n   * the token request.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Timeout for pinging services\n   */\n  timeout?: number;\n  /**\n   * Options to create a span using the tracer if any was set.\n   */\n  spanOptions?: SpanOptions;\n}\n\n/**\n * Represents an access token with an expiration time.\n */\nexport interface AccessToken {\n  /**\n   * The access token.\n   */\n  token: string;\n\n  /**\n   * The access token's expiration timestamp.\n   */\n  expiresOnTimestamp: number;\n}\n\n/**\n * Tests an object to determine whether it implements TokenCredential.\n *\n * @param credential The assumed TokenCredential to be tested.\n */\nexport function isTokenCredential(credential: any): credential is TokenCredential {\n  // Check for an object with a 'getToken' function and possibly with\n  // a 'signRequest' function.  We do this check to make sure that\n  // a ServiceClientCredentials implementor (like TokenClientCredentials\n  // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if\n  // it doesn't actually implement TokenCredential also.\n  return (\n    credential &&\n    typeof credential.getToken === \"function\" &&\n    (credential.signRequest === undefined || credential.getToken.length > 0)\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { replaceAll } from \"./util/utils\";\n\ntype URLQueryParseState = \"ParameterName\" | \"ParameterValue\" | \"Invalid\";\n\n/**\n * A class that handles the query portion of a URLBuilder.\n */\nexport class URLQuery {\n  private readonly _rawQuery: { [queryParameterName: string]: string | string[] } = {};\n\n  /**\n   * Get whether or not there any query parameters in this URLQuery.\n   */\n  public any(): boolean {\n    return Object.keys(this._rawQuery).length > 0;\n  }\n\n  /**\n   * Get the keys of the query string.\n   */\n  public keys(): string[] {\n    return Object.keys(this._rawQuery);\n  }\n\n  /**\n   * Set a query parameter with the provided name and value. If the parameterValue is undefined or\n   * empty, then this will attempt to remove an existing query parameter with the provided\n   * parameterName.\n   */\n  public set(parameterName: string, parameterValue: any): void {\n    if (parameterName) {\n      if (parameterValue != undefined) {\n        const newValue = Array.isArray(parameterValue) ? parameterValue : parameterValue.toString();\n        this._rawQuery[parameterName] = newValue;\n      } else {\n        delete this._rawQuery[parameterName];\n      }\n    }\n  }\n\n  /**\n   * Get the value of the query parameter with the provided name. If no parameter exists with the\n   * provided parameter name, then undefined will be returned.\n   */\n  public get(parameterName: string): string | string[] | undefined {\n    return parameterName ? this._rawQuery[parameterName] : undefined;\n  }\n\n  /**\n   * Get the string representation of this query. The return value will not start with a \"?\".\n   */\n  public toString(): string {\n    let result = \"\";\n    for (const parameterName in this._rawQuery) {\n      if (result) {\n        result += \"&\";\n      }\n      const parameterValue = this._rawQuery[parameterName];\n      if (Array.isArray(parameterValue)) {\n        const parameterStrings = [];\n        for (const parameterValueElement of parameterValue) {\n          parameterStrings.push(`${parameterName}=${parameterValueElement}`);\n        }\n        result += parameterStrings.join(\"&\");\n      } else {\n        result += `${parameterName}=${parameterValue}`;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Parse a URLQuery from the provided text.\n   */\n  public static parse(text: string): URLQuery {\n    const result = new URLQuery();\n\n    if (text) {\n      if (text.startsWith(\"?\")) {\n        text = text.substring(1);\n      }\n\n      let currentState: URLQueryParseState = \"ParameterName\";\n\n      let parameterName = \"\";\n      let parameterValue = \"\";\n      for (let i = 0; i < text.length; ++i) {\n        const currentCharacter: string = text[i];\n        switch (currentState) {\n          case \"ParameterName\":\n            switch (currentCharacter) {\n              case \"=\":\n                currentState = \"ParameterValue\";\n                break;\n\n              case \"&\":\n                parameterName = \"\";\n                parameterValue = \"\";\n                break;\n\n              default:\n                parameterName += currentCharacter;\n                break;\n            }\n            break;\n\n          case \"ParameterValue\":\n            switch (currentCharacter) {\n              case \"=\":\n                parameterName = \"\";\n                parameterValue = \"\";\n                currentState = \"Invalid\";\n                break;\n\n              case \"&\":\n                result.set(parameterName, parameterValue);\n                parameterName = \"\";\n                parameterValue = \"\";\n                currentState = \"ParameterName\";\n                break;\n\n              default:\n                parameterValue += currentCharacter;\n                break;\n            }\n            break;\n\n          case \"Invalid\":\n            if (currentCharacter === \"&\") {\n              currentState = \"ParameterName\";\n            }\n            break;\n\n          default:\n            throw new Error(\"Unrecognized URLQuery parse state: \" + currentState);\n        }\n      }\n      if (currentState === \"ParameterValue\") {\n        result.set(parameterName, parameterValue);\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * A class that handles creating, modifying, and parsing URLs.\n */\nexport class URLBuilder {\n  private _scheme: string | undefined;\n  private _host: string | undefined;\n  private _port: string | undefined;\n  private _path: string | undefined;\n  private _query: URLQuery | undefined;\n\n  /**\n   * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL\n   * (such as a host, port, path, or query), those parts will be added to this URL as well.\n   */\n  public setScheme(scheme: string | undefined): void {\n    if (!scheme) {\n      this._scheme = undefined;\n    } else {\n      this.set(scheme, \"SCHEME\");\n    }\n  }\n\n  /**\n   * Get the scheme that has been set in this URL.\n   */\n  public getScheme(): string | undefined {\n    return this._scheme;\n  }\n\n  /**\n   * Set the host for this URL. If the provided host contains other parts of a URL (such as a\n   * port, path, or query), those parts will be added to this URL as well.\n   */\n  public setHost(host: string | undefined): void {\n    if (!host) {\n      this._host = undefined;\n    } else {\n      this.set(host, \"SCHEME_OR_HOST\");\n    }\n  }\n\n  /**\n   * Get the host that has been set in this URL.\n   */\n  public getHost(): string | undefined {\n    return this._host;\n  }\n\n  /**\n   * Set the port for this URL. If the provided port contains other parts of a URL (such as a\n   * path or query), those parts will be added to this URL as well.\n   */\n  public setPort(port: number | string | undefined): void {\n    if (port == undefined || port === \"\") {\n      this._port = undefined;\n    } else {\n      this.set(port.toString(), \"PORT\");\n    }\n  }\n\n  /**\n   * Get the port that has been set in this URL.\n   */\n  public getPort(): string | undefined {\n    return this._port;\n  }\n\n  /**\n   * Set the path for this URL. If the provided path contains a query, then it will be added to\n   * this URL as well.\n   */\n  public setPath(path: string | undefined): void {\n    if (!path) {\n      this._path = undefined;\n    } else {\n      if (path.indexOf(\"://\") !== -1) {\n        this.set(path, \"SCHEME\");\n      } else {\n        this.set(path, \"PATH\");\n      }\n    }\n  }\n\n  /**\n   * Append the provided path to this URL's existing path. If the provided path contains a query,\n   * then it will be added to this URL as well.\n   */\n  public appendPath(path: string | undefined): void {\n    if (path) {\n      let currentPath: string | undefined = this.getPath();\n      if (currentPath) {\n        if (!currentPath.endsWith(\"/\")) {\n          currentPath += \"/\";\n        }\n\n        if (path.startsWith(\"/\")) {\n          path = path.substring(1);\n        }\n\n        path = currentPath + path;\n      }\n      this.set(path, \"PATH\");\n    }\n  }\n\n  /**\n   * Get the path that has been set in this URL.\n   */\n  public getPath(): string | undefined {\n    return this._path;\n  }\n\n  /**\n   * Set the query in this URL.\n   */\n  public setQuery(query: string | undefined): void {\n    if (!query) {\n      this._query = undefined;\n    } else {\n      this._query = URLQuery.parse(query);\n    }\n  }\n\n  /**\n   * Set a query parameter with the provided name and value in this URL's query. If the provided\n   * query parameter value is undefined or empty, then the query parameter will be removed if it\n   * existed.\n   */\n  public setQueryParameter(queryParameterName: string, queryParameterValue: any): void {\n    if (queryParameterName) {\n      if (!this._query) {\n        this._query = new URLQuery();\n      }\n      this._query.set(queryParameterName, queryParameterValue);\n    }\n  }\n\n  /**\n   * Get the value of the query parameter with the provided query parameter name. If no query\n   * parameter exists with the provided name, then undefined will be returned.\n   */\n  public getQueryParameterValue(queryParameterName: string): string | string[] | undefined {\n    return this._query ? this._query.get(queryParameterName) : undefined;\n  }\n\n  /**\n   * Get the query in this URL.\n   */\n  public getQuery(): string | undefined {\n    return this._query ? this._query.toString() : undefined;\n  }\n\n  /**\n   * Set the parts of this URL by parsing the provided text using the provided startState.\n   */\n  private set(text: string, startState: URLTokenizerState): void {\n    const tokenizer = new URLTokenizer(text, startState);\n\n    while (tokenizer.next()) {\n      const token: URLToken | undefined = tokenizer.current();\n      if (token) {\n        switch (token.type) {\n          case \"SCHEME\":\n            this._scheme = token.text || undefined;\n            break;\n\n          case \"HOST\":\n            this._host = token.text || undefined;\n            break;\n\n          case \"PORT\":\n            this._port = token.text || undefined;\n            break;\n\n          case \"PATH\":\n            const tokenPath: string | undefined = token.text || undefined;\n            if (!this._path || this._path === \"/\" || tokenPath !== \"/\") {\n              this._path = tokenPath;\n            }\n            break;\n\n          case \"QUERY\":\n            this._query = URLQuery.parse(token.text);\n            break;\n\n          default:\n            throw new Error(`Unrecognized URLTokenType: ${token.type}`);\n        }\n      }\n    }\n  }\n\n  public toString(): string {\n    let result = \"\";\n\n    if (this._scheme) {\n      result += `${this._scheme}://`;\n    }\n\n    if (this._host) {\n      result += this._host;\n    }\n\n    if (this._port) {\n      result += `:${this._port}`;\n    }\n\n    if (this._path) {\n      if (!this._path.startsWith(\"/\")) {\n        result += \"/\";\n      }\n      result += this._path;\n    }\n\n    if (this._query && this._query.any()) {\n      result += `?${this._query.toString()}`;\n    }\n\n    return result;\n  }\n\n  /**\n   * If the provided searchValue is found in this URLBuilder, then replace it with the provided\n   * replaceValue.\n   */\n  public replaceAll(searchValue: string, replaceValue: string): void {\n    if (searchValue) {\n      this.setScheme(replaceAll(this.getScheme(), searchValue, replaceValue));\n      this.setHost(replaceAll(this.getHost(), searchValue, replaceValue));\n      this.setPort(replaceAll(this.getPort(), searchValue, replaceValue));\n      this.setPath(replaceAll(this.getPath(), searchValue, replaceValue));\n      this.setQuery(replaceAll(this.getQuery(), searchValue, replaceValue));\n    }\n  }\n\n  public static parse(text: string): URLBuilder {\n    const result = new URLBuilder();\n    result.set(text, \"SCHEME_OR_HOST\");\n    return result;\n  }\n}\n\ntype URLTokenizerState = \"SCHEME\" | \"SCHEME_OR_HOST\" | \"HOST\" | \"PORT\" | \"PATH\" | \"QUERY\" | \"DONE\";\n\ntype URLTokenType = \"SCHEME\" | \"HOST\" | \"PORT\" | \"PATH\" | \"QUERY\";\n\nexport class URLToken {\n  public constructor(public readonly text: string, public readonly type: URLTokenType) {}\n\n  public static scheme(text: string): URLToken {\n    return new URLToken(text, \"SCHEME\");\n  }\n\n  public static host(text: string): URLToken {\n    return new URLToken(text, \"HOST\");\n  }\n\n  public static port(text: string): URLToken {\n    return new URLToken(text, \"PORT\");\n  }\n\n  public static path(text: string): URLToken {\n    return new URLToken(text, \"PATH\");\n  }\n\n  public static query(text: string): URLToken {\n    return new URLToken(text, \"QUERY\");\n  }\n}\n\n/**\n * Get whether or not the provided character (single character string) is an alphanumeric (letter or\n * digit) character.\n */\nexport function isAlphaNumericCharacter(character: string): boolean {\n  const characterCode: number = character.charCodeAt(0);\n  return (\n    (48 /* '0' */ <= characterCode && characterCode <= 57) /* '9' */ ||\n    (65 /* 'A' */ <= characterCode && characterCode <= 90) /* 'Z' */ ||\n    (97 /* 'a' */ <= characterCode && characterCode <= 122) /* 'z' */\n  );\n}\n\n/**\n * A class that tokenizes URL strings.\n */\nexport class URLTokenizer {\n  readonly _textLength: number;\n  _currentState: URLTokenizerState;\n  _currentIndex: number;\n  _currentToken: URLToken | undefined;\n\n  public constructor(readonly _text: string, state?: URLTokenizerState) {\n    this._textLength = _text ? _text.length : 0;\n    this._currentState = state != undefined ? state : \"SCHEME_OR_HOST\";\n    this._currentIndex = 0;\n  }\n\n  /**\n   * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer\n   * hasn't started or has finished tokenizing.\n   */\n  public current(): URLToken | undefined {\n    return this._currentToken;\n  }\n\n  /**\n   * Advance to the next URLToken and return whether or not a URLToken was found.\n   */\n  public next(): boolean {\n    if (!hasCurrentCharacter(this)) {\n      this._currentToken = undefined;\n    } else {\n      switch (this._currentState) {\n        case \"SCHEME\":\n          nextScheme(this);\n          break;\n\n        case \"SCHEME_OR_HOST\":\n          nextSchemeOrHost(this);\n          break;\n\n        case \"HOST\":\n          nextHost(this);\n          break;\n\n        case \"PORT\":\n          nextPort(this);\n          break;\n\n        case \"PATH\":\n          nextPath(this);\n          break;\n\n        case \"QUERY\":\n          nextQuery(this);\n          break;\n\n        default:\n          throw new Error(`Unrecognized URLTokenizerState: ${this._currentState}`);\n      }\n    }\n    return !!this._currentToken;\n  }\n}\n\n/**\n * Read the remaining characters from this Tokenizer's character stream.\n */\nfunction readRemaining(tokenizer: URLTokenizer): string {\n  let result = \"\";\n  if (tokenizer._currentIndex < tokenizer._textLength) {\n    result = tokenizer._text.substring(tokenizer._currentIndex);\n    tokenizer._currentIndex = tokenizer._textLength;\n  }\n  return result;\n}\n\n/**\n * Whether or not this URLTokenizer has a current character.\n */\nfunction hasCurrentCharacter(tokenizer: URLTokenizer): boolean {\n  return tokenizer._currentIndex < tokenizer._textLength;\n}\n\n/**\n * Get the character in the text string at the current index.\n */\nfunction getCurrentCharacter(tokenizer: URLTokenizer): string {\n  return tokenizer._text[tokenizer._currentIndex];\n}\n\n/**\n * Advance to the character in text that is \"step\" characters ahead. If no step value is provided,\n * then step will default to 1.\n */\nfunction nextCharacter(tokenizer: URLTokenizer, step?: number): void {\n  if (hasCurrentCharacter(tokenizer)) {\n    if (!step) {\n      step = 1;\n    }\n    tokenizer._currentIndex += step;\n  }\n}\n\n/**\n * Starting with the current character, peek \"charactersToPeek\" number of characters ahead in this\n * Tokenizer's stream of characters.\n */\nfunction peekCharacters(tokenizer: URLTokenizer, charactersToPeek: number): string {\n  let endIndex: number = tokenizer._currentIndex + charactersToPeek;\n  if (tokenizer._textLength < endIndex) {\n    endIndex = tokenizer._textLength;\n  }\n  return tokenizer._text.substring(tokenizer._currentIndex, endIndex);\n}\n\n/**\n * Read characters from this Tokenizer until the end of the stream or until the provided condition\n * is false when provided the current character.\n */\nfunction readWhile(tokenizer: URLTokenizer, condition: (character: string) => boolean): string {\n  let result = \"\";\n\n  while (hasCurrentCharacter(tokenizer)) {\n    const currentCharacter: string = getCurrentCharacter(tokenizer);\n    if (!condition(currentCharacter)) {\n      break;\n    } else {\n      result += currentCharacter;\n      nextCharacter(tokenizer);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Read characters from this Tokenizer until a non-alphanumeric character or the end of the\n * character stream is reached.\n */\nfunction readWhileLetterOrDigit(tokenizer: URLTokenizer): string {\n  return readWhile(tokenizer, (character: string) => isAlphaNumericCharacter(character));\n}\n\n/**\n * Read characters from this Tokenizer until one of the provided terminating characters is read or\n * the end of the character stream is reached.\n */\nfunction readUntilCharacter(tokenizer: URLTokenizer, ...terminatingCharacters: string[]): string {\n  return readWhile(\n    tokenizer,\n    (character: string) => terminatingCharacters.indexOf(character) === -1\n  );\n}\n\nfunction nextScheme(tokenizer: URLTokenizer): void {\n  const scheme: string = readWhileLetterOrDigit(tokenizer);\n  tokenizer._currentToken = URLToken.scheme(scheme);\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentState = \"DONE\";\n  } else {\n    tokenizer._currentState = \"HOST\";\n  }\n}\n\nfunction nextSchemeOrHost(tokenizer: URLTokenizer): void {\n  const schemeOrHost: string = readUntilCharacter(tokenizer, \":\", \"/\", \"?\");\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentToken = URLToken.host(schemeOrHost);\n    tokenizer._currentState = \"DONE\";\n  } else if (getCurrentCharacter(tokenizer) === \":\") {\n    if (peekCharacters(tokenizer, 3) === \"://\") {\n      tokenizer._currentToken = URLToken.scheme(schemeOrHost);\n      tokenizer._currentState = \"HOST\";\n    } else {\n      tokenizer._currentToken = URLToken.host(schemeOrHost);\n      tokenizer._currentState = \"PORT\";\n    }\n  } else {\n    tokenizer._currentToken = URLToken.host(schemeOrHost);\n    if (getCurrentCharacter(tokenizer) === \"/\") {\n      tokenizer._currentState = \"PATH\";\n    } else {\n      tokenizer._currentState = \"QUERY\";\n    }\n  }\n}\n\nfunction nextHost(tokenizer: URLTokenizer): void {\n  if (peekCharacters(tokenizer, 3) === \"://\") {\n    nextCharacter(tokenizer, 3);\n  }\n\n  const host: string = readUntilCharacter(tokenizer, \":\", \"/\", \"?\");\n  tokenizer._currentToken = URLToken.host(host);\n\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentState = \"DONE\";\n  } else if (getCurrentCharacter(tokenizer) === \":\") {\n    tokenizer._currentState = \"PORT\";\n  } else if (getCurrentCharacter(tokenizer) === \"/\") {\n    tokenizer._currentState = \"PATH\";\n  } else {\n    tokenizer._currentState = \"QUERY\";\n  }\n}\n\nfunction nextPort(tokenizer: URLTokenizer): void {\n  if (getCurrentCharacter(tokenizer) === \":\") {\n    nextCharacter(tokenizer);\n  }\n\n  const port: string = readUntilCharacter(tokenizer, \"/\", \"?\");\n  tokenizer._currentToken = URLToken.port(port);\n\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentState = \"DONE\";\n  } else if (getCurrentCharacter(tokenizer) === \"/\") {\n    tokenizer._currentState = \"PATH\";\n  } else {\n    tokenizer._currentState = \"QUERY\";\n  }\n}\n\nfunction nextPath(tokenizer: URLTokenizer): void {\n  const path: string = readUntilCharacter(tokenizer, \"?\");\n  tokenizer._currentToken = URLToken.path(path);\n\n  if (!hasCurrentCharacter(tokenizer)) {\n    tokenizer._currentState = \"DONE\";\n  } else {\n    tokenizer._currentState = \"QUERY\";\n  }\n}\n\nfunction nextQuery(tokenizer: URLTokenizer): void {\n  if (getCurrentCharacter(tokenizer) === \"?\") {\n    nextCharacter(tokenizer);\n  }\n\n  const query: string = readRemaining(tokenizer);\n  tokenizer._currentToken = URLToken.query(query);\n  tokenizer._currentState = \"DONE\";\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { HttpPipelineLogger } from \"../httpPipelineLogger\";\nimport { HttpPipelineLogLevel } from \"../httpPipelineLogLevel\";\nimport { WebResource } from \"../webResource\";\n\n/**\n * Creates a new RequestPolicy per-request that uses the provided nextPolicy.\n */\nexport type RequestPolicyFactory = {\n  create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): RequestPolicy;\n};\n\nexport interface RequestPolicy {\n  sendRequest(httpRequest: WebResource): Promise<HttpOperationResponse>;\n}\n\nexport abstract class BaseRequestPolicy implements RequestPolicy {\n  protected constructor(\n    readonly _nextPolicy: RequestPolicy,\n    readonly _options: RequestPolicyOptions\n  ) {}\n\n  public abstract sendRequest(webResource: WebResource): Promise<HttpOperationResponse>;\n\n  /**\n   * Get whether or not a log with the provided log level should be logged.\n   * @param logLevel The log level of the log that will be logged.\n   * @returns Whether or not a log with the provided log level should be logged.\n   */\n  public shouldLog(logLevel: HttpPipelineLogLevel): boolean {\n    return this._options.shouldLog(logLevel);\n  }\n\n  /**\n   * Attempt to log the provided message to the provided logger. If no logger was provided or if\n   * the log level does not meat the logger's threshold, then nothing will be logged.\n   * @param logLevel The log level of this log.\n   * @param message The message of this log.\n   */\n  public log(logLevel: HttpPipelineLogLevel, message: string): void {\n    this._options.log(logLevel, message);\n  }\n}\n\n/**\n * Optional properties that can be used when creating a RequestPolicy.\n */\nexport class RequestPolicyOptions {\n  constructor(private _logger?: HttpPipelineLogger) {}\n\n  /**\n   * Get whether or not a log with the provided log level should be logged.\n   * @param logLevel The log level of the log that will be logged.\n   * @returns Whether or not a log with the provided log level should be logged.\n   */\n  public shouldLog(logLevel: HttpPipelineLogLevel): boolean {\n    return (\n      !!this._logger &&\n      logLevel !== HttpPipelineLogLevel.OFF &&\n      logLevel <= this._logger.minimumLogLevel\n    );\n  }\n\n  /**\n   * Attempt to log the provided message to the provided logger. If no logger was provided or if\n   * the log level does not meat the logger's threshold, then nothing will be logged.\n   * @param logLevel The log level of this log.\n   * @param message The message of this log.\n   */\n  public log(logLevel: HttpPipelineLogLevel, message: string): void {\n    if (this._logger && this.shouldLog(logLevel)) {\n      this._logger.log(logLevel, message);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nconst logFunction = console.debug || console.log;\nexport function log(...args: any[]) {\n  logFunction(...args);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { log } from \"./log\";\n\n/**\n * A simple mechanism for enabling logging.\n * Intended to mimic the publicly available `debug` package.\n */\nexport interface Debug {\n  /**\n   * Creates a new logger with the given namespace.\n   */\n  (namespace: string): Debugger;\n  /**\n   * The default log method (defaults to console)\n   */\n  log: (...args: any[]) => void;\n  /**\n   * Enables a particular set of namespaces.\n   * To enable multiple separate them with commas, e.g. \"info,debug\".\n   * Supports wildcards, e.g. \"azure:*\"\n   * Supports skip syntax, e.g. \"azure:*,-azure:storage:*\" will enable\n   * everything under azure except for things under azure:storage.\n   */\n  enable: (namespaces: string) => void;\n  /**\n   * Checks if a particular namespace is enabled.\n   */\n  enabled: (namespace: string) => boolean;\n  /**\n   * Disables all logging, returns what was previously enabled.\n   */\n  disable: () => string;\n}\n\n/**\n * A log function that can be dynamically enabled and redirected.\n */\nexport interface Debugger {\n  /**\n   * Logs the given arguments to the `log` method.\n   */\n  (...args: any[]): void;\n  /**\n   * True if this logger is active and logging.\n   */\n  enabled: boolean;\n  /**\n   * Used to cleanup/remove this logger.\n   */\n  destroy: () => boolean;\n  /**\n   * The current log method. Can be overridden to redirect output.\n   */\n  log: (...args: any[]) => void;\n  /**\n   * The namespace of this logger.\n   */\n  namespace: string;\n  /**\n   * Extends this logger with a child namespace.\n   * Namespaces are separated with a ':' character.\n   */\n  extend: (namespace: string) => Debugger;\n}\n\nconst debugEnvVariable =\n  (typeof process !== \"undefined\" && process.env && process.env.DEBUG) || undefined;\n\nlet enabledString: string | undefined;\nlet enabledNamespaces: RegExp[] = [];\nlet skippedNamespaces: RegExp[] = [];\nconst debuggers: Debugger[] = [];\n\nif (debugEnvVariable) {\n  enable(debugEnvVariable);\n}\n\nfunction enable(namespaces: string): void {\n  enabledString = namespaces;\n  enabledNamespaces = [];\n  skippedNamespaces = [];\n  const wildcard = /\\*/g;\n  const namespaceList = namespaces.split(\",\").map((ns) => ns.trim().replace(wildcard, \".*?\"));\n  for (const ns of namespaceList) {\n    if (ns.startsWith(\"-\")) {\n      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));\n    } else {\n      enabledNamespaces.push(new RegExp(`^${ns}$`));\n    }\n  }\n  for (const instance of debuggers) {\n    instance.enabled = enabled(instance.namespace);\n  }\n}\n\nfunction enabled(namespace: string): boolean {\n  if (namespace.endsWith(\"*\")) {\n    return true;\n  }\n\n  for (const skipped of skippedNamespaces) {\n    if (skipped.test(namespace)) {\n      return false;\n    }\n  }\n  for (const enabled of enabledNamespaces) {\n    if (enabled.test(namespace)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction disable(): string {\n  const result = enabledString || \"\";\n  enable(\"\");\n  return result;\n}\n\nfunction createDebugger(namespace: string): Debugger {\n  function debug(...args: any[]) {\n    if (!newDebugger.enabled) {\n      return;\n    }\n    if (args.length > 0) {\n      args[0] = `${namespace} ${args[0]}`;\n    }\n    newDebugger.log(...args);\n  }\n\n  const newDebugger: Debugger = Object.assign(debug, {\n    enabled: enabled(namespace),\n    destroy,\n    log: debugObj.log,\n    namespace,\n    extend\n  });\n\n  debuggers.push(newDebugger);\n\n  return newDebugger;\n}\n\nfunction destroy(this: Debugger): boolean {\n  const index = debuggers.indexOf(this);\n  if (index >= 0) {\n    debuggers.splice(index, 1);\n    return true;\n  }\n  return false;\n}\n\nfunction extend(this: Debugger, namespace: string): Debugger {\n  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);\n  newDebugger.log = this.log;\n  return newDebugger;\n}\n\nconst debugObj: Debug = Object.assign(\n  (namespace: string): Debugger => {\n    return createDebugger(namespace);\n  },\n  {\n    enable,\n    enabled,\n    disable,\n    log\n  }\n);\n\nexport default debugObj;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport debug, { Debugger } from \"./debug\";\nexport { Debugger } from \"./debug\";\n\nconst registeredLoggers = new Set<AzureDebugger>();\nconst logLevelFromEnv =\n  (typeof process !== \"undefined\" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;\n\nlet azureLogLevel: AzureLogLevel | undefined;\n\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport const AzureLogger: AzureClientLogger = debug(\"azure\");\nAzureLogger.log = (...args) => {\n  debug.log(...args);\n};\n\n/**\n * The log levels supported by the logger.\n * The log levels in order of most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport type AzureLogLevel = \"verbose\" | \"info\" | \"warning\" | \"error\";\nconst AZURE_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\n\ntype AzureDebugger = Debugger & { level: AzureLogLevel };\n\n/**\n * An AzureClientLogger is a function that can log to an appropriate severity level.\n */\nexport type AzureClientLogger = Debugger;\n\nif (logLevelFromEnv) {\n  // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n  if (isAzureLogLevel(logLevelFromEnv)) {\n    setLogLevel(logLevelFromEnv);\n  } else {\n    console.error(\n      `AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(\n        \", \"\n      )}.`\n    );\n  }\n}\n\n/**\n * Immediately enables logging at the specified log level.\n * @param level The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level?: AzureLogLevel) {\n  if (level && !isAzureLogLevel(level)) {\n    throw new Error(\n      `Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(\",\")}`\n    );\n  }\n  azureLogLevel = level;\n\n  const enabledNamespaces = [];\n  for (const logger of registeredLoggers) {\n    if (shouldEnable(logger)) {\n      enabledNamespaces.push(logger.namespace);\n    }\n  }\n\n  debug.enable(enabledNamespaces.join(\",\"));\n}\n\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n  return azureLogLevel;\n}\n\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100\n};\n\n/**\n * Defines the methods available on the SDK-facing logger.\n */\nexport interface AzureLogger {\n  /**\n   * Used for failures the program is unlikely to recover from,\n   * such as Out of Memory.\n   */\n  error: Debugger;\n  /**\n   * Used when a function fails to perform its intended task.\n   * Usually this means the function will throw an exception.\n   * Not used for self-healing events (e.g. automatic retry)\n   */\n  warning: Debugger;\n  /**\n   * Used when a function operates normally.\n   */\n  info: Debugger;\n  /**\n   * Used for detailed trbouleshooting scenarios. This is\n   * intended for use by developers / system administrators\n   * for diagnosing specific failures.\n   */\n  verbose: Debugger;\n}\n\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace The name of the SDK package.\n * @ignore\n */\nexport function createClientLogger(namespace: string): AzureLogger {\n  const clientRootLogger: AzureClientLogger = AzureLogger.extend(namespace);\n  patchLogMethod(AzureLogger, clientRootLogger);\n  return {\n    error: createLogger(clientRootLogger, \"error\"),\n    warning: createLogger(clientRootLogger, \"warning\"),\n    info: createLogger(clientRootLogger, \"info\"),\n    verbose: createLogger(clientRootLogger, \"verbose\")\n  };\n}\n\nfunction patchLogMethod(parent: AzureClientLogger, child: AzureClientLogger | AzureDebugger): void {\n  child.log = (...args) => {\n    parent.log(...args);\n  };\n}\n\nfunction createLogger(parent: AzureClientLogger, level: AzureLogLevel): AzureDebugger {\n  const logger: AzureDebugger = Object.assign(parent.extend(level), {\n    level\n  });\n\n  patchLogMethod(parent, logger);\n\n  if (shouldEnable(logger)) {\n    const enabledNamespaces = debug.disable();\n    debug.enable(enabledNamespaces + \",\" + logger.namespace);\n  }\n\n  registeredLoggers.add(logger);\n\n  return logger;\n}\n\nfunction shouldEnable(logger: AzureDebugger) {\n  if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isAzureLogLevel(logLevel: string): logLevel is AzureLogLevel {\n  return AZURE_LOG_LEVELS.includes(logLevel as any);\n}\n","import { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-http\");\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResource } from \"../webResource\";\nimport { URLBuilder, URLQuery } from \"../url\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\nimport { Debugger } from \"@azure/logger\";\nimport { logger as coreLogger, logger } from \"../log\";\n\nexport interface LogPolicyOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled. Defaults to\n   * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  allowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  allowedQueryParameters?: string[];\n}\n\n/**\n * Options to configure request/response logging.\n */\nexport interface LoggingOptions {\n  /**\n   * The Debugger (logger) instance to use for writing pipeline logs.\n   */\n  logger?: Debugger,\n\n  /**\n   * Options to pass to the logPolicy factory.\n   */\n  logPolicyOptions?: LogPolicyOptions\n}\n\nconst RedactedString = \"REDACTED\";\n\nconst defaultAllowedHeaderNames = [\n  \"x-ms-client-request-id\",\n  \"x-ms-return-client-request-id\",\n  \"traceparent\",\n\n  \"Accept\",\n  \"Cache-Control\",\n  \"Connection\",\n  \"Content-Length\",\n  \"Content-Type\",\n  \"Date\",\n  \"ETag\",\n  \"Expires\",\n  \"If-Match\",\n  \"If-Modified-Since\",\n  \"If-None-Match\",\n  \"If-Unmodified-Since\",\n  \"Last-Modified\",\n  \"Pragma\",\n  \"Request-Id\",\n  \"Retry-After\",\n  \"Server\",\n  \"Transfer-Encoding\",\n  \"User-Agent\"\n];\n\nconst defaultAllowedQueryParameters: string[] = [\n  \"api-version\"\n];\n\nexport const DefaultLoggingOptions: LoggingOptions = {\n  logger: undefined,\n  logPolicyOptions: {\n    allowedHeaderNames: [],      // These are empty lists because they are additive to\n    allowedQueryParameters: []   // the real defaultAllowed[HeaderNames|QueryParameters].\n  }\n}\n\nexport function logPolicy(\n  logger: any = coreLogger.info.bind(coreLogger),\n  logOptions: LogPolicyOptions = {}\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new LogPolicy(nextPolicy, options, logger, logOptions);\n    }\n  };\n}\n\nexport class LogPolicy extends BaseRequestPolicy {\n  logger?: any;\n\n  public allowedHeaderNames: Set<string>;\n  public allowedQueryParameters: Set<string>;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    logger: any = console.log,\n    { allowedHeaderNames = [], allowedQueryParameters = [] }: LogPolicyOptions = {}\n  ) {\n    super(nextPolicy, options);\n    this.logger = logger;\n\n    allowedHeaderNames =\n      allowedHeaderNames && allowedHeaderNames instanceof Array\n        ? defaultAllowedHeaderNames.concat(allowedHeaderNames)\n        : defaultAllowedHeaderNames;\n\n    allowedQueryParameters =\n      allowedQueryParameters && allowedQueryParameters instanceof Array\n        ? defaultAllowedQueryParameters.concat(allowedQueryParameters)\n        : defaultAllowedQueryParameters;\n\n    this.allowedHeaderNames = new Set(allowedHeaderNames);\n    this.allowedQueryParameters = new Set(allowedQueryParameters);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    if (!logger.info.enabled) return this._nextPolicy.sendRequest(request);\n\n    this.logRequest(request);\n    return this._nextPolicy.sendRequest(request).then((response) => this.logResponse(response));\n  }\n\n  private logRequest(request: WebResource) {\n    this.logger(`Request: ${JSON.stringify(request, this.sanitize.bind(this), 2)}`);\n  }\n\n  private sanitize(key: string, value: unknown) {\n    if (key === \"_headersMap\") {\n      return this.sanitizeHeaders(key, value as {});\n    } else if (key === \"url\") {\n      return this.sanitizeUrl(value as string);\n    } else if (key === \"query\") {\n      return this.sanitizeQuery(value as {});\n    } else if (key === \"body\") {\n      // Don't log the request body\n      return undefined;\n    } else if (key === \"response\") {\n      // Don't log response again\n      return undefined;\n    } else if (key === \"operationSpec\") {\n      // When using sendOperationRequest, the request carries a massive\n      // field with the autorest spec. No need to log it.\n      return undefined;\n    }\n\n    return value;\n  }\n\n  private sanitizeHeaders(_: string, value: { [s: string]: any }) {\n    return this.sanitizeObject(value, this.allowedHeaderNames, (v, k) => v[k].value);\n  }\n\n  private sanitizeQuery(value: { [s: string]: string }) {\n    return this.sanitizeObject(value, this.allowedQueryParameters, (v, k) => v[k]);\n  }\n\n  private sanitizeObject(\n    value: { [s: string]: any },\n    allowedKeys: Set<string>,\n    accessor: (value: any, key: string) => any\n  ) {\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n\n    const sanitized: { [s: string]: string } = {};\n\n    for (const k of Object.keys(value)) {\n      if (allowedKeys.has(k)) {\n        sanitized[k] = accessor(value, k);\n      } else {\n        sanitized[k] = RedactedString;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private sanitizeUrl(value: string): string {\n    if (typeof value !== \"string\" || value === null) {\n      return value;\n    }\n\n    const urlBuilder = URLBuilder.parse(value);\n    const queryString = urlBuilder.getQuery();\n\n    if (!queryString) {\n      return value;\n    }\n\n    const query = URLQuery.parse(queryString);\n    for (const k of query.keys()) {\n      if (!this.allowedQueryParameters.has(k)) {\n        query.set(k, RedactedString);\n      }\n    }\n\n    urlBuilder.setQuery(query.toString());\n    return urlBuilder.toString();\n  }\n\n  private logResponse(response: HttpOperationResponse): HttpOperationResponse {\n    this.logger(`Response status code: ${response.status}`);\n    this.logger(`Headers: ${JSON.stringify(response.headers, this.sanitize.bind(this), 2)}`);\n    return response;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { Mapper } from \"./serializer\";\n\nexport type ParameterPath = string | string[] | { [propertyName: string]: ParameterPath };\n\n/**\n * A common interface that all Operation parameter's extend.\n */\nexport interface OperationParameter {\n  /**\n   * The path to this parameter's value in OperationArguments or the object that contains paths for\n   * each property's value in OperationArguments.\n   */\n  parameterPath: ParameterPath;\n\n  /**\n   * The mapper that defines how to validate and serialize this parameter's value.\n   */\n  mapper: Mapper;\n}\n\n/**\n * A parameter for an operation that will be substituted into the operation's request URL.\n */\nexport interface OperationURLParameter extends OperationParameter {\n  /**\n   * Whether or not to skip encoding the URL parameter's value before adding it to the URL.\n   */\n  skipEncoding?: boolean;\n}\n\n/**\n * A parameter for an operation that will be added as a query parameter to the operation's HTTP\n * request.\n */\nexport interface OperationQueryParameter extends OperationParameter {\n  /**\n   * Whether or not to skip encoding the query parameter's value before adding it to the URL.\n   */\n  skipEncoding?: boolean;\n\n  /**\n   * If this query parameter's value is a collection, what type of format should the value be\n   * converted to.\n   */\n  collectionFormat?: QueryCollectionFormat;\n}\n\n/**\n * Get the path to this parameter's value as a dotted string (a.b.c).\n * @param parameter The parameter to get the path string for.\n * @returns The path to this parameter's value as a dotted string.\n */\nexport function getPathStringFromParameter(parameter: OperationParameter): string {\n  return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);\n}\n\nexport function getPathStringFromParameterPath(\n  parameterPath: ParameterPath,\n  mapper: Mapper\n): string {\n  let result: string;\n  if (typeof parameterPath === \"string\") {\n    result = parameterPath;\n  } else if (Array.isArray(parameterPath)) {\n    result = parameterPath.join(\".\");\n  } else {\n    result = mapper.serializedName!;\n  }\n  return result;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  OperationParameter,\n  OperationQueryParameter,\n  OperationURLParameter\n} from \"./operationParameter\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { MapperType, Serializer } from \"./serializer\";\nimport { HttpMethods } from \"./webResource\";\n\n/**\n * A specification that defines an operation.\n */\nexport interface OperationSpec {\n  /**\n   * The serializer to use in this operation.\n   */\n  readonly serializer: Serializer;\n\n  /**\n   * The HTTP method that should be used by requests for this operation.\n   */\n  readonly httpMethod: HttpMethods;\n\n  /**\n   * The URL that was provided in the service's specification. This will still have all of the URL\n   * template variables in it. If this is not provided when the OperationSpec is created, then it\n   * will be populated by a \"baseUri\" property on the ServiceClient.\n   */\n  readonly baseUrl?: string;\n\n  /**\n   * The fixed path for this operation's URL. This will still have all of the URL template variables\n   * in it.\n   */\n  readonly path?: string;\n\n  /**\n   * The content type of the request body. This value will be used as the \"Content-Type\" header if\n   * it is provided.\n   */\n  readonly contentType?: string;\n\n  /**\n   * The parameter that will be used to construct the HTTP request's body.\n   */\n  readonly requestBody?: OperationParameter;\n\n  /**\n   * Whether or not this operation uses XML request and response bodies.\n   */\n  readonly isXML?: boolean;\n\n  /**\n   * The parameters to the operation method that will be substituted into the constructed URL.\n   */\n  readonly urlParameters?: ReadonlyArray<OperationURLParameter>;\n\n  /**\n   * The parameters to the operation method that will be added to the constructed URL's query.\n   */\n  readonly queryParameters?: ReadonlyArray<OperationQueryParameter>;\n\n  /**\n   * The parameters to the operation method that will be converted to headers on the operation's\n   * HTTP request.\n   */\n  readonly headerParameters?: ReadonlyArray<OperationParameter>;\n\n  /**\n   * The parameters to the operation method that will be used to create a formdata body for the\n   * operation's HTTP request.\n   */\n  readonly formDataParameters?: ReadonlyArray<OperationParameter>;\n\n  /**\n   * The different types of responses that this operation can return based on what status code is\n   * returned.\n   */\n  readonly responses: { [responseCode: string]: OperationResponse };\n}\n\nexport function isStreamOperation(operationSpec: OperationSpec): boolean {\n  let result = false;\n  for (const statusCode in operationSpec.responses) {\n    const operationResponse: OperationResponse = operationSpec.responses[statusCode];\n    if (\n      operationResponse.bodyMapper &&\n      operationResponse.bodyMapper.type.name === MapperType.Stream\n    ) {\n      result = true;\n      break;\n    }\n  }\n  return result;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n// tslint:disable-next-line:no-null-keyword\nconst doc = document.implementation.createDocument(null, null, null);\n\nconst parser = new DOMParser();\nexport function parseXML(str: string, opts?: { includeRoot?: boolean }): Promise<any> {\n  try {\n    const dom = parser.parseFromString(str, \"application/xml\");\n    throwIfError(dom);\n\n    let obj;\n    if (opts && opts.includeRoot) {\n      obj = domToObject(dom);\n    } else {\n      obj = domToObject(dom.childNodes[0]);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS = \"\";\ntry {\n  errorNS = parser.parseFromString(\"INVALID\", \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n    .namespaceURI!;\n} catch (ignored) {\n  // Most browsers will return a document containing <parsererror>, but IE will throw.\n}\n\nfunction throwIfError(dom: Document) {\n  if (errorNS) {\n    const parserErrors = dom.getElementsByTagNameNS(errorNS, \"parsererror\");\n    if (parserErrors.length) {\n      throw new Error(parserErrors.item(0)!.innerHTML);\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[\"$\"] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[\"$\"][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[\"_\"] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject: any = domToObject(child);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nconst serializer = new XMLSerializer();\n\nexport function stringifyXML(content: any, opts?: { rootName?: string }): string {\n  const rootName = (opts && opts.rootName) || \"root\";\n  const dom = buildNode(content, rootName)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom)\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string): Node[] {\n  if (\n    obj == undefined ||\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\"\n  ) {\n    const elem = doc.createElement(elementName);\n    elem.textContent = obj == undefined ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = doc.createElement(elementName);\n    for (const key of Object.keys(obj)) {\n      if (key === \"$\") {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === \"_\") {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (const child of buildNode(obj[key], key)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { OperationResponse } from \"../operationResponse\";\nimport { OperationSpec, isStreamOperation } from \"../operationSpec\";\nimport { RestError } from \"../restError\";\nimport { Mapper, MapperType } from \"../serializer\";\nimport * as utils from \"../util/utils\";\nimport { parseXML } from \"../util/xml\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\n/**\n * Options to configure API response deserialization.\n */\nexport interface DeserializationOptions {\n  /**\n   * Configures the expected content types for the deserialization of\n   * JSON and XML response bodies.\n   */\n  expectedContentTypes: DeserializationContentTypes;\n}\n\n/**\n * The content-types that will indicate that an operation response should be deserialized in a\n * particular way.\n */\nexport interface DeserializationContentTypes {\n  /**\n   * The content-types that indicate that an operation response should be deserialized as JSON.\n   * Defaults to [ \"application/json\", \"text/json\" ].\n   */\n  json?: string[];\n\n  /**\n   * The content-types that indicate that an operation response should be deserialized as XML.\n   * Defaults to [ \"application/xml\", \"application/atom+xml\" ].\n   */\n  xml?: string[];\n}\n\n/**\n * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they\n * pass through the HTTP pipeline.\n */\nexport function deserializationPolicy(\n  deserializationContentTypes?: DeserializationContentTypes\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new DeserializationPolicy(nextPolicy, deserializationContentTypes, options);\n    }\n  };\n}\n\nexport const defaultJsonContentTypes = [\"application/json\", \"text/json\", \"text/plain\"];\nexport const defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n\nexport const DefaultDeserializationOptions: DeserializationOptions = {\n  expectedContentTypes: {\n    json: defaultJsonContentTypes,\n    xml: defaultXmlContentTypes\n  }\n};\n\n/**\n * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the\n * HTTP pipeline.\n */\nexport class DeserializationPolicy extends BaseRequestPolicy {\n  public readonly jsonContentTypes: string[];\n  public readonly xmlContentTypes: string[];\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    deserializationContentTypes: DeserializationContentTypes | undefined,\n    options: RequestPolicyOptions\n  ) {\n    super(nextPolicy, options);\n\n    this.jsonContentTypes =\n      (deserializationContentTypes && deserializationContentTypes.json) || defaultJsonContentTypes;\n    this.xmlContentTypes =\n      (deserializationContentTypes && deserializationContentTypes.xml) || defaultXmlContentTypes;\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request)\n      .then((response: HttpOperationResponse) =>\n        deserializeResponseBody(this.jsonContentTypes, this.xmlContentTypes, response)\n      );\n  }\n}\n\nfunction getOperationResponse(\n  parsedResponse: HttpOperationResponse\n): undefined | OperationResponse {\n  let result: OperationResponse | undefined;\n  const request: WebResource = parsedResponse.request;\n  const operationSpec: OperationSpec | undefined = request.operationSpec;\n  if (operationSpec) {\n    const operationResponseGetter:\n      | undefined\n      | ((\n          operationSpec: OperationSpec,\n          response: HttpOperationResponse\n        ) => undefined | OperationResponse) = request.operationResponseGetter;\n    if (!operationResponseGetter) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\n\nfunction shouldDeserializeResponse(parsedResponse: HttpOperationResponse): boolean {\n  const shouldDeserialize: undefined | boolean | ((response: HttpOperationResponse) => boolean) =\n    parsedResponse.request.shouldDeserialize;\n  let result: boolean;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\n\nexport function deserializeResponseBody(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  response: HttpOperationResponse\n): Promise<HttpOperationResponse> {\n  return parse(jsonContentTypes, xmlContentTypes, response).then((parsedResponse) => {\n    const shouldDeserialize: boolean = shouldDeserializeResponse(parsedResponse);\n    if (shouldDeserialize) {\n      const operationSpec: OperationSpec | undefined = parsedResponse.request.operationSpec;\n      if (operationSpec && operationSpec.responses) {\n        const statusCode: number = parsedResponse.status;\n\n        const expectedStatusCodes: string[] = Object.keys(operationSpec.responses);\n\n        const hasNoExpectedStatusCodes: boolean =\n          expectedStatusCodes.length === 0 ||\n          (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\");\n\n        const responseSpec: OperationResponse | undefined = getOperationResponse(parsedResponse);\n\n        const isExpectedStatusCode: boolean = hasNoExpectedStatusCodes\n          ? 200 <= statusCode && statusCode < 300\n          : !!responseSpec;\n        if (!isExpectedStatusCode) {\n          const defaultResponseSpec: OperationResponse = operationSpec.responses.default;\n          if (defaultResponseSpec) {\n            const initialErrorMessage: string = isStreamOperation(operationSpec)\n              ? `Unexpected status code: ${statusCode}`\n              : (parsedResponse.bodyAsText as string);\n\n            const error = new RestError(initialErrorMessage);\n            error.statusCode = statusCode;\n            error.request = utils.stripRequest(parsedResponse.request);\n            error.response = utils.stripResponse(parsedResponse);\n\n            let parsedErrorResponse: { [key: string]: any } = parsedResponse.parsedBody;\n            try {\n              if (parsedErrorResponse) {\n                const defaultResponseBodyMapper: Mapper | undefined =\n                  defaultResponseSpec.bodyMapper;\n                if (\n                  defaultResponseBodyMapper &&\n                  defaultResponseBodyMapper.serializedName === \"CloudError\"\n                ) {\n                  if (parsedErrorResponse.error) {\n                    parsedErrorResponse = parsedErrorResponse.error;\n                  }\n                  if (parsedErrorResponse.code) {\n                    error.code = parsedErrorResponse.code;\n                  }\n                  if (parsedErrorResponse.message) {\n                    error.message = parsedErrorResponse.message;\n                  }\n                } else {\n                  let internalError: any = parsedErrorResponse;\n                  if (parsedErrorResponse.error) {\n                    internalError = parsedErrorResponse.error;\n                  }\n\n                  error.code = internalError.code;\n                  if (internalError.message) {\n                    error.message = internalError.message;\n                  }\n                }\n\n                if (defaultResponseBodyMapper) {\n                  let valueToDeserialize: any = parsedErrorResponse;\n                  if (\n                    operationSpec.isXML &&\n                    defaultResponseBodyMapper.type.name === MapperType.Sequence\n                  ) {\n                    valueToDeserialize =\n                      typeof parsedErrorResponse === \"object\"\n                        ? parsedErrorResponse[defaultResponseBodyMapper.xmlElementName!]\n                        : [];\n                  }\n                  error.response!.parsedBody = operationSpec.serializer.deserialize(\n                    defaultResponseBodyMapper,\n                    valueToDeserialize,\n                    \"error.response.parsedBody\"\n                  );\n                }\n              }\n\n              if (parsedResponse.headers && defaultResponseSpec.headersMapper) {\n                error.response!.parsedHeaders = operationSpec.serializer.deserialize(\n                  defaultResponseSpec.headersMapper,\n                  parsedResponse.headers.rawHeaders(),\n                  \"operationRes.parsedHeaders\"\n                );\n              }\n            } catch (defaultError) {\n              error.message = `Error \\\"${defaultError.message}\\\" occurred in deserializing the responseBody - \\\"${parsedResponse.bodyAsText}\\\" for the default response.`;\n            }\n            return Promise.reject(error);\n          }\n        } else if (responseSpec) {\n          if (responseSpec.bodyMapper) {\n            let valueToDeserialize: any = parsedResponse.parsedBody;\n            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {\n              valueToDeserialize =\n                typeof valueToDeserialize === \"object\"\n                  ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName!]\n                  : [];\n            }\n            try {\n              parsedResponse.parsedBody = operationSpec.serializer.deserialize(\n                responseSpec.bodyMapper,\n                valueToDeserialize,\n                \"operationRes.parsedBody\"\n              );\n            } catch (error) {\n              const restError = new RestError(\n                `Error ${error} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`\n              );\n              restError.request = utils.stripRequest(parsedResponse.request);\n              restError.response = utils.stripResponse(parsedResponse);\n              return Promise.reject(restError);\n            }\n          } else if (operationSpec.httpMethod === \"HEAD\") {\n            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n          }\n\n          if (responseSpec.headersMapper) {\n            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(\n              responseSpec.headersMapper,\n              parsedResponse.headers.rawHeaders(),\n              \"operationRes.parsedHeaders\"\n            );\n          }\n        }\n      }\n    }\n    return Promise.resolve(parsedResponse);\n  });\n}\n\nfunction parse(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  operationResponse: HttpOperationResponse\n): Promise<HttpOperationResponse> {\n  const errorHandler = (err: Error & { code: string }) => {\n    const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n    const errCode = err.code || RestError.PARSE_ERROR;\n    const e = new RestError(\n      msg,\n      errCode,\n      operationResponse.status,\n      operationResponse.request,\n      operationResponse\n    );\n    return Promise.reject(e);\n  };\n\n  if (!operationResponse.request.streamResponseBody && operationResponse.bodyAsText) {\n    const text = operationResponse.bodyAsText;\n    const contentType: string = operationResponse.headers.get(\"Content-Type\") || \"\";\n    const contentComponents: string[] = !contentType\n      ? []\n      : contentType.split(\";\").map((component) => component.toLowerCase());\n    if (\n      contentComponents.length === 0 ||\n      contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)\n    ) {\n      return new Promise<HttpOperationResponse>((resolve) => {\n        operationResponse.parsedBody = JSON.parse(text);\n        resolve(operationResponse);\n      }).catch(errorHandler);\n    } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n      return parseXML(text)\n        .then((body) => {\n          operationResponse.parsedBody = body;\n          return operationResponse;\n        })\n        .catch(errorHandler);\n    }\n  }\n\n  return Promise.resolve(operationResponse);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\nimport { RestError } from \"../restError\";\nimport { logger } from \"../log\";\n\nexport interface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\nexport interface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\nexport function exponentialRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ExponentialRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        maxRetryInterval\n      );\n    }\n  };\n}\n\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nconst DEFAULT_CLIENT_RETRY_COUNT = 3;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n * @enum RetryMode\n */\nexport enum RetryMode {\n  Exponential\n}\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface RetryOptions {\n  /**\n   * The maximum number of retry attempts.  Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 30000\n   * (30 seconds). The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 90000 (90 seconds).\n   */\n  maxRetryDelayInMs?: number;\n\n  /**\n   * Currently supporting only Exponential mode.\n   */\n  mode?: RetryMode;\n}\n\nexport const DefaultRetryOptions: RetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n}\n\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * The client retry count.\n   */\n  retryCount: number;\n  /**\n   * The client retry interval in milliseconds.\n   */\n  retryInterval: number;\n  /**\n   * The maximum retry interval in milliseconds.\n   */\n  maxRetryInterval: number;\n\n  /**\n   * @constructor\n   * @param {RequestPolicy} nextPolicy The next RequestPolicy in the pipeline chain.\n   * @param {RequestPolicyOptions} options The options for this RequestPolicy.\n   * @param {number} [retryCount]        The client retry count.\n   * @param {number} [retryInterval]     The client retry interval, in milliseconds.\n   * @param {number} [minRetryInterval]  The minimum retry interval, in milliseconds.\n   * @param {number} [maxRetryInterval]  The maximum retry interval, in milliseconds.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    function isNumber(n: any): n is number {\n      return typeof n === \"number\";\n    }\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval)\n      ? maxRetryInterval\n      : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => retry(this, request, response))\n      .catch((error) => retry(this, request, error.response, undefined, error));\n  }\n}\n\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\nfunction shouldRetry(\n  policy: ExponentialRetryPolicy,\n  statusCode: number | undefined,\n  retryData: RetryData\n): boolean {\n  if (\n    statusCode == undefined ||\n    (statusCode < 500 && statusCode !== 408) ||\n    statusCode === 501 ||\n    statusCode === 505\n  ) {\n    return false;\n  }\n\n  let currentCount: number;\n  if (!retryData) {\n    throw new Error(\"retryData for the ExponentialRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n\n  return currentCount < policy.retryCount;\n}\n\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {RetryData} retryData  The retry data.\n * @param {RetryError} [err] The operation\"s error, if any.\n */\nfunction updateRetryData(\n  policy: ExponentialRetryPolicy,\n  retryData?: RetryData,\n  err?: RetryError\n): RetryData {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  }\n\n  // Adjust retry count\n  retryData.retryCount++;\n\n  // Adjust retry interval\n  let incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  const boundedRandDelta =\n    policy.retryInterval * 0.8 +\n    Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n  incrementDelta *= boundedRandDelta;\n\n  retryData.retryInterval = Math.min(\n    incrementDelta,\n    policy.maxRetryInterval\n  );\n\n  return retryData;\n}\n\nfunction retry(\n  policy: ExponentialRetryPolicy,\n  request: WebResource,\n  response?: HttpOperationResponse,\n  retryData?: RetryData,\n  requestError?: RetryError\n): Promise<HttpOperationResponse> {\n  retryData = updateRetryData(policy, retryData, requestError);\n  const isAborted: boolean | undefined = request.abortSignal && request.abortSignal.aborted;\n  if (!isAborted && shouldRetry(policy, response && response.status, retryData)) {\n    logger.info(`Retrying request in ${retryData.retryInterval}`);\n    return utils\n      .delay(retryData.retryInterval)\n      .then(() => policy._nextPolicy.sendRequest(request.clone()))\n      .then((res) => retry(policy, request, res, retryData, undefined))\n      .catch((err) => retry(policy, request, response, retryData, err));\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    const err =\n      retryData.error ||\n      new RestError(\n        \"Failed to send the request.\",\n        RestError.REQUEST_SEND_ERROR,\n        response && response.status,\n        response && response.request,\n        response\n      );\n    return Promise.reject(err);\n  } else {\n    return Promise.resolve(response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport function generateClientRequestIdPolicy(\n  requestIdHeaderName = \"x-ms-client-request-id\"\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);\n    }\n  };\n}\n\nexport class GenerateClientRequestIdPolicy extends BaseRequestPolicy {\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private _requestIdHeaderName: string\n  ) {\n    super(nextPolicy, options);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    if (!request.headers.contains(this._requestIdHeaderName)) {\n      request.headers.set(this._requestIdHeaderName, utils.generateUuid());\n    }\n    return this._nextPolicy.sendRequest(request);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/*\n * NOTE: When moving this file, please update \"browser\" section in package.json\n * and \"plugins\" section in webpack.testconfig.ts.\n */\n\nimport { TelemetryInfo } from \"./userAgentPolicy\";\n\ninterface NavigatorEx extends Navigator {\n  // oscpu is not yet standards-compliant, but can not be undefined in TypeScript 3.6.2\n  readonly oscpu: string;\n}\n\nexport function getDefaultUserAgentKey(): string {\n  return \"x-ms-command-name\";\n}\n\nexport function getPlatformSpecificData(): TelemetryInfo[] {\n  const navigator = window.navigator as NavigatorEx;\n  const osInfo = {\n    key: \"OS\",\n    value: (navigator.oscpu || navigator.platform).replace(\" \", \"\")\n  };\n\n  return [osInfo];\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { Constants } from \"../util/constants\";\nimport { WebResource } from \"../webResource\";\nimport { getDefaultUserAgentKey, getPlatformSpecificData } from \"./msRestUserAgentPolicy\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport type TelemetryInfo = { key?: string; value?: string };\n\n/**\n * Options for adding user agent details to outgoing requests.\n */\nexport interface UserAgentOptions {\n  /*\n   * String prefix to add to the user agent for outgoing requests.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\nfunction getRuntimeInfo(): TelemetryInfo[] {\n  const msRestRuntime = {\n    key: \"core-http\",\n    value: Constants.coreHttpVersion\n  };\n\n  return [msRestRuntime];\n}\n\nfunction getUserAgentString(\n  telemetryInfo: TelemetryInfo[],\n  keySeparator = \" \",\n  valueSeparator = \"/\"\n): string {\n  return telemetryInfo\n    .map((info) => {\n      const value = info.value ? `${valueSeparator}${info.value}` : \"\";\n      return `${info.key}${value}`;\n    })\n    .join(keySeparator);\n}\n\nexport const getDefaultUserAgentHeaderName = getDefaultUserAgentKey;\n\nexport function getDefaultUserAgentValue(): string {\n  const runtimeInfo = getRuntimeInfo();\n  const platformSpecificData = getPlatformSpecificData();\n  const userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));\n  return userAgent;\n}\n\nexport function userAgentPolicy(userAgentData?: TelemetryInfo): RequestPolicyFactory {\n  const key: string =\n    !userAgentData || userAgentData.key == undefined ? getDefaultUserAgentKey() : userAgentData.key;\n  const value: string =\n    !userAgentData || userAgentData.value == undefined\n      ? getDefaultUserAgentValue()\n      : userAgentData.value;\n\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new UserAgentPolicy(nextPolicy, options, key, value);\n    }\n  };\n}\n\nexport class UserAgentPolicy extends BaseRequestPolicy {\n  constructor(\n    readonly _nextPolicy: RequestPolicy,\n    readonly _options: RequestPolicyOptions,\n    protected headerKey: string,\n    protected headerValue: string\n  ) {\n    super(_nextPolicy, _options);\n  }\n\n  sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    this.addUserAgentHeader(request);\n    return this._nextPolicy.sendRequest(request);\n  }\n\n  addUserAgentHeader(request: WebResource): void {\n    if (!request.headers) {\n      request.headers = new HttpHeaders();\n    }\n\n    if (!request.headers.get(this.headerKey) && this.headerValue) {\n      request.headers.set(this.headerKey, this.headerValue);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { URLBuilder } from \"../url\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\n/**\n * Options for how redirect responses are handled.\n */\nexport interface RedirectOptions {\n  /*\n   * When true, redirect responses are followed.  Defaults to true.\n   */\n  handleRedirects: boolean;\n\n  /*\n   * The maximum number of times the redirect URL will be tried before\n   * failing.  Defaults to 20.\n   */\n  maxRetries?: number;\n}\n\nexport const DefaultRedirectOptions: RedirectOptions = {\n  handleRedirects: true,\n  maxRetries: 20\n}\n\nexport function redirectPolicy(maximumRetries = 20): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new RedirectPolicy(nextPolicy, options, maximumRetries);\n    }\n  };\n}\n\nexport class RedirectPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, readonly maxRetries = 20) {\n    super(nextPolicy, options);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request)\n      .then((response) => handleRedirect(this, response, 0));\n  }\n}\n\nfunction handleRedirect(\n  policy: RedirectPolicy,\n  response: HttpOperationResponse,\n  currentRetries: number\n): Promise<HttpOperationResponse> {\n  const { request, status } = response;\n  const locationHeader = response.headers.get(\"location\");\n  if (\n    locationHeader &&\n    (status === 300 || status === 307 || (status === 303 && request.method === \"POST\")) &&\n    (!policy.maxRetries || currentRetries < policy.maxRetries)\n  ) {\n    const builder = URLBuilder.parse(request.url);\n    builder.setPath(locationHeader);\n    request.url = builder.toString();\n\n    // POST request with Status code 303 should be converted into a\n    // redirected GET request if the redirect url is present in the location header\n    if (status === 303) {\n      request.method = \"GET\";\n    }\n\n    return policy._nextPolicy\n      .sendRequest(request)\n      .then((res) => handleRedirect(policy, res, currentRetries + 1));\n  }\n\n  return Promise.resolve(response);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport function rpRegistrationPolicy(retryTimeout = 30): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);\n    }\n  };\n}\n\nexport class RPRegistrationPolicy extends BaseRequestPolicy {\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    readonly _retryTimeout = 30\n  ) {\n    super(nextPolicy, options);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => registerIfNeeded(this, request, response));\n  }\n}\n\nfunction registerIfNeeded(\n  policy: RPRegistrationPolicy,\n  request: WebResource,\n  response: HttpOperationResponse\n): Promise<HttpOperationResponse> {\n  if (response.status === 409) {\n    const rpName = checkRPNotRegisteredError(response.bodyAsText as string);\n    if (rpName) {\n      const urlPrefix = extractSubscriptionUrl(request.url);\n      return (\n        registerRP(policy, urlPrefix, rpName, request)\n          // Autoregistration of ${provider} failed for some reason. We will not return this error\n          // instead will return the initial response with 409 status code back to the user.\n          // do nothing here as we are returning the original response at the end of this method.\n          .catch(() => false)\n          .then((registrationStatus) => {\n            if (registrationStatus) {\n              // Retry the original request. We have to change the x-ms-client-request-id\n              // otherwise Azure endpoint will return the initial 409 (cached) response.\n              request.headers.set(\"x-ms-client-request-id\", utils.generateUuid());\n              return policy._nextPolicy.sendRequest(request.clone());\n            }\n            return response;\n          })\n      );\n    }\n  }\n\n  return Promise.resolve(response);\n}\n\n/**\n * Reuses the headers of the original request and url (if specified).\n * @param {WebResource} originalRequest The original request\n * @param {boolean} reuseUrlToo Should the url from the original request be reused as well. Default false.\n * @returns {object} A new request object with desired headers.\n */\nfunction getRequestEssentials(originalRequest: WebResource, reuseUrlToo = false): WebResource {\n  const reqOptions: WebResource = originalRequest.clone();\n  if (reuseUrlToo) {\n    reqOptions.url = originalRequest.url;\n  }\n\n  // We have to change the x-ms-client-request-id otherwise Azure endpoint\n  // will return the initial 409 (cached) response.\n  reqOptions.headers.set(\"x-ms-client-request-id\", utils.generateUuid());\n\n  // Set content-type to application/json\n  reqOptions.headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n\n  return reqOptions;\n}\n\n/**\n * Validates the error code and message associated with 409 response status code. If it matches to that of\n * RP not registered then it returns the name of the RP else returns undefined.\n * @param {string} body The response body received after making the original request.\n * @returns {string} The name of the RP if condition is satisfied else undefined.\n */\nfunction checkRPNotRegisteredError(body: string): string {\n  let result, responseBody;\n  if (body) {\n    try {\n      responseBody = JSON.parse(body);\n    } catch (err) {\n      // do nothing;\n    }\n    if (\n      responseBody &&\n      responseBody.error &&\n      responseBody.error.message &&\n      responseBody.error.code &&\n      responseBody.error.code === \"MissingSubscriptionRegistration\"\n    ) {\n      const matchRes = responseBody.error.message.match(/.*'(.*)'/i);\n      if (matchRes) {\n        result = matchRes.pop();\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Extracts the first part of the URL, just after subscription:\n * https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/\n * @param {string} url The original request url\n * @returns {string} The url prefix as explained above.\n */\nfunction extractSubscriptionUrl(url: string): string {\n  let result;\n  const matchRes = url.match(/.*\\/subscriptions\\/[a-f0-9-]+\\//gi);\n  if (matchRes && matchRes[0]) {\n    result = matchRes[0];\n  } else {\n    throw new Error(`Unable to extract subscriptionId from the given url - ${url}.`);\n  }\n  return result;\n}\n\n/**\n * Registers the given provider.\n * @param {RPRegistrationPolicy} policy The RPRegistrationPolicy this function is being called against.\n * @param {string} urlPrefix https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/\n * @param {string} provider The provider name to be registered.\n * @param {WebResource} originalRequest The original request sent by the user that returned a 409 response\n * with a message that the provider is not registered.\n * @param {registrationCallback} callback The callback that handles the RP registration\n */\nfunction registerRP(\n  policy: RPRegistrationPolicy,\n  urlPrefix: string,\n  provider: string,\n  originalRequest: WebResource\n): Promise<boolean> {\n  const postUrl = `${urlPrefix}providers/${provider}/register?api-version=2016-02-01`;\n  const getUrl = `${urlPrefix}providers/${provider}?api-version=2016-02-01`;\n  const reqOptions = getRequestEssentials(originalRequest);\n  reqOptions.method = \"POST\";\n  reqOptions.url = postUrl;\n\n  return policy._nextPolicy.sendRequest(reqOptions).then((response) => {\n    if (response.status !== 200) {\n      throw new Error(`Autoregistration of ${provider} failed. Please try registering manually.`);\n    }\n    return getRegistrationStatus(policy, getUrl, originalRequest);\n  });\n}\n\n/**\n * Polls the registration status of the provider that was registered. Polling happens at an interval of 30 seconds.\n * Polling will happen till the registrationState property of the response body is \"Registered\".\n * @param {RPRegistrationPolicy} policy The RPRegistrationPolicy this function is being called against.\n * @param {string} url The request url for polling\n * @param {WebResource} originalRequest The original request sent by the user that returned a 409 response\n * with a message that the provider is not registered.\n * @returns {Promise<boolean>} True if RP Registration is successful.\n */\nfunction getRegistrationStatus(\n  policy: RPRegistrationPolicy,\n  url: string,\n  originalRequest: WebResource\n): Promise<boolean> {\n  const reqOptions: any = getRequestEssentials(originalRequest);\n  reqOptions.url = url;\n  reqOptions.method = \"GET\";\n\n  return policy._nextPolicy.sendRequest(reqOptions).then((res) => {\n    const obj = res.parsedBody as any;\n    if (res.parsedBody && obj.registrationState && obj.registrationState === \"Registered\") {\n      return true;\n    } else {\n      return utils\n        .delay(policy._retryTimeout * 1000)\n        .then(() => getRegistrationStatus(policy, url, originalRequest));\n    }\n  });\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AccessToken } from \"@azure/core-auth\";\n\n/**\n * Defines the default token refresh buffer duration.\n */\nexport const TokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes\n\n/**\n * Provides a cache for an AccessToken that was that\n * was returned from a TokenCredential.\n */\nexport interface AccessTokenCache {\n  /**\n   * Sets the cached token.\n   *\n   * @param The {@link AccessToken} to be cached or null to\n   *        clear the cached token.\n   */\n  setCachedToken(accessToken: AccessToken | undefined): void;\n\n  /**\n   * Returns the cached {@link AccessToken} or undefined if nothing is cached.\n   */\n  getCachedToken(): AccessToken | undefined;\n}\n\n/**\n * Provides an {@link AccessTokenCache} implementation which clears\n * the cached {@link AccessToken}'s after the expiresOnTimestamp has\n * passed.\n */\nexport class ExpiringAccessTokenCache implements AccessTokenCache {\n  private tokenRefreshBufferMs: number;\n  private cachedToken?: AccessToken = undefined;\n\n  /**\n   * Constructs an instance of {@link ExpiringAccessTokenCache} with\n   * an optional expiration buffer time.\n   */\n  constructor(tokenRefreshBufferMs: number = TokenRefreshBufferMs) {\n    this.tokenRefreshBufferMs = tokenRefreshBufferMs;\n  }\n\n  setCachedToken(accessToken: AccessToken | undefined): void {\n    this.cachedToken = accessToken;\n  }\n\n  getCachedToken(): AccessToken | undefined {\n    if (\n      this.cachedToken &&\n      Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp\n    ) {\n      this.cachedToken = undefined;\n    }\n\n    return this.cachedToken;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { TokenCredential, GetTokenOptions } from \"@azure/core-auth\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"../policies/requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { WebResource } from \"../webResource\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"../credentials/accessTokenCache\";\n\n/**\n * Creates a new BearerTokenAuthenticationPolicy factory.\n *\n * @param credential The TokenCredential implementation that can supply the bearer token.\n * @param scopes The scopes for which the bearer token applies.\n */\nexport function bearerTokenAuthenticationPolicy(\n  credential: TokenCredential,\n  scopes: string | string[]\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new BearerTokenAuthenticationPolicy(\n        nextPolicy,\n        options,\n        credential,\n        scopes,\n        tokenCache\n      );\n    }\n  };\n}\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {\n  /**\n   * Creates a new BearerTokenAuthenticationPolicy object.\n   *\n   * @param nextPolicy The next RequestPolicy in the request pipeline.\n   * @param options Options for this RequestPolicy.\n   * @param credential The TokenCredential implementation that can supply the bearer token.\n   * @param scopes The scopes for which the bearer token applies.\n   * @param tokenCache The cache for the most recent AccessToken returned from the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private credential: TokenCredential,\n    private scopes: string | string[],\n    private tokenCache: AccessTokenCache\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   * @param webResource\n   */\n  public async sendRequest(webResource: WebResource): Promise<HttpOperationResponse> {\n    if (!webResource.headers) webResource.headers = new HttpHeaders();\n    const token = await this.getToken({\n      abortSignal: webResource.abortSignal,\n      spanOptions: webResource.spanOptions\n    });\n    webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  private async getToken(options: GetTokenOptions): Promise<string | undefined> {\n    let accessToken = this.tokenCache.getCachedToken();\n    if (accessToken === undefined) {\n      accessToken = (await this.credential.getToken(this.scopes, options)) || undefined;\n      this.tokenCache.setCachedToken(accessToken);\n    }\n\n    return accessToken ? accessToken.token : undefined;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport interface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\nexport interface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\nexport function systemErrorRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  minRetryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new SystemErrorRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        minRetryInterval,\n        maxRetryInterval\n      );\n    }\n  };\n}\n\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n *\n * @constructor\n * @param {number} retryCount        The client retry count.\n * @param {number} retryInterval     The client retry interval, in milliseconds.\n * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.\n * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.\n */\nexport class SystemErrorRetryPolicy extends BaseRequestPolicy {\n  retryCount: number;\n  retryInterval: number;\n  minRetryInterval: number;\n  maxRetryInterval: number;\n  DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\n  DEFAULT_CLIENT_RETRY_COUNT = 3;\n  DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n  DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    minRetryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    this.retryCount = typeof retryCount === \"number\" ? retryCount : this.DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval =\n      typeof retryInterval === \"number\" ? retryInterval : this.DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.minRetryInterval =\n      typeof minRetryInterval === \"number\"\n        ? minRetryInterval\n        : this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    this.maxRetryInterval =\n      typeof maxRetryInterval === \"number\"\n        ? maxRetryInterval\n        : this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => retry(this, request, response));\n  }\n}\n\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\nfunction shouldRetry(policy: SystemErrorRetryPolicy, retryData: RetryData): boolean {\n  let currentCount;\n  if (!retryData) {\n    throw new Error(\"retryData for the SystemErrorRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n  return currentCount < policy.retryCount;\n}\n\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {RetryData} retryData  The retry data.\n * @param {object} err        The operation\"s error, if any.\n */\nfunction updateRetryData(\n  policy: SystemErrorRetryPolicy,\n  retryData?: RetryData,\n  err?: RetryError\n): RetryData {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  }\n\n  // Adjust retry count\n  retryData.retryCount++;\n\n  // Adjust retry interval\n  let incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  const boundedRandDelta =\n    policy.retryInterval * 0.8 +\n    Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n  incrementDelta *= boundedRandDelta;\n\n  retryData.retryInterval = Math.min(\n    policy.minRetryInterval + incrementDelta,\n    policy.maxRetryInterval\n  );\n\n  return retryData;\n}\n\nfunction retry(\n  policy: SystemErrorRetryPolicy,\n  request: WebResource,\n  operationResponse: HttpOperationResponse,\n  retryData?: RetryData,\n  err?: RetryError\n): Promise<HttpOperationResponse> {\n  retryData = updateRetryData(policy, retryData, err);\n  if (\n    err &&\n    err.code &&\n    shouldRetry(policy, retryData) &&\n    (err.code === \"ETIMEDOUT\" ||\n      err.code === \"ESOCKETTIMEDOUT\" ||\n      err.code === \"ECONNREFUSED\" ||\n      err.code === \"ECONNRESET\" ||\n      err.code === \"ENOENT\")\n  ) {\n    // If previous operation ended with an error and the policy allows a retry, do that\n    return utils\n      .delay(retryData.retryInterval)\n      .then(() => policy._nextPolicy.sendRequest(request.clone()))\n      .then((res) => retry(policy, request, res, retryData, err))\n      .catch((err) => retry(policy, request, operationResponse, retryData, err));\n  } else {\n    if (err != undefined) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      err = retryData.error;\n      return Promise.reject(err);\n    }\n    return Promise.resolve(operationResponse);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * The format that will be used to join an array of values together for a query parameter value.\n */\nexport enum QueryCollectionFormat {\n  Csv = \",\",\n  Ssv = \" \",\n  Tsv = \"\\t\",\n  Pipes = \"|\",\n  Multi = \"Multi\"\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { ProxySettings } from \"../serviceClient\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResource } from \"../webResource\";\n\nconst proxyNotSupportedInBrowser = new Error(\"ProxyPolicy is not supported in browser environment\");\n\nexport function getDefaultProxySettings(_proxyUrl?: string): ProxySettings | undefined {\n  return undefined;\n}\n\nexport function proxyPolicy(_proxySettings?: ProxySettings): RequestPolicyFactory {\n  return {\n    create: (_nextPolicy: RequestPolicy, _options: RequestPolicyOptions) => {\n      throw proxyNotSupportedInBrowser;\n    }\n  };\n}\n\nexport class ProxyPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n    super(nextPolicy, options);\n    throw proxyNotSupportedInBrowser;\n  }\n\n  public sendRequest(_request: WebResource): Promise<HttpOperationResponse> {\n    throw proxyNotSupportedInBrowser;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"./requestPolicy\";\nimport { WebResource } from \"../webResource\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/utils\";\n\ntype ResponseHandler = (\n  httpRequest: WebResource,\n  response: HttpOperationResponse\n) => Promise<HttpOperationResponse>;\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n\nexport function throttlingRetryPolicy(): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\n\n/**\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  private _handleResponse: ResponseHandler;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    _handleResponse?: ResponseHandler\n  ) {\n    super(nextPolicy, options);\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n\n  public async sendRequest(httpRequest: WebResource): Promise<HttpOperationResponse> {\n    return this._nextPolicy.sendRequest(httpRequest.clone()).then((response) => {\n      if (response.status !== StatusCodes.TooManyRequests) {\n        return response;\n      } else {\n        return this._handleResponse(httpRequest, response);\n      }\n    });\n  }\n\n  private async _defaultResponseHandler(\n    httpRequest: WebResource,\n    httpResponse: HttpOperationResponse\n  ): Promise<HttpOperationResponse> {\n    const retryAfterHeader: string | undefined = httpResponse.headers.get(\n      Constants.HeaderConstants.RETRY_AFTER\n    );\n\n    if (retryAfterHeader) {\n      const delayInMs: number | undefined = ThrottlingRetryPolicy.parseRetryAfterHeader(\n        retryAfterHeader\n      );\n      if (delayInMs) {\n        return delay(delayInMs).then((_: any) => this._nextPolicy.sendRequest(httpRequest));\n      }\n    }\n\n    return httpResponse;\n  }\n\n  public static parseRetryAfterHeader(headerValue: string): number | undefined {\n    const retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  public static parseDateRetryAfterHeader(headerValue: string): number | undefined {\n    try {\n      const now: number = Date.now();\n      const date: number = Date.parse(headerValue);\n      const diff = date - now;\n\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { ServiceClientCredentials } from \"../credentials/serviceClientCredentials\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResource } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\n\nexport function signingPolicy(\n  authenticationProvider: ServiceClientCredentials\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new SigningPolicy(nextPolicy, options, authenticationProvider);\n    }\n  };\n}\n\nexport class SigningPolicy extends BaseRequestPolicy {\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    public authenticationProvider: ServiceClientCredentials\n  ) {\n    super(nextPolicy, options);\n  }\n\n  signRequest(request: WebResource): Promise<WebResource> {\n    return this.authenticationProvider.signRequest(request);\n  }\n\n  public sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    return this.signRequest(request).then((nextRequest) =>\n      this._nextPolicy.sendRequest(nextRequest)\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { BaseRequestPolicy, RequestPolicy, RequestPolicyOptions } from './requestPolicy';\nimport { WebResource } from '../webResource';\nimport { HttpOperationResponse } from '../httpOperationResponse';\n\n/**\n * Options for how HTTP connections should be maintained for future\n * requests.\n */\nexport interface KeepAliveOptions {\n  /*\n   * When true, connections will be kept alive for multiple requests.\n   * Defaults to true.\n   */\n  enable: boolean;\n}\n\nexport const DefaultKeepAliveOptions: KeepAliveOptions = {\n  enable: true\n}\n\nexport function keepAlivePolicy(keepAliveOptions?: KeepAliveOptions) {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || DefaultKeepAliveOptions);\n    }\n  };\n}\n\n/**\n * KeepAlivePolicy is a policy used to control keep alive settings for every request.\n */\nexport class KeepAlivePolicy extends BaseRequestPolicy {\n  /**\n   * Creates an instance of KeepAlivePolicy.\n   *\n   * @param {RequestPolicy} nextPolicy\n   * @param {RequestPolicyOptions} options\n   * @param {KeepAliveOptions} [keepAliveOptions]\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private readonly keepAliveOptions: KeepAliveOptions\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Sends out request.\n   *\n   * @param {WebResource} request\n   * @returns {Promise<HttpOperationResponse>}\n   * @memberof KeepAlivePolicy\n   */\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    request.keepAlive = this.keepAliveOptions.enable;\n    return this._nextPolicy.sendRequest(request);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { Span } from \"../../interfaces/span\";\nimport { SpanContext } from \"../../interfaces/span_context\";\nimport { Attributes } from \"../../interfaces/attributes\";\nimport { Status } from \"../../interfaces/status\";\n\n/**\n * A no-op implementation of Span that can safely be used without side-effects.\n */\nexport class NoOpSpan implements Span {\n\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  context(): SpanContext {\n    return {\n      spanId: \"\",\n      traceId: \"\"\n    };\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param _endTime The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    /* Noop */\n  }\n\n  /**\n   * Sets an attribute on the Span\n   * @param _key the attribute key\n   * @param _value the attribute value\n   */\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  /**\n   * Sets attributes on the Span\n   * @param _attributes the attributes to add\n   */\n  setAttributes(_attributes: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Adds an event to the Span\n   * @param _name The name of the event\n   * @param _attributes The associated attributes to add for this event\n   */\n  addEvent(_name: string, _attributes?: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Adds a link to the Span.\n   * @param _spanContext the context of the linked span\n   * @param _attributes attributes to be added that are associated with the link\n   */\n  addLink(_spanContext: SpanContext, _attributes?: Attributes): this {\n    return this;\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of CanonicalCode.OK.\n   * @param _status The status to set.\n   */\n  setStatus(_status: Status): this {\n    return this;\n  }\n\n  /**\n   * Updates the name of the Span\n   * @param _name the new Span name\n   */\n  updateName(_name: string): this {\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecordingEvents(): boolean {\n    return false;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { BinaryFormat } from \"../../interfaces/BinaryFormat\";\nimport { SpanContext } from \"../../interfaces/span_context\";\n\n/**\n * A no-op implementation of BinaryFormat to be used when tracing is disabled.\n */\nexport class NoOpBinaryFormat implements BinaryFormat {\n  /** Serialize the given SpanContext to a buffer */\n  toBytes(_spanContext: SpanContext): ArrayBuffer {\n    return new ArrayBuffer(0);\n  }\n\n  /** \n   * Deserialize a SpanContext from binary encoding. \n   * Returns null if the buffer does not contain a valid SpanContext.\n   */\n  fromBytes(_buffer: ArrayBuffer): SpanContext | null {\n    return null;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { HttpTextFormat } from \"../../interfaces/HttpTextFormat\";\nimport { SpanContext } from \"../../interfaces/span_context\";\n\n/**\n * A no-op implementation of HttpTextFormat to be used when tracing is disabled.\n */\nexport class NoOpHttpTextFormat implements HttpTextFormat {\n  /**\n   * Injects the given SpanContext for transmitting to a remote server.\n   * @param _spanContext The SpanContext to transmit\n   * @param _format The format of the carrier\n   * @param _carrier The carrier to propagate through, e.g. an HTTP request\n   */\n  inject(_spanContext: SpanContext, _format: string, _carrier: unknown): void { }\n  /**\n   * Returns a SpanContext intance extracted from the carrier.\n   * @param _format the format of the carrier\n   * @param _carrier The carrier being used for propagation, e.g. an HTTP request\n   */\n  extract(_format: string, _carrier: unknown): SpanContext | null {\n    return null;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { Tracer } from \"../../interfaces/tracer\";\nimport { Span } from \"../../interfaces/span\";\nimport { SpanOptions } from \"../../interfaces/SpanOptions\";\nimport { NoOpSpan } from \"./noOpSpan\";\nimport { BinaryFormat } from \"../../interfaces/BinaryFormat\";\nimport { HttpTextFormat } from \"../../interfaces/HttpTextFormat\";\nimport { NoOpBinaryFormat } from \"./noOpBinaryFormat\";\nimport { NoOpHttpTextFormat } from \"./noOpHttpTextFormat\";\n\n/**\n * A no-op implementation of Tracer that can be used when tracing\n * is disabled.\n */\nexport class NoOpTracer implements Tracer {\n\n  /**\n   * Starts a new Span.\n   * @param _name The name of the span.\n   * @param _options The SpanOptions used during Span creation.\n   */\n  startSpan(_name: string, _options?: SpanOptions): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Returns the current Span from the current context, if available.\n   */\n  getCurrentSpan(): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Executes the given function within the context provided by a Span.\n   * @param _span The span that provides the context.\n   * @param fn The function to be executed.\n   */\n  withSpan<T extends (...args: unknown[]) => ReturnType<T>>(\n    _span: Span,\n    fn: T\n  ): ReturnType<T> {\n    return fn();\n  }\n\n  /**\n   * Bind a Span as the target's scope\n   * @param target An object to bind the scope.\n   * @param _span A specific Span to use. Otherwise, use the current one.\n   */\n  bind<T>(target: T, _span?: Span): T {\n    return target;\n  }\n\n  /**\n   * Send a pre-populated Span object to the exporter.\n   * @param _span The span to pass along.\n   */\n  recordSpanData(_span: Span): void {\n    /* NOOP */\n  }\n\n  /**\n   * Returns the BinaryFormat interface for serializing/deserializing Spans.\n   */\n  getBinaryFormat(): BinaryFormat {\n    return new NoOpBinaryFormat();\n  }\n\n  /**\n   * Returns the HttpTextFormat interface for injecting/extracting Spans.\n   */\n  getHttpTextFormat(): HttpTextFormat {\n    return new NoOpHttpTextFormat();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Tracer } from \"../interfaces/tracer\";\nimport { getGlobalObject } from \"./global\";\n\nconst GLOBAL_TRACER_VERSION = 1;\nconst GLOBAL_TRACER_SYMBOL = Symbol.for(\"@azure/core-tracing.tracerCache\");\n\nexport interface TracerCache {\n  version: number;\n  tracer?: Tracer;\n}\n\nlet cache: TracerCache;\n\nfunction loadTracerCache(): void {\n  const globalObj = getGlobalObject();\n  const existingCache: TracerCache = globalObj[GLOBAL_TRACER_SYMBOL];\n  if (existingCache) {\n    if (existingCache.version !== GLOBAL_TRACER_VERSION) {\n      throw new Error(\n        `Two incompatible versions of @azure/core-tracing have been loaded.\n         This library is ${GLOBAL_TRACER_VERSION}, existing is ${existingCache.version}.`\n      );\n    }\n    cache = existingCache;\n  } else {\n    cache = {\n      tracer: undefined,\n      version: GLOBAL_TRACER_VERSION\n    };\n    globalObj[GLOBAL_TRACER_SYMBOL] = cache;\n  }\n}\n\nexport function getCache(): TracerCache {\n  if (!cache) {\n    loadTracerCache();\n  }\n  return cache;\n}\n","/*!\n * Copyright 2019, OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * An enumeration that represents global trace flags. These flags are\n * propagated to all child {@link Span}. These determine features such as\n * whether a Span should be traced. It is implemented as a bitmask.\n */\nexport enum TraceFlags {\n  /** Bit to represent whether trace is unsampled in trace flags. */\n  UNSAMPLED = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1,\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nexport function getGlobalObject(): any {\n  return self;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { SpanContext } from \"../interfaces/span_context\";\nimport { TraceFlags } from \"../interfaces/trace_flags\";\n\nconst VERSION = \"00\";\n\n/**\n * Generates a `SpanContext` given a `traceparent` header value.\n * @param traceParent Serialized span context data as a `traceparent` header value.\n * @returns The `SpanContext` generated from the `traceparent` value.\n */\nexport function extractSpanContextFromTraceParentHeader(\n  traceParentHeader: string\n): SpanContext | undefined {\n  const parts = traceParentHeader.split(\"-\");\n\n  if (parts.length !== 4) {\n    return;\n  }\n\n  const [version, traceId, spanId, traceOptions] = parts;\n\n  if (version !== VERSION) {\n    return;\n  }\n\n  const traceFlags = parseInt(traceOptions, 16);\n\n  const spanContext: SpanContext = {\n    spanId,\n    traceId,\n    traceFlags\n  };\n\n  return spanContext;\n}\n\n/**\n * Generates a `traceparent` value given a span context.\n * @param spanContext Contains context for a specific span.\n * @returns The `spanContext` represented as a `traceparent` value.\n */\nexport function getTraceParentHeader(spanContext: SpanContext): string | undefined {\n  const missingFields: string[] = [];\n  if (!spanContext.traceId) {\n    missingFields.push(\"traceId\");\n  }\n  if (!spanContext.spanId) {\n    missingFields.push(\"spanId\");\n  }\n\n  if (missingFields.length) {\n    return;\n  }\n\n  const flags = spanContext.traceFlags || TraceFlags.UNSAMPLED;\n  const hexFlags = flags.toString(16);\n  const traceFlags = hexFlags.length === 1 ? `0${hexFlags}` : hexFlags;\n\n  // https://www.w3.org/TR/trace-context/#traceparent-header-field-values\n  return `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-${traceFlags}`;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { getTracer, getTraceParentHeader } from \"@azure/core-tracing\";\nimport {\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions,\n  BaseRequestPolicy\n} from \"./requestPolicy\";\nimport { WebResource } from \"../webResource\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\n\nexport function tracingPolicy(): RequestPolicyFactory {\n  return {\n    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n      return new TracingPolicy(nextPolicy, options);\n    }\n  };\n}\n\nexport class TracingPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n    super(nextPolicy, options);\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    if (!request.spanOptions || !request.spanOptions.parent) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    // create a new span\n    const tracer = getTracer();\n    const span = tracer.startSpan(\"core-http\", request.spanOptions);\n\n    try {\n      // set headers\n      const spanContext = span.context();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n\n      const response = await this._nextPolicy.sendRequest(request);\n      span.end();\n      return response;\n    } catch (err) {\n      span.end();\n      throw err;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { NoOpTracer } from \"./tracers/noop/noOpTracer\";\nimport { Tracer } from \"./interfaces/tracer\";\nimport { getCache } from \"./utils/cache\";\n\n/**\n * Sets the global tracer, enabling tracing for the Azure SDK.\n * @param tracer An OpenTelemetry Tracer instance.\n */\nexport function setTracer(tracer: Tracer) {\n  const cache = getCache();\n  cache.tracer = tracer;\n}\n\n/**\n * Retrieves the active tracer, or returns a\n * no-op implementation if one is not set.\n */\nexport function getTracer() {\n  const cache = getCache();\n  if (!cache.tracer) {\n    cache.tracer = new NoOpTracer();\n  }\n  return cache.tracer;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { DefaultHttpClient } from \"./defaultHttpClient\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpOperationResponse, RestResponse } from \"./httpOperationResponse\";\nimport { HttpPipelineLogger } from \"./httpPipelineLogger\";\nimport { logPolicy, DefaultLoggingOptions } from \"./policies/logPolicy\";\nimport { OperationArguments } from \"./operationArguments\";\nimport {\n  getPathStringFromParameter,\n  getPathStringFromParameterPath,\n  OperationParameter,\n  ParameterPath\n} from \"./operationParameter\";\nimport { isStreamOperation, OperationSpec } from \"./operationSpec\";\nimport {\n  deserializationPolicy,\n  DeserializationContentTypes,\n  DefaultDeserializationOptions\n} from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy, DefaultRetryOptions } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport {\n  userAgentPolicy,\n  getDefaultUserAgentHeaderName,\n  getDefaultUserAgentValue,\n} from \"./policies/userAgentPolicy\";\nimport { redirectPolicy, DefaultRedirectOptions } from \"./policies/redirectPolicy\";\nimport {\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { CompositeMapper, DictionaryMapper, Mapper, MapperType, Serializer } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport { RequestOptionsBase, RequestPrepareOptions, WebResource } from \"./webResource\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { ServiceCallback, isNode } from \"./util/utils\";\nimport { proxyPolicy, getDefaultProxySettings } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { ServiceClientCredentials } from \"./credentials/serviceClientCredentials\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { logger } from \"./log\";\nimport { InternalPipelineOptions } from './pipelineOptions';\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from './policies/keepAlivePolicy';\nimport { tracingPolicy } from './policies/tracingPolicy';\n\n/**\n * Options to configure a proxy for outgoing requests (Node.js only).\n */\nexport interface ProxySettings {\n  /*\n   * The proxy's host address.\n   */\n  host: string;\n\n  /*\n   * The proxy host's port.\n   */\n  port: number;\n\n  /**\n   * The user name to authenticate with the proxy, if required.\n   */\n  username?: string;\n\n  /**\n   * The password to authenticate with the proxy, if required.\n   */\n  password?: string;\n}\n\nexport type ProxyOptions = ProxySettings; // Alias ProxySettings as ProxyOptions for future use.\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions {\n  /**\n   * An array of factories which get called to create the RequestPolicy pipeline used to send a HTTP\n   * request on the wire, or a function that takes in the defaultRequestPolicyFactories and returns\n   * the requestPolicyFactories that will be used.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * The HttpPipelineLogger that can be used to debug RequestPolicies within the HTTP pipeline.\n   */\n  httpPipelineLogger?: HttpPipelineLogger;\n  /**\n   * If set to true, turn off the default retry policy.\n   */\n  noRetryPolicy?: boolean;\n  /**\n   * Gets or sets the retry timeout in seconds for AutomaticRPRegistration. Default value is 30.\n   */\n  rpRegistrationRetryTimeout?: number;\n  /**\n   * Whether or not to generate a client request ID header for each HTTP request.\n   */\n  generateClientRequestIdHeader?: boolean;\n  /**\n   * Whether to include credentials in CORS requests in the browser.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials for more information.\n   */\n  withCredentials?: boolean;\n  /**\n   * If specified, a GenerateRequestIdPolicy will be added to the HTTP pipeline that will add a\n   * header to all outgoing requests with this header name and a random UUID as the request ID.\n   */\n  clientRequestIdHeaderName?: string;\n  /**\n   * The content-types that will be associated with JSON or XML serialization.\n   */\n  deserializationContentTypes?: DeserializationContentTypes;\n  /**\n   * The header name to use for the telemetry header while sending the request. If this is not\n   * specified, then \"User-Agent\" will be used when running on Node.js and \"x-ms-command-name\" will\n   * be used when running in a browser.\n   */\n  userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);\n  /**\n   * The string to be set to the telemetry header while sending the request, or a function that\n   * takes in the default user-agent string and returns the user-agent string that will be used.\n   */\n  userAgent?: string | ((defaultUserAgent: string) => string);\n  /**\n   * Proxy settings which will be used for every HTTP request (Node.js only).\n   */\n  proxySettings?: ProxySettings;\n}\n\n/**\n * @class\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  protected baseUri?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  protected requestContentType?: string;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n  private readonly _requestPolicyOptions: RequestPolicyOptions;\n\n  private readonly _requestPolicyFactories: RequestPolicyFactory[];\n  private readonly _withCredentials: boolean;\n\n  /**\n   * The ServiceClient constructor\n   * @constructor\n   * @param credentials The credentials used for authentication with the service.\n   * @param options The service client options that govern the behavior of the client.\n   */\n  constructor(\n    credentials?: TokenCredential | ServiceClientCredentials,\n    options?: ServiceClientOptions\n  ) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || new DefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n\n    let requestPolicyFactories: RequestPolicyFactory[];\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory: RequestPolicyFactory | undefined = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\n          \"ServiceClient: creating bearer token authentication policy from provided credentials\"\n        );\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory: () => RequestPolicyFactory = () => {\n          let bearerTokenPolicyFactory: RequestPolicyFactory | undefined = undefined;\n          let serviceClient = this;\n          return {\n            create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): RequestPolicy {\n              if (bearerTokenPolicyFactory === undefined) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(\n                  credentials,\n                  `${serviceClient.baseUri || \"\"}/.default`\n                );\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, options);\n            }\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories:\n          | void\n          | RequestPolicyFactory[] = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options: RequestPrepareOptions | WebResource): Promise<HttpOperationResponse> {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest: WebResource;\n    try {\n      if (options instanceof WebResource) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline: RequestPolicy = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(\n          httpPipeline,\n          this._requestPolicyOptions\n        );\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param {OperationArguments} operationArguments The arguments that the HTTP request's templated values will be populated from.\n   * @param {OperationSpec} operationSpec The OperationSpec to use to populate the httpRequest.\n   * @param {ServiceCallback} callback The callback to call when the response is received.\n   */\n  async sendOperationRequest(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n    callback?: ServiceCallback<any>\n  ): Promise<RestResponse> {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    const httpRequest = new WebResource();\n\n    let result: Promise<RestResponse>;\n    try {\n      const baseUri: string | undefined = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\n          \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\"\n        );\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n\n      const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue: string = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            urlParameter,\n            operationSpec.serializer\n          );\n          urlParameterValue = operationSpec.serializer.serialize(\n            urlParameter.mapper,\n            urlParameterValue,\n            getPathStringFromParameter(urlParameter)\n          );\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(\n            `{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`,\n            urlParameterValue\n          );\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            queryParameter,\n            operationSpec.serializer\n          );\n          if (queryParameterValue != undefined) {\n            queryParameterValue = operationSpec.serializer.serialize(\n              queryParameter.mapper,\n              queryParameterValue,\n              getPathStringFromParameter(queryParameter)\n            );\n            if (queryParameter.collectionFormat != undefined) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  queryParameterValue = \"\";\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] = item == undefined ? \"\" : item.toString();\n                  }\n                }\n              } else {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            requestUrl.setQueryParameter(\n              queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n              queryParameterValue\n            );\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            headerParameter,\n            operationSpec.serializer\n          );\n          if (headerValue != undefined) {\n            headerValue = operationSpec.serializer.serialize(\n              headerParameter.mapper,\n              headerValue,\n              getPathStringFromParameter(headerParameter)\n            );\n            const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n              .headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(\n                headerParameter.mapper.serializedName ||\n                  getPathStringFromParameter(headerParameter),\n                headerValue\n              );\n            }\n          }\n        }\n      }\n\n      const options: RequestOptionsBase | undefined = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n\n        if (options.spanOptions) {\n          httpRequest.spanOptions = options.spanOptions;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseBody == undefined) {\n        httpRequest.streamResponseBody = isStreamOperation(operationSpec);\n      }\n\n      let rawResponse: HttpOperationResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response){\n          sendRequestError.details = flattenResponse(\n            sendRequestError.response,\n            operationSpec.responses[sendRequestError.statusCode] ||\n              operationSpec.responses[\"default\"]\n          );\n        }\n        result = Promise.reject(\n          sendRequestError\n        );\n      } else {\n        result = Promise.resolve(\n          flattenResponse(rawResponse!, operationSpec.responses[rawResponse!.status])\n        );\n      }\n    } catch (error) {\n      result = Promise.reject(error);\n    }\n\n    const cb = callback;\n    if (cb) {\n      result\n        // tslint:disable-next-line:no-null-keyword\n        .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n        .catch((err) => cb(err));\n    }\n\n    return result;\n  }\n}\n\nexport function serializeRequestBody(\n  serviceClient: ServiceClient,\n  httpRequest: WebResource,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(\n      serviceClient,\n      operationArguments,\n      operationSpec.requestBody,\n      operationSpec.serializer\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const { required, xmlName, xmlElementName, serializedName } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n    try {\n      if (httpRequest.body != undefined || required) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        httpRequest.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          httpRequest.body,\n          requestBodyParameterPathString\n        );\n        const isStream = typeName === MapperType.Stream;\n        if (operationSpec.isXML) {\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(\n              utils.prepareXMLRootList(\n                httpRequest.body,\n                xmlElementName || xmlName || serializedName!\n              ),\n              { rootName: xmlName || serializedName }\n            );\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(httpRequest.body, {\n              rootName: xmlName || serializedName\n            });\n          }\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue: any = getOperationArgumentValueFromParameter(\n        serviceClient,\n        operationArguments,\n        formDataParameter,\n        operationSpec.serializer\n      );\n      if (formDataParameterValue != undefined) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter)\n        );\n      }\n    }\n  }\n}\n\nfunction getValueOrFunctionResult(\n  value: undefined | string | ((defaultValue: string) => string),\n  defaultValueCreator: () => string\n): string {\n  let result: string;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(\n  authPolicyFactory: RequestPolicyFactory | undefined,\n  options: ServiceClientOptions\n): RequestPolicyFactory[] {\n  const factories: RequestPolicyFactory[] = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName: string = getValueOrFunctionResult(\n    options.userAgentHeaderName,\n    getDefaultUserAgentHeaderName\n  );\n  const userAgentHeaderValue: string = getValueOrFunctionResult(\n    options.userAgent,\n    getDefaultUserAgentValue\n  );\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  const proxySettings = options.proxySettings || getDefaultProxySettings();\n  if (proxySettings) {\n    factories.push(proxyPolicy(proxySettings));\n  }\n\n  factories.push(logPolicy(logger.info, {}));\n\n  return factories;\n}\n\nexport function createPipelineFromOptions(\n  pipelineOptions: InternalPipelineOptions,\n  authPolicyFactory?: RequestPolicyFactory\n) : ServiceClientOptions {\n  let requestPolicyFactories: RequestPolicyFactory[] = [];\n\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo: string[] = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = {\n    ...DefaultKeepAliveOptions,\n    ...pipelineOptions.keepAliveOptions\n  };\n\n  const retryOptions = {\n    ...DefaultRetryOptions,\n    ...pipelineOptions.retryOptions\n  };\n\n  const redirectOptions = {\n    ...DefaultRedirectOptions,\n    ...pipelineOptions.redirectOptions\n  };\n\n  const proxySettings = pipelineOptions.proxyOptions || getDefaultProxySettings();\n  if (isNode && proxySettings) {\n    requestPolicyFactories.push(\n      proxyPolicy(proxySettings)\n    )\n  }\n\n  const deserializationOptions = {\n    ...DefaultDeserializationOptions,\n    ...pipelineOptions.deserializationOptions\n  };\n\n  const loggingOptions = {\n    ...DefaultLoggingOptions,\n    ...pipelineOptions.loggingOptions\n  };\n\n  requestPolicyFactories.push(\n    tracingPolicy(),\n    keepAlivePolicy(keepAliveOptions),\n    userAgentPolicy({ value: userAgentValue }),\n    generateClientRequestIdPolicy(),\n    deserializationPolicy(deserializationOptions.expectedContentTypes),\n    throttlingRetryPolicy(),\n    systemErrorRetryPolicy(),\n    exponentialRetryPolicy(\n      retryOptions.maxRetries,\n      retryOptions.retryDelayInMs,\n      retryOptions.maxRetryDelayInMs\n    )\n  )\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(\n      redirectPolicy(redirectOptions.maxRetries)\n    );\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(\n    logPolicy(\n      loggingOptions.logger,\n      loggingOptions.logPolicyOptions\n    )\n  );\n\n  if (pipelineOptions.updatePipelinePolicies) {\n    // If the update function throws an exception, let it bubble up.\n    requestPolicyFactories = pipelineOptions.updatePipelinePolicies(requestPolicyFactories);\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories\n  };\n}\n\n\nexport type PropertyParent = { [propertyName: string]: any };\n\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent: PropertyParent, propertyPath: string[]): PropertyParent {\n  if (parent && propertyPath) {\n    const propertyPathLength: number = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName: string = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  serializer: Serializer\n): any {\n  return getOperationArgumentValueFromParameterPath(\n    serviceClient,\n    operationArguments,\n    parameter.parameterPath,\n    parameter.mapper,\n    serializer\n  );\n}\n\nexport function getOperationArgumentValueFromParameterPath(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameterPath: ParameterPath,\n  parameterMapper: Mapper,\n  serializer: Serializer\n): any {\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult: PropertySearchResult = getPropertyFromParameterPath(\n          operationArguments,\n          parameterPath\n        );\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n\n      // Serialize just for validation purposes.\n      const parameterPathString: string = getPathStringFromParameterPath(\n        parameterPath,\n        parameterMapper\n      );\n      serializer.serialize(parameterMapper, value, parameterPathString);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameterPath(\n        serviceClient,\n        operationArguments,\n        propertyPath,\n        propertyMapper,\n        serializer\n      );\n      // Serialize just for validation purposes.\n      const propertyPathString: string = getPathStringFromParameterPath(\n        propertyPath,\n        propertyMapper\n      );\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString);\n      if (propertyValue !== undefined) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[]\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent != undefined && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\nexport function flattenResponse(\n  _response: HttpOperationResponse,\n  responseSpec: OperationResponse | undefined\n): RestResponse {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = (obj: {}) =>\n    Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      });\n    }\n\n    const modelProperties =\n      (typeName === \"Composite\" && (bodyMapper as CompositeMapper).type.modelProperties) || {};\n    const isPageableResponse = Object.keys(modelProperties).some(\n      (k) => modelProperties[k].serializedName === \"\"\n    );\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])] as RestResponse & any[];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        ..._response.parsedBody\n      });\n    }\n  }\n\n  if (\n    bodyMapper ||\n    _response.request.method === \"HEAD\" ||\n    utils.isPrimitiveType(_response.parsedBody)\n  ) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse({\n      ...parsedHeaders,\n      body: _response.parsedBody\n    });\n  }\n\n  return addOperationResponse({\n    ...parsedHeaders,\n    ..._response.parsedBody\n  });\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpHeaders } from \"../httpHeaders\";\nimport * as base64 from \"../util/base64\";\nimport { Constants } from \"../util/constants\";\nimport { WebResource } from \"../webResource\";\nimport { ServiceClientCredentials } from \"./serviceClientCredentials\";\nconst HeaderConstants = Constants.HeaderConstants;\nconst DEFAULT_AUTHORIZATION_SCHEME = \"Basic\";\n\nexport class BasicAuthenticationCredentials implements ServiceClientCredentials {\n  userName: string;\n  password: string;\n  authorizationScheme: string = DEFAULT_AUTHORIZATION_SCHEME;\n\n  /**\n   * Creates a new BasicAuthenticationCredentials object.\n   *\n   * @constructor\n   * @param {string} userName User name.\n   * @param {string} password Password.\n   * @param {string} [authorizationScheme] The authorization scheme.\n   */\n  constructor(\n    userName: string,\n    password: string,\n    authorizationScheme: string = DEFAULT_AUTHORIZATION_SCHEME\n  ) {\n    if (userName === null || userName === undefined || typeof userName.valueOf() !== \"string\") {\n      throw new Error(\"userName cannot be null or undefined and must be of type string.\");\n    }\n    if (password === null || password === undefined || typeof password.valueOf() !== \"string\") {\n      throw new Error(\"password cannot be null or undefined and must be of type string.\");\n    }\n    this.userName = userName;\n    this.password = password;\n    this.authorizationScheme = authorizationScheme;\n  }\n\n  /**\n   * Signs a request with the Authentication header.\n   *\n   * @param {WebResource} webResource The WebResource to be signed.\n   * @returns {Promise<WebResource>} The signed request object.\n   */\n  signRequest(webResource: WebResource) {\n    const credentials = `${this.userName}:${this.password}`;\n    const encodedCredentials = `${this.authorizationScheme} ${base64.encodeString(credentials)}`;\n    if (!webResource.headers) webResource.headers = new HttpHeaders();\n    webResource.headers.set(HeaderConstants.AUTHORIZATION, encodedCredentials);\n    return Promise.resolve(webResource);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { WebResource } from \"../webResource\";\nimport { ServiceClientCredentials } from \"./serviceClientCredentials\";\n\n/**\n * @interface ApiKeyCredentialOptions\n * Describes the options to be provided while creating an instance of ApiKeyCredentials\n */\nexport interface ApiKeyCredentialOptions {\n  /**\n   * A key value pair of the header parameters that need to be applied to the request.\n   */\n  inHeader?: { [x: string]: any };\n  /**\n   * A key value pair of the query parameters that need to be applied to the request.\n   */\n  inQuery?: { [x: string]: any };\n}\n\n/**\n * Authenticates to a service using an API key.\n */\nexport class ApiKeyCredentials implements ServiceClientCredentials {\n  /**\n   * A key value pair of the header parameters that need to be applied to the request.\n   */\n  private readonly inHeader?: { [x: string]: any };\n  /**\n   * A key value pair of the query parameters that need to be applied to the request.\n   */\n  private readonly inQuery?: { [x: string]: any };\n\n  /**\n   * @constructor\n   * @param {object} options   Specifies the options to be provided for auth. Either header or query needs to be provided.\n   */\n  constructor(options: ApiKeyCredentialOptions) {\n    if (!options || (options && !options.inHeader && !options.inQuery)) {\n      throw new Error(\n        `options cannot be null or undefined. Either \"inHeader\" or \"inQuery\" property of the options object needs to be provided.`\n      );\n    }\n    this.inHeader = options.inHeader;\n    this.inQuery = options.inQuery;\n  }\n\n  /**\n   * Signs a request with the values provided in the inHeader and inQuery parameter.\n   *\n   * @param {WebResource} webResource The WebResource to be signed.\n   * @returns {Promise<WebResource>} The signed request object.\n   */\n  signRequest(webResource: WebResource): Promise<WebResource> {\n    if (!webResource) {\n      return Promise.reject(\n        new Error(`webResource cannot be null or undefined and must be of type \"object\".`)\n      );\n    }\n\n    if (this.inHeader) {\n      if (!webResource.headers) {\n        webResource.headers = new HttpHeaders();\n      }\n      for (const headerName in this.inHeader) {\n        webResource.headers.set(headerName, this.inHeader[headerName]);\n      }\n    }\n\n    if (this.inQuery) {\n      if (!webResource.url) {\n        return Promise.reject(new Error(`url cannot be null in the request object.`));\n      }\n      if (webResource.url.indexOf(\"?\") < 0) {\n        webResource.url += \"?\";\n      }\n      for (const key in this.inQuery) {\n        if (!webResource.url.endsWith(\"?\")) {\n          webResource.url += \"&\";\n        }\n        webResource.url += `${key}=${this.inQuery[key]}`;\n      }\n    }\n\n    return Promise.resolve(webResource);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { ApiKeyCredentials, ApiKeyCredentialOptions } from \"./apiKeyCredentials\";\n\nexport class TopicCredentials extends ApiKeyCredentials {\n  /**\n   * Creates a new EventGrid TopicCredentials object.\n   *\n   * @constructor\n   * @param {string} topicKey   The EventGrid topic key\n   */\n  constructor(topicKey: string) {\n    if (!topicKey || (topicKey && typeof topicKey !== \"string\")) {\n      throw new Error(\"topicKey cannot be null or undefined and must be of type string.\");\n    }\n    const options: ApiKeyCredentialOptions = {\n      inHeader: {\n        \"aeg-sas-key\": topicKey\n      }\n    };\n    super(options);\n  }\n}\n"]}