// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import { URLBuilder, URLQuery } from "../url";
import { BaseRequestPolicy } from "./requestPolicy";
import { logger as coreLogger, logger } from "../log";
var RedactedString = "REDACTED";
var defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "traceparent",
    "Accept",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent"
];
var defaultAllowedQueryParameters = [
    "api-version"
];
export var DefaultLoggingOptions = {
    logger: undefined,
    logPolicyOptions: {
        allowedHeaderNames: [],
        allowedQueryParameters: [] // the real defaultAllowed[HeaderNames|QueryParameters].
    }
};
export function logPolicy(logger, logOptions) {
    if (logger === void 0) { logger = coreLogger.info.bind(coreLogger); }
    if (logOptions === void 0) { logOptions = {}; }
    return {
        create: function (nextPolicy, options) {
            return new LogPolicy(nextPolicy, options, logger, logOptions);
        }
    };
}
var LogPolicy = /** @class */ (function (_super) {
    tslib_1.__extends(LogPolicy, _super);
    function LogPolicy(nextPolicy, options, logger, _a) {
        if (logger === void 0) { logger = console.log; }
        var _b = _a === void 0 ? {} : _a, _c = _b.allowedHeaderNames, allowedHeaderNames = _c === void 0 ? [] : _c, _d = _b.allowedQueryParameters, allowedQueryParameters = _d === void 0 ? [] : _d;
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.logger = logger;
        allowedHeaderNames =
            allowedHeaderNames && allowedHeaderNames instanceof Array
                ? defaultAllowedHeaderNames.concat(allowedHeaderNames)
                : defaultAllowedHeaderNames;
        allowedQueryParameters =
            allowedQueryParameters && allowedQueryParameters instanceof Array
                ? defaultAllowedQueryParameters.concat(allowedQueryParameters)
                : defaultAllowedQueryParameters;
        _this.allowedHeaderNames = new Set(allowedHeaderNames);
        _this.allowedQueryParameters = new Set(allowedQueryParameters);
        return _this;
    }
    LogPolicy.prototype.sendRequest = function (request) {
        var _this = this;
        if (!logger.info.enabled)
            return this._nextPolicy.sendRequest(request);
        this.logRequest(request);
        return this._nextPolicy.sendRequest(request).then(function (response) { return _this.logResponse(response); });
    };
    LogPolicy.prototype.logRequest = function (request) {
        this.logger("Request: " + JSON.stringify(request, this.sanitize.bind(this), 2));
    };
    LogPolicy.prototype.sanitize = function (key, value) {
        if (key === "_headersMap") {
            return this.sanitizeHeaders(key, value);
        }
        else if (key === "url") {
            return this.sanitizeUrl(value);
        }
        else if (key === "query") {
            return this.sanitizeQuery(value);
        }
        else if (key === "body") {
            // Don't log the request body
            return undefined;
        }
        else if (key === "response") {
            // Don't log response again
            return undefined;
        }
        else if (key === "operationSpec") {
            // When using sendOperationRequest, the request carries a massive
            // field with the autorest spec. No need to log it.
            return undefined;
        }
        return value;
    };
    LogPolicy.prototype.sanitizeHeaders = function (_, value) {
        return this.sanitizeObject(value, this.allowedHeaderNames, function (v, k) { return v[k].value; });
    };
    LogPolicy.prototype.sanitizeQuery = function (value) {
        return this.sanitizeObject(value, this.allowedQueryParameters, function (v, k) { return v[k]; });
    };
    LogPolicy.prototype.sanitizeObject = function (value, allowedKeys, accessor) {
        if (typeof value !== "object" || value === null) {
            return value;
        }
        var sanitized = {};
        for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {
            var k = _a[_i];
            if (allowedKeys.has(k)) {
                sanitized[k] = accessor(value, k);
            }
            else {
                sanitized[k] = RedactedString;
            }
        }
        return sanitized;
    };
    LogPolicy.prototype.sanitizeUrl = function (value) {
        if (typeof value !== "string" || value === null) {
            return value;
        }
        var urlBuilder = URLBuilder.parse(value);
        var queryString = urlBuilder.getQuery();
        if (!queryString) {
            return value;
        }
        var query = URLQuery.parse(queryString);
        for (var _i = 0, _a = query.keys(); _i < _a.length; _i++) {
            var k = _a[_i];
            if (!this.allowedQueryParameters.has(k)) {
                query.set(k, RedactedString);
            }
        }
        urlBuilder.setQuery(query.toString());
        return urlBuilder.toString();
    };
    LogPolicy.prototype.logResponse = function (response) {
        this.logger("Response status code: " + response.status);
        this.logger("Headers: " + JSON.stringify(response.headers, this.sanitize.bind(this), 2));
        return response;
    };
    return LogPolicy;
}(BaseRequestPolicy));
export { LogPolicy };
//# sourceMappingURL=logPolicy.js.map