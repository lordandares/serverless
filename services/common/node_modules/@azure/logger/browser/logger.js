(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory((global.Azure = global.Azure || {}, global.Azure.Logger = {})));
}(this, function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var logFunction = console.debug || console.log;
    function log() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        logFunction.apply(void 0, __spread(args));
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var debugEnvVariable = (typeof process !== "undefined" && process.env && process.env.DEBUG) || undefined;
    var enabledString;
    var enabledNamespaces = [];
    var skippedNamespaces = [];
    var debuggers = [];
    if (debugEnvVariable) {
        enable(debugEnvVariable);
    }
    function enable(namespaces) {
        var e_1, _a, e_2, _b;
        enabledString = namespaces;
        enabledNamespaces = [];
        skippedNamespaces = [];
        var wildcard = /\*/g;
        var namespaceList = namespaces.split(",").map(function (ns) { return ns.trim().replace(wildcard, ".*?"); });
        try {
            for (var namespaceList_1 = __values(namespaceList), namespaceList_1_1 = namespaceList_1.next(); !namespaceList_1_1.done; namespaceList_1_1 = namespaceList_1.next()) {
                var ns = namespaceList_1_1.value;
                if (ns.startsWith("-")) {
                    skippedNamespaces.push(new RegExp("^" + ns.substr(1) + "$"));
                }
                else {
                    enabledNamespaces.push(new RegExp("^" + ns + "$"));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (namespaceList_1_1 && !namespaceList_1_1.done && (_a = namespaceList_1.return)) _a.call(namespaceList_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var debuggers_1 = __values(debuggers), debuggers_1_1 = debuggers_1.next(); !debuggers_1_1.done; debuggers_1_1 = debuggers_1.next()) {
                var instance = debuggers_1_1.value;
                instance.enabled = enabled(instance.namespace);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (debuggers_1_1 && !debuggers_1_1.done && (_b = debuggers_1.return)) _b.call(debuggers_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    function enabled(namespace) {
        var e_3, _a, e_4, _b;
        if (namespace.endsWith("*")) {
            return true;
        }
        try {
            for (var skippedNamespaces_1 = __values(skippedNamespaces), skippedNamespaces_1_1 = skippedNamespaces_1.next(); !skippedNamespaces_1_1.done; skippedNamespaces_1_1 = skippedNamespaces_1.next()) {
                var skipped = skippedNamespaces_1_1.value;
                if (skipped.test(namespace)) {
                    return false;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (skippedNamespaces_1_1 && !skippedNamespaces_1_1.done && (_a = skippedNamespaces_1.return)) _a.call(skippedNamespaces_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var enabledNamespaces_1 = __values(enabledNamespaces), enabledNamespaces_1_1 = enabledNamespaces_1.next(); !enabledNamespaces_1_1.done; enabledNamespaces_1_1 = enabledNamespaces_1.next()) {
                var enabled_1 = enabledNamespaces_1_1.value;
                if (enabled_1.test(namespace)) {
                    return true;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (enabledNamespaces_1_1 && !enabledNamespaces_1_1.done && (_b = enabledNamespaces_1.return)) _b.call(enabledNamespaces_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return false;
    }
    function disable() {
        var result = enabledString || "";
        enable("");
        return result;
    }
    function createDebugger(namespace) {
        function debug() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!newDebugger.enabled) {
                return;
            }
            if (args.length > 0) {
                args[0] = namespace + " " + args[0];
            }
            newDebugger.log.apply(newDebugger, __spread(args));
        }
        var newDebugger = Object.assign(debug, {
            enabled: enabled(namespace),
            destroy: destroy,
            log: debugObj.log,
            namespace: namespace,
            extend: extend
        });
        debuggers.push(newDebugger);
        return newDebugger;
    }
    function destroy() {
        var index = debuggers.indexOf(this);
        if (index >= 0) {
            debuggers.splice(index, 1);
            return true;
        }
        return false;
    }
    function extend(namespace) {
        var newDebugger = createDebugger(this.namespace + ":" + namespace);
        newDebugger.log = this.log;
        return newDebugger;
    }
    var debugObj = Object.assign(function (namespace) {
        return createDebugger(namespace);
    }, {
        enable: enable,
        enabled: enabled,
        disable: disable,
        log: log
    });

    // Copyright (c) Microsoft Corporation. All rights reserved.
    var registeredLoggers = new Set();
    var logLevelFromEnv = (typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;
    var azureLogLevel;
    /**
     * The AzureLogger provides a mechanism for overriding where logs are output to.
     * By default, logs are sent to stderr.
     * Override the `log` method to redirect logs to another location.
     */
    var AzureLogger = debugObj("azure");
    AzureLogger.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        debugObj.log.apply(debugObj, __spread(args));
    };
    var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    if (logLevelFromEnv) {
        // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
        if (isAzureLogLevel(logLevelFromEnv)) {
            setLogLevel(logLevelFromEnv);
        }
        else {
            console.error("AZURE_LOG_LEVEL set to unknown log level '" + logLevelFromEnv + "'; logging is not enabled. Acceptable values: " + AZURE_LOG_LEVELS.join(", ") + ".");
        }
    }
    /**
     * Immediately enables logging at the specified log level.
     * @param level The log level to enable for logging.
     * Options from most verbose to least verbose are:
     * - verbose
     * - info
     * - warning
     * - error
     */
    function setLogLevel(level) {
        var e_1, _a;
        if (level && !isAzureLogLevel(level)) {
            throw new Error("Unknown log level '" + level + "'. Acceptable values: " + AZURE_LOG_LEVELS.join(","));
        }
        azureLogLevel = level;
        var enabledNamespaces = [];
        try {
            for (var registeredLoggers_1 = __values(registeredLoggers), registeredLoggers_1_1 = registeredLoggers_1.next(); !registeredLoggers_1_1.done; registeredLoggers_1_1 = registeredLoggers_1.next()) {
                var logger = registeredLoggers_1_1.value;
                if (shouldEnable(logger)) {
                    enabledNamespaces.push(logger.namespace);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (registeredLoggers_1_1 && !registeredLoggers_1_1.done && (_a = registeredLoggers_1.return)) _a.call(registeredLoggers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        debugObj.enable(enabledNamespaces.join(","));
    }
    /**
     * Retrieves the currently specified log level.
     */
    function getLogLevel() {
        return azureLogLevel;
    }
    var levelMap = {
        verbose: 400,
        info: 300,
        warning: 200,
        error: 100
    };
    /**
     * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
     * @param namespace The name of the SDK package.
     * @ignore
     */
    function createClientLogger(namespace) {
        var clientRootLogger = AzureLogger.extend(namespace);
        patchLogMethod(AzureLogger, clientRootLogger);
        return {
            error: createLogger(clientRootLogger, "error"),
            warning: createLogger(clientRootLogger, "warning"),
            info: createLogger(clientRootLogger, "info"),
            verbose: createLogger(clientRootLogger, "verbose")
        };
    }
    function patchLogMethod(parent, child) {
        child.log = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            parent.log.apply(parent, __spread(args));
        };
    }
    function createLogger(parent, level) {
        var logger = Object.assign(parent.extend(level), {
            level: level
        });
        patchLogMethod(parent, logger);
        if (shouldEnable(logger)) {
            var enabledNamespaces = debugObj.disable();
            debugObj.enable(enabledNamespaces + "," + logger.namespace);
        }
        registeredLoggers.add(logger);
        return logger;
    }
    function shouldEnable(logger) {
        if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {
            return true;
        }
        else {
            return false;
        }
    }
    function isAzureLogLevel(logLevel) {
        return AZURE_LOG_LEVELS.includes(logLevel);
    }

    exports.AzureLogger = AzureLogger;
    exports.createClientLogger = createClientLogger;
    exports.getLogLevel = getLogLevel;
    exports.setLogLevel = setLogLevel;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=logger.js.map
